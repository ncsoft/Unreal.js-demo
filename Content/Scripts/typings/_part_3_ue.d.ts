declare class MaterialExpressionSkyAtmosphereLightDiskLuminance extends MaterialExpression { 
	LightIndex: number;
	DiskAngularDiameterOverride: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereLightDiskLuminance;
}

declare class MaterialExpressionSkyAtmosphereAerialPerspective extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereAerialPerspective;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereAerialPerspective;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereAerialPerspective;
}

declare class MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
}

declare class MaterialExpressionSkyAtmosphereViewLuminance extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereViewLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereViewLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereViewLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereViewLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereViewLuminance;
}

declare class MaterialExpressionSkyLightEnvMapSample extends MaterialExpression { 
	Direction: ExpressionInput;
	Roughness: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyLightEnvMapSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyLightEnvMapSample;
	static GetDefaultObject(): MaterialExpressionSkyLightEnvMapSample;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyLightEnvMapSample;
	static C(Other: UObject | any): MaterialExpressionSkyLightEnvMapSample;
}

declare class MaterialExpressionSmoothStep extends MaterialExpression { 
	Min: ExpressionInput;
	Max: ExpressionInput;
	Value: ExpressionInput;
	ConstMin: number;
	ConstMax: number;
	ConstValue: number;
	static Load(ResourceName: string): MaterialExpressionSmoothStep;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSmoothStep;
	static GetDefaultObject(): MaterialExpressionSmoothStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSmoothStep;
	static C(Other: UObject | any): MaterialExpressionSmoothStep;
}

declare class MaterialExpressionSobol extends MaterialExpression { 
	Cell: ExpressionInput;
	Index: ExpressionInput;
	Seed: ExpressionInput;
	ConstIndex: number;
	ConstSeed: Vector2D;
	static Load(ResourceName: string): MaterialExpressionSobol;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSobol;
	static GetDefaultObject(): MaterialExpressionSobol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSobol;
	static C(Other: UObject | any): MaterialExpressionSobol;
}

declare type ESpeedTreeGeometryType = 'STG_Branch' | 'STG_Frond' | 'STG_Leaf' | 'STG_FacingLeaf' | 'STG_Billboard' | 'STG_MAX';
declare var ESpeedTreeGeometryType : { STG_Branch:'STG_Branch',STG_Frond:'STG_Frond',STG_Leaf:'STG_Leaf',STG_FacingLeaf:'STG_FacingLeaf',STG_Billboard:'STG_Billboard',STG_MAX:'STG_MAX', };
declare type ESpeedTreeWindType = 'STW_None' | 'STW_Fastest' | 'STW_Fast' | 'STW_Better' | 'STW_Best' | 'STW_Palm' | 'STW_BestPlus' | 'STW_MAX';
declare var ESpeedTreeWindType : { STW_None:'STW_None',STW_Fastest:'STW_Fastest',STW_Fast:'STW_Fast',STW_Better:'STW_Better',STW_Best:'STW_Best',STW_Palm:'STW_Palm',STW_BestPlus:'STW_BestPlus',STW_MAX:'STW_MAX', };
declare type ESpeedTreeLODType = 'STLOD_Pop' | 'STLOD_Smooth' | 'STLOD_MAX';
declare var ESpeedTreeLODType : { STLOD_Pop:'STLOD_Pop',STLOD_Smooth:'STLOD_Smooth',STLOD_MAX:'STLOD_MAX', };
declare class MaterialExpressionSpeedTree extends MaterialExpression { 
	GeometryInput: ExpressionInput;
	WindInput: ExpressionInput;
	LODInput: ExpressionInput;
	ExtraBendWS: ExpressionInput;
	GeometryType: ESpeedTreeGeometryType;
	WindType: ESpeedTreeWindType;
	LODType: ESpeedTreeLODType;
	BillboardThreshold: number;
	bAccurateWindVelocities: boolean;
	static Load(ResourceName: string): MaterialExpressionSpeedTree;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSpeedTree;
	static GetDefaultObject(): MaterialExpressionSpeedTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSpeedTree;
	static C(Other: UObject | any): MaterialExpressionSpeedTree;
}

declare class MaterialExpressionSphereMask extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	Radius: ExpressionInput;
	Hardness: ExpressionInput;
	AttenuationRadius: number;
	HardnessPercent: number;
	static Load(ResourceName: string): MaterialExpressionSphereMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphereMask;
	static GetDefaultObject(): MaterialExpressionSphereMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphereMask;
	static C(Other: UObject | any): MaterialExpressionSphereMask;
}

declare class MaterialExpressionSphericalParticleOpacity extends MaterialExpression { 
	Density: ExpressionInput;
	ConstantDensity: number;
	static Load(ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static GetDefaultObject(): MaterialExpressionSphericalParticleOpacity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphericalParticleOpacity;
	static C(Other: UObject | any): MaterialExpressionSphericalParticleOpacity;
}

declare class MaterialExpressionSquareRoot extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSquareRoot;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSquareRoot;
	static GetDefaultObject(): MaterialExpressionSquareRoot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSquareRoot;
	static C(Other: UObject | any): MaterialExpressionSquareRoot;
}

declare class MaterialExpressionStaticBool extends MaterialExpression { 
	Value: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticBool;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBool;
	static GetDefaultObject(): MaterialExpressionStaticBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBool;
	static C(Other: UObject | any): MaterialExpressionStaticBool;
}

declare class MaterialExpressionStaticBoolParameter extends MaterialExpressionParameter { 
	DefaultValue: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticBoolParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBoolParameter;
	static GetDefaultObject(): MaterialExpressionStaticBoolParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBoolParameter;
	static C(Other: UObject | any): MaterialExpressionStaticBoolParameter;
}

declare class MaterialExpressionStaticComponentMaskParameter extends MaterialExpressionParameter { 
	Input: ExpressionInput;
	DefaultR: boolean;
	DefaultG: boolean;
	DefaultB: boolean;
	DefaultA: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static GetDefaultObject(): MaterialExpressionStaticComponentMaskParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticComponentMaskParameter;
	static C(Other: UObject | any): MaterialExpressionStaticComponentMaskParameter;
}

declare class MaterialExpressionStaticSwitch extends MaterialExpression { 
	DefaultValue: boolean;
	A: ExpressionInput;
	B: ExpressionInput;
	Value: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStaticSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitch;
	static GetDefaultObject(): MaterialExpressionStaticSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitch;
	static C(Other: UObject | any): MaterialExpressionStaticSwitch;
}

declare class MaterialExpressionStaticSwitchParameter extends MaterialExpressionStaticBoolParameter { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static GetDefaultObject(): MaterialExpressionStaticSwitchParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitchParameter;
	static C(Other: UObject | any): MaterialExpressionStaticSwitchParameter;
}

declare class MaterialExpressionStep extends MaterialExpression { 
	Y: ExpressionInput;
	X: ExpressionInput;
	ConstY: number;
	ConstX: number;
	static Load(ResourceName: string): MaterialExpressionStep;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStep;
	static GetDefaultObject(): MaterialExpressionStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStep;
	static C(Other: UObject | any): MaterialExpressionStep;
}

declare class MaterialExpressionStrataBSDF extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionStrataBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataBSDF;
	static GetDefaultObject(): MaterialExpressionStrataBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataBSDF;
}

declare class StrataMaterialInfo { 
	ShadingModelField: number;
	bHasShadingModelFromExpression: number;
	ConnectedProperties: number;
	SubsurfaceProfiles: SubsurfaceProfile[];
	clone() : StrataMaterialInfo;
	static C(Other: UObject | any): StrataMaterialInfo;
}

declare class MaterialExpressionStrataLegacyConversion extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Anisotropy: ExpressionInput;
	EmissiveColor: ExpressionInput;
	Normal: ExpressionInput;
	Tangent: ExpressionInput;
	SubsurfaceColor: ExpressionInput;
	ClearCoat: ExpressionInput;
	ClearCoatRoughness: ExpressionInput;
	Opacity: ExpressionInput;
	TransmittanceColor: ExpressionInput;
	WaterScatteringCoefficients: ExpressionInput;
	WaterAbsorptionCoefficients: ExpressionInput;
	WaterPhaseG: ExpressionInput;
	ColorScaleBehindWater: ExpressionInput;
	ClearCoatNormal: ExpressionInput;
	CustomTangent: ExpressionInput;
	ShadingModel: ShadingModelMaterialInput;
	SubsurfaceProfile: SubsurfaceProfile;
	ConvertedStrataMaterialInfo: StrataMaterialInfo;
	static Load(ResourceName: string): MaterialExpressionStrataLegacyConversion;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataLegacyConversion;
	static GetDefaultObject(): MaterialExpressionStrataLegacyConversion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataLegacyConversion;
	static C(Other: UObject | any): MaterialExpressionStrataLegacyConversion;
}

declare class MaterialExpressionStrataSlabBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	EdgeColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	DiffuseAlbedo: ExpressionInput;
	F0: ExpressionInput;
	F90: ExpressionInput;
	Roughness: ExpressionInput;
	Anisotropy: ExpressionInput;
	Normal: ExpressionInput;
	Tangent: ExpressionInput;
	SSSMFP: ExpressionInput;
	SSSMFPScale: ExpressionInput;
	SSSPhaseAnisotropy: ExpressionInput;
	EmissiveColor: ExpressionInput;
	SecondRoughness: ExpressionInput;
	SecondRoughnessWeight: ExpressionInput;
	Thickness: ExpressionInput;
	FuzzAmount: ExpressionInput;
	FuzzColor: ExpressionInput;
	SubsurfaceProfile: SubsurfaceProfile;
	bUseMetalness: boolean;
	bUseSSSDiffusion: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataSlabBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataSlabBSDF;
	static GetDefaultObject(): MaterialExpressionStrataSlabBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataSlabBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataSlabBSDF;
}

declare class MaterialExpressionStrataSimpleClearCoatBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	ClearCoatCoverage: ExpressionInput;
	ClearCoatRoughness: ExpressionInput;
	Normal: ExpressionInput;
	EmissiveColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataSimpleClearCoatBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataSimpleClearCoatBSDF;
	static GetDefaultObject(): MaterialExpressionStrataSimpleClearCoatBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataSimpleClearCoatBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataSimpleClearCoatBSDF;
}

declare class MaterialExpressionStrataVolumetricFogCloudBSDF extends MaterialExpressionStrataBSDF { 
	Albedo: ExpressionInput;
	Extinction: ExpressionInput;
	EmissiveColor: ExpressionInput;
	AmbientOcclusion: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static GetDefaultObject(): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataVolumetricFogCloudBSDF;
}

declare class MaterialExpressionStrataUnlitBSDF extends MaterialExpressionStrataBSDF { 
	EmissiveColor: ExpressionInput;
	TransmittanceColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataUnlitBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataUnlitBSDF;
	static GetDefaultObject(): MaterialExpressionStrataUnlitBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataUnlitBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataUnlitBSDF;
}

declare class MaterialExpressionStrataHairBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Scatter: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Backlit: ExpressionInput;
	Tangent: ExpressionInput;
	EmissiveColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataHairBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataHairBSDF;
	static GetDefaultObject(): MaterialExpressionStrataHairBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataHairBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataHairBSDF;
}

declare class MaterialExpressionStrataEyeBSDF extends MaterialExpressionStrataBSDF { 
	DiffuseColor: ExpressionInput;
	Roughness: ExpressionInput;
	CorneaNormal: ExpressionInput;
	IrisNormal: ExpressionInput;
	IrisPlaneNormal: ExpressionInput;
	IrisMask: ExpressionInput;
	IrisDistance: ExpressionInput;
	EmissiveColor: ExpressionInput;
	SubsurfaceProfile: SubsurfaceProfile;
	static Load(ResourceName: string): MaterialExpressionStrataEyeBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataEyeBSDF;
	static GetDefaultObject(): MaterialExpressionStrataEyeBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataEyeBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataEyeBSDF;
}

declare class MaterialExpressionStrataSingleLayerWaterBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Normal: ExpressionInput;
	EmissiveColor: ExpressionInput;
	TopMaterialOpacity: ExpressionInput;
	WaterAlbedo: ExpressionInput;
	WaterExtinction: ExpressionInput;
	WaterPhaseG: ExpressionInput;
	ColorScaleBehindWater: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataSingleLayerWaterBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataSingleLayerWaterBSDF;
	static GetDefaultObject(): MaterialExpressionStrataSingleLayerWaterBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataSingleLayerWaterBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataSingleLayerWaterBSDF;
}

declare class MaterialExpressionStrataLightFunction extends MaterialExpressionStrataBSDF { 
	Color: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataLightFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataLightFunction;
	static GetDefaultObject(): MaterialExpressionStrataLightFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataLightFunction;
	static C(Other: UObject | any): MaterialExpressionStrataLightFunction;
}

declare class MaterialExpressionStrataPostProcess extends MaterialExpressionStrataBSDF { 
	Color: ExpressionInput;
	Opacity: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataPostProcess;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataPostProcess;
	static GetDefaultObject(): MaterialExpressionStrataPostProcess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataPostProcess;
	static C(Other: UObject | any): MaterialExpressionStrataPostProcess;
}

declare class MaterialExpressionStrataConvertToDecal extends MaterialExpressionStrataBSDF { 
	DecalMaterial: ExpressionInput;
	Coverage: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataConvertToDecal;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataConvertToDecal;
	static GetDefaultObject(): MaterialExpressionStrataConvertToDecal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataConvertToDecal;
	static C(Other: UObject | any): MaterialExpressionStrataConvertToDecal;
}

declare class MaterialExpressionStrataHorizontalMixing extends MaterialExpressionStrataBSDF { 
	Background: ExpressionInput;
	Foreground: ExpressionInput;
	Mix: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataHorizontalMixing;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataHorizontalMixing;
	static GetDefaultObject(): MaterialExpressionStrataHorizontalMixing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataHorizontalMixing;
	static C(Other: UObject | any): MaterialExpressionStrataHorizontalMixing;
}

declare class MaterialExpressionStrataVerticalLayering extends MaterialExpressionStrataBSDF { 
	Top: ExpressionInput;
	Base: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataVerticalLayering;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataVerticalLayering;
	static GetDefaultObject(): MaterialExpressionStrataVerticalLayering;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataVerticalLayering;
	static C(Other: UObject | any): MaterialExpressionStrataVerticalLayering;
}

declare class MaterialExpressionStrataAdd extends MaterialExpressionStrataBSDF { 
	A: ExpressionInput;
	B: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataAdd;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataAdd;
	static GetDefaultObject(): MaterialExpressionStrataAdd;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataAdd;
	static C(Other: UObject | any): MaterialExpressionStrataAdd;
}

declare class MaterialExpressionStrataWeight extends MaterialExpressionStrataBSDF { 
	A: ExpressionInput;
	Weight: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataWeight;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataWeight;
	static GetDefaultObject(): MaterialExpressionStrataWeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataWeight;
	static C(Other: UObject | any): MaterialExpressionStrataWeight;
}

declare class MaterialExpressionStrataThinFilm extends MaterialExpressionStrataBSDF { 
	A: ExpressionInput;
	Thickness: ExpressionInput;
	IOR: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataThinFilm;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataThinFilm;
	static GetDefaultObject(): MaterialExpressionStrataThinFilm;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataThinFilm;
	static C(Other: UObject | any): MaterialExpressionStrataThinFilm;
}

declare class MaterialExpressionStrataUtilityBase extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionStrataUtilityBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataUtilityBase;
	static GetDefaultObject(): MaterialExpressionStrataUtilityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataUtilityBase;
	static C(Other: UObject | any): MaterialExpressionStrataUtilityBase;
}

declare class MaterialExpressionStrataTransmittanceToMFP extends MaterialExpressionStrataUtilityBase { 
	TransmittanceColor: ExpressionInput;
	Thickness: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataTransmittanceToMFP;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataTransmittanceToMFP;
	static GetDefaultObject(): MaterialExpressionStrataTransmittanceToMFP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataTransmittanceToMFP;
	static C(Other: UObject | any): MaterialExpressionStrataTransmittanceToMFP;
}

declare class MaterialExpressionStrataMetalnessToDiffuseAlbedoF0 extends MaterialExpressionStrataUtilityBase { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataMetalnessToDiffuseAlbedoF0;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataMetalnessToDiffuseAlbedoF0;
	static GetDefaultObject(): MaterialExpressionStrataMetalnessToDiffuseAlbedoF0;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataMetalnessToDiffuseAlbedoF0;
	static C(Other: UObject | any): MaterialExpressionStrataMetalnessToDiffuseAlbedoF0;
}

declare class MaterialExpressionStrataHazinessToSecondaryRoughness extends MaterialExpressionStrataUtilityBase { 
	BaseRoughness: ExpressionInput;
	Haziness: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataHazinessToSecondaryRoughness;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataHazinessToSecondaryRoughness;
	static GetDefaultObject(): MaterialExpressionStrataHazinessToSecondaryRoughness;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataHazinessToSecondaryRoughness;
	static C(Other: UObject | any): MaterialExpressionStrataHazinessToSecondaryRoughness;
}

declare class MaterialExpressionSubtract extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionSubtract;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSubtract;
	static GetDefaultObject(): MaterialExpressionSubtract;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSubtract;
	static C(Other: UObject | any): MaterialExpressionSubtract;
}

declare class MaterialExpressionTangent extends MaterialExpression { 
	Input: ExpressionInput;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionTangent;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTangent;
	static GetDefaultObject(): MaterialExpressionTangent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTangent;
	static C(Other: UObject | any): MaterialExpressionTangent;
}

declare class MaterialExpressionTangentOutput extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionTangentOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTangentOutput;
	static GetDefaultObject(): MaterialExpressionTangentOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTangentOutput;
	static C(Other: UObject | any): MaterialExpressionTangentOutput;
}

declare class MaterialExpressionTemporalSobol extends MaterialExpression { 
	Index: ExpressionInput;
	Seed: ExpressionInput;
	ConstIndex: number;
	ConstSeed: Vector2D;
	static Load(ResourceName: string): MaterialExpressionTemporalSobol;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTemporalSobol;
	static GetDefaultObject(): MaterialExpressionTemporalSobol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTemporalSobol;
	static C(Other: UObject | any): MaterialExpressionTemporalSobol;
}

declare class MaterialExpressionTextureCoordinate extends MaterialExpression { 
	CoordinateIndex: number;
	UTiling: number;
	VTiling: number;
	UnMirrorU: boolean;
	UnMirrorV: boolean;
	static Load(ResourceName: string): MaterialExpressionTextureCoordinate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureCoordinate;
	static GetDefaultObject(): MaterialExpressionTextureCoordinate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureCoordinate;
	static C(Other: UObject | any): MaterialExpressionTextureCoordinate;
}

declare class MaterialExpressionTextureObject extends MaterialExpressionTextureBase { 
	static Load(ResourceName: string): MaterialExpressionTextureObject;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObject;
	static GetDefaultObject(): MaterialExpressionTextureObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObject;
	static C(Other: UObject | any): MaterialExpressionTextureObject;
}

declare class MaterialExpressionTextureObjectParameter extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureObjectParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObjectParameter;
	static GetDefaultObject(): MaterialExpressionTextureObjectParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObjectParameter;
	static C(Other: UObject | any): MaterialExpressionTextureObjectParameter;
}

declare type EMaterialExposedTextureProperty = 'TMTM_TextureSize' | 'TMTM_TexelSize' | 'TMTM_MAX';
declare var EMaterialExposedTextureProperty : { TMTM_TextureSize:'TMTM_TextureSize',TMTM_TexelSize:'TMTM_TexelSize',TMTM_MAX:'TMTM_MAX', };
declare class MaterialExpressionTextureProperty extends MaterialExpression { 
	TextureObject: ExpressionInput;
	Property: EMaterialExposedTextureProperty;
	static Load(ResourceName: string): MaterialExpressionTextureProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureProperty;
	static GetDefaultObject(): MaterialExpressionTextureProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureProperty;
	static C(Other: UObject | any): MaterialExpressionTextureProperty;
}

declare class MaterialExpressionTextureSampleParameter2DArray extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter2DArray;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter2DArray;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter2DArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter2DArray;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameter2DArray;
}

declare class MaterialExpressionTextureSampleParameterCube extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterCube;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterCube;
}

declare class MaterialExpressionTextureSampleParameterCubeArray extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterCubeArray;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterCubeArray;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterCubeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterCubeArray;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterCubeArray;
}

declare class MaterialExpressionTextureSampleParameterSubUV extends MaterialExpressionTextureSampleParameter2D { 
	bBlend: boolean;
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterSubUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterSubUV;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterSubUV;
}

declare class MaterialExpressionTextureSampleParameterVolume extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterVolume;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterVolume;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterVolume;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterVolume;
}

declare class MaterialExpressionThinTranslucentMaterialOutput extends MaterialExpressionCustomOutput { 
	TransmittanceColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionThinTranslucentMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionThinTranslucentMaterialOutput;
	static GetDefaultObject(): MaterialExpressionThinTranslucentMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionThinTranslucentMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionThinTranslucentMaterialOutput;
}

declare class MaterialExpressionTime extends MaterialExpression { 
	bIgnorePause: boolean;
	bOverride_Period: boolean;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTime;
	static GetDefaultObject(): MaterialExpressionTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTime;
	static C(Other: UObject | any): MaterialExpressionTime;
}

declare type EMaterialVectorCoordTransformSource = 'TRANSFORMSOURCE_Tangent' | 'TRANSFORMSOURCE_Local' | 'TRANSFORMSOURCE_World' | 'TRANSFORMSOURCE_View' | 'TRANSFORMSOURCE_Camera' | 'TRANSFORMSOURCE_ParticleWorld' | 'TRANSFORMSOURCE_Instance' | 'TRANSFORMSOURCE_MAX';
declare var EMaterialVectorCoordTransformSource : { TRANSFORMSOURCE_Tangent:'TRANSFORMSOURCE_Tangent',TRANSFORMSOURCE_Local:'TRANSFORMSOURCE_Local',TRANSFORMSOURCE_World:'TRANSFORMSOURCE_World',TRANSFORMSOURCE_View:'TRANSFORMSOURCE_View',TRANSFORMSOURCE_Camera:'TRANSFORMSOURCE_Camera',TRANSFORMSOURCE_ParticleWorld:'TRANSFORMSOURCE_ParticleWorld',TRANSFORMSOURCE_Instance:'TRANSFORMSOURCE_Instance',TRANSFORMSOURCE_MAX:'TRANSFORMSOURCE_MAX', };
declare type EMaterialVectorCoordTransform = 'TRANSFORM_Tangent' | 'TRANSFORM_Local' | 'TRANSFORM_World' | 'TRANSFORM_View' | 'TRANSFORM_Camera' | 'TRANSFORM_ParticleWorld' | 'TRANSFORM_Instance' | 'TRANSFORM_MAX';
declare var EMaterialVectorCoordTransform : { TRANSFORM_Tangent:'TRANSFORM_Tangent',TRANSFORM_Local:'TRANSFORM_Local',TRANSFORM_World:'TRANSFORM_World',TRANSFORM_View:'TRANSFORM_View',TRANSFORM_Camera:'TRANSFORM_Camera',TRANSFORM_ParticleWorld:'TRANSFORM_ParticleWorld',TRANSFORM_Instance:'TRANSFORM_Instance',TRANSFORM_MAX:'TRANSFORM_MAX', };
declare class MaterialExpressionTransform extends MaterialExpression { 
	Input: ExpressionInput;
	TransformSourceType: EMaterialVectorCoordTransformSource;
	TransformType: EMaterialVectorCoordTransform;
	static Load(ResourceName: string): MaterialExpressionTransform;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransform;
	static GetDefaultObject(): MaterialExpressionTransform;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransform;
	static C(Other: UObject | any): MaterialExpressionTransform;
}

declare type EMaterialPositionTransformSource = 'TRANSFORMPOSSOURCE_Local' | 'TRANSFORMPOSSOURCE_World' | 'TRANSFORMPOSSOURCE_TranslatedWorld' | 'TRANSFORMPOSSOURCE_View' | 'TRANSFORMPOSSOURCE_Camera' | 'TRANSFORMPOSSOURCE_Particle' | 'TRANSFORMPOSSOURCE_Instance' | 'TRANSFORMPOSSOURCE_MAX';
declare var EMaterialPositionTransformSource : { TRANSFORMPOSSOURCE_Local:'TRANSFORMPOSSOURCE_Local',TRANSFORMPOSSOURCE_World:'TRANSFORMPOSSOURCE_World',TRANSFORMPOSSOURCE_TranslatedWorld:'TRANSFORMPOSSOURCE_TranslatedWorld',TRANSFORMPOSSOURCE_View:'TRANSFORMPOSSOURCE_View',TRANSFORMPOSSOURCE_Camera:'TRANSFORMPOSSOURCE_Camera',TRANSFORMPOSSOURCE_Particle:'TRANSFORMPOSSOURCE_Particle',TRANSFORMPOSSOURCE_Instance:'TRANSFORMPOSSOURCE_Instance',TRANSFORMPOSSOURCE_MAX:'TRANSFORMPOSSOURCE_MAX', };
declare class MaterialExpressionTransformPosition extends MaterialExpression { 
	Input: ExpressionInput;
	TransformSourceType: EMaterialPositionTransformSource;
	TransformType: EMaterialPositionTransformSource;
	static Load(ResourceName: string): MaterialExpressionTransformPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransformPosition;
	static GetDefaultObject(): MaterialExpressionTransformPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransformPosition;
	static C(Other: UObject | any): MaterialExpressionTransformPosition;
}

declare class MaterialExpressionTruncate extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionTruncate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTruncate;
	static GetDefaultObject(): MaterialExpressionTruncate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTruncate;
	static C(Other: UObject | any): MaterialExpressionTruncate;
}

declare class MaterialExpressionTwoSidedSign extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionTwoSidedSign;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTwoSidedSign;
	static GetDefaultObject(): MaterialExpressionTwoSidedSign;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTwoSidedSign;
	static C(Other: UObject | any): MaterialExpressionTwoSidedSign;
}

declare type EVectorNoiseFunction = 'VNF_CellnoiseALU' | 'VNF_VectorALU' | 'VNF_GradientALU' | 'VNF_CurlALU' | 'VNF_VoronoiALU' | 'VNF_MAX';
declare var EVectorNoiseFunction : { VNF_CellnoiseALU:'VNF_CellnoiseALU',VNF_VectorALU:'VNF_VectorALU',VNF_GradientALU:'VNF_GradientALU',VNF_CurlALU:'VNF_CurlALU',VNF_VoronoiALU:'VNF_VoronoiALU',VNF_MAX:'VNF_MAX', };
declare class MaterialExpressionVectorNoise extends MaterialExpression { 
	Position: ExpressionInput;
	NoiseFunction: EVectorNoiseFunction;
	Quality: number;
	bTiling: boolean;
	TileSize: number;
	static Load(ResourceName: string): MaterialExpressionVectorNoise;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVectorNoise;
	static GetDefaultObject(): MaterialExpressionVectorNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVectorNoise;
	static C(Other: UObject | any): MaterialExpressionVectorNoise;
}

declare class MaterialExpressionVertexColor extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexColor;
	static GetDefaultObject(): MaterialExpressionVertexColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexColor;
	static C(Other: UObject | any): MaterialExpressionVertexColor;
}

declare class MaterialExpressionVertexInterpolator extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionVertexInterpolator;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexInterpolator;
	static GetDefaultObject(): MaterialExpressionVertexInterpolator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexInterpolator;
	static C(Other: UObject | any): MaterialExpressionVertexInterpolator;
}

declare class MaterialExpressionVertexNormalWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexNormalWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexNormalWS;
	static GetDefaultObject(): MaterialExpressionVertexNormalWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexNormalWS;
	static C(Other: UObject | any): MaterialExpressionVertexNormalWS;
}

declare class MaterialExpressionVertexTangentWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexTangentWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexTangentWS;
	static GetDefaultObject(): MaterialExpressionVertexTangentWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexTangentWS;
	static C(Other: UObject | any): MaterialExpressionVertexTangentWS;
}

declare type EMaterialExposedViewProperty = 'MEVP_BufferSize' | 'MEVP_FieldOfView' | 'MEVP_TanHalfFieldOfView' | 'MEVP_ViewSize' | 'MEVP_WorldSpaceViewPosition' | 'MEVP_WorldSpaceCameraPosition' | 'MEVP_ViewportOffset' | 'MEVP_TemporalSampleCount' | 'MEVP_TemporalSampleIndex' | 'MEVP_TemporalSampleOffset' | 'MEVP_RuntimeVirtualTextureOutputLevel' | 'MEVP_RuntimeVirtualTextureOutputDerivative' | 'MEVP_PreExposure' | 'MEVP_RuntimeVirtualTextureMaxLevel' | 'MEVP_ResolutionFraction' | 'MEVP_MAX';
declare var EMaterialExposedViewProperty : { MEVP_BufferSize:'MEVP_BufferSize',MEVP_FieldOfView:'MEVP_FieldOfView',MEVP_TanHalfFieldOfView:'MEVP_TanHalfFieldOfView',MEVP_ViewSize:'MEVP_ViewSize',MEVP_WorldSpaceViewPosition:'MEVP_WorldSpaceViewPosition',MEVP_WorldSpaceCameraPosition:'MEVP_WorldSpaceCameraPosition',MEVP_ViewportOffset:'MEVP_ViewportOffset',MEVP_TemporalSampleCount:'MEVP_TemporalSampleCount',MEVP_TemporalSampleIndex:'MEVP_TemporalSampleIndex',MEVP_TemporalSampleOffset:'MEVP_TemporalSampleOffset',MEVP_RuntimeVirtualTextureOutputLevel:'MEVP_RuntimeVirtualTextureOutputLevel',MEVP_RuntimeVirtualTextureOutputDerivative:'MEVP_RuntimeVirtualTextureOutputDerivative',MEVP_PreExposure:'MEVP_PreExposure',MEVP_RuntimeVirtualTextureMaxLevel:'MEVP_RuntimeVirtualTextureMaxLevel',MEVP_ResolutionFraction:'MEVP_ResolutionFraction',MEVP_MAX:'MEVP_MAX', };
declare class MaterialExpressionViewProperty extends MaterialExpression { 
	Property: EMaterialExposedViewProperty;
	static Load(ResourceName: string): MaterialExpressionViewProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewProperty;
	static GetDefaultObject(): MaterialExpressionViewProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewProperty;
	static C(Other: UObject | any): MaterialExpressionViewProperty;
}

declare class MaterialExpressionViewSize extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionViewSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewSize;
	static GetDefaultObject(): MaterialExpressionViewSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewSize;
	static C(Other: UObject | any): MaterialExpressionViewSize;
}

declare class MaterialExpressionVirtualTextureFeatureSwitch extends MaterialExpression { 
	No: ExpressionInput;
	Yes: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionVirtualTextureFeatureSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVirtualTextureFeatureSwitch;
	static GetDefaultObject(): MaterialExpressionVirtualTextureFeatureSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVirtualTextureFeatureSwitch;
	static C(Other: UObject | any): MaterialExpressionVirtualTextureFeatureSwitch;
}

declare class MaterialExpressionVolumetricAdvancedMaterialInput extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialInput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialInput;
	static GetDefaultObject(): MaterialExpressionVolumetricAdvancedMaterialInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricAdvancedMaterialInput;
	static C(Other: UObject | any): MaterialExpressionVolumetricAdvancedMaterialInput;
}

declare class MaterialExpressionVolumetricCloudEmptySpaceSkippingInput extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVolumetricCloudEmptySpaceSkippingInput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricCloudEmptySpaceSkippingInput;
	static GetDefaultObject(): MaterialExpressionVolumetricCloudEmptySpaceSkippingInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricCloudEmptySpaceSkippingInput;
	static C(Other: UObject | any): MaterialExpressionVolumetricCloudEmptySpaceSkippingInput;
}

declare class MaterialExpressionVolumetricAdvancedMaterialOutput extends MaterialExpressionCustomOutput { 
	PhaseG: ExpressionInput;
	PhaseG2: ExpressionInput;
	PhaseBlend: ExpressionInput;
	MultiScatteringContribution: ExpressionInput;
	MultiScatteringOcclusion: ExpressionInput;
	MultiScatteringEccentricity: ExpressionInput;
	ConservativeDensity: ExpressionInput;
	ConstPhaseG: number;
	ConstPhaseG2: number;
	ConstPhaseBlend: number;
	PerSamplePhaseEvaluation: boolean;
	MultiScatteringApproximationOctaveCount: number;
	ConstMultiScatteringContribution: number;
	ConstMultiScatteringOcclusion: number;
	ConstMultiScatteringEccentricity: number;
	bGroundContribution: boolean;
	bGrayScaleMaterial: boolean;
	bRayMarchVolumeShadow: boolean;
	bClampMultiScatteringContribution: boolean;
	static Load(ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static GetDefaultObject(): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionVolumetricAdvancedMaterialOutput;
}

declare class MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput extends MaterialExpressionCustomOutput { 
	ContainsMatter: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput;
	static GetDefaultObject(): MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput;
	static C(Other: UObject | any): MaterialExpressionVolumetricCloudEmptySpaceSkippingOutput;
}

declare class MaterialExpressionWhileLoop extends MaterialExpression { 
	LoopBody: ExpressionExecOutput;
	Completed: ExpressionExecOutput;
	Condition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionWhileLoop;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionWhileLoop;
	static GetDefaultObject(): MaterialExpressionWhileLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionWhileLoop;
	static C(Other: UObject | any): MaterialExpressionWhileLoop;
}

declare type EWorldPositionIncludedOffsets = 'WPT_Default' | 'WPT_ExcludeAllShaderOffsets' | 'WPT_CameraRelative' | 'WPT_CameraRelativeNoOffsets' | 'WPT_MAX';
declare var EWorldPositionIncludedOffsets : { WPT_Default:'WPT_Default',WPT_ExcludeAllShaderOffsets:'WPT_ExcludeAllShaderOffsets',WPT_CameraRelative:'WPT_CameraRelative',WPT_CameraRelativeNoOffsets:'WPT_CameraRelativeNoOffsets',WPT_MAX:'WPT_MAX', };
declare class MaterialExpressionWorldPosition extends MaterialExpression { 
	WorldPositionShaderOffset: EWorldPositionIncludedOffsets;
	static Load(ResourceName: string): MaterialExpressionWorldPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionWorldPosition;
	static GetDefaultObject(): MaterialExpressionWorldPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionWorldPosition;
	static C(Other: UObject | any): MaterialExpressionWorldPosition;
}

declare class MaterialFunctionEditorOnlyData extends MaterialFunctionInterfaceEditorOnlyData { 
	ExpressionCollection: MaterialExpressionCollection;
	static Load(ResourceName: string): MaterialFunctionEditorOnlyData;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionEditorOnlyData;
	static GetDefaultObject(): MaterialFunctionEditorOnlyData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionEditorOnlyData;
	static C(Other: UObject | any): MaterialFunctionEditorOnlyData;
}

declare class MaterialFunctionMaterialLayer extends MaterialFunction { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayer;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayer;
	static GetDefaultObject(): MaterialFunctionMaterialLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayer;
	static C(Other: UObject | any): MaterialFunctionMaterialLayer;
}

declare class MaterialFunctionMaterialLayerInstance extends MaterialFunctionInstance { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerInstance;
	static GetDefaultObject(): MaterialFunctionMaterialLayerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerInstance;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerInstance;
}

declare class MaterialFunctionMaterialLayerBlend extends MaterialFunction { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerBlend;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerBlend;
	static GetDefaultObject(): MaterialFunctionMaterialLayerBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerBlend;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerBlend;
}

declare class MaterialFunctionMaterialLayerBlendInstance extends MaterialFunctionInstance { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerBlendInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerBlendInstance;
	static GetDefaultObject(): MaterialFunctionMaterialLayerBlendInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerBlendInstance;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerBlendInstance;
}

declare class PurchaseInfo { 
	Identifier: string;
	DisplayName: string;
	DisplayDescription: string;
	DisplayPrice: string;
	clone() : PurchaseInfo;
	static C(Other: UObject | any): PurchaseInfo;
}

declare class MicroTransactionBase extends PlatformInterfaceBase { 
	AvailableProducts: PurchaseInfo[];
	LastError: string;
	LastErrorSolution: string;
	static Load(ResourceName: string): MicroTransactionBase;
	static Find(Outer: UObject, ResourceName: string): MicroTransactionBase;
	static GetDefaultObject(): MicroTransactionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MicroTransactionBase;
	static C(Other: UObject | any): MicroTransactionBase;
}

declare class NavAgentInterface extends Interface { 
	static Load(ResourceName: string): NavAgentInterface;
	static Find(Outer: UObject, ResourceName: string): NavAgentInterface;
	static GetDefaultObject(): NavAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAgentInterface;
	static C(Other: UObject | any): NavAgentInterface;
}

declare class NavEdgeProviderInterface extends Interface { 
	static Load(ResourceName: string): NavEdgeProviderInterface;
	static Find(Outer: UObject, ResourceName: string): NavEdgeProviderInterface;
	static GetDefaultObject(): NavEdgeProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavEdgeProviderInterface;
	static C(Other: UObject | any): NavEdgeProviderInterface;
}

declare class NavigationDataInterface extends Interface { 
	static Load(ResourceName: string): NavigationDataInterface;
	static Find(Outer: UObject, ResourceName: string): NavigationDataInterface;
	static GetDefaultObject(): NavigationDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataInterface;
	static C(Other: UObject | any): NavigationDataInterface;
}

declare class NavPathObserverInterface extends Interface { 
	static Load(ResourceName: string): NavPathObserverInterface;
	static Find(Outer: UObject, ResourceName: string): NavPathObserverInterface;
	static GetDefaultObject(): NavPathObserverInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavPathObserverInterface;
	static C(Other: UObject | any): NavPathObserverInterface;
}

declare class NavRelevantInterface extends Interface { 
	static Load(ResourceName: string): NavRelevantInterface;
	static Find(Outer: UObject, ResourceName: string): NavRelevantInterface;
	static GetDefaultObject(): NavRelevantInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantInterface;
	static C(Other: UObject | any): NavRelevantInterface;
}

declare class NetworkPredictionInterface extends Interface { 
	static Load(ResourceName: string): NetworkPredictionInterface;
	static Find(Outer: UObject, ResourceName: string): NetworkPredictionInterface;
	static GetDefaultObject(): NetworkPredictionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkPredictionInterface;
	static C(Other: UObject | any): NetworkPredictionInterface;
}

declare class ParticleModuleAccelerationBase extends ParticleModule { 
	bAlwaysInWorldSpace: boolean;
	static Load(ResourceName: string): ParticleModuleAccelerationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationBase;
	static GetDefaultObject(): ParticleModuleAccelerationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationBase;
	static C(Other: UObject | any): ParticleModuleAccelerationBase;
}

declare class ParticleModuleAcceleration extends ParticleModuleAccelerationBase { 
	Acceleration: RawDistributionVector;
	bApplyOwnerScale: boolean;
	static Load(ResourceName: string): ParticleModuleAcceleration;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAcceleration;
	static GetDefaultObject(): ParticleModuleAcceleration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAcceleration;
	static C(Other: UObject | any): ParticleModuleAcceleration;
}

declare class ParticleModuleAccelerationConstant extends ParticleModuleAccelerationBase { 
	Acceleration: Vector;
	static Load(ResourceName: string): ParticleModuleAccelerationConstant;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationConstant;
	static GetDefaultObject(): ParticleModuleAccelerationConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationConstant;
	static C(Other: UObject | any): ParticleModuleAccelerationConstant;
}

declare class ParticleModuleAccelerationDrag extends ParticleModuleAccelerationBase { 
	DragCoefficient: DistributionFloat;
	DragCoefficientRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAccelerationDrag;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDrag;
	static GetDefaultObject(): ParticleModuleAccelerationDrag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDrag;
	static C(Other: UObject | any): ParticleModuleAccelerationDrag;
}

declare class ParticleModuleAccelerationDragScaleOverLife extends ParticleModuleAccelerationBase { 
	DragScale: DistributionFloat;
	DragScaleRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static GetDefaultObject(): ParticleModuleAccelerationDragScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDragScaleOverLife;
	static C(Other: UObject | any): ParticleModuleAccelerationDragScaleOverLife;
}

declare class ParticleModuleAccelerationOverLifetime extends ParticleModuleAccelerationBase { 
	AccelOverLife: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static GetDefaultObject(): ParticleModuleAccelerationOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationOverLifetime;
	static C(Other: UObject | any): ParticleModuleAccelerationOverLifetime;
}

declare class ParticleModuleAttractorBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleAttractorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorBase;
	static GetDefaultObject(): ParticleModuleAttractorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorBase;
	static C(Other: UObject | any): ParticleModuleAttractorBase;
}

declare class ParticleModuleAttractorLine extends ParticleModuleAttractorBase { 
	EndPoint0: Vector;
	EndPoint1: Vector;
	Range: RawDistributionFloat;
	Strength: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAttractorLine;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorLine;
	static GetDefaultObject(): ParticleModuleAttractorLine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorLine;
	static C(Other: UObject | any): ParticleModuleAttractorLine;
}

declare type EAttractorParticleSelectionMethod = 'EAPSM_Random' | 'EAPSM_Sequential' | 'EAPSM_MAX';
declare var EAttractorParticleSelectionMethod : { EAPSM_Random:'EAPSM_Random',EAPSM_Sequential:'EAPSM_Sequential',EAPSM_MAX:'EAPSM_MAX', };
declare class ParticleModuleAttractorParticle extends ParticleModuleAttractorBase { 
	EmitterName: string;
	Range: RawDistributionFloat;
	bStrengthByDistance: boolean;
	Strength: RawDistributionFloat;
	bAffectBaseVelocity: boolean;
	SelectionMethod: EAttractorParticleSelectionMethod;
	bRenewSource: boolean;
	bInheritSourceVel: boolean;
	LastSelIndex: number;
	static Load(ResourceName: string): ParticleModuleAttractorParticle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorParticle;
	static GetDefaultObject(): ParticleModuleAttractorParticle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorParticle;
	static C(Other: UObject | any): ParticleModuleAttractorParticle;
}

declare class ParticleModuleAttractorPoint extends ParticleModuleAttractorBase { 
	Position: RawDistributionVector;
	Range: RawDistributionFloat;
	Strength: RawDistributionFloat;
	StrengthByDistance: boolean;
	bAffectBaseVelocity: boolean;
	bOverrideVelocity: boolean;
	bUseWorldSpacePosition: boolean;
	Positive_X: boolean;
	Positive_Y: boolean;
	Positive_Z: boolean;
	Negative_X: boolean;
	Negative_Y: boolean;
	Negative_Z: boolean;
	static Load(ResourceName: string): ParticleModuleAttractorPoint;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPoint;
	static GetDefaultObject(): ParticleModuleAttractorPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPoint;
	static C(Other: UObject | any): ParticleModuleAttractorPoint;
}

declare class ParticleModuleAttractorPointGravity extends ParticleModuleAttractorBase { 
	Position: Vector;
	Radius: number;
	Strength: DistributionFloat;
	StrengthRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAttractorPointGravity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPointGravity;
	static GetDefaultObject(): ParticleModuleAttractorPointGravity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPointGravity;
	static C(Other: UObject | any): ParticleModuleAttractorPointGravity;
}

declare class ParticleModuleBeamBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleBeamBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamBase;
	static GetDefaultObject(): ParticleModuleBeamBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamBase;
	static C(Other: UObject | any): ParticleModuleBeamBase;
}

declare type BeamModifierType = 'PEB2MT_Source' | 'PEB2MT_Target' | 'PEB2MT_MAX';
declare var BeamModifierType : { PEB2MT_Source:'PEB2MT_Source',PEB2MT_Target:'PEB2MT_Target',PEB2MT_MAX:'PEB2MT_MAX', };
declare class BeamModifierOptions { 
	bModify: boolean;
	bScale: boolean;
	bLock: boolean;
	clone() : BeamModifierOptions;
	static C(Other: UObject | any): BeamModifierOptions;
}

declare class ParticleModuleBeamModifier extends ParticleModuleBeamBase { 
	ModifierType: BeamModifierType;
	PositionOptions: BeamModifierOptions;
	Position: RawDistributionVector;
	TangentOptions: BeamModifierOptions;
	Tangent: RawDistributionVector;
	bAbsoluteTangent: boolean;
	StrengthOptions: BeamModifierOptions;
	Strength: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleBeamModifier;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamModifier;
	static GetDefaultObject(): ParticleModuleBeamModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamModifier;
	static C(Other: UObject | any): ParticleModuleBeamModifier;
}

declare class ParticleModuleBeamNoise extends ParticleModuleBeamBase { 
	bLowFreq_Enabled: boolean;
	Frequency: number;
	Frequency_LowRange: number;
	NoiseRange: RawDistributionVector;
	NoiseRangeScale: RawDistributionFloat;
	bNRScaleEmitterTime: boolean;
	NoiseSpeed: RawDistributionVector;
	bSmooth: boolean;
	NoiseLockRadius: number;
	bNoiseLock: boolean;
	bOscillate: boolean;
	NoiseLockTime: number;
	NoiseTension: number;
	bUseNoiseTangents: boolean;
	NoiseTangentStrength: RawDistributionFloat;
	NoiseTessellation: number;
	bTargetNoise: boolean;
	FrequencyDistance: number;
	bApplyNoiseScale: boolean;
	NoiseScale: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleBeamNoise;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamNoise;
	static GetDefaultObject(): ParticleModuleBeamNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamNoise;
	static C(Other: UObject | any): ParticleModuleBeamNoise;
}

declare type Beam2SourceTargetMethod = 'PEB2STM_Default' | 'PEB2STM_UserSet' | 'PEB2STM_Emitter' | 'PEB2STM_Particle' | 'PEB2STM_Actor' | 'PEB2STM_MAX';
declare var Beam2SourceTargetMethod : { PEB2STM_Default:'PEB2STM_Default',PEB2STM_UserSet:'PEB2STM_UserSet',PEB2STM_Emitter:'PEB2STM_Emitter',PEB2STM_Particle:'PEB2STM_Particle',PEB2STM_Actor:'PEB2STM_Actor',PEB2STM_MAX:'PEB2STM_MAX', };
declare type Beam2SourceTargetTangentMethod = 'PEB2STTM_Direct' | 'PEB2STTM_UserSet' | 'PEB2STTM_Distribution' | 'PEB2STTM_Emitter' | 'PEB2STTM_MAX';
declare var Beam2SourceTargetTangentMethod : { PEB2STTM_Direct:'PEB2STTM_Direct',PEB2STTM_UserSet:'PEB2STTM_UserSet',PEB2STTM_Distribution:'PEB2STTM_Distribution',PEB2STTM_Emitter:'PEB2STTM_Emitter',PEB2STTM_MAX:'PEB2STTM_MAX', };
declare class ParticleModuleBeamSource extends ParticleModuleBeamBase { 
	SourceMethod: Beam2SourceTargetMethod;
	SourceName: string;
	bSourceAbsolute: boolean;
	Source: RawDistributionVector;
	bLockSource: boolean;
	SourceTangentMethod: Beam2SourceTargetTangentMethod;
	SourceTangent: RawDistributionVector;
	bLockSourceTangent: boolean;
	SourceStrength: RawDistributionFloat;
	bLockSourceStength: boolean;
	static Load(ResourceName: string): ParticleModuleBeamSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamSource;
	static GetDefaultObject(): ParticleModuleBeamSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamSource;
	static C(Other: UObject | any): ParticleModuleBeamSource;
}

declare class ParticleModuleBeamTarget extends ParticleModuleBeamBase { 
	TargetMethod: Beam2SourceTargetMethod;
	TargetName: string;
	Target: RawDistributionVector;
	bTargetAbsolute: boolean;
	bLockTarget: boolean;
	TargetTangentMethod: Beam2SourceTargetTangentMethod;
	TargetTangent: RawDistributionVector;
	bLockTargetTangent: boolean;
	TargetStrength: RawDistributionFloat;
	bLockTargetStength: boolean;
	LockRadius: number;
	static Load(ResourceName: string): ParticleModuleBeamTarget;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamTarget;
	static GetDefaultObject(): ParticleModuleBeamTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamTarget;
	static C(Other: UObject | any): ParticleModuleBeamTarget;
}

declare class ParticleModuleCameraBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleCameraBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraBase;
	static GetDefaultObject(): ParticleModuleCameraBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraBase;
	static C(Other: UObject | any): ParticleModuleCameraBase;
}

declare type EParticleCameraOffsetUpdateMethod = 'EPCOUM_DirectSet' | 'EPCOUM_Additive' | 'EPCOUM_Scalar' | 'EPCOUM_MAX';
declare var EParticleCameraOffsetUpdateMethod : { EPCOUM_DirectSet:'EPCOUM_DirectSet',EPCOUM_Additive:'EPCOUM_Additive',EPCOUM_Scalar:'EPCOUM_Scalar',EPCOUM_MAX:'EPCOUM_MAX', };
declare class ParticleModuleCameraOffset extends ParticleModuleCameraBase { 
	CameraOffset: RawDistributionFloat;
	bSpawnTimeOnly: boolean;
	UpdateMethod: EParticleCameraOffsetUpdateMethod;
	static Load(ResourceName: string): ParticleModuleCameraOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraOffset;
	static GetDefaultObject(): ParticleModuleCameraOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraOffset;
	static C(Other: UObject | any): ParticleModuleCameraOffset;
}

declare class ParticleModuleCollisionBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleCollisionBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionBase;
	static GetDefaultObject(): ParticleModuleCollisionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionBase;
	static C(Other: UObject | any): ParticleModuleCollisionBase;
}

declare type EParticleCollisionComplete = 'EPCC_Kill' | 'EPCC_Freeze' | 'EPCC_HaltCollisions' | 'EPCC_FreezeTranslation' | 'EPCC_FreezeRotation' | 'EPCC_FreezeMovement' | 'EPCC_MAX';
declare var EParticleCollisionComplete : { EPCC_Kill:'EPCC_Kill',EPCC_Freeze:'EPCC_Freeze',EPCC_HaltCollisions:'EPCC_HaltCollisions',EPCC_FreezeTranslation:'EPCC_FreezeTranslation',EPCC_FreezeRotation:'EPCC_FreezeRotation',EPCC_FreezeMovement:'EPCC_FreezeMovement',EPCC_MAX:'EPCC_MAX', };
declare class ParticleModuleCollision extends ParticleModuleCollisionBase { 
	DampingFactor: RawDistributionVector;
	DampingFactorRotation: RawDistributionVector;
	MaxCollisions: RawDistributionFloat;
	CollisionCompletionOption: EParticleCollisionComplete;
	CollisionTypes: EObjectTypeQuery[];
	bApplyPhysics: boolean;
	bIgnoreTriggerVolumes: boolean;
	ParticleMass: RawDistributionFloat;
	DirScalar: number;
	bPawnsDoNotDecrementCount: boolean;
	bOnlyVerticalNormalsDecrementCount: boolean;
	VerticalFudgeFactor: number;
	DelayAmount: RawDistributionFloat;
	bDropDetail: boolean;
	bCollideOnlyIfVisible: boolean;
	bIgnoreSourceActor: boolean;
	MaxCollisionDistance: number;
	static Load(ResourceName: string): ParticleModuleCollision;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollision;
	static GetDefaultObject(): ParticleModuleCollision;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollision;
	static C(Other: UObject | any): ParticleModuleCollision;
}

declare type EParticleCollisionResponse = 'Bounce' | 'Stop' | 'Kill' | 'EParticleCollisionResponse_MAX';
declare var EParticleCollisionResponse : { Bounce:'Bounce',Stop:'Stop',Kill:'Kill',EParticleCollisionResponse_MAX:'EParticleCollisionResponse_MAX', };
declare type EParticleCollisionMode = 'SceneDepth' | 'DistanceField' | 'EParticleCollisionMode_MAX';
declare var EParticleCollisionMode : { SceneDepth:'SceneDepth',DistanceField:'DistanceField',EParticleCollisionMode_MAX:'EParticleCollisionMode_MAX', };
declare class ParticleModuleCollisionGPU extends ParticleModuleCollisionBase { 
	Resilience: RawDistributionFloat;
	ResilienceScaleOverLife: RawDistributionFloat;
	Friction: number;
	RandomSpread: number;
	RandomDistribution: number;
	RadiusScale: number;
	RadiusBias: number;
	Response: EParticleCollisionResponse;
	CollisionMode: EParticleCollisionMode;
	static Load(ResourceName: string): ParticleModuleCollisionGPU;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionGPU;
	static GetDefaultObject(): ParticleModuleCollisionGPU;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionGPU;
	static C(Other: UObject | any): ParticleModuleCollisionGPU;
}

declare class ParticleModuleColorBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleColorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorBase;
	static GetDefaultObject(): ParticleModuleColorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorBase;
	static C(Other: UObject | any): ParticleModuleColorBase;
}

declare class ParticleModuleColor extends ParticleModuleColorBase { 
	StartColor: RawDistributionVector;
	StartAlpha: RawDistributionFloat;
	bClampAlpha: boolean;
	static Load(ResourceName: string): ParticleModuleColor;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor;
	static GetDefaultObject(): ParticleModuleColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor;
	static C(Other: UObject | any): ParticleModuleColor;
}

declare class ParticleModuleColorOverLife extends ParticleModuleColorBase { 
	ColorOverLife: RawDistributionVector;
	AlphaOverLife: RawDistributionFloat;
	bClampAlpha: boolean;
	static Load(ResourceName: string): ParticleModuleColorOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorOverLife;
	static GetDefaultObject(): ParticleModuleColorOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorOverLife;
	static C(Other: UObject | any): ParticleModuleColorOverLife;
}

declare class ParticleModuleColorScaleOverLife extends ParticleModuleColorBase { 
	ColorScaleOverLife: RawDistributionVector;
	AlphaScaleOverLife: RawDistributionFloat;
	bEmitterTime: boolean;
	static Load(ResourceName: string): ParticleModuleColorScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorScaleOverLife;
	static GetDefaultObject(): ParticleModuleColorScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorScaleOverLife;
	static C(Other: UObject | any): ParticleModuleColorScaleOverLife;
}

declare class ParticleRandomSeedInfo { 
	ParameterName: string;
	bGetSeedFromInstance: boolean;
	bInstanceSeedIsIndex: boolean;
	bResetSeedOnEmitterLooping: boolean;
	bRandomlySelectSeedArray: boolean;
	RandomSeeds: number[];
	clone() : ParticleRandomSeedInfo;
	static C(Other: UObject | any): ParticleRandomSeedInfo;
}

declare class ParticleModuleColor_Seeded extends ParticleModuleColor { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleColor_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor_Seeded;
	static GetDefaultObject(): ParticleModuleColor_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor_Seeded;
	static C(Other: UObject | any): ParticleModuleColor_Seeded;
}

declare class ParticleModuleEventReceiverKillParticles extends ParticleModuleEventReceiverBase { 
	bStopSpawning: boolean;
	static Load(ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static GetDefaultObject(): ParticleModuleEventReceiverKillParticles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverKillParticles;
	static C(Other: UObject | any): ParticleModuleEventReceiverKillParticles;
}

declare class ParticleModuleEventReceiverSpawn extends ParticleModuleEventReceiverBase { 
	SpawnCount: RawDistributionFloat;
	bUseParticleTime: boolean;
	bUsePSysLocation: boolean;
	bInheritVelocity: boolean;
	InheritVelocityScale: RawDistributionVector;
	PhysicalMaterials: PhysicalMaterial[];
	bBanPhysicalMaterials: boolean;
	static Load(ResourceName: string): ParticleModuleEventReceiverSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverSpawn;
	static GetDefaultObject(): ParticleModuleEventReceiverSpawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverSpawn;
	static C(Other: UObject | any): ParticleModuleEventReceiverSpawn;
}

declare class ParticleModuleKillBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleKillBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBase;
	static GetDefaultObject(): ParticleModuleKillBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBase;
	static C(Other: UObject | any): ParticleModuleKillBase;
}

declare class ParticleModuleKillBox extends ParticleModuleKillBase { 
	LowerLeftCorner: RawDistributionVector;
	UpperRightCorner: RawDistributionVector;
	bAbsolute: boolean;
	bKillInside: boolean;
	bAxisAlignedAndFixedSize: boolean;
	static Load(ResourceName: string): ParticleModuleKillBox;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBox;
	static GetDefaultObject(): ParticleModuleKillBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBox;
	static C(Other: UObject | any): ParticleModuleKillBox;
}

declare class ParticleModuleKillHeight extends ParticleModuleKillBase { 
	Height: RawDistributionFloat;
	bAbsolute: boolean;
	bFloor: boolean;
	bApplyPSysScale: boolean;
	static Load(ResourceName: string): ParticleModuleKillHeight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillHeight;
	static GetDefaultObject(): ParticleModuleKillHeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillHeight;
	static C(Other: UObject | any): ParticleModuleKillHeight;
}

declare class ParticleModuleLifetimeBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLifetimeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetimeBase;
	static GetDefaultObject(): ParticleModuleLifetimeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetimeBase;
	static C(Other: UObject | any): ParticleModuleLifetimeBase;
}

declare class ParticleModuleLifetime extends ParticleModuleLifetimeBase { 
	Lifetime: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime;
	static GetDefaultObject(): ParticleModuleLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime;
	static C(Other: UObject | any): ParticleModuleLifetime;
}

declare class ParticleModuleLifetime_Seeded extends ParticleModuleLifetime { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLifetime_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime_Seeded;
	static GetDefaultObject(): ParticleModuleLifetime_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime_Seeded;
	static C(Other: UObject | any): ParticleModuleLifetime_Seeded;
}

declare class ParticleModuleLightBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLightBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLightBase;
	static GetDefaultObject(): ParticleModuleLightBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLightBase;
	static C(Other: UObject | any): ParticleModuleLightBase;
}

declare class ParticleModuleLight extends ParticleModuleLightBase { 
	bUseInverseSquaredFalloff: boolean;
	bAffectsTranslucency: boolean;
	bOverrideInverseExposureBlend: boolean;
	bPreviewLightRadius: boolean;
	SpawnFraction: number;
	ColorScaleOverLife: RawDistributionVector;
	BrightnessOverLife: RawDistributionFloat;
	RadiusScale: RawDistributionFloat;
	LightExponent: RawDistributionFloat;
	InverseExposureBlend: number;
	LightingChannels: LightingChannels;
	VolumetricScatteringIntensity: number;
	bHighQualityLights: boolean;
	bShadowCastingLights: boolean;
	static Load(ResourceName: string): ParticleModuleLight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight;
	static GetDefaultObject(): ParticleModuleLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight;
	static C(Other: UObject | any): ParticleModuleLight;
}

declare class ParticleModuleLight_Seeded extends ParticleModuleLight { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLight_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight_Seeded;
	static GetDefaultObject(): ParticleModuleLight_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight_Seeded;
	static C(Other: UObject | any): ParticleModuleLight_Seeded;
}

declare class ParticleModuleLocationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLocationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBase;
	static GetDefaultObject(): ParticleModuleLocationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBase;
	static C(Other: UObject | any): ParticleModuleLocationBase;
}

declare class ParticleModuleLocation extends ParticleModuleLocationBase { 
	StartLocation: RawDistributionVector;
	DistributeOverNPoints: number;
	DistributeThreshold: number;
	static Load(ResourceName: string): ParticleModuleLocation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation;
	static GetDefaultObject(): ParticleModuleLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation;
	static C(Other: UObject | any): ParticleModuleLocation;
}

declare type ELocationBoneSocketSource = 'BONESOCKETSOURCE_Bones' | 'BONESOCKETSOURCE_Sockets' | 'BONESOCKETSOURCE_MAX';
declare var ELocationBoneSocketSource : { BONESOCKETSOURCE_Bones:'BONESOCKETSOURCE_Bones',BONESOCKETSOURCE_Sockets:'BONESOCKETSOURCE_Sockets',BONESOCKETSOURCE_MAX:'BONESOCKETSOURCE_MAX', };
declare class LocationBoneSocketInfo { 
	BoneSocketName: string;
	Offset: Vector;
	clone() : LocationBoneSocketInfo;
	static C(Other: UObject | any): LocationBoneSocketInfo;
}

declare type ELocationBoneSocketSelectionMethod = 'BONESOCKETSEL_Sequential' | 'BONESOCKETSEL_Random' | 'BONESOCKETSEL_MAX';
declare var ELocationBoneSocketSelectionMethod : { BONESOCKETSEL_Sequential:'BONESOCKETSEL_Sequential',BONESOCKETSEL_Random:'BONESOCKETSEL_Random',BONESOCKETSEL_MAX:'BONESOCKETSEL_MAX', };
declare class ParticleModuleLocationBoneSocket extends ParticleModuleLocationBase { 
	SourceType: ELocationBoneSocketSource;
	UniversalOffset: Vector;
	SourceLocations: LocationBoneSocketInfo[];
	SelectionMethod: ELocationBoneSocketSelectionMethod;
	bUpdatePositionEachFrame: boolean;
	bOrientMeshEmitters: boolean;
	bInheritBoneVelocity: boolean;
	InheritVelocityScale: number;
	SkelMeshActorParamName: string;
	NumPreSelectedIndices: number;
	EditorSkelMesh: SkeletalMesh;
	static Load(ResourceName: string): ParticleModuleLocationBoneSocket;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBoneSocket;
	static GetDefaultObject(): ParticleModuleLocationBoneSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBoneSocket;
	static C(Other: UObject | any): ParticleModuleLocationBoneSocket;
}

declare class ParticleModuleLocationDirect extends ParticleModuleLocationBase { 
	Location: RawDistributionVector;
	LocationOffset: RawDistributionVector;
	ScaleFactor: RawDistributionVector;
	Direction: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleLocationDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationDirect;
	static GetDefaultObject(): ParticleModuleLocationDirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationDirect;
	static C(Other: UObject | any): ParticleModuleLocationDirect;
}

declare type ELocationEmitterSelectionMethod = 'ELESM_Random' | 'ELESM_Sequential' | 'ELESM_MAX';
declare var ELocationEmitterSelectionMethod : { ELESM_Random:'ELESM_Random',ELESM_Sequential:'ELESM_Sequential',ELESM_MAX:'ELESM_MAX', };
declare class ParticleModuleLocationEmitter extends ParticleModuleLocationBase { 
	EmitterName: string;
	SelectionMethod: ELocationEmitterSelectionMethod;
	InheritSourceVelocity: boolean;
	InheritSourceVelocityScale: number;
	bInheritSourceRotation: boolean;
	InheritSourceRotationScale: number;
	static Load(ResourceName: string): ParticleModuleLocationEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitter;
	static GetDefaultObject(): ParticleModuleLocationEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitter;
	static C(Other: UObject | any): ParticleModuleLocationEmitter;
}

declare class ParticleModuleLocationEmitterDirect extends ParticleModuleLocationBase { 
	EmitterName: string;
	static Load(ResourceName: string): ParticleModuleLocationEmitterDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitterDirect;
	static GetDefaultObject(): ParticleModuleLocationEmitterDirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitterDirect;
	static C(Other: UObject | any): ParticleModuleLocationEmitterDirect;
}

declare class ParticleModuleLocationPrimitiveBase extends ParticleModuleLocationBase { 
	Positive_X: boolean;
	Positive_Y: boolean;
	Positive_Z: boolean;
	Negative_X: boolean;
	Negative_Y: boolean;
	Negative_Z: boolean;
	SurfaceOnly: boolean;
	Velocity: boolean;
	VelocityScale: RawDistributionFloat;
	StartLocation: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveBase;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveBase;
}

declare type CylinderHeightAxis = 'PMLPC_HEIGHTAXIS_X' | 'PMLPC_HEIGHTAXIS_Y' | 'PMLPC_HEIGHTAXIS_Z' | 'PMLPC_HEIGHTAXIS_MAX';
declare var CylinderHeightAxis : { PMLPC_HEIGHTAXIS_X:'PMLPC_HEIGHTAXIS_X',PMLPC_HEIGHTAXIS_Y:'PMLPC_HEIGHTAXIS_Y',PMLPC_HEIGHTAXIS_Z:'PMLPC_HEIGHTAXIS_Z',PMLPC_HEIGHTAXIS_MAX:'PMLPC_HEIGHTAXIS_MAX', };
declare class ParticleModuleLocationPrimitiveCylinder extends ParticleModuleLocationPrimitiveBase { 
	RadialVelocity: boolean;
	StartRadius: RawDistributionFloat;
	StartHeight: RawDistributionFloat;
	HeightAxis: CylinderHeightAxis;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveCylinder;
}

declare class ParticleModuleLocationPrimitiveCylinder_Seeded extends ParticleModuleLocationPrimitiveCylinder { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveCylinder_Seeded;
}

declare class ParticleModuleLocationPrimitiveSphere extends ParticleModuleLocationPrimitiveBase { 
	StartRadius: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveSphere;
}

declare class ParticleModuleLocationPrimitiveSphere_Seeded extends ParticleModuleLocationPrimitiveSphere { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveSphere_Seeded;
}

declare class ParticleModuleLocationPrimitiveTriangle extends ParticleModuleLocationBase { 
	StartOffset: RawDistributionVector;
	Height: RawDistributionFloat;
	Angle: RawDistributionFloat;
	Thickness: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveTriangle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveTriangle;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveTriangle;
}

declare type ELocationSkelVertSurfaceSource = 'VERTSURFACESOURCE_Vert' | 'VERTSURFACESOURCE_Surface' | 'VERTSURFACESOURCE_MAX';
declare var ELocationSkelVertSurfaceSource : { VERTSURFACESOURCE_Vert:'VERTSURFACESOURCE_Vert',VERTSURFACESOURCE_Surface:'VERTSURFACESOURCE_Surface',VERTSURFACESOURCE_MAX:'VERTSURFACESOURCE_MAX', };
declare class ParticleModuleLocationSkelVertSurface extends ParticleModuleLocationBase { 
	SourceType: ELocationSkelVertSurfaceSource;
	UniversalOffset: Vector;
	bUpdatePositionEachFrame: boolean;
	bOrientMeshEmitters: boolean;
	bInheritBoneVelocity: boolean;
	InheritVelocityScale: number;
	SkelMeshActorParamName: string;
	EditorSkelMesh: SkeletalMesh;
	ValidAssociatedBones: string[];
	bEnforceNormalCheck: boolean;
	NormalToCompare: Vector;
	NormalCheckToleranceDegrees: number;
	NormalCheckTolerance: number;
	ValidMaterialIndices: number[];
	bInheritVertexColor: boolean;
	bInheritUV: boolean;
	InheritUVChannel: number;
	static Load(ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static GetDefaultObject(): ParticleModuleLocationSkelVertSurface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationSkelVertSurface;
	static C(Other: UObject | any): ParticleModuleLocationSkelVertSurface;
}

declare class ParticleModuleLocationWorldOffset extends ParticleModuleLocation { 
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset;
	static C(Other: UObject | any): ParticleModuleLocationWorldOffset;
}

declare class ParticleModuleLocationWorldOffset_Seeded extends ParticleModuleLocationWorldOffset { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationWorldOffset_Seeded;
}

declare class ParticleModuleLocation_Seeded extends ParticleModuleLocation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation_Seeded;
	static GetDefaultObject(): ParticleModuleLocation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation_Seeded;
	static C(Other: UObject | any): ParticleModuleLocation_Seeded;
}

declare class ParticleModuleMaterialBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleMaterialBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMaterialBase;
	static GetDefaultObject(): ParticleModuleMaterialBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMaterialBase;
	static C(Other: UObject | any): ParticleModuleMaterialBase;
}

declare class ParticleModuleMeshMaterial extends ParticleModuleMaterialBase { 
	MeshMaterials: MaterialInterface[];
	static Load(ResourceName: string): ParticleModuleMeshMaterial;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshMaterial;
	static GetDefaultObject(): ParticleModuleMeshMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshMaterial;
	static C(Other: UObject | any): ParticleModuleMeshMaterial;
}

declare class ParticleModuleRotationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleRotationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationBase;
	static GetDefaultObject(): ParticleModuleRotationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationBase;
	static C(Other: UObject | any): ParticleModuleRotationBase;
}

declare class ParticleModuleMeshRotation extends ParticleModuleRotationBase { 
	StartRotation: RawDistributionVector;
	bInheritParent: boolean;
	static Load(ResourceName: string): ParticleModuleMeshRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation;
	static GetDefaultObject(): ParticleModuleMeshRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation;
	static C(Other: UObject | any): ParticleModuleMeshRotation;
}

declare class ParticleModuleRotationRateBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleRotationRateBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateBase;
	static GetDefaultObject(): ParticleModuleRotationRateBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateBase;
	static C(Other: UObject | any): ParticleModuleRotationRateBase;
}

declare class ParticleModuleMeshRotationRate extends ParticleModuleRotationRateBase { 
	StartRotationRate: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleMeshRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate;
	static GetDefaultObject(): ParticleModuleMeshRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate;
	static C(Other: UObject | any): ParticleModuleMeshRotationRate;
}

declare class ParticleModuleMeshRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	LifeMultiplier: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static GetDefaultObject(): ParticleModuleMeshRotationRateMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateMultiplyLife;
	static C(Other: UObject | any): ParticleModuleMeshRotationRateMultiplyLife;
}

declare class ParticleModuleMeshRotationRateOverLife extends ParticleModuleRotationRateBase { 
	RotRate: RawDistributionVector;
	bScaleRotRate: boolean;
	static Load(ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static GetDefaultObject(): ParticleModuleMeshRotationRateOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateOverLife;
	static C(Other: UObject | any): ParticleModuleMeshRotationRateOverLife;
}

declare class ParticleModuleMeshRotationRate_Seeded extends ParticleModuleMeshRotationRate { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static GetDefaultObject(): ParticleModuleMeshRotationRate_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate_Seeded;
	static C(Other: UObject | any): ParticleModuleMeshRotationRate_Seeded;
}

declare class ParticleModuleMeshRotation_Seeded extends ParticleModuleMeshRotation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static GetDefaultObject(): ParticleModuleMeshRotation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation_Seeded;
	static C(Other: UObject | any): ParticleModuleMeshRotation_Seeded;
}

declare class ParticleModuleOrientationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleOrientationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationBase;
	static GetDefaultObject(): ParticleModuleOrientationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationBase;
	static C(Other: UObject | any): ParticleModuleOrientationBase;
}

declare type EParticleAxisLock = 'EPAL_NONE' | 'EPAL_X' | 'EPAL_Y' | 'EPAL_Z' | 'EPAL_NEGATIVE_X' | 'EPAL_NEGATIVE_Y' | 'EPAL_NEGATIVE_Z' | 'EPAL_ROTATE_X' | 'EPAL_ROTATE_Y' | 'EPAL_ROTATE_Z' | 'EPAL_MAX';
declare var EParticleAxisLock : { EPAL_NONE:'EPAL_NONE',EPAL_X:'EPAL_X',EPAL_Y:'EPAL_Y',EPAL_Z:'EPAL_Z',EPAL_NEGATIVE_X:'EPAL_NEGATIVE_X',EPAL_NEGATIVE_Y:'EPAL_NEGATIVE_Y',EPAL_NEGATIVE_Z:'EPAL_NEGATIVE_Z',EPAL_ROTATE_X:'EPAL_ROTATE_X',EPAL_ROTATE_Y:'EPAL_ROTATE_Y',EPAL_ROTATE_Z:'EPAL_ROTATE_Z',EPAL_MAX:'EPAL_MAX', };
declare class ParticleModuleOrientationAxisLock extends ParticleModuleOrientationBase { 
	LockAxisFlags: EParticleAxisLock;
	static Load(ResourceName: string): ParticleModuleOrientationAxisLock;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationAxisLock;
	static GetDefaultObject(): ParticleModuleOrientationAxisLock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationAxisLock;
	static C(Other: UObject | any): ParticleModuleOrientationAxisLock;
}

declare class ParticleModuleParameterBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleParameterBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterBase;
	static GetDefaultObject(): ParticleModuleParameterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterBase;
	static C(Other: UObject | any): ParticleModuleParameterBase;
}

declare type EEmitterDynamicParameterValue = 'EDPV_UserSet' | 'EDPV_AutoSet' | 'EDPV_VelocityX' | 'EDPV_VelocityY' | 'EDPV_VelocityZ' | 'EDPV_VelocityMag' | 'EDPV_MAX';
declare var EEmitterDynamicParameterValue : { EDPV_UserSet:'EDPV_UserSet',EDPV_AutoSet:'EDPV_AutoSet',EDPV_VelocityX:'EDPV_VelocityX',EDPV_VelocityY:'EDPV_VelocityY',EDPV_VelocityZ:'EDPV_VelocityZ',EDPV_VelocityMag:'EDPV_VelocityMag',EDPV_MAX:'EDPV_MAX', };
declare class EmitterDynamicParameter { 
	ParamName: string;
	bUseEmitterTime: boolean;
	bSpawnTimeOnly: boolean;
	ValueMethod: EEmitterDynamicParameterValue;
	bScaleVelocityByParamValue: boolean;
	ParamValue: RawDistributionFloat;
	clone() : EmitterDynamicParameter;
	static C(Other: UObject | any): EmitterDynamicParameter;
}

declare class ParticleModuleParameterDynamic extends ParticleModuleParameterBase { 
	DynamicParams: EmitterDynamicParameter[];
	UpdateFlags: number;
	bUsesVelocity: boolean;
	static Load(ResourceName: string): ParticleModuleParameterDynamic;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic;
	static GetDefaultObject(): ParticleModuleParameterDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic;
	static C(Other: UObject | any): ParticleModuleParameterDynamic;
}

declare class ParticleModuleParameterDynamic_Seeded extends ParticleModuleParameterDynamic { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static GetDefaultObject(): ParticleModuleParameterDynamic_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic_Seeded;
	static C(Other: UObject | any): ParticleModuleParameterDynamic_Seeded;
}

declare class ParticleModulePivotOffset extends ParticleModuleLocationBase { 
	PivotOffset: Vector2D;
	static Load(ResourceName: string): ParticleModulePivotOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModulePivotOffset;
	static GetDefaultObject(): ParticleModulePivotOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModulePivotOffset;
	static C(Other: UObject | any): ParticleModulePivotOffset;
}

declare class ParticleModuleRotation extends ParticleModuleRotationBase { 
	StartRotation: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation;
	static GetDefaultObject(): ParticleModuleRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation;
	static C(Other: UObject | any): ParticleModuleRotation;
}

declare class ParticleModuleRotationOverLifetime extends ParticleModuleRotationBase { 
	RotationOverLife: RawDistributionFloat;
	Scale: boolean;
	static Load(ResourceName: string): ParticleModuleRotationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationOverLifetime;
	static GetDefaultObject(): ParticleModuleRotationOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationOverLifetime;
	static C(Other: UObject | any): ParticleModuleRotationOverLifetime;
}

declare class ParticleModuleRotationRate extends ParticleModuleRotationRateBase { 
	StartRotationRate: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate;
	static GetDefaultObject(): ParticleModuleRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate;
	static C(Other: UObject | any): ParticleModuleRotationRate;
}

declare class ParticleModuleRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	LifeMultiplier: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static GetDefaultObject(): ParticleModuleRotationRateMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateMultiplyLife;
	static C(Other: UObject | any): ParticleModuleRotationRateMultiplyLife;
}

declare class ParticleModuleRotationRate_Seeded extends ParticleModuleRotationRate { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate_Seeded;
	static GetDefaultObject(): ParticleModuleRotationRate_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate_Seeded;
	static C(Other: UObject | any): ParticleModuleRotationRate_Seeded;
}

declare class ParticleModuleRotation_Seeded extends ParticleModuleRotation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation_Seeded;
	static GetDefaultObject(): ParticleModuleRotation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation_Seeded;
	static C(Other: UObject | any): ParticleModuleRotation_Seeded;
}

declare class ParticleModuleSizeBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleSizeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeBase;
	static GetDefaultObject(): ParticleModuleSizeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeBase;
	static C(Other: UObject | any): ParticleModuleSizeBase;
}

declare class ParticleModuleSize extends ParticleModuleSizeBase { 
	StartSize: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleSize;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize;
	static GetDefaultObject(): ParticleModuleSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize;
	static C(Other: UObject | any): ParticleModuleSize;
}

declare class ParticleModuleSizeMultiplyLife extends ParticleModuleSizeBase { 
	LifeMultiplier: RawDistributionVector;
	MultiplyX: boolean;
	MultiplyY: boolean;
	MultiplyZ: boolean;
	static Load(ResourceName: string): ParticleModuleSizeMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeMultiplyLife;
	static GetDefaultObject(): ParticleModuleSizeMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeMultiplyLife;
	static C(Other: UObject | any): ParticleModuleSizeMultiplyLife;
}

declare class ParticleModuleSizeScale extends ParticleModuleSizeBase { 
	SizeScale: RawDistributionVector;
	EnableX: boolean;
	EnableY: boolean;
	EnableZ: boolean;
	static Load(ResourceName: string): ParticleModuleSizeScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScale;
	static GetDefaultObject(): ParticleModuleSizeScale;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScale;
	static C(Other: UObject | any): ParticleModuleSizeScale;
}

declare class ParticleModuleSizeScaleBySpeed extends ParticleModuleSizeBase { 
	SpeedScale: Vector2D;
	MaxScale: Vector2D;
	static Load(ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static GetDefaultObject(): ParticleModuleSizeScaleBySpeed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScaleBySpeed;
	static C(Other: UObject | any): ParticleModuleSizeScaleBySpeed;
}

declare class ParticleModuleSize_Seeded extends ParticleModuleSize { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleSize_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize_Seeded;
	static GetDefaultObject(): ParticleModuleSize_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize_Seeded;
	static C(Other: UObject | any): ParticleModuleSize_Seeded;
}

declare class ParticleModuleSourceMovement extends ParticleModuleLocationBase { 
	SourceMovementScale: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleSourceMovement;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSourceMovement;
	static GetDefaultObject(): ParticleModuleSourceMovement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSourceMovement;
	static C(Other: UObject | any): ParticleModuleSourceMovement;
}

declare class ParticleModuleSpawnPerUnit extends ParticleModuleSpawnBase { 
	UnitScalar: number;
	MovementTolerance: number;
	SpawnPerUnit: RawDistributionFloat;
	MaxFrameDistance: number;
	bIgnoreSpawnRateWhenMoving: boolean;
	bIgnoreMovementAlongX: boolean;
	bIgnoreMovementAlongY: boolean;
	bIgnoreMovementAlongZ: boolean;
	static Load(ResourceName: string): ParticleModuleSpawnPerUnit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnPerUnit;
	static GetDefaultObject(): ParticleModuleSpawnPerUnit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnPerUnit;
	static C(Other: UObject | any): ParticleModuleSpawnPerUnit;
}

declare class ParticleModuleSubUVBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleSubUVBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVBase;
	static GetDefaultObject(): ParticleModuleSubUVBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVBase;
	static C(Other: UObject | any): ParticleModuleSubUVBase;
}

declare class SubUVAnimation extends UObject { 
	SubUVTexture: Texture2D;
	SubImages_Horizontal: number;
	SubImages_Vertical: number;
	BoundingMode: ESubUVBoundingVertexCount;
	OpacitySourceMode: EOpacitySourceMode;
	AlphaThreshold: number;
	static Load(ResourceName: string): SubUVAnimation;
	static Find(Outer: UObject, ResourceName: string): SubUVAnimation;
	static GetDefaultObject(): SubUVAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubUVAnimation;
	static C(Other: UObject | any): SubUVAnimation;
}

declare class ParticleModuleSubUV extends ParticleModuleSubUVBase { 
	Animation: SubUVAnimation;
	SubImageIndex: RawDistributionFloat;
	bUseRealTime: boolean;
	static Load(ResourceName: string): ParticleModuleSubUV;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUV;
	static GetDefaultObject(): ParticleModuleSubUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUV;
	static C(Other: UObject | any): ParticleModuleSubUV;
}

declare class ParticleModuleSubUVMovie extends ParticleModuleSubUV { 
	bUseEmitterTime: boolean;
	FrameRate: RawDistributionFloat;
	StartingFrame: number;
	static Load(ResourceName: string): ParticleModuleSubUVMovie;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVMovie;
	static GetDefaultObject(): ParticleModuleSubUVMovie;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVMovie;
	static C(Other: UObject | any): ParticleModuleSubUVMovie;
}

declare class ParticleModuleTrailBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleTrailBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailBase;
	static GetDefaultObject(): ParticleModuleTrailBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailBase;
	static C(Other: UObject | any): ParticleModuleTrailBase;
}

declare type ETrail2SourceMethod = 'PET2SRCM_Default' | 'PET2SRCM_Particle' | 'PET2SRCM_Actor' | 'PET2SRCM_MAX';
declare var ETrail2SourceMethod : { PET2SRCM_Default:'PET2SRCM_Default',PET2SRCM_Particle:'PET2SRCM_Particle',PET2SRCM_Actor:'PET2SRCM_Actor',PET2SRCM_MAX:'PET2SRCM_MAX', };
declare type EParticleSourceSelectionMethod = 'EPSSM_Random' | 'EPSSM_Sequential' | 'EPSSM_MAX';
declare var EParticleSourceSelectionMethod : { EPSSM_Random:'EPSSM_Random',EPSSM_Sequential:'EPSSM_Sequential',EPSSM_MAX:'EPSSM_MAX', };
declare class ParticleModuleTrailSource extends ParticleModuleTrailBase { 
	SourceMethod: ETrail2SourceMethod;
	SourceName: string;
	SourceStrength: RawDistributionFloat;
	bLockSourceStength: boolean;
	SourceOffsetCount: number;
	SourceOffsetDefaults: Vector[];
	SelectionMethod: EParticleSourceSelectionMethod;
	bInheritRotation: boolean;
	static Load(ResourceName: string): ParticleModuleTrailSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailSource;
	static GetDefaultObject(): ParticleModuleTrailSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailSource;
	static C(Other: UObject | any): ParticleModuleTrailSource;
}

declare class ParticleModuleTypeDataAnimTrail extends ParticleModuleTypeDataBase { 
	bDeadTrailsOnDeactivate: boolean;
	bEnablePreviousTangentRecalculation: boolean;
	bTangentRecalculationEveryFrame: boolean;
	TilingDistance: number;
	DistanceTessellationStepSize: number;
	TangentTessellationStepSize: number;
	WidthTessellationStepSize: number;
	static Load(ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static GetDefaultObject(): ParticleModuleTypeDataAnimTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataAnimTrail;
	static C(Other: UObject | any): ParticleModuleTypeDataAnimTrail;
}

declare type EBeam2Method = 'PEB2M_Distance' | 'PEB2M_Target' | 'PEB2M_Branch' | 'PEB2M_MAX';
declare var EBeam2Method : { PEB2M_Distance:'PEB2M_Distance',PEB2M_Target:'PEB2M_Target',PEB2M_Branch:'PEB2M_Branch',PEB2M_MAX:'PEB2M_MAX', };
declare type EBeamTaperMethod = 'PEBTM_None' | 'PEBTM_Full' | 'PEBTM_Partial' | 'PEBTM_MAX';
declare var EBeamTaperMethod : { PEBTM_None:'PEBTM_None',PEBTM_Full:'PEBTM_Full',PEBTM_Partial:'PEBTM_Partial',PEBTM_MAX:'PEBTM_MAX', };
declare class ParticleModuleTypeDataBeam2 extends ParticleModuleTypeDataBase { 
	BeamMethod: EBeam2Method;
	TextureTile: number;
	TextureTileDistance: number;
	Sheets: number;
	MaxBeamCount: number;
	Speed: number;
	InterpolationPoints: number;
	bAlwaysOn: boolean;
	UpVectorStepSize: number;
	BranchParentName: string;
	Distance: RawDistributionFloat;
	TaperMethod: EBeamTaperMethod;
	TaperFactor: RawDistributionFloat;
	TaperScale: RawDistributionFloat;
	RenderGeometry: boolean;
	RenderDirectLine: boolean;
	RenderLines: boolean;
	RenderTessellation: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataBeam2;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBeam2;
	static GetDefaultObject(): ParticleModuleTypeDataBeam2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBeam2;
	static C(Other: UObject | any): ParticleModuleTypeDataBeam2;
}

declare class VectorField extends UObject { 
	Bounds: Box;
	Intensity: number;
	static Load(ResourceName: string): VectorField;
	static Find(Outer: UObject, ResourceName: string): VectorField;
	static GetDefaultObject(): VectorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorField;
	static C(Other: UObject | any): VectorField;
}

declare class GPUSpriteLocalVectorFieldInfo { 
	Field: VectorField;
	Transform: Transform;
	MinInitialRotation: Rotator;
	MaxInitialRotation: Rotator;
	RotationRate: Rotator;
	Intensity: number;
	Tightness: number;
	bIgnoreComponentTransform: boolean;
	bTileX: boolean;
	bTileY: boolean;
	bTileZ: boolean;
	bUseFixDT: boolean;
	clone() : GPUSpriteLocalVectorFieldInfo;
	static C(Other: UObject | any): GPUSpriteLocalVectorFieldInfo;
}

declare class FloatDistribution { 
	Table: DistributionLookupTable;
	clone() : FloatDistribution;
	static C(Other: UObject | any): FloatDistribution;
}

declare class GPUSpriteEmitterInfo { 
	RequiredModule: ParticleModuleRequired;
	SpawnModule: ParticleModuleSpawn;
	SpawnPerUnitModule: ParticleModuleSpawnPerUnit;
	SpawnModules: ParticleModule[];
	LocalVectorField: GPUSpriteLocalVectorFieldInfo;
	VectorFieldScale: FloatDistribution;
	DragCoefficient: FloatDistribution;
	PointAttractorStrength: FloatDistribution;
	Resilience: FloatDistribution;
	ConstantAcceleration: Vector;
	PointAttractorPosition: Vector;
	PointAttractorRadiusSq: number;
	OrbitOffsetBase: Vector;
	OrbitOffsetRange: Vector;
	InvMaxSize: Vector2D;
	InvRotationRateScale: number;
	MaxLifetime: number;
	MaxParticleCount: number;
	ScreenAlignment: EParticleScreenAlignment;
	LockAxisFlag: EParticleAxisLock;
	bEnableCollision: boolean;
	CollisionMode: EParticleCollisionMode;
	bRemoveHMDRoll: boolean;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	DynamicColor: RawDistributionVector;
	DynamicAlpha: RawDistributionFloat;
	DynamicColorScale: RawDistributionVector;
	DynamicAlphaScale: RawDistributionFloat;
	clone() : GPUSpriteEmitterInfo;
	static C(Other: UObject | any): GPUSpriteEmitterInfo;
}

declare class GPUSpriteResourceData { 
	QuantizedColorSamples: Color[];
	QuantizedMiscSamples: Color[];
	QuantizedSimulationAttrSamples: Color[];
	ColorScale: Vector4;
	ColorBias: Vector4;
	MiscScale: Vector4;
	MiscBias: Vector4;
	SimulationAttrCurveScale: Vector4;
	SimulationAttrCurveBias: Vector4;
	SubImageSize: Vector4;
	SizeBySpeed: Vector4;
	ConstantAcceleration: Vector;
	OrbitOffsetBase: Vector;
	OrbitOffsetRange: Vector;
	OrbitFrequencyBase: Vector;
	OrbitFrequencyRange: Vector;
	OrbitPhaseBase: Vector;
	OrbitPhaseRange: Vector;
	GlobalVectorFieldScale: number;
	GlobalVectorFieldTightness: number;
	PerParticleVectorFieldScale: number;
	PerParticleVectorFieldBias: number;
	DragCoefficientScale: number;
	DragCoefficientBias: number;
	ResilienceScale: number;
	ResilienceBias: number;
	CollisionRadiusScale: number;
	CollisionRadiusBias: number;
	CollisionTimeBias: number;
	CollisionRandomSpread: number;
	CollisionRandomDistribution: number;
	OneMinusFriction: number;
	RotationRateScale: number;
	CameraMotionBlurAmount: number;
	ScreenAlignment: EParticleScreenAlignment;
	LockAxisFlag: EParticleAxisLock;
	PivotOffset: Vector2D;
	bRemoveHMDRoll: boolean;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	clone() : GPUSpriteResourceData;
	static C(Other: UObject | any): GPUSpriteResourceData;
}

declare class ParticleModuleTypeDataGpu extends ParticleModuleTypeDataBase { 
	EmitterInfo: GPUSpriteEmitterInfo;
	ResourceData: GPUSpriteResourceData;
	CameraMotionBlurAmount: number;
	bClearExistingParticlesOnInit: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataGpu;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataGpu;
	static GetDefaultObject(): ParticleModuleTypeDataGpu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataGpu;
	static C(Other: UObject | any): ParticleModuleTypeDataGpu;
}

declare type EMeshScreenAlignment = 'PSMA_MeshFaceCameraWithRoll' | 'PSMA_MeshFaceCameraWithSpin' | 'PSMA_MeshFaceCameraWithLockedAxis' | 'PSMA_MAX';
declare var EMeshScreenAlignment : { PSMA_MeshFaceCameraWithRoll:'PSMA_MeshFaceCameraWithRoll',PSMA_MeshFaceCameraWithSpin:'PSMA_MeshFaceCameraWithSpin',PSMA_MeshFaceCameraWithLockedAxis:'PSMA_MeshFaceCameraWithLockedAxis',PSMA_MAX:'PSMA_MAX', };
declare type EMeshCameraFacingUpAxis = 'CameraFacing_NoneUP' | 'CameraFacing_ZUp' | 'CameraFacing_NegativeZUp' | 'CameraFacing_YUp' | 'CameraFacing_NegativeYUp' | 'CameraFacing_MAX';
declare var EMeshCameraFacingUpAxis : { CameraFacing_NoneUP:'CameraFacing_NoneUP',CameraFacing_ZUp:'CameraFacing_ZUp',CameraFacing_NegativeZUp:'CameraFacing_NegativeZUp',CameraFacing_YUp:'CameraFacing_YUp',CameraFacing_NegativeYUp:'CameraFacing_NegativeYUp',CameraFacing_MAX:'CameraFacing_MAX', };
declare type EMeshCameraFacingOptions = 'XAxisFacing_NoUp' | 'XAxisFacing_ZUp' | 'XAxisFacing_NegativeZUp' | 'XAxisFacing_YUp' | 'XAxisFacing_NegativeYUp' | 'LockedAxis_ZAxisFacing' | 'LockedAxis_NegativeZAxisFacing' | 'LockedAxis_YAxisFacing' | 'LockedAxis_NegativeYAxisFacing' | 'VelocityAligned_ZAxisFacing' | 'VelocityAligned_NegativeZAxisFacing' | 'VelocityAligned_YAxisFacing' | 'VelocityAligned_NegativeYAxisFacing' | 'EMeshCameraFacingOptions_MAX';
declare var EMeshCameraFacingOptions : { XAxisFacing_NoUp:'XAxisFacing_NoUp',XAxisFacing_ZUp:'XAxisFacing_ZUp',XAxisFacing_NegativeZUp:'XAxisFacing_NegativeZUp',XAxisFacing_YUp:'XAxisFacing_YUp',XAxisFacing_NegativeYUp:'XAxisFacing_NegativeYUp',LockedAxis_ZAxisFacing:'LockedAxis_ZAxisFacing',LockedAxis_NegativeZAxisFacing:'LockedAxis_NegativeZAxisFacing',LockedAxis_YAxisFacing:'LockedAxis_YAxisFacing',LockedAxis_NegativeYAxisFacing:'LockedAxis_NegativeYAxisFacing',VelocityAligned_ZAxisFacing:'VelocityAligned_ZAxisFacing',VelocityAligned_NegativeZAxisFacing:'VelocityAligned_NegativeZAxisFacing',VelocityAligned_YAxisFacing:'VelocityAligned_YAxisFacing',VelocityAligned_NegativeYAxisFacing:'VelocityAligned_NegativeYAxisFacing',EMeshCameraFacingOptions_MAX:'EMeshCameraFacingOptions_MAX', };
declare class ParticleModuleTypeDataMesh extends ParticleModuleTypeDataBase { 
	Mesh: StaticMesh;
	LODSizeScale: number;
	bUseStaticMeshLODs: boolean;
	CastShadows: boolean;
	DoCollisions: boolean;
	MeshAlignment: EMeshScreenAlignment;
	bOverrideMaterial: boolean;
	bOverrideDefaultMotionBlurSettings: boolean;
	bEnableMotionBlur: boolean;
	RollPitchYawRange: RawDistributionVector;
	AxisLockOption: EParticleAxisLock;
	bCameraFacing: boolean;
	CameraFacingUpAxisOption: EMeshCameraFacingUpAxis;
	CameraFacingOption: EMeshCameraFacingOptions;
	bApplyParticleRotationAsSpin: boolean;
	bFaceCameraDirectionRatherThanPosition: boolean;
	bCollisionsConsiderPartilceSize: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataMesh;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataMesh;
	static GetDefaultObject(): ParticleModuleTypeDataMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataMesh;
	static C(Other: UObject | any): ParticleModuleTypeDataMesh;
}

declare type ETrailsRenderAxisOption = 'Trails_CameraUp' | 'Trails_SourceUp' | 'Trails_WorldUp' | 'Trails_MAX';
declare var ETrailsRenderAxisOption : { Trails_CameraUp:'Trails_CameraUp',Trails_SourceUp:'Trails_SourceUp',Trails_WorldUp:'Trails_WorldUp',Trails_MAX:'Trails_MAX', };
declare class ParticleModuleTypeDataRibbon extends ParticleModuleTypeDataBase { 
	MaxTessellationBetweenParticles: number;
	SheetsPerTrail: number;
	MaxTrailCount: number;
	MaxParticleInTrailCount: number;
	bDeadTrailsOnDeactivate: boolean;
	bDeadTrailsOnSourceLoss: boolean;
	bClipSourceSegement: boolean;
	bEnablePreviousTangentRecalculation: boolean;
	bTangentRecalculationEveryFrame: boolean;
	bSpawnInitialParticle: boolean;
	RenderAxis: ETrailsRenderAxisOption;
	TangentSpawningScalar: number;
	bRenderGeometry: boolean;
	bRenderSpawnPoints: boolean;
	bRenderTangents: boolean;
	bRenderTessellation: boolean;
	TilingDistance: number;
	DistanceTessellationStepSize: number;
	bEnableTangentDiffInterpScale: boolean;
	TangentTessellationScalar: number;
	static Load(ResourceName: string): ParticleModuleTypeDataRibbon;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataRibbon;
	static GetDefaultObject(): ParticleModuleTypeDataRibbon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataRibbon;
	static C(Other: UObject | any): ParticleModuleTypeDataRibbon;
}

declare class ParticleModuleVectorFieldBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleVectorFieldBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldBase;
	static GetDefaultObject(): ParticleModuleVectorFieldBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldBase;
	static C(Other: UObject | any): ParticleModuleVectorFieldBase;
}

declare class ParticleModuleVectorFieldGlobal extends ParticleModuleVectorFieldBase { 
	bOverrideGlobalVectorFieldTightness: boolean;
	GlobalVectorFieldScale: number;
	GlobalVectorFieldTightness: number;
	static Load(ResourceName: string): ParticleModuleVectorFieldGlobal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldGlobal;
	static GetDefaultObject(): ParticleModuleVectorFieldGlobal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldGlobal;
	static C(Other: UObject | any): ParticleModuleVectorFieldGlobal;
}

declare class ParticleModuleVectorFieldLocal extends ParticleModuleVectorFieldBase { 
	VectorField: VectorField;
	RelativeTranslation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	Intensity: number;
	Tightness: number;
	bIgnoreComponentTransform: boolean;
	bTileX: boolean;
	bTileY: boolean;
	bTileZ: boolean;
	bUseFixDT: boolean;
	static Load(ResourceName: string): ParticleModuleVectorFieldLocal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldLocal;
	static GetDefaultObject(): ParticleModuleVectorFieldLocal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldLocal;
	static C(Other: UObject | any): ParticleModuleVectorFieldLocal;
}

declare class ParticleModuleVectorFieldRotation extends ParticleModuleVectorFieldBase { 
	MinInitialRotation: Vector;
	MaxInitialRotation: Vector;
	static Load(ResourceName: string): ParticleModuleVectorFieldRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotation;
	static GetDefaultObject(): ParticleModuleVectorFieldRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotation;
	static C(Other: UObject | any): ParticleModuleVectorFieldRotation;
}

declare class ParticleModuleVectorFieldRotationRate extends ParticleModuleVectorFieldBase { 
	RotationRate: Vector;
	static Load(ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static GetDefaultObject(): ParticleModuleVectorFieldRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotationRate;
	static C(Other: UObject | any): ParticleModuleVectorFieldRotationRate;
}

declare class ParticleModuleVectorFieldScale extends ParticleModuleVectorFieldBase { 
	VectorFieldScale: DistributionFloat;
	VectorFieldScaleRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVectorFieldScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScale;
	static GetDefaultObject(): ParticleModuleVectorFieldScale;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScale;
	static C(Other: UObject | any): ParticleModuleVectorFieldScale;
}

declare class ParticleModuleVectorFieldScaleOverLife extends ParticleModuleVectorFieldBase { 
	VectorFieldScaleOverLife: DistributionFloat;
	VectorFieldScaleOverLifeRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static GetDefaultObject(): ParticleModuleVectorFieldScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScaleOverLife;
	static C(Other: UObject | any): ParticleModuleVectorFieldScaleOverLife;
}

declare class ParticleModuleVelocityBase extends ParticleModule { 
	bInWorldSpace: boolean;
	bApplyOwnerScale: boolean;
	static Load(ResourceName: string): ParticleModuleVelocityBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityBase;
	static GetDefaultObject(): ParticleModuleVelocityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityBase;
	static C(Other: UObject | any): ParticleModuleVelocityBase;
}

declare class ParticleModuleVelocity extends ParticleModuleVelocityBase { 
	StartVelocity: RawDistributionVector;
	StartVelocityRadial: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVelocity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity;
	static GetDefaultObject(): ParticleModuleVelocity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity;
	static C(Other: UObject | any): ParticleModuleVelocity;
}

declare class ParticleModuleVelocityCone extends ParticleModuleVelocityBase { 
	Angle: RawDistributionFloat;
	Velocity: RawDistributionFloat;
	Direction: Vector;
	static Load(ResourceName: string): ParticleModuleVelocityCone;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityCone;
	static GetDefaultObject(): ParticleModuleVelocityCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityCone;
	static C(Other: UObject | any): ParticleModuleVelocityCone;
}

declare class ParticleModuleVelocityInheritParent extends ParticleModuleVelocityBase { 
	Scale: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleVelocityInheritParent;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityInheritParent;
	static GetDefaultObject(): ParticleModuleVelocityInheritParent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityInheritParent;
	static C(Other: UObject | any): ParticleModuleVelocityInheritParent;
}

declare class ParticleModuleVelocityOverLifetime extends ParticleModuleVelocityBase { 
	VelOverLife: RawDistributionVector;
	Absolute: boolean;
	static Load(ResourceName: string): ParticleModuleVelocityOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityOverLifetime;
	static GetDefaultObject(): ParticleModuleVelocityOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityOverLifetime;
	static C(Other: UObject | any): ParticleModuleVelocityOverLifetime;
}

declare class ParticleModuleVelocity_Seeded extends ParticleModuleVelocity { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleVelocity_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity_Seeded;
	static GetDefaultObject(): ParticleModuleVelocity_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity_Seeded;
	static C(Other: UObject | any): ParticleModuleVelocity_Seeded;
}

declare class ParticleSpriteEmitter extends ParticleEmitter { 
	static Load(ResourceName: string): ParticleSpriteEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleSpriteEmitter;
	static GetDefaultObject(): ParticleSpriteEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSpriteEmitter;
	static C(Other: UObject | any): ParticleSpriteEmitter;
}

declare class PathFollowingAgentInterface extends Interface { 
	static Load(ResourceName: string): PathFollowingAgentInterface;
	static Find(Outer: UObject, ResourceName: string): PathFollowingAgentInterface;
	static GetDefaultObject(): PathFollowingAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingAgentInterface;
	static C(Other: UObject | any): PathFollowingAgentInterface;
}

declare class PhysicsSpringComponent extends SceneComponent { 
	SpringStiffness: number;
	SpringDamping: number;
	SpringLengthAtRest: number;
	SpringRadius: number;
	SpringChannel: ECollisionChannel;
	bIgnoreSelf: boolean;
	SpringCompression: number;
	static Load(ResourceName: string): PhysicsSpringComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsSpringComponent;
	static GetDefaultObject(): PhysicsSpringComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSpringComponent;
	GetSpringRestingPoint(): Vector;
	GetSpringDirection(): Vector;
	GetSpringCurrentEndPoint(): Vector;
	GetNormalizedCompressionScalar(): number;
	static C(Other: UObject | any): PhysicsSpringComponent;
}

declare class PhysicsThreadLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): PhysicsThreadLibrary;
	static Find(Outer: UObject, ResourceName: string): PhysicsThreadLibrary;
	static GetDefaultObject(): PhysicsThreadLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsThreadLibrary;
	static AddForce(Handle: BodyInstanceAsyncPhysicsTickHandle,Force: Vector,bAccelChange: boolean): void;
	static C(Other: UObject | any): PhysicsThreadLibrary;
}

declare class PhysicsThrusterComponent extends SceneComponent { 
	ThrustStrength: number;
	static Load(ResourceName: string): PhysicsThrusterComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsThrusterComponent;
	static GetDefaultObject(): PhysicsThrusterComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsThrusterComponent;
	static C(Other: UObject | any): PhysicsThrusterComponent;
}

declare class SceneCapture extends Actor { 
	MeshComp: StaticMeshComponent;
	SceneComponent: SceneComponent;
	static GetDefaultObject(): SceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCapture;
	static C(Other: UObject | any): SceneCapture;
}

declare type ESceneCapturePrimitiveRenderMode = 'PRM_LegacySceneCapture' | 'PRM_RenderScenePrimitives' | 'PRM_UseShowOnlyList' | 'PRM_MAX';
declare var ESceneCapturePrimitiveRenderMode : { PRM_LegacySceneCapture:'PRM_LegacySceneCapture',PRM_RenderScenePrimitives:'PRM_RenderScenePrimitives',PRM_UseShowOnlyList:'PRM_UseShowOnlyList',PRM_MAX:'PRM_MAX', };
declare type ESceneCaptureSource = 'SCS_SceneColorHDR' | 'SCS_SceneColorHDRNoAlpha' | 'SCS_FinalColorLDR' | 'SCS_SceneColorSceneDepth' | 'SCS_SceneDepth' | 'SCS_DeviceDepth' | 'SCS_Normal' | 'SCS_BaseColor' | 'SCS_FinalColorHDR' | 'SCS_FinalToneCurveHDR' | 'SCS_MAX';
declare var ESceneCaptureSource : { SCS_SceneColorHDR:'SCS_SceneColorHDR',SCS_SceneColorHDRNoAlpha:'SCS_SceneColorHDRNoAlpha',SCS_FinalColorLDR:'SCS_FinalColorLDR',SCS_SceneColorSceneDepth:'SCS_SceneColorSceneDepth',SCS_SceneDepth:'SCS_SceneDepth',SCS_DeviceDepth:'SCS_DeviceDepth',SCS_Normal:'SCS_Normal',SCS_BaseColor:'SCS_BaseColor',SCS_FinalColorHDR:'SCS_FinalColorHDR',SCS_FinalToneCurveHDR:'SCS_FinalToneCurveHDR',SCS_MAX:'SCS_MAX', };
declare class EngineShowFlagsSetting { 
	ShowFlagName: string;
	Enabled: boolean;
	clone() : EngineShowFlagsSetting;
	static C(Other: UObject | any): EngineShowFlagsSetting;
}

declare class SceneCaptureComponent extends SceneComponent { 
	PrimitiveRenderMode: ESceneCapturePrimitiveRenderMode;
	CaptureSource: ESceneCaptureSource;
	bCaptureEveryFrame: boolean;
	bCaptureOnMovement: boolean;
	bAlwaysPersistRenderingState: boolean;
	HiddenComponents: PrimitiveComponent[];
	HiddenActors: Actor[];
	ShowOnlyComponents: PrimitiveComponent[];
	ShowOnlyActors: Actor[];
	LODDistanceFactor: number;
	MaxViewDistanceOverride: number;
	CaptureSortPriority: number;
	bUseRayTracingIfEnabled: boolean;
	ShowFlagSettings: EngineShowFlagsSetting[];
	ProfilingEventName: string;
	CaptureMesh: StaticMesh;
	static Load(ResourceName: string): SceneCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponent;
	static GetDefaultObject(): SceneCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponent;
	ShowOnlyComponent(InComponent: PrimitiveComponent): void;
	ShowOnlyActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	SetCaptureSortPriority(NewCaptureSortPriority: number): void;
	RemoveShowOnlyComponent(InComponent: PrimitiveComponent): void;
	RemoveShowOnlyActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	HideComponent(InComponent: PrimitiveComponent): void;
	HideActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	ClearShowOnlyComponents(): void;
	ClearHiddenComponents(): void;
	static C(Other: UObject | any): SceneCaptureComponent;
}

declare class PlanarReflectionComponent extends SceneCaptureComponent { 
	PreviewBox: BoxComponent;
	NormalDistortionStrength: number;
	PrefilterRoughness: number;
	PrefilterRoughnessDistance: number;
	ScreenPercentage: number;
	ExtraFOV: number;
	DistanceFromPlaneFadeStart: number;
	DistanceFromPlaneFadeEnd: number;
	DistanceFromPlaneFadeoutStart: number;
	DistanceFromPlaneFadeoutEnd: number;
	AngleFromPlaneFadeStart: number;
	AngleFromPlaneFadeEnd: number;
	bShowPreviewPlane: boolean;
	bRenderSceneTwoSided: boolean;
	CaptureMaterial: Material;
	static Load(ResourceName: string): PlanarReflectionComponent;
	static Find(Outer: UObject, ResourceName: string): PlanarReflectionComponent;
	static GetDefaultObject(): PlanarReflectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanarReflectionComponent;
	static C(Other: UObject | any): PlanarReflectionComponent;
}

declare class PlanarReflection extends SceneCapture { 
	PlanarReflectionComponent: PlanarReflectionComponent;
	SpriteComponent: BillboardComponent;
	bShowPreviewPlane: boolean;
	static GetDefaultObject(): PlanarReflection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanarReflection;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): PlanarReflection;
}

declare class PlaneReflectionCapture extends ReflectionCapture { 
	static GetDefaultObject(): PlaneReflectionCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneReflectionCapture;
	static C(Other: UObject | any): PlaneReflectionCapture;
}

declare class DrawSphereComponent extends SphereComponent { 
	static Load(ResourceName: string): DrawSphereComponent;
	static Find(Outer: UObject, ResourceName: string): DrawSphereComponent;
	static GetDefaultObject(): DrawSphereComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawSphereComponent;
	static C(Other: UObject | any): DrawSphereComponent;
}

declare class PlaneReflectionCaptureComponent extends ReflectionCaptureComponent { 
	InfluenceRadiusScale: number;
	PreviewInfluenceRadius: DrawSphereComponent;
	PreviewCaptureBox: BoxComponent;
	static Load(ResourceName: string): PlaneReflectionCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): PlaneReflectionCaptureComponent;
	static GetDefaultObject(): PlaneReflectionCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneReflectionCaptureComponent;
	static C(Other: UObject | any): PlaneReflectionCaptureComponent;
}

declare class PlatformInterfaceWebResponse extends UObject { 
	OriginalURL: string;
	ResponseCode: number;
	Tag: number;
	StringResponse: string;
	BinaryResponse: number[];
	static Load(ResourceName: string): PlatformInterfaceWebResponse;
	static Find(Outer: UObject, ResourceName: string): PlatformInterfaceWebResponse;
	static GetDefaultObject(): PlatformInterfaceWebResponse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformInterfaceWebResponse;
	GetNumHeaders(): number;
	GetHeaderValue(HeaderName: string): string;
	GetHeader(HeaderIndex: number,Header?: string,Value?: string): {Header: string, Value: string};
	static C(Other: UObject | any): PlatformInterfaceWebResponse;
}

declare class PlayerStateCountLimiterConfig extends NetObjectCountLimiterConfig { 
	static Load(ResourceName: string): PlayerStateCountLimiterConfig;
	static Find(Outer: UObject, ResourceName: string): PlayerStateCountLimiterConfig;
	static GetDefaultObject(): PlayerStateCountLimiterConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStateCountLimiterConfig;
	static C(Other: UObject | any): PlayerStateCountLimiterConfig;
}

declare class PointLight extends Light { 
	PointLightComponent: PointLightComponent;
	static GetDefaultObject(): PointLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLight;
	SetRadius(NewRadius: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
	static C(Other: UObject | any): PointLight;
}

declare class Polys extends UObject { 
	static Load(ResourceName: string): Polys;
	static Find(Outer: UObject, ResourceName: string): Polys;
	static GetDefaultObject(): Polys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Polys;
	static C(Other: UObject | any): Polys;
}

declare class PrecomputedVisibilityOverrideVolume extends Volume { 
	OverrideVisibleActors: Actor[];
	OverrideInvisibleActors: Actor[];
	OverrideInvisibleLevels: string[];
	static GetDefaultObject(): PrecomputedVisibilityOverrideVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityOverrideVolume;
	static C(Other: UObject | any): PrecomputedVisibilityOverrideVolume;
}

declare class RigidBodyBase extends Actor { 
	static GetDefaultObject(): RigidBodyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigidBodyBase;
	static C(Other: UObject | any): RigidBodyBase;
}

declare class RadialForceComponent extends SceneComponent { 
	Radius: number;
	Falloff: ERadialImpulseFalloff;
	ImpulseStrength: number;
	bImpulseVelChange: boolean;
	bIgnoreOwningActor: boolean;
	ForceStrength: number;
	DestructibleDamage: number;
	ObjectTypesToAffect: EObjectTypeQuery[];
	static Load(ResourceName: string): RadialForceComponent;
	static Find(Outer: UObject, ResourceName: string): RadialForceComponent;
	static GetDefaultObject(): RadialForceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialForceComponent;
	RemoveObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;
	FireImpulse(): void;
	AddObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;
	static C(Other: UObject | any): RadialForceComponent;
}

declare class RadialForceActor extends RigidBodyBase { 
	ForceComponent: RadialForceComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): RadialForceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialForceActor;
	ToggleForce(): void;
	FireImpulse(): void;
	EnableForce(): void;
	DisableForce(): void;
	static C(Other: UObject | any): RadialForceActor;
}

declare class ReplicationConnectionDriver extends UObject { 
	static Load(ResourceName: string): ReplicationConnectionDriver;
	static Find(Outer: UObject, ResourceName: string): ReplicationConnectionDriver;
	static GetDefaultObject(): ReplicationConnectionDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplicationConnectionDriver;
	static C(Other: UObject | any): ReplicationConnectionDriver;
}

declare class RVOAvoidanceInterface extends Interface { 
	static Load(ResourceName: string): RVOAvoidanceInterface;
	static Find(Outer: UObject, ResourceName: string): RVOAvoidanceInterface;
	static GetDefaultObject(): RVOAvoidanceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RVOAvoidanceInterface;
	static C(Other: UObject | any): RVOAvoidanceInterface;
}

declare class Scene extends UObject { 
	static Load(ResourceName: string): Scene;
	static Find(Outer: UObject, ResourceName: string): Scene;
	static GetDefaultObject(): Scene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Scene;
	static C(Other: UObject | any): Scene;
}

declare type ESceneCaptureCompositeMode = 'SCCM_Overwrite' | 'SCCM_Additive' | 'SCCM_Composite' | 'SCCM_MAX';
declare var ESceneCaptureCompositeMode : { SCCM_Overwrite:'SCCM_Overwrite',SCCM_Additive:'SCCM_Additive',SCCM_Composite:'SCCM_Composite',SCCM_MAX:'SCCM_MAX', };
declare class SceneCaptureComponent2D extends SceneCaptureComponent { 
	ProjectionType: ECameraProjectionMode;
	FOVAngle: number;
	OrthoWidth: number;
	TextureTarget: TextureRenderTarget2D;
	CompositeMode: ESceneCaptureCompositeMode;
	PostProcessSettings: PostProcessSettings;
	PostProcessBlendWeight: number;
	bOverride_CustomNearClippingPlane: boolean;
	CustomNearClippingPlane: number;
	bUseCustomProjectionMatrix: boolean;
	CustomProjectionMatrix: Matrix;
	bUseFauxOrthoViewPos: boolean;
	bEnableOrthographicTiling: boolean;
	NumXTiles: number;
	NumYTiles: number;
	bEnableClipPlane: boolean;
	ClipPlaneBase: Vector;
	ClipPlaneNormal: Vector;
	bCameraCutThisFrame: boolean;
	bConsiderUnrenderedOpaquePixelAsFullyTranslucent: boolean;
	static Load(ResourceName: string): SceneCaptureComponent2D;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponent2D;
	static GetDefaultObject(): SceneCaptureComponent2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponent2D;
	CaptureScene(): void;
	static C(Other: UObject | any): SceneCaptureComponent2D;
}

declare class SceneCapture2D extends SceneCapture { 
	CaptureComponent2D: SceneCaptureComponent2D;
	static GetDefaultObject(): SceneCapture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCapture2D;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): SceneCapture2D;
	DeprojectSceneCaptureToWorld(TargetUV: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	static DeprojectSceneCaptureToWorld(SceneCapture2D: SceneCapture2D,TargetUV: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
}

declare class TextureRenderTargetCube extends TextureRenderTarget { 
	SizeX: number;
	ClearColor: LinearColor;
	OverrideFormat: EPixelFormat;
	bHDR: boolean;
	bForceLinearGamma: boolean;
	static Load(ResourceName: string): TextureRenderTargetCube;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTargetCube;
	static GetDefaultObject(): TextureRenderTargetCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTargetCube;
	static C(Other: UObject | any): TextureRenderTargetCube;
}

declare class SceneCaptureComponentCube extends SceneCaptureComponent { 
	TextureTarget: TextureRenderTargetCube;
	bCaptureRotation: boolean;
	static Load(ResourceName: string): SceneCaptureComponentCube;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponentCube;
	static GetDefaultObject(): SceneCaptureComponentCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponentCube;
	CaptureScene(): void;
	static C(Other: UObject | any): SceneCaptureComponentCube;
}

declare class SceneCaptureCube extends SceneCapture { 
	CaptureComponentCube: SceneCaptureComponentCube;
	static GetDefaultObject(): SceneCaptureCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureCube;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): SceneCaptureCube;
}

declare type EShadowMapFlags = 'SMF_None' | 'SMF_Streamed' | 'SMF_MAX';
declare var EShadowMapFlags : { SMF_None:'SMF_None',SMF_Streamed:'SMF_Streamed',SMF_MAX:'SMF_MAX', };
declare class ShadowMapTexture2D extends Texture2D { 
	ShadowmapFlags: EShadowMapFlags;
	static Load(ResourceName: string): ShadowMapTexture2D;
	static Find(Outer: UObject, ResourceName: string): ShadowMapTexture2D;
	static GetDefaultObject(): ShadowMapTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShadowMapTexture2D;
	static C(Other: UObject | any): ShadowMapTexture2D;
}

declare class SMInstanceManager extends Interface { 
	static Load(ResourceName: string): SMInstanceManager;
	static Find(Outer: UObject, ResourceName: string): SMInstanceManager;
	static GetDefaultObject(): SMInstanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceManager;
	static C(Other: UObject | any): SMInstanceManager;
}

declare class SMInstanceManagerProvider extends Interface { 
	static Load(ResourceName: string): SMInstanceManagerProvider;
	static Find(Outer: UObject, ResourceName: string): SMInstanceManagerProvider;
	static GetDefaultObject(): SMInstanceManagerProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceManagerProvider;
	static C(Other: UObject | any): SMInstanceManagerProvider;
}

declare class SoundEffectPresetWidgetInterface extends AudioPanelWidgetInterface { 
	static Load(ResourceName: string): SoundEffectPresetWidgetInterface;
	static Find(Outer: UObject, ResourceName: string): SoundEffectPresetWidgetInterface;
	static GetDefaultObject(): SoundEffectPresetWidgetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectPresetWidgetInterface;
	OnPropertyChanged(Preset: SoundEffectPreset,PropertyName: string): void;
	OnConstructed(Preset: SoundEffectPreset): void;
	GetClass(): UnrealEngineClass;
	static C(Other: UObject | any): SoundEffectPresetWidgetInterface;
}

declare class SoundGroup { 
	SoundGroup: ESoundGroup;
	DisplayName: string;
	bAlwaysDecompressOnLoad: boolean;
	DecompressedDuration: number;
	clone() : SoundGroup;
	static C(Other: UObject | any): SoundGroup;
}

declare class SoundGroups extends UObject { 
	SoundGroupProfiles: SoundGroup[];
	static Load(ResourceName: string): SoundGroups;
	static Find(Outer: UObject, ResourceName: string): SoundGroups;
	static GetDefaultObject(): SoundGroups;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundGroups;
	static C(Other: UObject | any): SoundGroups;
}

declare type ModulationParamMode = 'MPM_Normal' | 'MPM_Abs' | 'MPM_Direct' | 'MPM_MAX';
declare var ModulationParamMode : { MPM_Normal:'MPM_Normal',MPM_Abs:'MPM_Abs',MPM_Direct:'MPM_Direct',MPM_MAX:'MPM_MAX', };
declare class ModulatorContinuousParams { 
	ParameterName: string;
	Default: number;
	MinInput: number;
	MaxInput: number;
	MinOutput: number;
	MaxOutput: number;
	ParamMode: ModulationParamMode;
	clone() : ModulatorContinuousParams;
	static C(Other: UObject | any): ModulatorContinuousParams;
}

declare class SoundNodeModulatorContinuous extends SoundNode { 
	PitchModulationParams: ModulatorContinuousParams;
	VolumeModulationParams: ModulatorContinuousParams;
	static Load(ResourceName: string): SoundNodeModulatorContinuous;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulatorContinuous;
	static GetDefaultObject(): SoundNodeModulatorContinuous;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulatorContinuous;
	static C(Other: UObject | any): SoundNodeModulatorContinuous;
}

declare class SoundSubmixWidgetInterface extends Interface { 
	static Load(ResourceName: string): SoundSubmixWidgetInterface;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixWidgetInterface;
	static GetDefaultObject(): SoundSubmixWidgetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixWidgetInterface;
	OnConstructed(SoundSubmix: SoundSubmixBase): void;
	static C(Other: UObject | any): SoundSubmixWidgetInterface;
}

declare class SphereReflectionCapture extends ReflectionCapture { 
	DrawCaptureRadius: DrawSphereComponent;
	static GetDefaultObject(): SphereReflectionCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereReflectionCapture;
	static C(Other: UObject | any): SphereReflectionCapture;
}

declare class SphereReflectionCaptureComponent extends ReflectionCaptureComponent { 
	InfluenceRadius: number;
	CaptureDistanceScale: number;
	PreviewInfluenceRadius: DrawSphereComponent;
	static Load(ResourceName: string): SphereReflectionCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): SphereReflectionCaptureComponent;
	static GetDefaultObject(): SphereReflectionCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereReflectionCaptureComponent;
	static C(Other: UObject | any): SphereReflectionCaptureComponent;
}

declare class StereoLayerShape extends UObject { 
	static Load(ResourceName: string): StereoLayerShape;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShape;
	static GetDefaultObject(): StereoLayerShape;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShape;
	static C(Other: UObject | any): StereoLayerShape;
}

declare class StereoLayerShapeQuad extends StereoLayerShape { 
	static Load(ResourceName: string): StereoLayerShapeQuad;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeQuad;
	static GetDefaultObject(): StereoLayerShapeQuad;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeQuad;
	static C(Other: UObject | any): StereoLayerShapeQuad;
}

declare class StereoLayerShapeCylinder extends StereoLayerShape { 
	Radius: number;
	OverlayArc: number;
	Height: number;
	static Load(ResourceName: string): StereoLayerShapeCylinder;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeCylinder;
	static GetDefaultObject(): StereoLayerShapeCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeCylinder;
	SetRadius(InRadius: number): void;
	SetOverlayArc(InOverlayArc: number): void;
	SetHeight(InHeight: number): void;
	static C(Other: UObject | any): StereoLayerShapeCylinder;
}

declare class StereoLayerShapeCubemap extends StereoLayerShape { 
	static Load(ResourceName: string): StereoLayerShapeCubemap;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeCubemap;
	static GetDefaultObject(): StereoLayerShapeCubemap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeCubemap;
	static C(Other: UObject | any): StereoLayerShapeCubemap;
}

declare class EquirectProps { 
	LeftUVRect: Box2D;
	RightUVRect: Box2D;
	LeftScale: Vector2D;
	RightScale: Vector2D;
	LeftBias: Vector2D;
	RightBias: Vector2D;
	clone() : EquirectProps;
	static C(Other: UObject | any): EquirectProps;
}

declare class StereoLayerShapeEquirect extends StereoLayerShape { 
	LeftUVRect: Box2D;
	RightUVRect: Box2D;
	LeftScale: Vector2D;
	RightScale: Vector2D;
	LeftBias: Vector2D;
	RightBias: Vector2D;
	static Load(ResourceName: string): StereoLayerShapeEquirect;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeEquirect;
	static GetDefaultObject(): StereoLayerShapeEquirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeEquirect;
	SetEquirectProps(InScaleBiases: EquirectProps): void;
	static C(Other: UObject | any): StereoLayerShapeEquirect;
}

declare type EStereoLayerType = 'SLT_WorldLocked' | 'SLT_TrackerLocked' | 'SLT_FaceLocked' | 'SLT_MAX';
declare var EStereoLayerType : { SLT_WorldLocked:'SLT_WorldLocked',SLT_TrackerLocked:'SLT_TrackerLocked',SLT_FaceLocked:'SLT_FaceLocked',SLT_MAX:'SLT_MAX', };
declare type EStereoLayerShape = 'SLSH_QuadLayer' | 'SLSH_CylinderLayer' | 'SLSH_CubemapLayer' | 'SLSH_EquirectLayer' | 'SLSH_MAX';
declare var EStereoLayerShape : { SLSH_QuadLayer:'SLSH_QuadLayer',SLSH_CylinderLayer:'SLSH_CylinderLayer',SLSH_CubemapLayer:'SLSH_CubemapLayer',SLSH_EquirectLayer:'SLSH_EquirectLayer',SLSH_MAX:'SLSH_MAX', };
declare class StereoLayerComponent extends SceneComponent { 
	bLiveTexture: boolean;
	bSupportsDepth: boolean;
	bNoAlphaChannel: boolean;
	Texture: Texture;
	LeftTexture: Texture;
	bQuadPreserveTextureRatio: boolean;
	QuadSize: Vector2D;
	UVRect: Box2D;
	CylinderRadius: number;
	CylinderOverlayArc: number;
	CylinderHeight: number;
	EquirectProps: EquirectProps;
	StereoLayerType: EStereoLayerType;
	StereoLayerShape: EStereoLayerShape;
	Shape: StereoLayerShape;
	Priority: number;
	static Load(ResourceName: string): StereoLayerComponent;
	static Find(Outer: UObject, ResourceName: string): StereoLayerComponent;
	static GetDefaultObject(): StereoLayerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerComponent;
	SetUVRect(InUVRect: Box2D): void;
	SetTexture(InTexture: Texture): void;
	SetQuadSize(InQuadSize: Vector2D): void;
	SetPriority(InPriority: number): void;
	SetLeftTexture(InTexture: Texture): void;
	SetEquirectProps(InScaleBiases: EquirectProps): void;
	MarkTextureForUpdate(): void;
	GetUVRect(): Box2D;
	GetTexture(): Texture;
	GetQuadSize(): Vector2D;
	GetPriority(): number;
	GetLeftTexture(): Texture;
	static C(Other: UObject | any): StereoLayerComponent;
}

declare class TextPropertyTestObject extends UObject { 
	DefaultedText: string;
	UndefaultedText: string;
	TransientText: string;
	static Load(ResourceName: string): TextPropertyTestObject;
	static Find(Outer: UObject, ResourceName: string): TextPropertyTestObject;
	static GetDefaultObject(): TextPropertyTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextPropertyTestObject;
	static C(Other: UObject | any): TextPropertyTestObject;
}

declare class TextRenderActor extends Actor { 
	TextRender: TextRenderComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): TextRenderActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextRenderActor;
	static C(Other: UObject | any): TextRenderActor;
}

declare class TimelineEventEntry { 
	Time: number;
	EventFunc: UnrealEngineDelegate<() => void>;
	clone() : TimelineEventEntry;
	static C(Other: UObject | any): TimelineEventEntry;
}

declare class TimelineVectorTrack { 
	VectorCurve: CurveVector;
	InterpFunc: UnrealEngineDelegate<(Output: Vector) => void>;
	TrackName: string;
	VectorPropertyName: string;
	clone() : TimelineVectorTrack;
	static C(Other: UObject | any): TimelineVectorTrack;
}

declare class TimelineFloatTrack { 
	FloatCurve: CurveFloat;
	InterpFunc: UnrealEngineDelegate<(Output: number) => void>;
	TrackName: string;
	FloatPropertyName: string;
	clone() : TimelineFloatTrack;
	static C(Other: UObject | any): TimelineFloatTrack;
}

declare class TimelineLinearColorTrack { 
	LinearColorCurve: CurveLinearColor;
	InterpFunc: UnrealEngineDelegate<(Output: LinearColor) => void>;
	TrackName: string;
	LinearColorPropertyName: string;
	clone() : TimelineLinearColorTrack;
	static C(Other: UObject | any): TimelineLinearColorTrack;
}

declare class Timeline { 
	LengthMode: ETimelineLengthMode;
	bLooping: boolean;
	bReversePlayback: boolean;
	bPlaying: boolean;
	Length: number;
	PlayRate: number;
	Position: number;
	Events: TimelineEventEntry[];
	InterpVectors: TimelineVectorTrack[];
	InterpFloats: TimelineFloatTrack[];
	InterpLinearColors: TimelineLinearColorTrack[];
	TimelinePostUpdateFunc: UnrealEngineDelegate<() => void>;
	TimelineFinishedFunc: UnrealEngineDelegate<() => void>;
	PropertySetObject: UObject;
	DirectionPropertyName: string;
	clone() : Timeline;
	static C(Other: UObject | any): Timeline;
}

declare class TimelineComponent extends ActorComponent { 
	TheTimeline: Timeline;
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): TimelineComponent;
	static Find(Outer: UObject, ResourceName: string): TimelineComponent;
	static GetDefaultObject(): TimelineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineComponent;
	Stop(): void;
	SetVectorCurve(NewVectorCurve: CurveVector,VectorTrackName: string): void;
	SetTimelineLengthMode(NewLengthMode: ETimelineLengthMode): void;
	SetTimelineLength(NewLength: number): void;
	SetPlayRate(NewRate: number): void;
	SetPlaybackPosition(NewPosition: number,bFireEvents: boolean,bFireUpdate: boolean): void;
	SetNewTime(NewTime: number): void;
	SetLooping(bNewLooping: boolean): void;
	SetLinearColorCurve(NewLinearColorCurve: CurveLinearColor,LinearColorTrackName: string): void;
	SetIgnoreTimeDilation(bNewIgnoreTimeDilation: boolean): void;
	SetFloatCurve(NewFloatCurve: CurveFloat,FloatTrackName: string): void;
	ReverseFromEnd(): void;
	Reverse(): void;
	PlayFromStart(): void;
	Play(): void;
	OnRep_Timeline(OldTimeline?: Timeline): {OldTimeline: Timeline};
	IsReversing(): boolean;
	IsPlaying(): boolean;
	IsLooping(): boolean;
	GetTimelineLength(): number;
	GetScaledTimelineLength(): number;
	GetPlayRate(): number;
	GetPlaybackPosition(): number;
	GetIgnoreTimeDilation(): boolean;
	static C(Other: UObject | any): TimelineComponent;
}

declare class TriggerBase extends Actor { 
	CollisionComponent: ShapeComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): TriggerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerBase;
	static C(Other: UObject | any): TriggerBase;
}

declare class TriggerBox extends TriggerBase { 
	static GetDefaultObject(): TriggerBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerBox;
	static C(Other: UObject | any): TriggerBox;
}

declare class TriggerCapsule extends TriggerBase { 
	static GetDefaultObject(): TriggerCapsule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerCapsule;
	static C(Other: UObject | any): TriggerCapsule;
}

declare class TriggerSphere extends TriggerBase { 
	static GetDefaultObject(): TriggerSphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerSphere;
	static C(Other: UObject | any): TriggerSphere;
}

declare type ETwitterRequestMethod = 'TRM_Get' | 'TRM_Post' | 'TRM_Delete' | 'TRM_MAX';
declare var ETwitterRequestMethod : { TRM_Get:'TRM_Get',TRM_Post:'TRM_Post',TRM_Delete:'TRM_Delete',TRM_MAX:'TRM_MAX', };
declare class TwitterIntegrationBase extends PlatformInterfaceBase { 
	static Load(ResourceName: string): TwitterIntegrationBase;
	static Find(Outer: UObject, ResourceName: string): TwitterIntegrationBase;
	static GetDefaultObject(): TwitterIntegrationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TwitterIntegrationBase;
	TwitterRequest(URL: string,ParamKeysAndValues: string[],RequestMethod: ETwitterRequestMethod,AccountIndex: number): boolean;
	ShowTweetUI(InitialMessage: string,URL: string,Picture: string): boolean;
	Init(): void;
	GetNumAccounts(): number;
	GetAccountName(AccountIndex: number): string;
	CanShowTweetUI(): boolean;
	AuthorizeAccounts(): boolean;
	static C(Other: UObject | any): TwitterIntegrationBase;
}

declare type EVectorFieldConstructionOp = 'VFCO_Extrude' | 'VFCO_Revolve' | 'VFCO_MAX';
declare var EVectorFieldConstructionOp : { VFCO_Extrude:'VFCO_Extrude',VFCO_Revolve:'VFCO_Revolve',VFCO_MAX:'VFCO_MAX', };
declare class VectorFieldStatic extends VectorField { 
	SizeX: number;
	SizeY: number;
	SizeZ: number;
	bAllowCPUAccess: boolean;
	SourceFilePath: string;
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): VectorFieldStatic;
	static Find(Outer: UObject, ResourceName: string): VectorFieldStatic;
	static GetDefaultObject(): VectorFieldStatic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldStatic;
	static C(Other: UObject | any): VectorFieldStatic;
}

declare class VectorFieldAnimated extends VectorField { 
	Texture: Texture2D;
	ConstructionOp: EVectorFieldConstructionOp;
	VolumeSizeX: number;
	VolumeSizeY: number;
	VolumeSizeZ: number;
	SubImagesX: number;
	SubImagesY: number;
	FrameCount: number;
	FramesPerSecond: number;
	bLoop: boolean;
	NoiseField: VectorFieldStatic;
	NoiseScale: number;
	NoiseMax: number;
	static Load(ResourceName: string): VectorFieldAnimated;
	static Find(Outer: UObject, ResourceName: string): VectorFieldAnimated;
	static GetDefaultObject(): VectorFieldAnimated;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldAnimated;
	static C(Other: UObject | any): VectorFieldAnimated;
}

declare class VectorFieldComponent extends PrimitiveComponent { 
	VectorField: VectorField;
	Intensity: number;
	Tightness: number;
	bPreviewVectorField: boolean;
	static Load(ResourceName: string): VectorFieldComponent;
	static Find(Outer: UObject, ResourceName: string): VectorFieldComponent;
	static GetDefaultObject(): VectorFieldComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldComponent;
	SetIntensity(NewIntensity: number): void;
	static C(Other: UObject | any): VectorFieldComponent;
}

declare class VisualLoggerDebugSnapshotInterface extends Interface { 
	static Load(ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static GetDefaultObject(): VisualLoggerDebugSnapshotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerDebugSnapshotInterface;
	static C(Other: UObject | any): VisualLoggerDebugSnapshotInterface;
}

declare type EWindSourceType = 'Directional' | 'Point' | 'EWindSourceType_MAX';
declare var EWindSourceType : { Directional:'Directional',Point:'Point',EWindSourceType_MAX:'EWindSourceType_MAX', };
declare class WindDirectionalSourceComponent extends SceneComponent { 
	Strength: number;
	Speed: number;
	MinGustAmount: number;
	MaxGustAmount: number;
	Radius: number;
	bPointWind: boolean;
	static Load(ResourceName: string): WindDirectionalSourceComponent;
	static Find(Outer: UObject, ResourceName: string): WindDirectionalSourceComponent;
	static GetDefaultObject(): WindDirectionalSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSourceComponent;
	SetWindType(InNewType: EWindSourceType): void;
	SetStrength(InNewStrength: number): void;
	SetSpeed(InNewSpeed: number): void;
	SetRadius(InNewRadius: number): void;
	SetMinimumGustAmount(InNewMinGust: number): void;
	SetMaximumGustAmount(InNewMaxGust: number): void;
	static C(Other: UObject | any): WindDirectionalSourceComponent;
}

declare class WorldPartitionRuntimeCellOwner extends Interface { 
	static Load(ResourceName: string): WorldPartitionRuntimeCellOwner;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeCellOwner;
	static GetDefaultObject(): WorldPartitionRuntimeCellOwner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeCellOwner;
	static C(Other: UObject | any): WorldPartitionRuntimeCellOwner;
}

declare class HierarchicalLODSetup extends UObject { 
	HierarchicalLODSetup: HierarchicalSimplification[];
	OverrideBaseMaterial: MaterialInterface;
	static Load(ResourceName: string): HierarchicalLODSetup;
	static Find(Outer: UObject, ResourceName: string): HierarchicalLODSetup;
	static GetDefaultObject(): HierarchicalLODSetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalLODSetup;
	static C(Other: UObject | any): HierarchicalLODSetup;
}

declare class ActorPartitionSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): ActorPartitionSubsystem;
	static Find(Outer: UObject, ResourceName: string): ActorPartitionSubsystem;
	static GetDefaultObject(): ActorPartitionSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorPartitionSubsystem;
	static C(Other: UObject | any): ActorPartitionSubsystem;
}

declare class NullNavSysConfig extends NavigationSystemConfig { 
	static Load(ResourceName: string): NullNavSysConfig;
	static Find(Outer: UObject, ResourceName: string): NullNavSysConfig;
	static GetDefaultObject(): NullNavSysConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullNavSysConfig;
	static C(Other: UObject | any): NullNavSysConfig;
}

declare class AmbientSound extends Actor { 
	AudioComponent: AudioComponent;
	static GetDefaultObject(): AmbientSound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AmbientSound;
	Stop(): void;
	Play(StartTime: number): void;
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number): void;
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number): void;
	static C(Other: UObject | any): AmbientSound;
}

declare class AimOffsetBlendSpace extends BlendSpace { 
	static Load(ResourceName: string): AimOffsetBlendSpace;
	static Find(Outer: UObject, ResourceName: string): AimOffsetBlendSpace;
	static GetDefaultObject(): AimOffsetBlendSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AimOffsetBlendSpace;
	static C(Other: UObject | any): AimOffsetBlendSpace;
}

declare class BlendSpace1D extends BlendSpace { 
	bDisplayEditorVertically: boolean;
	bScaleAnimation: boolean;
	static Load(ResourceName: string): BlendSpace1D;
	static Find(Outer: UObject, ResourceName: string): BlendSpace1D;
	static GetDefaultObject(): BlendSpace1D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpace1D;
	static C(Other: UObject | any): BlendSpace1D;
}

declare class AimOffsetBlendSpace1D extends BlendSpace1D { 
	static Load(ResourceName: string): AimOffsetBlendSpace1D;
	static Find(Outer: UObject, ResourceName: string): AimOffsetBlendSpace1D;
	static GetDefaultObject(): AimOffsetBlendSpace1D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AimOffsetBlendSpace1D;
	static C(Other: UObject | any): AimOffsetBlendSpace1D;
}

declare class TimecodeCustomAttributeNameSettings { 
	HourAttributeName: string;
	MinuteAttributeName: string;
	SecondAttributeName: string;
	FrameAttributeName: string;
	SubframeAttributeName: string;
	RateAttributeName: string;
	TakenameAttributeName: string;
	clone() : TimecodeCustomAttributeNameSettings;
	static C(Other: UObject | any): TimecodeCustomAttributeNameSettings;
}

declare class CustomAttributeSetting { 
	Name: string;
	Meaning: string;
	clone() : CustomAttributeSetting;
	static C(Other: UObject | any): CustomAttributeSetting;
}

declare type ECustomAttributeBlendType = 'Override' | 'Blend' | 'ECustomAttributeBlendType_MAX';
declare var ECustomAttributeBlendType : { Override:'Override',Blend:'Blend',ECustomAttributeBlendType_MAX:'ECustomAttributeBlendType_MAX', };
declare class AnimationSettings extends DeveloperSettings { 
	CompressCommandletVersion: number;
	KeyEndEffectorsMatchNameArray: string[];
	ForceRecompression: boolean;
	bForceBelowThreshold: boolean;
	bFirstRecompressUsingCurrentOrDefault: boolean;
	bRaiseMaxErrorToExisting: boolean;
	bEnablePerformanceLog: boolean;
	bStripAnimationDataOnDedicatedServer: boolean;
	bTickAnimationOnSkeletalMeshInit: boolean;
	BoneTimecodeCustomAttributeNameSettings: TimecodeCustomAttributeNameSettings;
	BoneCustomAttributesNames: CustomAttributeSetting[];
	BoneNamesWithCustomAttributes: string[];
	AttributeBlendModes: Map<string, ECustomAttributeBlendType>;
	DefaultAttributeBlendMode: ECustomAttributeBlendType;
	TransformAttributeNames: string[];
	UserDefinedStructAttributes: UserDefinedStruct[];
	MirrorFindReplaceExpressions: MirrorFindReplaceExpression[];
	static Load(ResourceName: string): AnimationSettings;
	static Find(Outer: UObject, ResourceName: string): AnimationSettings;
	static GetDefaultObject(): AnimationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSettings;
	GetBoneCustomAttributeNamesToImport(): string[];
	static C(Other: UObject | any): AnimationSettings;
}

declare class AnimBlueprintGeneratedStruct extends ScriptStruct { 
	static Load(ResourceName: string): AnimBlueprintGeneratedStruct;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintGeneratedStruct;
	static GetDefaultObject(): AnimBlueprintGeneratedStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintGeneratedStruct;
	static C(Other: UObject | any): AnimBlueprintGeneratedStruct;
}

declare class BakedStateExitTransition { 
	CanTakeDelegateIndex: number;
	CustomResultNodeIndex: number;
	TransitionIndex: number;
	bDesiredTransitionReturnValue: boolean;
	bAutomaticRemainingTimeRule: boolean;
	SyncGroupNameToRequireValidMarkersRule: string;
	PoseEvaluatorLinks: number[];
	clone() : BakedStateExitTransition;
	static C(Other: UObject | any): BakedStateExitTransition;
}

declare class BakedAnimationState { 
	StateName: string;
	Transitions: BakedStateExitTransition[];
	StateRootNodeIndex: number;
	StartNotify: number;
	EndNotify: number;
	FullyBlendedNotify: number;
	bIsAConduit: boolean;
	EntryRuleNodeIndex: number;
	PlayerNodeIndices: number[];
	LayerNodeIndices: number[];
	bAlwaysResetOnEntry: boolean;
	clone() : BakedAnimationState;
	static C(Other: UObject | any): BakedAnimationState;
}

declare class AnimationStateBase { 
	StateName: string;
	clone() : AnimationStateBase;
	static C(Other: UObject | any): AnimationStateBase;
}

declare class AnimationTransitionBetweenStates extends AnimationStateBase { 
	PreviousState: number;
	NextState: number;
	CrossfadeDuration: number;
	StartNotify: number;
	EndNotify: number;
	InterruptNotify: number;
	BlendMode: EAlphaBlendOption;
	CustomCurve: CurveFloat;
	BlendProfile: BlendProfile;
	LogicType: ETransitionLogicType;
	clone() : AnimationTransitionBetweenStates;
	static C(Other: UObject | any): AnimationTransitionBetweenStates;
}

declare class BakedAnimationStateMachine { 
	MachineName: string;
	InitialState: number;
	States: BakedAnimationState[];
	Transitions: AnimationTransitionBetweenStates[];
	clone() : BakedAnimationStateMachine;
	static C(Other: UObject | any): BakedAnimationStateMachine;
}

declare class CachedPoseIndices { 
	OrderedSavedPoseNodeIndices: number[];
	clone() : CachedPoseIndices;
	static C(Other: UObject | any): CachedPoseIndices;
}

declare class GraphAssetPlayerInformation { 
	PlayerNodeIndices: number[];
	clone() : GraphAssetPlayerInformation;
	static C(Other: UObject | any): GraphAssetPlayerInformation;
}

declare type EAnimNodeDataFlags = 'None' | 'HasInitialUpdateFunction' | 'HasBecomeRelevantFunction' | 'HasUpdateFunction' | 'EAnimNodeDataFlags_MAX';
declare var EAnimNodeDataFlags : { None:'None',HasInitialUpdateFunction:'HasInitialUpdateFunction',HasBecomeRelevantFunction:'HasBecomeRelevantFunction',HasUpdateFunction:'HasUpdateFunction',EAnimNodeDataFlags_MAX:'EAnimNodeDataFlags_MAX', };
declare class AnimNodeData { 
	AnimClassInterface: AnimClassInterface;
	Entries: number[];
	NodeIndex: number;
	Flags: EAnimNodeDataFlags;
	clone() : AnimNodeData;
	static C(Other: UObject | any): AnimNodeData;
}

declare class AnimNodeStructData { 
	NameToIndexMap: Map<string, number>;
	NumProperties: number;
	clone() : AnimNodeStructData;
	static C(Other: UObject | any): AnimNodeStructData;
}

declare class AnimBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	BakedStateMachines: BakedAnimationStateMachine[];
	TargetSkeleton: Skeleton;
	AnimNotifies: AnimNotifyEvent[];
	OrderedSavedPoseIndicesMap: Map<string, CachedPoseIndices>;
	SyncGroupNames: string[];
	EvaluateGraphExposedInputs: ExposedValueHandler[];
	GraphAssetPlayerInformation: Map<string, GraphAssetPlayerInformation>;
	GraphBlendOptions: Map<string, AnimGraphBlendOptions>;
	AnimNodeData: AnimNodeData[];
	NodeTypeMap: Map<ScriptStruct, AnimNodeStructData>;
	static Load(ResourceName: string): AnimBlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintGeneratedClass;
	static GetDefaultObject(): AnimBlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintGeneratedClass;
	static C(Other: UObject | any): AnimBlueprintGeneratedClass;
}

declare class AnimBlueprintFunction { 
	Name: string;
	Group: string;
	OutputPoseNodeIndex: number;
	InputPoseNames: string[];
	InputPoseNodeIndices: number[];
	bImplemented: boolean;
	clone() : AnimBlueprintFunction;
	static C(Other: UObject | any): AnimBlueprintFunction;
}

declare class AnimBlueprintFunctionData { 
	OutputPoseNodeProperty: any;
	InputPoseNodeProperties: any[];
	InputProperties: any[];
	clone() : AnimBlueprintFunctionData;
	static C(Other: UObject | any): AnimBlueprintFunctionData;
}

declare class AnimClassData extends UObject { 
	BakedStateMachines: BakedAnimationStateMachine[];
	TargetSkeleton: Skeleton;
	AnimNotifies: AnimNotifyEvent[];
	OrderedSavedPoseIndicesMap: Map<string, CachedPoseIndices>;
	AnimBlueprintFunctions: AnimBlueprintFunction[];
	AnimBlueprintFunctionData: AnimBlueprintFunctionData[];
	AnimNodeProperties: any[];
	LinkedAnimGraphNodeProperties: any[];
	LinkedAnimLayerNodeProperties: any[];
	PreUpdateNodeProperties: any[];
	DynamicResetNodeProperties: any[];
	StateMachineNodeProperties: any[];
	InitializationNodeProperties: any[];
	GraphNameAssetPlayers: Map<string, GraphAssetPlayerInformation>;
	SyncGroupNames: string[];
	GraphBlendOptions: Map<string, AnimGraphBlendOptions>;
	static Load(ResourceName: string): AnimClassData;
	static Find(Outer: UObject, ResourceName: string): AnimClassData;
	static GetDefaultObject(): AnimClassData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimClassData;
	static C(Other: UObject | any): AnimClassData;
}

declare class AnimComposite extends AnimCompositeBase { 
	AnimationTrack: AnimTrack;
	PreviewBasePose: AnimSequence;
	static Load(ResourceName: string): AnimComposite;
	static Find(Outer: UObject, ResourceName: string): AnimComposite;
	static GetDefaultObject(): AnimComposite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimComposite;
	static C(Other: UObject | any): AnimComposite;
}

declare class AnimCompress_BitwiseCompressOnly extends AnimCompress { 
	static Load(ResourceName: string): AnimCompress_BitwiseCompressOnly;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_BitwiseCompressOnly;
	static GetDefaultObject(): AnimCompress_BitwiseCompressOnly;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_BitwiseCompressOnly;
	static C(Other: UObject | any): AnimCompress_BitwiseCompressOnly;
}

declare class AnimCompress_LeastDestructive extends AnimCompress_BitwiseCompressOnly { 
	static Load(ResourceName: string): AnimCompress_LeastDestructive;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_LeastDestructive;
	static GetDefaultObject(): AnimCompress_LeastDestructive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_LeastDestructive;
	static C(Other: UObject | any): AnimCompress_LeastDestructive;
}

declare class AnimCompress_RemoveLinearKeys extends AnimCompress { 
	MaxPosDiff: number;
	MaxAngleDiff: number;
	MaxScaleDiff: number;
	MaxEffectorDiff: number;
	MinEffectorDiff: number;
	EffectorDiffSocket: number;
	ParentKeyScale: number;
	bRetarget: boolean;
	bActuallyFilterLinearKeys: boolean;
	static Load(ResourceName: string): AnimCompress_RemoveLinearKeys;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_RemoveLinearKeys;
	static GetDefaultObject(): AnimCompress_RemoveLinearKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_RemoveLinearKeys;
	static C(Other: UObject | any): AnimCompress_RemoveLinearKeys;
}

declare class AnimCompress_PerTrackCompression extends AnimCompress_RemoveLinearKeys { 
	MaxZeroingThreshold: number;
	MaxPosDiffBitwise: number;
	MaxAngleDiffBitwise: number;
	MaxScaleDiffBitwise: number;
	AllowedRotationFormats: AnimationCompressionFormat[];
	AllowedTranslationFormats: AnimationCompressionFormat[];
	AllowedScaleFormats: AnimationCompressionFormat[];
	bResampleAnimation: boolean;
	ResampledFramerate: number;
	MinKeysForResampling: number;
	bUseAdaptiveError: boolean;
	bUseOverrideForEndEffectors: boolean;
	TrackHeightBias: number;
	ParentingDivisor: number;
	ParentingDivisorExponent: number;
	bUseAdaptiveError2: boolean;
	RotationErrorSourceRatio: number;
	TranslationErrorSourceRatio: number;
	ScaleErrorSourceRatio: number;
	MaxErrorPerTrackRatio: number;
	PerturbationProbeSize: number;
	static Load(ResourceName: string): AnimCompress_PerTrackCompression;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_PerTrackCompression;
	static GetDefaultObject(): AnimCompress_PerTrackCompression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_PerTrackCompression;
	static C(Other: UObject | any): AnimCompress_PerTrackCompression;
}

declare class AnimCompress_RemoveEverySecondKey extends AnimCompress { 
	MinKeys: number;
	bStartAtSecondKey: boolean;
	static Load(ResourceName: string): AnimCompress_RemoveEverySecondKey;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_RemoveEverySecondKey;
	static GetDefaultObject(): AnimCompress_RemoveEverySecondKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_RemoveEverySecondKey;
	static C(Other: UObject | any): AnimCompress_RemoveEverySecondKey;
}

declare class AnimCompress_RemoveTrivialKeys extends AnimCompress { 
	MaxPosDiff: number;
	MaxAngleDiff: number;
	MaxScaleDiff: number;
	static Load(ResourceName: string): AnimCompress_RemoveTrivialKeys;
	static Find(Outer: UObject, ResourceName: string): AnimCompress_RemoveTrivialKeys;
	static GetDefaultObject(): AnimCompress_RemoveTrivialKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress_RemoveTrivialKeys;
	static C(Other: UObject | any): AnimCompress_RemoveTrivialKeys;
}

declare class AnimCurveCompressionCodec_CompressedRichCurve extends AnimCurveCompressionCodec { 
	MaxCurveError: number;
	UseAnimSequenceSampleRate: boolean;
	ErrorSampleRate: number;
	static Load(ResourceName: string): AnimCurveCompressionCodec_CompressedRichCurve;
	static Find(Outer: UObject, ResourceName: string): AnimCurveCompressionCodec_CompressedRichCurve;
	static GetDefaultObject(): AnimCurveCompressionCodec_CompressedRichCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveCompressionCodec_CompressedRichCurve;
	static C(Other: UObject | any): AnimCurveCompressionCodec_CompressedRichCurve;
}

declare class AnimCurveCompressionCodec_UniformIndexable extends AnimCurveCompressionCodec { 
	static Load(ResourceName: string): AnimCurveCompressionCodec_UniformIndexable;
	static Find(Outer: UObject, ResourceName: string): AnimCurveCompressionCodec_UniformIndexable;
	static GetDefaultObject(): AnimCurveCompressionCodec_UniformIndexable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveCompressionCodec_UniformIndexable;
	static C(Other: UObject | any): AnimCurveCompressionCodec_UniformIndexable;
}

declare class AnimCurveCompressionCodec_UniformlySampled extends AnimCurveCompressionCodec { 
	UseAnimSequenceSampleRate: boolean;
	SampleRate: number;
	static Load(ResourceName: string): AnimCurveCompressionCodec_UniformlySampled;
	static Find(Outer: UObject, ResourceName: string): AnimCurveCompressionCodec_UniformlySampled;
	static GetDefaultObject(): AnimCurveCompressionCodec_UniformlySampled;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveCompressionCodec_UniformlySampled;
	static C(Other: UObject | any): AnimCurveCompressionCodec_UniformlySampled;
}

declare class AnimNotifyLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimNotifyLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyLibrary;
	static GetDefaultObject(): AnimNotifyLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyLibrary;
	static NotifyStateReachedEnd(EventReference: AnimNotifyEventReference): boolean;
	static C(Other: UObject | any): AnimNotifyLibrary;
}

declare class AnimNotifyMirrorInspectionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimNotifyMirrorInspectionLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyMirrorInspectionLibrary;
	static GetDefaultObject(): AnimNotifyMirrorInspectionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyMirrorInspectionLibrary;
	static IsTriggeredByMirroredAnimation(EventReference: AnimNotifyEventReference): boolean;
	static GetMirrorDataTable(EventReference: AnimNotifyEventReference): MirrorDataTable;
	static C(Other: UObject | any): AnimNotifyMirrorInspectionLibrary;
}

declare class AnimNotifyStateMachineInspectionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimNotifyStateMachineInspectionLibrary;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyStateMachineInspectionLibrary;
	static GetDefaultObject(): AnimNotifyStateMachineInspectionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyStateMachineInspectionLibrary;
	static IsTriggeredByStateMachine(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateMachineName: string): boolean;
	static IsTriggeredByStateInStateMachine(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateMachineName: string,StateName: string): boolean;
	static IsTriggeredByState(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateName: string): boolean;
	static C(Other: UObject | any): AnimNotifyStateMachineInspectionLibrary;
}

declare class AnimNotifyState_DisableRootMotion extends AnimNotifyState { 
	static Load(ResourceName: string): AnimNotifyState_DisableRootMotion;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState_DisableRootMotion;
	static GetDefaultObject(): AnimNotifyState_DisableRootMotion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState_DisableRootMotion;
	static C(Other: UObject | any): AnimNotifyState_DisableRootMotion;
}

declare class AnimNotifyState_TimedParticleEffect extends AnimNotifyState { 
	PSTemplate: ParticleSystem;
	SocketName: string;
	LocationOffset: Vector;
	RotationOffset: Rotator;
	bDestroyAtEnd: boolean;
	PreviousPSTemplates: ParticleSystem[];
	PreviousSocketNames: string[];
	static Load(ResourceName: string): AnimNotifyState_TimedParticleEffect;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState_TimedParticleEffect;
	static GetDefaultObject(): AnimNotifyState_TimedParticleEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState_TimedParticleEffect;
	static C(Other: UObject | any): AnimNotifyState_TimedParticleEffect;
}

declare class AnimNotifyState_Trail extends AnimNotifyState { 
	PSTemplate: ParticleSystem;
	FirstSocketName: string;
	SecondSocketName: string;
	WidthScaleMode: ETrailWidthMode;
	WidthScaleCurve: string;
	bRecycleSpawnedSystems: boolean;
	bRenderGeometry: boolean;
	bRenderSpawnPoints: boolean;
	bRenderTangents: boolean;
	bRenderTessellation: boolean;
	static Load(ResourceName: string): AnimNotifyState_Trail;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState_Trail;
	static GetDefaultObject(): AnimNotifyState_Trail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState_Trail;
	OverridePSTemplate(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): ParticleSystem;
	static C(Other: UObject | any): AnimNotifyState_Trail;
}

declare class AnimNotify_PauseClothingSimulation extends AnimNotify { 
	static Load(ResourceName: string): AnimNotify_PauseClothingSimulation;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PauseClothingSimulation;
	static GetDefaultObject(): AnimNotify_PauseClothingSimulation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PauseClothingSimulation;
	static C(Other: UObject | any): AnimNotify_PauseClothingSimulation;
}

declare class AnimNotify_PlayParticleEffect extends AnimNotify { 
	PSTemplate: ParticleSystem;
	LocationOffset: Vector;
	RotationOffset: Rotator;
	Scale: Vector;
	Attached: boolean;
	SocketName: string;
	static Load(ResourceName: string): AnimNotify_PlayParticleEffect;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlayParticleEffect;
	static GetDefaultObject(): AnimNotify_PlayParticleEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlayParticleEffect;
	static C(Other: UObject | any): AnimNotify_PlayParticleEffect;
}

declare class AnimNotify_PlaySound extends AnimNotify { 
	Sound: SoundBase;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	bFollow: boolean;
	bPreviewIgnoreAttenuation: boolean;
	AttachName: string;
	static Load(ResourceName: string): AnimNotify_PlaySound;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_PlaySound;
	static GetDefaultObject(): AnimNotify_PlaySound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_PlaySound;
	static C(Other: UObject | any): AnimNotify_PlaySound;
}

declare class AnimNotify_ResetClothingSimulation extends AnimNotify { 
	static Load(ResourceName: string): AnimNotify_ResetClothingSimulation;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_ResetClothingSimulation;
	static GetDefaultObject(): AnimNotify_ResetClothingSimulation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_ResetClothingSimulation;
	static C(Other: UObject | any): AnimNotify_ResetClothingSimulation;
}

declare class AnimNotify_ResetDynamics extends AnimNotify { 
	static Load(ResourceName: string): AnimNotify_ResetDynamics;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_ResetDynamics;
	static GetDefaultObject(): AnimNotify_ResetDynamics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_ResetDynamics;
	static C(Other: UObject | any): AnimNotify_ResetDynamics;
}

declare class AnimNotify_ResumeClothingSimulation extends AnimNotify { 
	static Load(ResourceName: string): AnimNotify_ResumeClothingSimulation;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_ResumeClothingSimulation;
	static GetDefaultObject(): AnimNotify_ResumeClothingSimulation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_ResumeClothingSimulation;
	static C(Other: UObject | any): AnimNotify_ResumeClothingSimulation;
}

declare class AnimSetMeshLinkup { 
	BoneToTrackTable: number[];
	clone() : AnimSetMeshLinkup;
	static C(Other: UObject | any): AnimSetMeshLinkup;
}

declare class AnimSet extends UObject { 
	bAnimRotationOnly: boolean;
	TrackBoneNames: string[];
	Sequences: AnimSequence[];
	LinkupCache: AnimSetMeshLinkup[];
	BoneUseAnimTranslation: number[];
	ForceUseMeshTranslation: number[];
	UseTranslationBoneNames: string[];
	ForceMeshTranslationBoneNames: string[];
	PreviewSkelMeshName: string;
	BestRatioSkelMeshName: string;
	static Load(ResourceName: string): AnimSet;
	static Find(Outer: UObject, ResourceName: string): AnimSet;
	static GetDefaultObject(): AnimSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSet;
	static C(Other: UObject | any): AnimSet;
}

declare class AnimStateMachineTypes extends UObject { 
	static Load(ResourceName: string): AnimStateMachineTypes;
	static Find(Outer: UObject, ResourceName: string): AnimStateMachineTypes;
	static GetDefaultObject(): AnimStateMachineTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateMachineTypes;
	static C(Other: UObject | any): AnimStateMachineTypes;
}

declare class AnimStreamable extends AnimSequenceBase { 
	NumberOfKeys: number;
	Interpolation: EAnimInterpolationType;
	RetargetSource: string;
	SourceSequence: AnimSequence;
	RawDataGuid: Guid;
	NumFrames: number;
	RawAnimationData: RawAnimSequenceTrack[];
	TrackToSkeletonMapTable: TrackToSkeletonMap[];
	AnimationTrackNames: string[];
	BoneCompressionSettings: AnimBoneCompressionSettings;
	CurveCompressionSettings: AnimCurveCompressionSettings;
	bEnableRootMotion: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	bForceRootLock: boolean;
	bUseNormalizedRootMotionScale: boolean;
	static Load(ResourceName: string): AnimStreamable;
	static Find(Outer: UObject, ResourceName: string): AnimStreamable;
	static GetDefaultObject(): AnimStreamable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStreamable;
	static C(Other: UObject | any): AnimStreamable;
}

declare class AnimationAttributeIdentifierExtensions extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimationAttributeIdentifierExtensions;
	static Find(Outer: UObject, ResourceName: string): AnimationAttributeIdentifierExtensions;
	static GetDefaultObject(): AnimationAttributeIdentifierExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationAttributeIdentifierExtensions;
	static IsValid(Identifier?: AnimationAttributeIdentifier): {Identifier: AnimationAttributeIdentifier, $: boolean};
	static CreateAttributeIdentifier(AnimationAsset: AnimationAsset,AttributeName: string,BoneName: string,AttributeType: ScriptStruct,bValidateExistsOnAsset: boolean): AnimationAttributeIdentifier;
	static C(Other: UObject | any): AnimationAttributeIdentifierExtensions;
}

declare class BoneMaskFilter extends UObject { 
	BlendPoses: InputBlendPose[];
	static Load(ResourceName: string): BoneMaskFilter;
	static Find(Outer: UObject, ResourceName: string): BoneMaskFilter;
	static GetDefaultObject(): BoneMaskFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoneMaskFilter;
	static C(Other: UObject | any): BoneMaskFilter;
}

declare class CachedAnimDataLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): CachedAnimDataLibrary;
	static Find(Outer: UObject, ResourceName: string): CachedAnimDataLibrary;
	static GetDefaultObject(): CachedAnimDataLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CachedAnimDataLibrary;
	static StateMachine_IsStateRelevant(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): boolean;
	static StateMachine_GetLocalWeight(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): number;
	static StateMachine_GetGlobalWeight(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): number;
	static C(Other: UObject | any): CachedAnimDataLibrary;
}

declare class AnimationCurveIdentifierExtensions extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AnimationCurveIdentifierExtensions;
	static Find(Outer: UObject, ResourceName: string): AnimationCurveIdentifierExtensions;
	static GetDefaultObject(): AnimationCurveIdentifierExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCurveIdentifierExtensions;
	static IsValid(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: boolean};
	static GetType(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: ERawCurveTrackTypes};
	static GetTransformChildCurveIdentifier(InOutIdentifier?: AnimationCurveIdentifier,Channel?: ETransformCurveChannel,Axis?: EVectorCurveChannel): {InOutIdentifier: AnimationCurveIdentifier, $: boolean};
	static GetName(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: string};
	static GetCurveIdentifiers(InSkeleton: Skeleton,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier[];
	static GetCurveIdentifier(InSkeleton: Skeleton,Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	static FindCurveIdentifier(InSkeleton: Skeleton,Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	static C(Other: UObject | any): AnimationCurveIdentifierExtensions;
}

declare class NodeMappingProviderInterface extends Interface { 
	static Load(ResourceName: string): NodeMappingProviderInterface;
	static Find(Outer: UObject, ResourceName: string): NodeMappingProviderInterface;
	static GetDefaultObject(): NodeMappingProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeMappingProviderInterface;
	static C(Other: UObject | any): NodeMappingProviderInterface;
}

declare class PreviewCollectionInterface extends Interface { 
	static Load(ResourceName: string): PreviewCollectionInterface;
	static Find(Outer: UObject, ResourceName: string): PreviewCollectionInterface;
	static GetDefaultObject(): PreviewCollectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PreviewCollectionInterface;
	static C(Other: UObject | any): PreviewCollectionInterface;
}

declare class PreviewMeshCollectionEntry { 
	SkeletalMesh: SkeletalMesh;
	AnimBlueprint: AnimBlueprint;
	clone() : PreviewMeshCollectionEntry;
	static C(Other: UObject | any): PreviewMeshCollectionEntry;
}

declare class PreviewMeshCollection extends DataAsset { 
	Skeleton: Skeleton;
	SkeletalMeshes: PreviewMeshCollectionEntry[];
	static Load(ResourceName: string): PreviewMeshCollection;
	static Find(Outer: UObject, ResourceName: string): PreviewMeshCollection;
	static GetDefaultObject(): PreviewMeshCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PreviewMeshCollection;
	static C(Other: UObject | any): PreviewMeshCollection;
}

declare class AsyncActionLoadPrimaryAssetBase extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): AsyncActionLoadPrimaryAssetBase;
	static Find(Outer: UObject, ResourceName: string): AsyncActionLoadPrimaryAssetBase;
	static GetDefaultObject(): AsyncActionLoadPrimaryAssetBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionLoadPrimaryAssetBase;
	static C(Other: UObject | any): AsyncActionLoadPrimaryAssetBase;
}

declare class AsyncActionLoadPrimaryAsset extends AsyncActionLoadPrimaryAssetBase { 
	Completed: UnrealEngineMulticastDelegate<(Loaded: UObject) => void>;
	static Load(ResourceName: string): AsyncActionLoadPrimaryAsset;
	static Find(Outer: UObject, ResourceName: string): AsyncActionLoadPrimaryAsset;
	static GetDefaultObject(): AsyncActionLoadPrimaryAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionLoadPrimaryAsset;
	static AsyncLoadPrimaryAsset(WorldContextObject: UObject,PrimaryAsset: PrimaryAssetId,LoadBundles: string[]): AsyncActionLoadPrimaryAsset;
	static C(Other: UObject | any): AsyncActionLoadPrimaryAsset;
}

declare class AsyncActionLoadPrimaryAssetClass extends AsyncActionLoadPrimaryAssetBase { 
	Completed: UnrealEngineMulticastDelegate<(Loaded: UnrealEngineClass) => void>;
	static Load(ResourceName: string): AsyncActionLoadPrimaryAssetClass;
	static Find(Outer: UObject, ResourceName: string): AsyncActionLoadPrimaryAssetClass;
	static GetDefaultObject(): AsyncActionLoadPrimaryAssetClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionLoadPrimaryAssetClass;
	static AsyncLoadPrimaryAssetClass(WorldContextObject: UObject,PrimaryAsset: PrimaryAssetId,LoadBundles: string[]): AsyncActionLoadPrimaryAssetClass;
	static C(Other: UObject | any): AsyncActionLoadPrimaryAssetClass;
}

declare class AsyncActionLoadPrimaryAssetList extends AsyncActionLoadPrimaryAssetBase { 
	Completed: UnrealEngineMulticastDelegate<(Loaded: UObject[]) => void>;
	static Load(ResourceName: string): AsyncActionLoadPrimaryAssetList;
	static Find(Outer: UObject, ResourceName: string): AsyncActionLoadPrimaryAssetList;
	static GetDefaultObject(): AsyncActionLoadPrimaryAssetList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionLoadPrimaryAssetList;
	static AsyncLoadPrimaryAssetList(WorldContextObject: UObject,PrimaryAssetList: PrimaryAssetId[],LoadBundles: string[]): AsyncActionLoadPrimaryAssetList;
	static C(Other: UObject | any): AsyncActionLoadPrimaryAssetList;
}

declare class AsyncActionLoadPrimaryAssetClassList extends AsyncActionLoadPrimaryAssetBase { 
	Completed: UnrealEngineMulticastDelegate<(Loaded: UnrealEngineClass[]) => void>;
	static Load(ResourceName: string): AsyncActionLoadPrimaryAssetClassList;
	static Find(Outer: UObject, ResourceName: string): AsyncActionLoadPrimaryAssetClassList;
	static GetDefaultObject(): AsyncActionLoadPrimaryAssetClassList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionLoadPrimaryAssetClassList;
	static AsyncLoadPrimaryAssetClassList(WorldContextObject: UObject,PrimaryAssetList: PrimaryAssetId[],LoadBundles: string[]): AsyncActionLoadPrimaryAssetClassList;
	static C(Other: UObject | any): AsyncActionLoadPrimaryAssetClassList;
}

declare class AsyncActionChangePrimaryAssetBundles extends AsyncActionLoadPrimaryAssetBase { 
	Completed: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AsyncActionChangePrimaryAssetBundles;
	static Find(Outer: UObject, ResourceName: string): AsyncActionChangePrimaryAssetBundles;
	static GetDefaultObject(): AsyncActionChangePrimaryAssetBundles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionChangePrimaryAssetBundles;
	static AsyncChangeBundleStateForPrimaryAssetList(WorldContextObject: UObject,PrimaryAssetList: PrimaryAssetId[],AddBundles: string[],RemoveBundles: string[]): AsyncActionChangePrimaryAssetBundles;
	static AsyncChangeBundleStateForMatchingPrimaryAssets(WorldContextObject: UObject,NewBundles: string[],OldBundles: string[]): AsyncActionChangePrimaryAssetBundles;
	static C(Other: UObject | any): AsyncActionChangePrimaryAssetBundles;
}

declare type ESkyAtmosphereTransformMode = 'PlanetTopAtAbsoluteWorldOrigin' | 'PlanetTopAtComponentTransform' | 'PlanetCenterAtComponentTransform' | 'ESkyAtmosphereTransformMode_MAX';
declare var ESkyAtmosphereTransformMode : { PlanetTopAtAbsoluteWorldOrigin:'PlanetTopAtAbsoluteWorldOrigin',PlanetTopAtComponentTransform:'PlanetTopAtComponentTransform',PlanetCenterAtComponentTransform:'PlanetCenterAtComponentTransform',ESkyAtmosphereTransformMode_MAX:'ESkyAtmosphereTransformMode_MAX', };
declare class TentDistribution { 
	TipAltitude: number;
	TipValue: number;
	Width: number;
	clone() : TentDistribution;
	static C(Other: UObject | any): TentDistribution;
}

declare class SkyAtmosphereComponent extends SceneComponent { 
	TransformMode: ESkyAtmosphereTransformMode;
	BottomRadius: number;
	GroundAlbedo: Color;
	AtmosphereHeight: number;
	MultiScatteringFactor: number;
	TraceSampleCountScale: number;
	RayleighScatteringScale: number;
	RayleighScattering: LinearColor;
	RayleighExponentialDistribution: number;
	MieScatteringScale: number;
	MieScattering: LinearColor;
	MieAbsorptionScale: number;
	MieAbsorption: LinearColor;
	MieAnisotropy: number;
	MieExponentialDistribution: number;
	OtherAbsorptionScale: number;
	OtherAbsorption: LinearColor;
	OtherTentDistribution: TentDistribution;
	SkyLuminanceFactor: LinearColor;
	AerialPespectiveViewDistanceScale: number;
	HeightFogContribution: number;
	TransmittanceMinLightElevationAngle: number;
	AerialPerspectiveStartDepth: number;
	bStaticLightingBuiltGUID: Guid;
	static Load(ResourceName: string): SkyAtmosphereComponent;
	static Find(Outer: UObject, ResourceName: string): SkyAtmosphereComponent;
	static GetDefaultObject(): SkyAtmosphereComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyAtmosphereComponent;
	SetSkyLuminanceFactor(NewValue: LinearColor): void;
	SetRayleighScatteringScale(NewValue: number): void;
	SetRayleighScattering(NewValue: LinearColor): void;
	SetRayleighExponentialDistribution(NewValue: number): void;
	SetOtherAbsorptionScale(NewValue: number): void;
	SetOtherAbsorption(NewValue: LinearColor): void;
	SetMultiScatteringFactor(NewValue: number): void;
	SetMieScatteringScale(NewValue: number): void;
	SetMieScattering(NewValue: LinearColor): void;
	SetMieExponentialDistribution(NewValue: number): void;
	SetMieAnisotropy(NewValue: number): void;
	SetMieAbsorptionScale(NewValue: number): void;
	SetMieAbsorption(NewValue: LinearColor): void;
	SetHeightFogContribution(NewValue: number): void;
	SetAtmosphereHeight(NewValue: number): void;
	SetAerialPespectiveViewDistanceScale(NewValue: number): void;
	OverrideAtmosphereLightDirection(AtmosphereLightIndex: number,LightDirection: Vector): void;
	GetAtmosphereTransmitanceOnGroundAtPlanetTop(DirectionalLight: DirectionalLightComponent): LinearColor;
	static C(Other: UObject | any): SkyAtmosphereComponent;
}

declare class AtmosphericFogComponent extends SkyAtmosphereComponent { 
	static Load(ResourceName: string): AtmosphericFogComponent;
	static Find(Outer: UObject, ResourceName: string): AtmosphericFogComponent;
	static GetDefaultObject(): AtmosphericFogComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AtmosphericFogComponent;
	SetSunMultiplier(NewSunMultiplier: number): void;
	SetStartDistance(NewStartDistance: number): void;
	SetPrecomputeParams(DensityHeight: number,MaxScatteringOrder: number,InscatterAltitudeSampleNum: number): void;
	SetFogMultiplier(NewFogMultiplier: number): void;
	SetDistanceScale(NewDistanceScale: number): void;
	SetDistanceOffset(NewDistanceOffset: number): void;
	SetDensityOffset(NewDensityOffset: number): void;
	SetDensityMultiplier(NewDensityMultiplier: number): void;
	SetDefaultLightColor(NewLightColor: LinearColor): void;
	SetDefaultBrightness(NewBrightness: number): void;
	SetAltitudeScale(NewAltitudeScale: number): void;
	DisableSunDisk(NewSunDisk: boolean): void;
	DisableGroundScattering(NewGroundScattering: boolean): void;
	static C(Other: UObject | any): AtmosphericFogComponent;
}

declare class AtmosphericFog extends Info { 
	AtmosphericFogComponent: AtmosphericFogComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): AtmosphericFog;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AtmosphericFog;
	static C(Other: UObject | any): AtmosphericFog;
}

declare type EVoiceSampleRate = 'Low16000Hz' | 'Normal24000Hz' | 'EVoiceSampleRate_MAX';
declare var EVoiceSampleRate : { Low16000Hz:'Low16000Hz',Normal24000Hz:'Normal24000Hz',EVoiceSampleRate_MAX:'EVoiceSampleRate_MAX', };
declare type EDefaultAudioCompressionType = 'BinkAudio' | 'ADPCM' | 'PCM' | 'PlatformSpecific' | 'EDefaultAudioCompressionType_MAX';
declare var EDefaultAudioCompressionType : { BinkAudio:'BinkAudio',ADPCM:'ADPCM',PCM:'PCM',PlatformSpecific:'PlatformSpecific',EDefaultAudioCompressionType_MAX:'EDefaultAudioCompressionType_MAX', };
declare class AudioQualitySettings { 
	DisplayName: string;
	MaxChannels: number;
	clone() : AudioQualitySettings;
	static C(Other: UObject | any): AudioQualitySettings;
}

declare type EPanningMethod = 'Linear' | 'EqualPower' | 'EPanningMethod_MAX';
declare var EPanningMethod : { Linear:'Linear',EqualPower:'EqualPower',EPanningMethod_MAX:'EPanningMethod_MAX', };
declare type EMonoChannelUpmixMethod = 'Linear' | 'EqualPower' | 'FullVolume' | 'EMonoChannelUpmixMethod_MAX';
declare var EMonoChannelUpmixMethod : { Linear:'Linear',EqualPower:'EqualPower',FullVolume:'FullVolume',EMonoChannelUpmixMethod_MAX:'EMonoChannelUpmixMethod_MAX', };
declare class SoundDebugEntry { 
	DebugName: string;
	Sound: SoftObjectPath;
	clone() : SoundDebugEntry;
	static C(Other: UObject | any): SoundDebugEntry;
}

declare class DefaultAudioBusSettings { 
	AudioBus: SoftObjectPath;
	clone() : DefaultAudioBusSettings;
	static C(Other: UObject | any): DefaultAudioBusSettings;
}

declare class AudioSettings extends DeveloperSettings { 
	DefaultSoundClassName: SoftObjectPath;
	DefaultMediaSoundClassName: SoftObjectPath;
	DefaultSoundConcurrencyName: SoftObjectPath;
	DefaultBaseSoundMix: SoftObjectPath;
	VoiPSoundClass: SoftObjectPath;
	MasterSubmix: SoftObjectPath;
	BaseDefaultSubmix: SoftObjectPath;
	ReverbSubmix: SoftObjectPath;
	EQSubmix: SoftObjectPath;
	VoiPSampleRate: EVoiceSampleRate;
	DefaultAudioCompressionType: EDefaultAudioCompressionType;
	DefaultReverbSendLevel: number;
	MaximumConcurrentStreams: number;
	GlobalMinPitchScale: number;
	GlobalMaxPitchScale: number;
	QualityLevels: AudioQualitySettings[];
	bAllowPlayWhenSilent: boolean;
	bDisableMasterEQ: boolean;
	bAllowCenterChannel3DPanning: boolean;
	NumStoppingSources: number;
	PanningMethod: EPanningMethod;
	MonoChannelUpmixMethod: EMonoChannelUpmixMethod;
	DialogueFilenameFormat: string;
	DebugSounds: SoundDebugEntry[];
	DefaultAudioBuses: DefaultAudioBusSettings[];
	DefaultSoundClass: SoundClass;
	DefaultMediaSoundClass: SoundClass;
	DefaultSoundConcurrency: SoundConcurrency;
	static Load(ResourceName: string): AudioSettings;
	static Find(Outer: UObject, ResourceName: string): AudioSettings;
	static GetDefaultObject(): AudioSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSettings;
	static C(Other: UObject | any): AudioSettings;
}

declare type EAudioVolumeLocationState = 'InsideTheVolume' | 'OutsideTheVolume' | 'EAudioVolumeLocationState_MAX';
declare var EAudioVolumeLocationState : { InsideTheVolume:'InsideTheVolume',OutsideTheVolume:'OutsideTheVolume',EAudioVolumeLocationState_MAX:'EAudioVolumeLocationState_MAX', };
declare class AudioVolumeSubmixSendSettings { 
	ListenerLocationState: EAudioVolumeLocationState;
	SourceLocationState: EAudioVolumeLocationState;
	SubmixSends: SoundSubmixSendInfo[];
	clone() : AudioVolumeSubmixSendSettings;
	static C(Other: UObject | any): AudioVolumeSubmixSendSettings;
}

declare class AudioVolumeSubmixOverrideSettings { 
	Submix: SoundSubmix;
	SubmixEffectChain: SoundEffectSubmixPreset[];
	CrossfadeTime: number;
	clone() : AudioVolumeSubmixOverrideSettings;
	static C(Other: UObject | any): AudioVolumeSubmixOverrideSettings;
}

declare class AudioVolume extends Volume { 
	Priority: number;
	bEnabled: boolean;
	Settings: ReverbSettings;
	AmbientZoneSettings: InteriorSettings;
	SubmixSendSettings: AudioVolumeSubmixSendSettings[];
	SubmixOverrideSettings: AudioVolumeSubmixOverrideSettings[];
	static GetDefaultObject(): AudioVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioVolume;
	SetSubmixSendSettings(NewSubmixSendSettings: AudioVolumeSubmixSendSettings[]): void;
	SetSubmixOverrideSettings(NewSubmixOverrideSettings: AudioVolumeSubmixOverrideSettings[]): void;
	SetReverbSettings(NewReverbSettings: ReverbSettings): void;
	SetPriority(NewPriority: number): void;
	SetInteriorSettings(NewInteriorSettings: InteriorSettings): void;
	SetEnabled(bNewEnabled: boolean): void;
	OnRep_bEnabled(): void;
	static C(Other: UObject | any): AudioVolume;
}

declare class ActorSoundParameterInterface extends Interface { 
	static Load(ResourceName: string): ActorSoundParameterInterface;
	static Find(Outer: UObject, ResourceName: string): ActorSoundParameterInterface;
	static GetDefaultObject(): ActorSoundParameterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorSoundParameterInterface;
	GetActorSoundParams(Params?: AudioParameter[]): {Params: AudioParameter[]};
	static C(Other: UObject | any): ActorSoundParameterInterface;
}

declare class AudioWidgetSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): AudioWidgetSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioWidgetSubsystem;
	static GetDefaultObject(): AudioWidgetSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioWidgetSubsystem;
	static C(Other: UObject | any): AudioWidgetSubsystem;
}

declare class SoundParameterControllerInterface extends AudioParameterControllerInterface { 
	static Load(ResourceName: string): SoundParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): SoundParameterControllerInterface;
	static GetDefaultObject(): SoundParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundParameterControllerInterface;
	static C(Other: UObject | any): SoundParameterControllerInterface;
}

declare class AudioParameterConversionStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AudioParameterConversionStatics;
	static Find(Outer: UObject, ResourceName: string): AudioParameterConversionStatics;
	static GetDefaultObject(): AudioParameterConversionStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterConversionStatics;
	static StringToAudioParameter(Name: string,string: string): AudioParameter;
	static StringArrayToAudioParameter(Name: string,Strings: string[]): AudioParameter;
	static ObjectToAudioParameter(Name: string,UObject: UObject): AudioParameter;
	static ObjectArrayToAudioParameter(Name: string,Objects: UObject[]): AudioParameter;
	static IntegerToAudioParameter(Name: string,Integer: number): AudioParameter;
	static IntegerArrayToAudioParameter(Name: string,Integers: number[]): AudioParameter;
	static FloatToAudioParameter(Name: string,float: number): AudioParameter;
	static FloatArrayToAudioParameter(Name: string,Floats: number[]): AudioParameter;
	static BooleanToAudioParameter(Name: string,bool: boolean): AudioParameter;
	static BooleanArrayToAudioParameter(Name: string,Bools: boolean[]): AudioParameter;
	static C(Other: UObject | any): AudioParameterConversionStatics;
}

declare class BlockingVolume extends Volume { 
	static GetDefaultObject(): BlockingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlockingVolume;
	static C(Other: UObject | any): BlockingVolume;
}

declare class BlueprintMapLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintMapLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintMapLibrary;
	static GetDefaultObject(): BlueprintMapLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintMapLibrary;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: Map<number, number>): void;
	static Map_Values(TargetMap: Map<number, number>,Values?: number[]): {Values: number[]};
	static Map_Remove(TargetMap: Map<number, number>,Key: number): boolean;
	static Map_Length(TargetMap: Map<number, number>): number;
	static Map_Keys(TargetMap: Map<number, number>,Keys?: number[]): {Keys: number[]};
	static Map_IsNotEmpty(TargetMap: Map<number, number>): boolean;
	static Map_IsEmpty(TargetMap: Map<number, number>): boolean;
	static Map_Find(TargetMap: Map<number, number>,Key: number,Value?: number): {Value: number, $: boolean};
	static Map_Contains(TargetMap: Map<number, number>,Key: number): boolean;
	static Map_Clear(TargetMap: Map<number, number>): void;
	static Map_Add(TargetMap: Map<number, number>,Key: number,Value: number): void;
	static C(Other: UObject | any): BlueprintMapLibrary;
}

declare class BlueprintSetLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintSetLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintSetLibrary;
	static GetDefaultObject(): BlueprintSetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintSetLibrary;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: Set<number>): void;
	static Set_Union(A: Set<number>,B: Set<number>,Result?: Set<number>): {Result: Set<number>};
	static Set_ToArray(A: Set<number>,Result?: number[]): {Result: number[]};
	static Set_RemoveItems(TargetSet: Set<number>,Items: number[]): void;
	static Set_Remove(TargetSet: Set<number>,Item: number): boolean;
	static Set_Length(TargetSet: Set<number>): number;
	static Set_IsNotEmpty(TargetSet: Set<number>): boolean;
	static Set_IsEmpty(TargetSet: Set<number>): boolean;
	static Set_Intersection(A: Set<number>,B: Set<number>,Result?: Set<number>): {Result: Set<number>};
	static Set_Difference(A: Set<number>,B: Set<number>,Result?: Set<number>): {Result: Set<number>};
	static Set_Contains(TargetSet: Set<number>,ItemToFind: number): boolean;
	static Set_Clear(TargetSet: Set<number>): void;
	static Set_AddItems(TargetSet: Set<number>,NewItems: number[]): void;
	static Set_Add(TargetSet: Set<number>,NewItem: number): void;
	static C(Other: UObject | any): BlueprintSetLibrary;
}

declare class BrushShape extends Brush { 
	static GetDefaultObject(): BrushShape;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushShape;
	static C(Other: UObject | any): BrushShape;
}

declare class CameraBlockingVolume extends Volume { 
	static GetDefaultObject(): CameraBlockingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraBlockingVolume;
	static C(Other: UObject | any): CameraBlockingVolume;
}

declare class CameraLensEffectInterfaceClassSupportLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): CameraLensEffectInterfaceClassSupportLibrary;
	static Find(Outer: UObject, ResourceName: string): CameraLensEffectInterfaceClassSupportLibrary;
	static GetDefaultObject(): CameraLensEffectInterfaceClassSupportLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraLensEffectInterfaceClassSupportLibrary;
	static SetInterfaceClass(Class: UnrealEngineClass,Var?: CameraLensInterfaceClassSupport,Result?: EInterfaceValidResult): {Var: CameraLensInterfaceClassSupport, Result: EInterfaceValidResult};
	static IsInterfaceClassValid(CameraLens: CameraLensInterfaceClassSupport,Result?: EInterfaceValidResult): {Result: EInterfaceValidResult};
	static GetInterfaceClass(CameraLens: CameraLensInterfaceClassSupport): UnrealEngineClass;
	static C(Other: UObject | any): CameraLensEffectInterfaceClassSupportLibrary;
}

declare class CameraShakeSourceActor extends Actor { 
	CameraShakeSourceComponent: CameraShakeSourceComponent;
	static GetDefaultObject(): CameraShakeSourceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShakeSourceActor;
	static C(Other: UObject | any): CameraShakeSourceActor;
}

declare class CanvasRenderTarget2D extends TextureRenderTarget2D { 
	OnCanvasRenderTargetUpdate: UnrealEngineMulticastDelegate<(Canvas: Canvas, Width: number, Height: number) => void>;
	World: World;
	bShouldClearRenderTargetOnReceiveUpdate: boolean;
	static Load(ResourceName: string): CanvasRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): CanvasRenderTarget2D;
	static GetDefaultObject(): CanvasRenderTarget2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasRenderTarget2D;
	UpdateResource(): void;
	ReceiveUpdate(Canvas: Canvas,Width: number,Height: number): void;
	GetSize(Width?: number,Height?: number): {Width: number, Height: number};
	static CreateCanvasRenderTarget2D(WorldContextObject: UObject,CanvasRenderTarget2DClass: UnrealEngineClass,Width: number,Height: number): CanvasRenderTarget2D;
	static C(Other: UObject | any): CanvasRenderTarget2D;
}

declare class CollisionResponseTemplate { 
	Name: string;
	CollisionEnabled: ECollisionEnabled;
	bCanModify: boolean;
	ObjectTypeName: string;
	CustomResponses: ResponseChannel[];
	HelpMessage: string;
	clone() : CollisionResponseTemplate;
	static C(Other: UObject | any): CollisionResponseTemplate;
}

declare class CustomChannelSetup { 
	Channel: ECollisionChannel;
	DefaultResponse: ECollisionResponse;
	bTraceType: boolean;
	bStaticObject: boolean;
	Name: string;
	clone() : CustomChannelSetup;
	static C(Other: UObject | any): CustomChannelSetup;
}

declare class CustomProfile { 
	Name: string;
	CustomResponses: ResponseChannel[];
	clone() : CustomProfile;
	static C(Other: UObject | any): CustomProfile;
}

declare class Redirector { 
	OldName: string;
	NewName: string;
	clone() : Redirector;
	static C(Other: UObject | any): Redirector;
}

declare class CollisionProfile extends DeveloperSettings { 
	Profiles: CollisionResponseTemplate[];
	DefaultChannelResponses: CustomChannelSetup[];
	EditProfiles: CustomProfile[];
	ProfileRedirects: Redirector[];
	CollisionChannelRedirects: Redirector[];
	static Load(ResourceName: string): CollisionProfile;
	static Find(Outer: UObject, ResourceName: string): CollisionProfile;
	static GetDefaultObject(): CollisionProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CollisionProfile;
	static C(Other: UObject | any): CollisionProfile;
}

declare class PluginCommandlet extends Commandlet { 
	static Load(ResourceName: string): PluginCommandlet;
	static Find(Outer: UObject, ResourceName: string): PluginCommandlet;
	static GetDefaultObject(): PluginCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginCommandlet;
	static C(Other: UObject | any): PluginCommandlet;
}

declare class SmokeTestCommandlet extends Commandlet { 
	static Load(ResourceName: string): SmokeTestCommandlet;
	static Find(Outer: UObject, ResourceName: string): SmokeTestCommandlet;
	static GetDefaultObject(): SmokeTestCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SmokeTestCommandlet;
	static C(Other: UObject | any): SmokeTestCommandlet;
}

declare class BlueprintComponentDelegateBinding { 
	ComponentPropertyName: string;
	DelegatePropertyName: string;
	FunctionNameToBind: string;
	clone() : BlueprintComponentDelegateBinding;
	static C(Other: UObject | any): BlueprintComponentDelegateBinding;
}

declare class ComponentDelegateBinding extends DynamicBlueprintBinding { 
	ComponentDelegateBindings: BlueprintComponentDelegateBinding[];
	static Load(ResourceName: string): ComponentDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): ComponentDelegateBinding;
	static GetDefaultObject(): ComponentDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComponentDelegateBinding;
	static C(Other: UObject | any): ComponentDelegateBinding;
}

declare class ActorComponentInstanceDataTransientOuter extends UObject { 
	static Load(ResourceName: string): ActorComponentInstanceDataTransientOuter;
	static Find(Outer: UObject, ResourceName: string): ActorComponentInstanceDataTransientOuter;
	static GetDefaultObject(): ActorComponentInstanceDataTransientOuter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponentInstanceDataTransientOuter;
	static C(Other: UObject | any): ActorComponentInstanceDataTransientOuter;
}

declare type ETemperatureSeverityType = 'Unknown' | 'Good' | 'Bad' | 'Serious' | 'Critical' | 'NumSeverities' | 'ETemperatureSeverityType_MAX';
declare var ETemperatureSeverityType : { Unknown:'Unknown',Good:'Good',Bad:'Bad',Serious:'Serious',Critical:'Critical',NumSeverities:'NumSeverities',ETemperatureSeverityType_MAX:'ETemperatureSeverityType_MAX', };
declare class ApplicationLifecycleComponent extends ActorComponent { 
	ApplicationWillDeactivateDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationHasReactivatedDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationWillEnterBackgroundDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationHasEnteredForegroundDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationWillTerminateDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationShouldUnloadResourcesDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationReceivedStartupArgumentsDelegate: UnrealEngineMulticastDelegate<(StartupArguments: string[]) => void>;
	OnTemperatureChangeDelegate: UnrealEngineMulticastDelegate<(Severity: ETemperatureSeverityType) => void>;
	OnLowPowerModeDelegate: UnrealEngineMulticastDelegate<(bInLowPowerMode: boolean) => void>;
	static Load(ResourceName: string): ApplicationLifecycleComponent;
	static Find(Outer: UObject, ResourceName: string): ApplicationLifecycleComponent;
	static GetDefaultObject(): ApplicationLifecycleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ApplicationLifecycleComponent;
	static C(Other: UObject | any): ApplicationLifecycleComponent;
}

declare class BoundsCopyComponent extends ActorComponent { 
	BoundsSourceActor: Actor;
	bUseCollidingComponentsForSourceBounds: boolean;
	bKeepOwnBoundsScale: boolean;
	bUseCollidingComponentsForOwnBounds: boolean;
	PostTransform: Transform;
	bCopyXBounds: boolean;
	bCopyYBounds: boolean;
	bCopyZBounds: boolean;
	static Load(ResourceName: string): BoundsCopyComponent;
	static Find(Outer: UObject, ResourceName: string): BoundsCopyComponent;
	static GetDefaultObject(): BoundsCopyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoundsCopyComponent;
	SetTransformToBounds(): void;
	SetRotation(): void;
	static C(Other: UObject | any): BoundsCopyComponent;
}

declare type EInterpToBehaviourType = 'OneShot' | 'OneShot_Reverse' | 'Loop_Reset' | 'PingPong' | 'EInterpToBehaviourType_MAX';
declare var EInterpToBehaviourType : { OneShot:'OneShot',OneShot_Reverse:'OneShot_Reverse',Loop_Reset:'Loop_Reset',PingPong:'PingPong',EInterpToBehaviourType_MAX:'EInterpToBehaviourType_MAX', };
declare class InterpControlPoint { 
	PositionControlPoint: Vector;
	bPositionIsRelative: boolean;
	clone() : InterpControlPoint;
	static C(Other: UObject | any): InterpControlPoint;
}

declare class InterpToMovementComponent extends MovementComponent { 
	Duration: number;
	bPauseOnImpact: boolean;
	bSweep: boolean;
	TeleportType: ETeleportType;
	BehaviourType: EInterpToBehaviourType;
	bCheckIfStillInWorld: boolean;
	bForceSubStepping: boolean;
	OnInterpToReverse: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
	OnInterpToStop: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
	OnWaitBeginDelegate: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
	OnWaitEndDelegate: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
	OnResetDelegate: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
	MaxSimulationTimeStep: number;
	MaxSimulationIterations: number;
	ControlPoints: InterpControlPoint[];
	static Load(ResourceName: string): InterpToMovementComponent;
	static Find(Outer: UObject, ResourceName: string): InterpToMovementComponent;
	static GetDefaultObject(): InterpToMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpToMovementComponent;
	StopSimulating(HitResult: HitResult): void;
	RestartMovement(InitialDirection: number): void;
	ResetControlPoints(): void;
	FinaliseControlPoints(): void;
	AddControlPointPosition(Pos: Vector,bPositionIsRelative: boolean): void;
	static C(Other: UObject | any): InterpToMovementComponent;
}

declare type ESyncOption = 'Drive' | 'Passive' | 'Disabled' | 'ESyncOption_MAX';
declare var ESyncOption : { Drive:'Drive',Passive:'Passive',Disabled:'Disabled',ESyncOption_MAX:'ESyncOption_MAX', };
declare class ComponentSync { 
	Name: string;
	SyncOption: ESyncOption;
	clone() : ComponentSync;
	static C(Other: UObject | any): ComponentSync;
}

declare class LODMappingData { 
	Mapping: number[];
	InverseMapping: number[];
	clone() : LODMappingData;
	static C(Other: UObject | any): LODMappingData;
}

declare class LODSyncComponent extends ActorComponent { 
	NumLODs: number;
	ForcedLOD: number;
	MinLOD: number;
	ComponentsToSync: ComponentSync[];
	CustomLODMapping: Map<string, LODMappingData>;
	CurrentLOD: number;
	CurrentNumLODs: number;
	DriveComponents: PrimitiveComponent[];
	SubComponents: PrimitiveComponent[];
	static Load(ResourceName: string): LODSyncComponent;
	static Find(Outer: UObject, ResourceName: string): LODSyncComponent;
	static GetDefaultObject(): LODSyncComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODSyncComponent;
	GetLODSyncDebugText(): string;
	static C(Other: UObject | any): LODSyncComponent;
}

declare class MaterialSpriteElement { 
	Material: MaterialInterface;
	DistanceToOpacityCurve: CurveFloat;
	bSizeIsInScreenSpace: boolean;
	BaseSizeX: number;
	BaseSizeY: number;
	DistanceToSizeCurve: CurveFloat;
	clone() : MaterialSpriteElement;
	static C(Other: UObject | any): MaterialSpriteElement;
}

declare class MaterialBillboardComponent extends PrimitiveComponent { 
	Elements: MaterialSpriteElement[];
	static Load(ResourceName: string): MaterialBillboardComponent;
	static Find(Outer: UObject, ResourceName: string): MaterialBillboardComponent;
	static GetDefaultObject(): MaterialBillboardComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialBillboardComponent;
	SetElements(NewElements: MaterialSpriteElement[]): void;
	AddElement(Material: MaterialInterface,DistanceToOpacityCurve: CurveFloat,bSizeIsInScreenSpace: boolean,BaseSizeX: number,BaseSizeY: number,DistanceToSizeCurve: CurveFloat): void;
	static C(Other: UObject | any): MaterialBillboardComponent;
}

declare class PawnNoiseEmitterComponent extends ActorComponent { 
	bAIPerceptionSystemCompatibilityMode: boolean;
	LastRemoteNoisePosition: Vector;
	NoiseLifetime: number;
	LastRemoteNoiseVolume: number;
	LastRemoteNoiseTime: number;
	LastLocalNoiseVolume: number;
	LastLocalNoiseTime: number;
	static Load(ResourceName: string): PawnNoiseEmitterComponent;
	static Find(Outer: UObject, ResourceName: string): PawnNoiseEmitterComponent;
	static GetDefaultObject(): PawnNoiseEmitterComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnNoiseEmitterComponent;
	MakeNoise(NoiseMaker: Actor,Loudness: number,NoiseLocation: Vector): void;
	static C(Other: UObject | any): PawnNoiseEmitterComponent;
}

declare class PlatformEventsComponent extends ActorComponent { 
	PlatformChangedToLaptopModeDelegate: UnrealEngineMulticastDelegate<() => void>;
	PlatformChangedToTabletModeDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): PlatformEventsComponent;
	static Find(Outer: UObject, ResourceName: string): PlatformEventsComponent;
	static GetDefaultObject(): PlatformEventsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformEventsComponent;
	SupportsConvertibleLaptops(): boolean;
	IsInTabletMode(): boolean;
	IsInLaptopMode(): boolean;
	static C(Other: UObject | any): PlatformEventsComponent;
}

declare type EBoneSpaces = 'WorldSpace' | 'ComponentSpace' | 'EBoneSpaces_MAX';
declare var EBoneSpaces : { WorldSpace:'WorldSpace',ComponentSpace:'ComponentSpace',EBoneSpaces_MAX:'EBoneSpaces_MAX', };
declare class PoseableMeshComponent extends SkinnedMeshComponent { 
	static Load(ResourceName: string): PoseableMeshComponent;
	static Find(Outer: UObject, ResourceName: string): PoseableMeshComponent;
	static GetDefaultObject(): PoseableMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseableMeshComponent;
	SetBoneTransformByName(BoneName: string,InTransform: Transform,BoneSpace: EBoneSpaces): void;
	SetBoneScaleByName(BoneName: string,InScale3D: Vector,BoneSpace: EBoneSpaces): void;
	SetBoneRotationByName(BoneName: string,InRotation: Rotator,BoneSpace: EBoneSpaces): void;
	SetBoneLocationByName(BoneName: string,InLocation: Vector,BoneSpace: EBoneSpaces): void;
	ResetBoneTransformByName(BoneName: string): void;
	GetBoneTransformByName(BoneName: string,BoneSpace: EBoneSpaces): Transform;
	GetBoneScaleByName(BoneName: string,BoneSpace: EBoneSpaces): Vector;
	GetBoneRotationByName(BoneName: string,BoneSpace: EBoneSpaces): Rotator;
	GetBoneLocationByName(BoneName: string,BoneSpace: EBoneSpaces): Vector;
	CopyPoseFromSkeletalComponent(InComponentToCopy: SkeletalMeshComponent): void;
	static C(Other: UObject | any): PoseableMeshComponent;
}

declare class ProjectileMovementComponent extends MovementComponent { 
	InitialSpeed: number;
	MaxSpeed: number;
	bRotationFollowsVelocity: boolean;
	bRotationRemainsVertical: boolean;
	bShouldBounce: boolean;
	bInitialVelocityInLocalSpace: boolean;
	bForceSubStepping: boolean;
	bSimulationEnabled: boolean;
	bSweepCollision: boolean;
	bIsHomingProjectile: boolean;
	bBounceAngleAffectsFriction: boolean;
	bIsSliding: boolean;
	bInterpMovement: boolean;
	bInterpRotation: boolean;
	PreviousHitTime: number;
	PreviousHitNormal: Vector;
	ProjectileGravityScale: number;
	Buoyancy: number;
	Bounciness: number;
	Friction: number;
	BounceVelocityStopSimulatingThreshold: number;
	MinFrictionFraction: number;
	OnProjectileBounce: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, ImpactVelocity: Vector) => void>;
	OnProjectileStop: UnrealEngineMulticastDelegate<(ImpactResult: HitResult) => void>;
	HomingAccelerationMagnitude: number;
	HomingTargetComponent: SceneComponent;
	MaxSimulationTimeStep: number;
	MaxSimulationIterations: number;
	BounceAdditionalIterations: number;
	InterpLocationTime: number;
	InterpRotationTime: number;
	InterpLocationMaxLagDistance: number;
	InterpLocationSnapToTargetDistance: number;
	static Load(ResourceName: string): ProjectileMovementComponent;
	static Find(Outer: UObject, ResourceName: string): ProjectileMovementComponent;
	static GetDefaultObject(): ProjectileMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectileMovementComponent;
	StopSimulating(HitResult: HitResult): void;
	SetVelocityInLocalSpace(NewVelocity: Vector): void;
	SetInterpolatedComponent(Component: SceneComponent): void;
	ResetInterpolation(): void;
	MoveInterpolationTarget(NewLocation: Vector,NewRotation: Rotator): void;
	LimitVelocity(NewVelocity: Vector): Vector;
	IsVelocityUnderSimulationThreshold(): boolean;
	IsInterpolationComplete(): boolean;
	static C(Other: UObject | any): ProjectileMovementComponent;
}

declare class RectLightComponent extends LocalLightComponent { 
	SourceWidth: number;
	SourceHeight: number;
	BarnDoorAngle: number;
	BarnDoorLength: number;
	SourceTexture: Texture;
	static Load(ResourceName: string): RectLightComponent;
	static Find(Outer: UObject, ResourceName: string): RectLightComponent;
	static GetDefaultObject(): RectLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectLightComponent;
	SetSourceWidth(NewValue: number): void;
	SetSourceTexture(NewValue: Texture): void;
	SetSourceHeight(NewValue: number): void;
	SetBarnDoorLength(NewValue: number): void;
	SetBarnDoorAngle(NewValue: number): void;
	static C(Other: UObject | any): RectLightComponent;
}

declare class RotatingMovementComponent extends MovementComponent { 
	RotationRate: Rotator;
	PivotTranslation: Vector;
	bRotationInLocalSpace: boolean;
	static Load(ResourceName: string): RotatingMovementComponent;
	static Find(Outer: UObject, ResourceName: string): RotatingMovementComponent;
	static GetDefaultObject(): RotatingMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotatingMovementComponent;
	static C(Other: UObject | any): RotatingMovementComponent;
}

declare class VirtualTextureBuildSettings { 
	TileSize: number;
	TileBorderSize: number;
	clone() : VirtualTextureBuildSettings;
	static C(Other: UObject | any): VirtualTextureBuildSettings;
}

declare class VirtualTexture2D extends Texture2D { 
	Settings: VirtualTextureBuildSettings;
	bContinuousUpdate: boolean;
	bSinglePhysicalSpace: boolean;
	static Load(ResourceName: string): VirtualTexture2D;
	static Find(Outer: UObject, ResourceName: string): VirtualTexture2D;
	static GetDefaultObject(): VirtualTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexture2D;
	static C(Other: UObject | any): VirtualTexture2D;
}

declare class VirtualTextureBuilder extends UObject { 
	Texture: VirtualTexture2D;
	BuildHash: number;
	static Load(ResourceName: string): VirtualTextureBuilder;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilder;
	static GetDefaultObject(): VirtualTextureBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilder;
	static C(Other: UObject | any): VirtualTextureBuilder;
}

declare class RuntimeVirtualTextureComponent extends SceneComponent { 
	BoundsAlignActor: Actor;
	bSetBoundsButton: boolean;
	bSnapBoundsToLandscape: boolean;
	VirtualTexture: RuntimeVirtualTexture;
	bEnableScalability: boolean;
	ScalabilityGroup: number;
	bHidePrimitives: boolean;
	StreamingTexture: VirtualTextureBuilder;
	StreamLowMips: number;
	bBuildStreamingMipsButton: boolean;
	LossyCompressionAmount: ETextureLossyCompressionAmount;
	bUseStreamingLowMipsInEditor: boolean;
	bBuildDebugStreamingMips: boolean;
	static Load(ResourceName: string): RuntimeVirtualTextureComponent;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureComponent;
	static GetDefaultObject(): RuntimeVirtualTextureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureComponent;
	Invalidate(WorldBounds: BoxSphereBounds): void;
	static C(Other: UObject | any): RuntimeVirtualTextureComponent;
}

declare class SkyAtmosphere extends Info { 
	SkyAtmosphereComponent: SkyAtmosphereComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): SkyAtmosphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyAtmosphere;
	static C(Other: UObject | any): SkyAtmosphere;
}

declare type EVolumetricCloudTracingMaxDistanceMode = 'DistanceFromCloudLayerEntryPoint' | 'DistanceFromPointOfView' | 'EVolumetricCloudTracingMaxDistanceMode_MAX';
declare var EVolumetricCloudTracingMaxDistanceMode : { DistanceFromCloudLayerEntryPoint:'DistanceFromCloudLayerEntryPoint',DistanceFromPointOfView:'DistanceFromPointOfView',EVolumetricCloudTracingMaxDistanceMode_MAX:'EVolumetricCloudTracingMaxDistanceMode_MAX', };
declare class VolumetricCloudComponent extends SceneComponent { 
	LayerBottomAltitude: number;
	LayerHeight: number;
	TracingStartMaxDistance: number;
	TracingMaxDistanceMode: EVolumetricCloudTracingMaxDistanceMode;
	TracingMaxDistance: number;
	PlanetRadius: number;
	GroundAlbedo: Color;
	Material: MaterialInterface;
	bUsePerSampleAtmosphericLightTransmittance: boolean;
	SkyLightCloudBottomOcclusion: number;
	ViewSampleCountScale: number;
	ReflectionViewSampleCountScaleValue: number;
	ReflectionViewSampleCountScale: number;
	ReflectionSampleCountScale: number;
	ShadowViewSampleCountScale: number;
	ShadowReflectionViewSampleCountScaleValue: number;
	ShadowReflectionViewSampleCountScale: number;
	ShadowReflectionSampleCountScale: number;
	ShadowTracingDistance: number;
	StopTracingTransmittanceThreshold: number;
	static Load(ResourceName: string): VolumetricCloudComponent;
	static Find(Outer: UObject, ResourceName: string): VolumetricCloudComponent;
	static GetDefaultObject(): VolumetricCloudComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricCloudComponent;
	SetViewSampleCountScale(NewValue: number): void;
	SetTracingStartMaxDistance(NewValue: number): void;
	SetTracingMaxDistance(NewValue: number): void;
	SetStopTracingTransmittanceThreshold(NewValue: number): void;
	SetSkyLightCloudBottomOcclusion(NewValue: number): void;
	SetShadowViewSampleCountScale(NewValue: number): void;
	SetShadowTracingDistance(NewValue: number): void;
	SetShadowReflectionViewSampleCountScale(NewValue: number): void;
	SetShadowReflectionSampleCountScale(NewValue: number): void;
	SetReflectionViewSampleCountScale(NewValue: number): void;
	SetReflectionSampleCountScale(NewValue: number): void;
	SetPlanetRadius(NewValue: number): void;
	SetMaterial(NewValue: MaterialInterface): void;
	SetLayerHeight(NewValue: number): void;
	SetLayerBottomAltitude(NewValue: number): void;
	SetGroundAlbedo(NewValue: Color): void;
	SetbUsePerSampleAtmosphericLightTransmittance(NewValue: boolean): void;
	static C(Other: UObject | any): VolumetricCloudComponent;
}

declare class VolumetricCloud extends Info { 
	VolumetricCloudComponent: VolumetricCloudComponent;
	static GetDefaultObject(): VolumetricCloud;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricCloud;
	static C(Other: UObject | any): VolumetricCloud;
}

declare type EStreamingSourceTargetState = 'Loaded' | 'Activated' | 'EStreamingSourceTargetState_MAX';
declare var EStreamingSourceTargetState : { Loaded:'Loaded',Activated:'Activated',EStreamingSourceTargetState_MAX:'EStreamingSourceTargetState_MAX', };
declare class WorldPartitionStreamingSourceComponent extends ActorComponent { 
	DefaultVisualizerLoadingRange: number;
	TargetGrid: string;
	DebugColor: Color;
	TargetHLODLayer: HLODLayer;
	Shapes: StreamingSourceShape[];
	Priority: EStreamingSourcePriority;
	bStreamingSourceEnabled: boolean;
	TargetState: EStreamingSourceTargetState;
	static Load(ResourceName: string): WorldPartitionStreamingSourceComponent;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionStreamingSourceComponent;
	static GetDefaultObject(): WorldPartitionStreamingSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionStreamingSourceComponent;
	IsStreamingSourceEnabled(): boolean;
	IsStreamingCompleted(): boolean;
	EnableStreamingSource(): void;
	DisableStreamingSource(): void;
	static C(Other: UObject | any): WorldPartitionStreamingSourceComponent;
}

declare class CompositeCurveTable extends CurveTable { 
	ParentTables: CurveTable[];
	OldParentTables: CurveTable[];
	static Load(ResourceName: string): CompositeCurveTable;
	static Find(Outer: UObject, ResourceName: string): CompositeCurveTable;
	static GetDefaultObject(): CompositeCurveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositeCurveTable;
	static C(Other: UObject | any): CompositeCurveTable;
}

declare class CompositeDataTable extends DataTable { 
	ParentTables: DataTable[];
	OldParentTables: DataTable[];
	static Load(ResourceName: string): CompositeDataTable;
	static Find(Outer: UObject, ResourceName: string): CompositeDataTable;
	static GetDefaultObject(): CompositeDataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositeDataTable;
	static C(Other: UObject | any): CompositeDataTable;
}

declare class EnumCookedMetaData extends UObject { 
	EnumMetaData: ObjectCookedMetaDataStore;
	static Load(ResourceName: string): EnumCookedMetaData;
	static Find(Outer: UObject, ResourceName: string): EnumCookedMetaData;
	static GetDefaultObject(): EnumCookedMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumCookedMetaData;
	static C(Other: UObject | any): EnumCookedMetaData;
}

declare class StreamingSettings extends DeveloperSettings { 
	AsyncLoadingThreadEnabled: boolean;
	WarnIfTimeLimitExceeded: boolean;
	TimeLimitExceededMultiplier: number;
	TimeLimitExceededMinTime: number;
	MinBulkDataSizeForAsyncLoading: number;
	UseBackgroundLevelStreaming: boolean;
	AsyncLoadingUseFullTimeLimit: boolean;
	AsyncLoadingTimeLimit: number;
	PriorityAsyncLoadingExtraTime: number;
	LevelStreamingActorsUpdateTimeLimit: number;
	PriorityLevelStreamingActorsUpdateExtraTime: number;
	LevelStreamingComponentsRegistrationGranularity: number;
	LevelStreamingAddPrimitiveGranularity: number;
	LevelStreamingUnregisterComponentsTimeLimit: number;
	LevelStreamingComponentsUnregistrationGranularity: number;
	FlushStreamingOnExit: boolean;
	EventDrivenLoaderEnabled: boolean;
	static Load(ResourceName: string): StreamingSettings;
	static Find(Outer: UObject, ResourceName: string): StreamingSettings;
	static GetDefaultObject(): StreamingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamingSettings;
	static C(Other: UObject | any): StreamingSettings;
}

declare class GarbageCollectionSettings extends DeveloperSettings { 
	TimeBetweenPurgingPendingKillObjects: number;
	FlushStreamingOnGC: boolean;
	AllowParallelGC: boolean;
	IncrementalBeginDestroyEnabled: boolean;
	MultithreadedDestructionEnabled: boolean;
	CreateGCClusters: boolean;
	AssetClusteringEnabled: boolean;
	ActorClusteringEnabled: boolean;
	BlueprintClusteringEnabled: boolean;
	UseDisregardForGCOnDedicatedServers: boolean;
	VerifyGCObjectNames: boolean;
	VerifyUObjectsAreNotFGCObjects: boolean;
	PendingKillEnabled: boolean;
	MinGCClusterSize: number;
	NumRetriesBeforeForcingGC: number;
	MaxObjectsNotConsideredByGC: number;
	SizeOfPermanentObjectPool: number;
	MaxObjectsInGame: number;
	MaxObjectsInEditor: number;
	static Load(ResourceName: string): GarbageCollectionSettings;
	static Find(Outer: UObject, ResourceName: string): GarbageCollectionSettings;
	static GetDefaultObject(): GarbageCollectionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GarbageCollectionSettings;
	static C(Other: UObject | any): GarbageCollectionSettings;
}

declare class CullDistanceSizePair { 
	Size: number;
	CullDistance: number;
	clone() : CullDistanceSizePair;
	static C(Other: UObject | any): CullDistanceSizePair;
}

declare class CullDistanceVolume extends Volume { 
	CullDistances: CullDistanceSizePair[];
	bEnabled: boolean;
	static GetDefaultObject(): CullDistanceVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullDistanceVolume;
	static C(Other: UObject | any): CullDistanceVolume;
}

declare class CurveEdPresetCurve extends UObject { 
	static Load(ResourceName: string): CurveEdPresetCurve;
	static Find(Outer: UObject, ResourceName: string): CurveEdPresetCurve;
	static GetDefaultObject(): CurveEdPresetCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEdPresetCurve;
	static C(Other: UObject | any): CurveEdPresetCurve;
}

declare class AssetBundleEntry { 
	BundleName: string;
	BundleAssets: SoftObjectPath[];
	AssetPaths: TopLevelAssetPath[];
	clone() : AssetBundleEntry;
	static C(Other: UObject | any): AssetBundleEntry;
}

declare class AssetBundleData { 
	Bundles: AssetBundleEntry[];
	clone() : AssetBundleData;
	static C(Other: UObject | any): AssetBundleData;
}

declare class PrimaryDataAsset extends DataAsset { 
	AssetBundleData: AssetBundleData;
	static Load(ResourceName: string): PrimaryDataAsset;
	static Find(Outer: UObject, ResourceName: string): PrimaryDataAsset;
	static GetDefaultObject(): PrimaryDataAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimaryDataAsset;
	static C(Other: UObject | any): PrimaryDataAsset;
}

declare class DataDrivenCVarEngineSubsystem extends EngineSubsystem { 
	OnDataDrivenCVarDelegate: UnrealEngineMulticastDelegate<(CVarName: string) => void>;
	static Load(ResourceName: string): DataDrivenCVarEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataDrivenCVarEngineSubsystem;
	static GetDefaultObject(): DataDrivenCVarEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataDrivenCVarEngineSubsystem;
	static C(Other: UObject | any): DataDrivenCVarEngineSubsystem;
}

declare type FDataDrivenCVarType = 'CVarFloat' | 'CVarInt' | 'CVarBool' | 'FDataDrivenCVarType_MAX';
declare var FDataDrivenCVarType : { CVarFloat:'CVarFloat',CVarInt:'CVarInt',CVarBool:'CVarBool',FDataDrivenCVarType_MAX:'FDataDrivenCVarType_MAX', };
declare class DataDrivenConsoleVariable { 
	Type: FDataDrivenCVarType;
	Name: string;
	Tooltip: string;
	DefaultValueFloat: number;
	DefaultValueInt: number;
	DefaultValueBool: boolean;
	clone() : DataDrivenConsoleVariable;
	static C(Other: UObject | any): DataDrivenConsoleVariable;
}

declare class DataDrivenConsoleVariableSettings extends DeveloperSettings { 
	CVarsArray: DataDrivenConsoleVariable[];
	static Load(ResourceName: string): DataDrivenConsoleVariableSettings;
	static Find(Outer: UObject, ResourceName: string): DataDrivenConsoleVariableSettings;
	static GetDefaultObject(): DataDrivenConsoleVariableSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataDrivenConsoleVariableSettings;
	static C(Other: UObject | any): DataDrivenConsoleVariableSettings;
}

declare class DataTableFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): DataTableFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): DataTableFunctionLibrary;
	static GetDefaultObject(): DataTableFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataTableFunctionLibrary;
	static GetDataTableRowNames(Table: DataTable,OutRowNames?: string[]): {OutRowNames: string[]};
	static GetDataTableRowFromName(Table: DataTable,RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	static GetDataTableColumnAsString(DataTable: DataTable,PropertyName: string): string[];
	static FillDataTableFromJSONString(DataTable: DataTable,JsonString: string): boolean;
	static FillDataTableFromJSONFile(DataTable: DataTable,JSONFilePath: string,ImportRowStruct: ScriptStruct): boolean;
	static FillDataTableFromCSVString(DataTable: DataTable,CSVString: string): boolean;
	static FillDataTableFromCSVFile(DataTable: DataTable,CSVFilePath: string): boolean;
	static EvaluateCurveTableRow(CurveTable: CurveTable,RowName: string,InXY: number,OutResult?: EEvaluateCurveTableResult,OutXY?: number,ContextString?: string): {OutResult: EEvaluateCurveTableResult, OutXY: number};
	static DoesDataTableRowExist(Table: DataTable,RowName: string): boolean;
	static C(Other: UObject | any): DataTableFunctionLibrary;
}

declare class DebugCameraControllerSettingsViewModeIndex { 
	ViewModeIndex: EViewModeIndex;
	clone() : DebugCameraControllerSettingsViewModeIndex;
	static C(Other: UObject | any): DebugCameraControllerSettingsViewModeIndex;
}

declare class DebugCameraControllerSettings extends DeveloperSettings { 
	CycleViewModes: DebugCameraControllerSettingsViewModeIndex[];
	static Load(ResourceName: string): DebugCameraControllerSettings;
	static Find(Outer: UObject, ResourceName: string): DebugCameraControllerSettings;
	static GetDefaultObject(): DebugCameraControllerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraControllerSettings;
	static C(Other: UObject | any): DebugCameraControllerSettings;
}

declare class DebugCameraHUD extends HUD { 
	static GetDefaultObject(): DebugCameraHUD;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraHUD;
	static C(Other: UObject | any): DebugCameraHUD;
}

declare class DebugDrawService extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): DebugDrawService;
	static Find(Outer: UObject, ResourceName: string): DebugDrawService;
	static GetDefaultObject(): DebugDrawService;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugDrawService;
	static C(Other: UObject | any): DebugDrawService;
}

declare class DecalActor extends Actor { 
	Decal: DecalComponent;
	ArrowComponent: ArrowComponent;
	SpriteComponent: BillboardComponent;
	BoxComponent: BoxComponent;
	static GetDefaultObject(): DecalActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalActor;
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	GetDecalMaterial(): MaterialInterface;
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
	static C(Other: UObject | any): DecalActor;
}

declare class DestructibleInterface extends Interface { 
	static Load(ResourceName: string): DestructibleInterface;
	static Find(Outer: UObject, ResourceName: string): DestructibleInterface;
	static GetDefaultObject(): DestructibleInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleInterface;
	static C(Other: UObject | any): DestructibleInterface;
}

declare class TextureLODGroup { 
	Group: TextureGroup;
	LODBias: number;
	LODBias_Smaller: number;
	LODBias_Smallest: number;
	NumStreamedMips: number;
	MipGenSettings: TextureMipGenSettings;
	MinLODSize: number;
	MaxLODSize: number;
	MaxLODSize_Smaller: number;
	MaxLODSize_Smallest: number;
	MaxLODSize_VT: number;
	OptionalLODBias: number;
	OptionalMaxLODSize: number;
	MinMagFilter: string;
	MipFilter: string;
	MipLoadOptions: ETextureMipLoadOptions;
	HighPriorityLoad: boolean;
	DuplicateNonOptionalMips: boolean;
	Downscale: number;
	DownscaleOptions: ETextureDownscaleOptions;
	VirtualTextureTileCountBias: number;
	VirtualTextureTileSizeBias: number;
	LossyCompressionAmount: ETextureLossyCompressionAmount;
	clone() : TextureLODGroup;
	static C(Other: UObject | any): TextureLODGroup;
}

declare class TextureLODSettings extends UObject { 
	TextureLODGroups: TextureLODGroup[];
	static Load(ResourceName: string): TextureLODSettings;
	static Find(Outer: UObject, ResourceName: string): TextureLODSettings;
	static GetDefaultObject(): TextureLODSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureLODSettings;
	static C(Other: UObject | any): TextureLODSettings;
}

declare class DPMatchingIfCondition { 
	Operator: string;
	Arg1: string;
	Arg2: string;
	clone() : DPMatchingIfCondition;
	static C(Other: UObject | any): DPMatchingIfCondition;
}

declare class DPMatchingRulestructBase { 
	RuleName: string;
	IfConditions: DPMatchingIfCondition[];
	AppendFragments: string;
	SetUserVar: string;
	clone() : DPMatchingRulestructBase;
	static C(Other: UObject | any): DPMatchingRulestructBase;
}

declare class DPMatchingRulestructA extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructBase[];
	OnFalse: DPMatchingRulestructBase[];
	clone() : DPMatchingRulestructA;
	static C(Other: UObject | any): DPMatchingRulestructA;
}

declare class DPMatchingRulestructB extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructA[];
	OnFalse: DPMatchingRulestructA[];
	clone() : DPMatchingRulestructB;
	static C(Other: UObject | any): DPMatchingRulestructB;
}

declare class DPMatchingRulestructC extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructB[];
	OnFalse: DPMatchingRulestructB[];
	clone() : DPMatchingRulestructC;
	static C(Other: UObject | any): DPMatchingRulestructC;
}

declare class DPMatchingRulestructD extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructC[];
	OnFalse: DPMatchingRulestructC[];
	clone() : DPMatchingRulestructD;
	static C(Other: UObject | any): DPMatchingRulestructD;
}

declare class DPMatchingRulestructE extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructD[];
	OnFalse: DPMatchingRulestructD[];
	clone() : DPMatchingRulestructE;
	static C(Other: UObject | any): DPMatchingRulestructE;
}

declare class DPMatchingRulestruct extends DPMatchingRulestructBase { 
	OnTrue: DPMatchingRulestructE[];
	OnFalse: DPMatchingRulestructE[];
	clone() : DPMatchingRulestruct;
	static C(Other: UObject | any): DPMatchingRulestruct;
}

declare class DeviceProfile extends TextureLODSettings { 
	DeviceType: string;
	BaseProfileName: string;
	bIsVisibleForAssets: boolean;
	Parent: DeviceProfile;
	CVars: string[];
	MatchingRules: DPMatchingRulestruct[];
	static Load(ResourceName: string): DeviceProfile;
	static Find(Outer: UObject, ResourceName: string): DeviceProfile;
	static GetDefaultObject(): DeviceProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeviceProfile;
	static C(Other: UObject | any): DeviceProfile;
}

declare class DeviceProfileManager extends UObject { 
	Profiles: DeviceProfile[];
	BackupProfiles: DeviceProfile[];
	static Load(ResourceName: string): DeviceProfileManager;
	static Find(Outer: UObject, ResourceName: string): DeviceProfileManager;
	static GetDefaultObject(): DeviceProfileManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeviceProfileManager;
	static C(Other: UObject | any): DeviceProfileManager;
}

declare class DocumentationActor extends Actor { 
	DocumentLink: string;
	Billboard: MaterialBillboardComponent;
	static GetDefaultObject(): DocumentationActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DocumentationActor;
	static C(Other: UObject | any): DocumentationActor;
}

declare class DPICustomScalingRule extends UObject { 
	static Load(ResourceName: string): DPICustomScalingRule;
	static Find(Outer: UObject, ResourceName: string): DPICustomScalingRule;
	static GetDefaultObject(): DPICustomScalingRule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DPICustomScalingRule;
	static C(Other: UObject | any): DPICustomScalingRule;
}

declare class EdGraphNode_Documentation extends EdGraphNode { 
	Link: string;
	Excerpt: string;
	static Load(ResourceName: string): EdGraphNode_Documentation;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode_Documentation;
	static GetDefaultObject(): EdGraphNode_Documentation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode_Documentation;
	static C(Other: UObject | any): EdGraphNode_Documentation;
}

declare class ActorElementCounterInterface extends UObject { 
	static Load(ResourceName: string): ActorElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): ActorElementCounterInterface;
	static GetDefaultObject(): ActorElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorElementCounterInterface;
	static C(Other: UObject | any): ActorElementCounterInterface;
}

declare class ActorElementHierarchyInterface extends UObject { 
	static Load(ResourceName: string): ActorElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): ActorElementHierarchyInterface;
	static GetDefaultObject(): ActorElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorElementHierarchyInterface;
	static C(Other: UObject | any): ActorElementHierarchyInterface;
}

declare class ActorElementObjectInterface extends UObject { 
	static Load(ResourceName: string): ActorElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): ActorElementObjectInterface;
	static GetDefaultObject(): ActorElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorElementObjectInterface;
	static C(Other: UObject | any): ActorElementObjectInterface;
}

declare class ComponentElementCounterInterface extends UObject { 
	static Load(ResourceName: string): ComponentElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): ComponentElementCounterInterface;
	static GetDefaultObject(): ComponentElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComponentElementCounterInterface;
	static C(Other: UObject | any): ComponentElementCounterInterface;
}

declare class ComponentElementHierarchyInterface extends UObject { 
	static Load(ResourceName: string): ComponentElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): ComponentElementHierarchyInterface;
	static GetDefaultObject(): ComponentElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComponentElementHierarchyInterface;
	static C(Other: UObject | any): ComponentElementHierarchyInterface;
}

declare class ComponentElementObjectInterface extends UObject { 
	static Load(ResourceName: string): ComponentElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): ComponentElementObjectInterface;
	static GetDefaultObject(): ComponentElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComponentElementObjectInterface;
	static C(Other: UObject | any): ComponentElementObjectInterface;
}

declare class EngineElementsLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): EngineElementsLibrary;
	static Find(Outer: UObject, ResourceName: string): EngineElementsLibrary;
	static GetDefaultObject(): EngineElementsLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineElementsLibrary;
	static K2_AcquireEditorSMInstanceElementHandle(ISMComponent: InstancedStaticMeshComponent,InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorObjectElementHandle(UObject: UObject,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorComponentElementHandle(Component: ActorComponent,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorActorElementHandle(Actor: Actor,bAllowCreate: boolean): ScriptTypedElementHandle;
	static C(Other: UObject | any): EngineElementsLibrary;
}

declare class TypedElementDeletionOptions { 
	bVerifyDeletionCanHappen: boolean;
	bWarnAboutReferences: boolean;
	bWarnAboutSoftReferences: boolean;
	clone() : TypedElementDeletionOptions;
	static C(Other: UObject | any): TypedElementDeletionOptions;
}

declare class TypedElementCommonActions extends UObject { 
	static Load(ResourceName: string): TypedElementCommonActions;
	static Find(Outer: UObject, ResourceName: string): TypedElementCommonActions;
	static GetDefaultObject(): TypedElementCommonActions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCommonActions;
	K2_DuplicateSelectedElements(SelectionSet: TypedElementSelectionSet,World: World,LocationOffset: Vector): ScriptTypedElementHandle[];
	DuplicateNormalizedElements(ElementList: ScriptTypedElementListProxy,World: World,LocationOffset: Vector): ScriptTypedElementHandle[];
	DeleteSelectedElements(SelectionSet: TypedElementSelectionSet,World: World,DeletionOptions: TypedElementDeletionOptions): boolean;
	DeleteNormalizedElements(ElementList: ScriptTypedElementListProxy,World: World,InSelectionSet: TypedElementSelectionSet,DeletionOptions: TypedElementDeletionOptions): boolean;
	static C(Other: UObject | any): TypedElementCommonActions;
}

declare type ETypedElementWorldType = 'Game' | 'Editor' | 'ETypedElementWorldType_MAX';
declare var ETypedElementWorldType : { Game:'Game',Editor:'Editor',ETypedElementWorldType_MAX:'ETypedElementWorldType_MAX', };
declare class TypedElementWorldInterface extends Interface { 
	static Load(ResourceName: string): TypedElementWorldInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementWorldInterface;
	static GetDefaultObject(): TypedElementWorldInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementWorldInterface;
	SetWorldTransform(InElementHandle: ScriptTypedElementHandle,InTransform: Transform): boolean;
	SetRelativeTransform(InElementHandle: ScriptTypedElementHandle,InTransform: Transform): boolean;
	SetPivotOffset(InElementHandle: ScriptTypedElementHandle,InPivotOffset: Vector): boolean;
	PromoteElement(InElementHandle: ScriptTypedElementHandle,OverrideWorld: World): ScriptTypedElementHandle;
	NotifyMovementStarted(InElementHandle: ScriptTypedElementHandle): void;
	NotifyMovementOngoing(InElementHandle: ScriptTypedElementHandle): void;
	NotifyMovementEnded(InElementHandle: ScriptTypedElementHandle): void;
	IsTemplateElement(InElementHandle: ScriptTypedElementHandle): boolean;
	GetWorldTransform(InElementHandle: ScriptTypedElementHandle,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	GetRelativeTransform(InElementHandle: ScriptTypedElementHandle,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	GetPivotOffset(InElementHandle: ScriptTypedElementHandle,OutPivotOffset?: Vector): {OutPivotOffset: Vector, $: boolean};
	GetOwnerWorld(InElementHandle: ScriptTypedElementHandle): World;
	GetOwnerLevel(InElementHandle: ScriptTypedElementHandle): Level;
	GetBounds(InElementHandle: ScriptTypedElementHandle,OutBounds?: BoxSphereBounds): {OutBounds: BoxSphereBounds, $: boolean};
	DuplicateElement(InElementHandle: ScriptTypedElementHandle,InWorld: World,InLocationOffset: Vector): ScriptTypedElementHandle;
	DeleteElement(InElementHandle: ScriptTypedElementHandle,InWorld: World,InSelectionSet: TypedElementSelectionSet,InDeletionOptions: TypedElementDeletionOptions): boolean;
	CanPromoteElement(InElementHandle: ScriptTypedElementHandle): boolean;
	CanMoveElement(InElementHandle: ScriptTypedElementHandle,InWorldType: ETypedElementWorldType): boolean;
	CanEditElement(InElementHandle: ScriptTypedElementHandle): boolean;
	CanDuplicateElement(InElementHandle: ScriptTypedElementHandle): boolean;
	CanDeleteElement(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementWorldInterface;
}

declare class ObjectElementAssetDataInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementAssetDataInterface;
	static GetDefaultObject(): ObjectElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementAssetDataInterface;
	static C(Other: UObject | any): ObjectElementAssetDataInterface;
}

declare class ObjectElementCounterInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementCounterInterface;
	static GetDefaultObject(): ObjectElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementCounterInterface;
	static C(Other: UObject | any): ObjectElementCounterInterface;
}

declare class ObjectElementObjectInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementObjectInterface;
	static GetDefaultObject(): ObjectElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementObjectInterface;
	static C(Other: UObject | any): ObjectElementObjectInterface;
}

declare class SMInstanceElementAssetDataInterface extends UObject { 
	static Load(ResourceName: string): SMInstanceElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementAssetDataInterface;
	static GetDefaultObject(): SMInstanceElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementAssetDataInterface;
	static C(Other: UObject | any): SMInstanceElementAssetDataInterface;
}

declare class SMInstanceElementHierarchyInterface extends UObject { 
	static Load(ResourceName: string): SMInstanceElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementHierarchyInterface;
	static GetDefaultObject(): SMInstanceElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementHierarchyInterface;
	static C(Other: UObject | any): SMInstanceElementHierarchyInterface;
}

declare class SMInstanceElementIdMapTransactor extends UObject { 
	static Load(ResourceName: string): SMInstanceElementIdMapTransactor;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementIdMapTransactor;
	static GetDefaultObject(): SMInstanceElementIdMapTransactor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementIdMapTransactor;
	static C(Other: UObject | any): SMInstanceElementIdMapTransactor;
}

declare class EngineMessage extends LocalMessage { 
	FailedPlaceMessage: string;
	MaxedOutMessage: string;
	EnteredMessage: string;
	LeftMessage: string;
	GlobalNameChange: string;
	SpecEnteredMessage: string;
	NewPlayerMessage: string;
	NewSpecMessage: string;
	static Load(ResourceName: string): EngineMessage;
	static Find(Outer: UObject, ResourceName: string): EngineMessage;
	static GetDefaultObject(): EngineMessage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineMessage;
	static C(Other: UObject | any): EngineMessage;
}

declare class AutoDestroySubsystem extends TickableWorldSubsystem { 
	ActorsToPoll: Actor[];
	static Load(ResourceName: string): AutoDestroySubsystem;
	static Find(Outer: UObject, ResourceName: string): AutoDestroySubsystem;
	static GetDefaultObject(): AutoDestroySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutoDestroySubsystem;
	OnActorEndPlay(Actor: Actor,EndPlayReason: EEndPlayReason): void;
	static C(Other: UObject | any): AutoDestroySubsystem;
}

declare class CancellableAsyncAction extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): CancellableAsyncAction;
	static Find(Outer: UObject, ResourceName: string): CancellableAsyncAction;
	static GetDefaultObject(): CancellableAsyncAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CancellableAsyncAction;
	IsActive(): boolean;
	Cancel(): void;
	static C(Other: UObject | any): CancellableAsyncAction;
}

declare class LODSyncInterface extends Interface { 
	static Load(ResourceName: string): LODSyncInterface;
	static Find(Outer: UObject, ResourceName: string): LODSyncInterface;
	static GetDefaultObject(): LODSyncInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODSyncInterface;
	static C(Other: UObject | any): LODSyncInterface;
}

declare class PoseWatchPoseElement extends PoseWatchElement { 
	ViewportMask: BlendProfile;
	bInvertViewportMask: boolean;
	BlendScaleThreshold: number;
	ViewportOffset: Vector3d;
	static Load(ResourceName: string): PoseWatchPoseElement;
	static Find(Outer: UObject, ResourceName: string): PoseWatchPoseElement;
	static GetDefaultObject(): PoseWatchPoseElement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseWatchPoseElement;
	static C(Other: UObject | any): PoseWatchPoseElement;
}

declare class SystemTimeTimecodeProvider extends TimecodeProvider { 
	FrameRate: FrameRate;
	bGenerateFullFrame: boolean;
	bUseHighPerformanceClock: boolean;
	static Load(ResourceName: string): SystemTimeTimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): SystemTimeTimecodeProvider;
	static GetDefaultObject(): SystemTimeTimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SystemTimeTimecodeProvider;
	static C(Other: UObject | any): SystemTimeTimecodeProvider;
}

declare class ViewportStatsSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): ViewportStatsSubsystem;
	static Find(Outer: UObject, ResourceName: string): ViewportStatsSubsystem;
	static GetDefaultObject(): ViewportStatsSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportStatsSubsystem;
	RemoveDisplayDelegate(IndexToRemove: number): void;
	AddTimedDisplay(Text: string,Color: LinearColor,Duration: number,DisplayOffset: Vector2D): void;
	static C(Other: UObject | any): ViewportStatsSubsystem;
}

declare class FloatingPawnMovement extends PawnMovementComponent { 
	MaxSpeed: number;
	Acceleration: number;
	Deceleration: number;
	TurningBoost: number;
	bPositionCorrected: boolean;
	static Load(ResourceName: string): FloatingPawnMovement;
	static Find(Outer: UObject, ResourceName: string): FloatingPawnMovement;
	static GetDefaultObject(): FloatingPawnMovement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatingPawnMovement;
	static C(Other: UObject | any): FloatingPawnMovement;
}

declare type EFontLayoutMethod = 'Metrics' | 'BoundingBox' | 'EFontLayoutMethod_MAX';
declare var EFontLayoutMethod : { Metrics:'Metrics',BoundingBox:'BoundingBox',EFontLayoutMethod_MAX:'EFontLayoutMethod_MAX', };
declare class FontFace extends UObject { 
	SourceFilename: string;
	Hinting: EFontHinting;
	LoadingPolicy: EFontLoadingPolicy;
	LayoutMethod: EFontLayoutMethod;
	FontFaceData: number[];
	SubFaces: string[];
	static Load(ResourceName: string): FontFace;
	static Find(Outer: UObject, ResourceName: string): FontFace;
	static GetDefaultObject(): FontFace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFace;
	static C(Other: UObject | any): FontFace;
}

declare class GameEngine extends Engine { 
	MaxDeltaTime: number;
	ServerFlushLogInterval: number;
	GameInstance: GameInstance;
	static Load(ResourceName: string): GameEngine;
	static Find(Outer: UObject, ResourceName: string): GameEngine;
	static GetDefaultObject(): GameEngine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameEngine;
	static C(Other: UObject | any): GameEngine;
}

declare class AsyncActionHandleSaveGame extends BlueprintAsyncActionBase { 
	Completed: UnrealEngineMulticastDelegate<(SaveGame: SaveGame, bSuccess: boolean) => void>;
	SaveGameObject: SaveGame;
	static Load(ResourceName: string): AsyncActionHandleSaveGame;
	static Find(Outer: UObject, ResourceName: string): AsyncActionHandleSaveGame;
	static GetDefaultObject(): AsyncActionHandleSaveGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncActionHandleSaveGame;
	static AsyncSaveGameToSlot(WorldContextObject: UObject,SaveGameObject: SaveGame,SlotName: string,UserIndex: number): AsyncActionHandleSaveGame;
	static AsyncLoadGameFromSlot(WorldContextObject: UObject,SlotName: string,UserIndex: number): AsyncActionHandleSaveGame;
	static C(Other: UObject | any): AsyncActionHandleSaveGame;
}

declare class SpringArmComponent extends SceneComponent { 
	TargetArmLength: number;
	SocketOffset: Vector;
	TargetOffset: Vector;
	ProbeSize: number;
	ProbeChannel: ECollisionChannel;
	bDoCollisionTest: boolean;
	bUsePawnControlRotation: boolean;
	bInheritPitch: boolean;
	bInheritYaw: boolean;
	bInheritRoll: boolean;
	bEnableCameraLag: boolean;
	bEnableCameraRotationLag: boolean;
	bUseCameraLagSubstepping: boolean;
	bDrawDebugLagMarkers: boolean;
	CameraLagSpeed: number;
	CameraRotationLagSpeed: number;
	CameraLagMaxTimeStep: number;
	CameraLagMaxDistance: number;
	bClampToMaxPhysicsDeltaTime: boolean;
	static Load(ResourceName: string): SpringArmComponent;
	static Find(Outer: UObject, ResourceName: string): SpringArmComponent;
	static GetDefaultObject(): SpringArmComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpringArmComponent;
	IsCollisionFixApplied(): boolean;
	GetUnfixedCameraPosition(): Vector;
	GetTargetRotation(): Rotator;
	static C(Other: UObject | any): SpringArmComponent;
}

declare class GameplayStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): GameplayStatics;
	static Find(Outer: UObject, ResourceName: string): GameplayStatics;
	static GetDefaultObject(): GameplayStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayStatics;
	static UnRetainAllSoundsInSoundClass(InSoundClass: SoundClass): void;
	static UnloadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static UnloadStreamLevel(WorldContextObject: UObject,LevelName: string,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static SuggestProjectileVelocity_CustomArc(WorldContextObject: UObject,OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	static SpawnSoundAttached(Sound: SoundBase,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SpawnSoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SpawnSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static SpawnObject(ObjectClass: UnrealEngineClass,Outer: UObject): UObject;
	static SpawnForceFeedbackAttached(ForceFeedbackEffect: ForceFeedbackEffect,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnForceFeedbackAtLocation(WorldContextObject: UObject,ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnEmitterAttached(EmitterTemplate: ParticleSystem,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,Scale: Vector,LocationType: EAttachLocation,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivate: boolean): ParticleSystemComponent;
	static SpawnEmitterAtLocation(WorldContextObject: UObject,EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivateSystem: boolean): ParticleSystemComponent;
	static SpawnDialogueAttached(Dialogue: DialogueWave,Context: DialogueContext,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	static SpawnDecalAttached(DecalMaterial: MaterialInterface,DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	static SpawnDecalAtLocation(WorldContextObject: UObject,DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	static SetWorldOriginLocation(WorldContextObject: UObject,NewLocation: IntVector): void;
	static SetViewportMouseCaptureMode(WorldContextObject: UObject,MouseCaptureMode: EMouseCaptureMode): void;
	static SetSubtitlesEnabled(bEnabled: boolean): void;
	static SetSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	static SetSoundClassDistanceScale(WorldContextObject: UObject,SoundClass: SoundClass,DistanceAttenuationScale: number,TimeSec: number): void;
	static SetPlayerPlatformUserId(PlayerController: PlayerController,UserId: PlatformUserId): void;
	static SetPlayerControllerID(Player: PlayerController,ControllerId: number): void;
	static SetMaxAudioChannelsScaled(WorldContextObject: UObject,MaxChannelCountScale: number): void;
	static SetGlobalTimeDilation(WorldContextObject: UObject,TimeDilation: number): void;
	static SetGlobalPitchModulation(WorldContextObject: UObject,PitchModulation: number,TimeSec: number): void;
	static SetGlobalListenerFocusParameters(WorldContextObject: UObject,FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	static SetGamePaused(WorldContextObject: UObject,bPaused: boolean): boolean;
	static SetForceDisableSplitscreen(WorldContextObject: UObject,bDisable: boolean): void;
	static SetEnableWorldRendering(WorldContextObject: UObject,bEnable: boolean): void;
	static SetBaseSoundMix(WorldContextObject: UObject,InSoundMix: SoundMix): void;
	static SetActiveSpatialPluginByName(WorldContextObject: UObject,InPluginName: string): boolean;
	static SaveGameToSlot(SaveGameObject: SaveGame,SlotName: string,UserIndex: number): boolean;
	static RemovePlayer(Player: PlayerController,bDestroyPawn: boolean): void;
	static RebaseZeroOriginOntoLocal(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static RebaseLocalOriginOntoZero(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static PushSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static ProjectWorldToScreen(Player: PlayerController,WorldPosition: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static PrimeSound(InSound: SoundBase): void;
	static PrimeAllSoundsInSoundClass(InSoundClass: SoundClass): void;
	static PopSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static PlayWorldCameraShake(WorldContextObject: UObject,Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	static PlaySoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,InitialParams: InitialActiveSoundParams): void;
	static PlaySound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,bIsUISound: boolean): void;
	static PlayDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	static PlayDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	static ParseOption(Options: string,Key: string): string;
	static OpenLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bAbsolute: boolean,Options: string): void;
	static OpenLevel(WorldContextObject: UObject,LevelName: string,bAbsolute: boolean,Options: string): void;
	static ObjectIsA(UObject: UObject,ObjectClass: UnrealEngineClass): boolean;
	static MakeHitResult(bBlockingHit: boolean,bInitialOverlap: boolean,Time: number,Distance: number,Location: Vector,ImpactPoint: Vector,Normal: Vector,ImpactNormal: Vector,PhysMat: PhysicalMaterial,HitActor: Actor,HitComponent: PrimitiveComponent,HitBoneName: string,BoneName: string,HitItem: number,ElementIndex: number,FaceIndex: number,TraceStart: Vector,TraceEnd: Vector): HitResult;
	static LoadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static LoadStreamLevel(WorldContextObject: UObject,LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static LoadGameFromSlot(SlotName: string,UserIndex: number): SaveGame;
	static IsSplitscreenForceDisabled(WorldContextObject: UObject): boolean;
	static IsGamePaused(WorldContextObject: UObject): boolean;
	static HasOption(Options: string,InKey: string): boolean;
	static HasLaunchOption(OptionToCheck: string): boolean;
	static GrassOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static GetWorldOriginLocation(WorldContextObject: UObject): IntVector;
	static GetWorldDeltaSeconds(WorldContextObject: UObject): number;
	static GetViewProjectionMatrix(DesiredView: MinimalViewInfo,ViewMatrix?: Matrix,ProjectionMatrix?: Matrix,ViewProjectionMatrix?: Matrix): {ViewMatrix: Matrix, ProjectionMatrix: Matrix, ViewProjectionMatrix: Matrix};
	static GetViewportMouseCaptureMode(WorldContextObject: UObject): EMouseCaptureMode;
	static GetUnpausedTimeSeconds(WorldContextObject: UObject): number;
	static GetTimeSeconds(WorldContextObject: UObject): number;
	static GetSurfaceType(Hit: HitResult): EPhysicalSurface;
	static GetStreamingLevel(WorldContextObject: UObject,PackageName: string): LevelStreaming;
	static GetRealTimeSeconds(WorldContextObject: UObject): number;
	static GetPlayerStateFromUniqueNetId(WorldContextObject: UObject,UniqueId: UniqueNetIdRepl): PlayerState;
	static GetPlayerState(WorldContextObject: UObject,PlayerStateIndex: number): PlayerState;
	static GetPlayerPawn(WorldContextObject: UObject,PlayerIndex: number): Pawn;
	static GetPlayerControllerID(Player: PlayerController): number;
	static GetPlayerControllerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId): PlayerController;
	static GetPlayerControllerFromID(WorldContextObject: UObject,ControllerId: number): PlayerController;
	static GetPlayerController(WorldContextObject: UObject,PlayerIndex: number): PlayerController;
	static GetPlayerCharacter(WorldContextObject: UObject,PlayerIndex: number): Character;
	static GetPlayerCameraManager(WorldContextObject: UObject,PlayerIndex: number): PlayerCameraManager;
	static GetPlatformName(): string;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static GetNumPlayerStates(WorldContextObject: UObject): number;
	static GetNumPlayerControllers(WorldContextObject: UObject): number;
	static GetNumLocalPlayerControllers(WorldContextObject: UObject): number;
	static GetMaxAudioChannelCount(WorldContextObject: UObject): number;
	static GetKeyValue(Pair: string,Key?: string,Value?: string): {Key: string, Value: string};
	static GetIntOption(Options: string,Key: string,DefaultValue: number): number;
	static GetGlobalTimeDilation(WorldContextObject: UObject): number;
	static GetGameState(WorldContextObject: UObject): GameStateBase;
	static GetGameMode(WorldContextObject: UObject): GameModeBase;
	static GetGameInstance(WorldContextObject: UObject): GameInstance;
	static GetEnableWorldRendering(WorldContextObject: UObject): boolean;
	static GetCurrentReverbEffect(WorldContextObject: UObject): ReverbEffect;
	static GetCurrentLevelName(WorldContextObject: UObject,bRemovePrefixString: boolean): string;
	static GetClosestListenerLocation(WorldContextObject: UObject,Location: Vector,MaximumRange: number,bAllowAttenuationOverride: boolean,ListenerPosition?: Vector): {ListenerPosition: Vector, $: boolean};
	static GetAvailableSpatialPluginNames(WorldContextObject: UObject): string[];
	static GetAudioTimeSeconds(WorldContextObject: UObject): number;
	static GetAllActorsWithTag(WorldContextObject: UObject,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClassWithTag(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetActorOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass): Actor;
	static GetActorArrayBounds(Actors: Actor[],bOnlyCollidingComponents: boolean,Center?: Vector,BoxExtent?: Vector): {Center: Vector, BoxExtent: Vector};
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
	static GetActiveSpatialPluginName(WorldContextObject: UObject): string;
	static GetAccurateRealTime(Seconds?: number,PartialSeconds?: number): {Seconds: number, PartialSeconds: number};
	static FlushLevelStreaming(WorldContextObject: UObject): void;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static FindNearestActor(Origin: Vector,ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	static FindCollisionUV(Hit: HitResult,UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	static EnableLiveStreaming(Enable: boolean): void;
	static DoesSaveGameExist(SlotName: string,UserIndex: number): boolean;
	static DeprojectScreenToWorld(Player: PlayerController,ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	static DeprojectSceneCaptureToWorld(SceneCapture2D: SceneCapture2D,TargetUV: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	static DeleteGameInSlot(SlotName: string,UserIndex: number): boolean;
	static DeactivateReverbEffect(WorldContextObject: UObject,TagName: string): void;
	static CreateSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static CreateSaveGameObject(SaveGameClass: UnrealEngineClass): SaveGame;
	static CreatePlayerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId,bSpawnPlayerController: boolean): PlayerController;
	static CreatePlayer(WorldContextObject: UObject,ControllerId: number,bSpawnPlayerController: boolean): PlayerController;
	static ClearSoundMixModifiers(WorldContextObject: UObject): void;
	static ClearSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	static CancelAsyncLoading(): void;
	static BreakHitResult(Hit: HitResult,bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Distance?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,BoneName?: string,HitItem?: number,ElementIndex?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, BoneName: string, HitItem: number, ElementIndex: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	static BlueprintSuggestProjectileVelocity(WorldContextObject: UObject,TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: UObject,PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	static BeginSpawningActorFromBlueprint(WorldContextObject: UObject,Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	static BeginDeferredActorSpawnFromClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	static AreSubtitlesEnabled(): boolean;
	static AreAnyListenersWithinRange(WorldContextObject: UObject,Location: Vector,MaximumRange: number): boolean;
	static ApplyRadialDamageWithFalloff(WorldContextObject: UObject,BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	static ApplyRadialDamage(WorldContextObject: UObject,BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static AnnounceAccessibleString(AnnouncementString: string): void;
	static ActivateReverbEffect(WorldContextObject: UObject,ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	static C(Other: UObject | any): GameplayStatics;
}

declare class HLODInstancingKey { 
	StaticMesh: StaticMesh;
	Material: MaterialInterface;
	clone() : HLODInstancingKey;
	static C(Other: UObject | any): HLODInstancingKey;
}

declare class HLODISMComponentDesc { 
	StaticMesh: StaticMesh;
	Material: MaterialInterface;
	Instances: Transform[];
	InstancesCustomPrimitiveData: CustomPrimitiveData[];
	clone() : HLODISMComponentDesc;
	static C(Other: UObject | any): HLODISMComponentDesc;
}

declare class HLODProxyDesc extends UObject { 
	SubActors: string[];
	StaticMesh: StaticMesh;
	ISMComponentsDesc: HLODISMComponentDesc[];
	LODDrawDistance: number;
	bOverrideMaterialMergeSettings: boolean;
	MaterialSettings: MaterialProxySettings;
	bOverrideTransitionScreenSize: boolean;
	TransitionScreenSize: number;
	bOverrideScreenSize: boolean;
	ScreenSize: number;
	Key: string;
	LODLevel: number;
	LODActorTag: string;
	Location: Vector;
	HLODBakingTransform: Transform;
	SubHLODDescs: HLODProxyDesc[];
	static Load(ResourceName: string): HLODProxyDesc;
	static Find(Outer: UObject, ResourceName: string): HLODProxyDesc;
	static GetDefaultObject(): HLODProxyDesc;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODProxyDesc;
	static C(Other: UObject | any): HLODProxyDesc;
}

declare class LODActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	InstancedStaticMeshComponents: Map<HLODInstancingKey, InstancedStaticMeshComponent>;
	Proxy: HLODProxy;
	Key: string;
	LODDrawDistance: number;
	LODLevel: number;
	SubActors: Actor[];
	CachedNumHLODLevels: number;
	NumTrianglesInSubActors: number;
	NumTrianglesInMergedMesh: number;
	bOverrideMaterialMergeSettings: boolean;
	MaterialSettings: MaterialProxySettings;
	bOverrideTransitionScreenSize: boolean;
	TransitionScreenSize: number;
	bOverrideScreenSize: boolean;
	ScreenSize: number;
	LODActorTag: string;
	bBuiltFromHLODDesc: boolean;
	ProxyDesc: HLODProxyDesc;
	static GetDefaultObject(): LODActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODActor;
	OnSubActorEndPlay(Actor: Actor,Reason: EEndPlayReason): void;
	static C(Other: UObject | any): LODActor;
}

declare class HLODProxyMesh { 
	LODActor: LODActor;
	StaticMesh: StaticMesh;
	Key: string;
	clone() : HLODProxyMesh;
	static C(Other: UObject | any): HLODProxyMesh;
}

declare class HLODProxy extends UObject { 
	OwningMap: World;
	ProxyMeshes: HLODProxyMesh[];
	HLODActors: Map<HLODProxyDesc, HLODProxyMesh>;
	static Load(ResourceName: string): HLODProxy;
	static Find(Outer: UObject, ResourceName: string): HLODProxy;
	static GetDefaultObject(): HLODProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODProxy;
	static C(Other: UObject | any): HLODProxy;
}

declare class HLODEngineSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): HLODEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): HLODEngineSubsystem;
	static GetDefaultObject(): HLODEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODEngineSubsystem;
	static C(Other: UObject | any): HLODEngineSubsystem;
}

declare class ImportantToggleSettingInterface extends Interface { 
	static Load(ResourceName: string): ImportantToggleSettingInterface;
	static Find(Outer: UObject, ResourceName: string): ImportantToggleSettingInterface;
	static GetDefaultObject(): ImportantToggleSettingInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImportantToggleSettingInterface;
	static C(Other: UObject | any): ImportantToggleSettingInterface;
}

declare class InputDelegateBinding extends DynamicBlueprintBinding { 
	static Load(ResourceName: string): InputDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputDelegateBinding;
	static GetDefaultObject(): InputDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputDelegateBinding;
	static C(Other: UObject | any): InputDelegateBinding;
}

declare class BlueprintInputDelegateBinding { 
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	clone() : BlueprintInputDelegateBinding;
	static C(Other: UObject | any): BlueprintInputDelegateBinding;
}

declare class BlueprintInputActionDelegateBinding extends BlueprintInputDelegateBinding { 
	InputActionName: string;
	InputKeyEvent: EInputEvent;
	FunctionNameToBind: string;
	clone() : BlueprintInputActionDelegateBinding;
	static C(Other: UObject | any): BlueprintInputActionDelegateBinding;
}

declare class InputActionDelegateBinding extends InputDelegateBinding { 
	InputActionDelegateBindings: BlueprintInputActionDelegateBinding[];
	static Load(ResourceName: string): InputActionDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputActionDelegateBinding;
	static GetDefaultObject(): InputActionDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputActionDelegateBinding;
	static C(Other: UObject | any): InputActionDelegateBinding;
}

declare class BlueprintInputAxisDelegateBinding extends BlueprintInputDelegateBinding { 
	InputAxisName: string;
	FunctionNameToBind: string;
	clone() : BlueprintInputAxisDelegateBinding;
	static C(Other: UObject | any): BlueprintInputAxisDelegateBinding;
}

declare class InputAxisDelegateBinding extends InputDelegateBinding { 
	InputAxisDelegateBindings: BlueprintInputAxisDelegateBinding[];
	static Load(ResourceName: string): InputAxisDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputAxisDelegateBinding;
	static GetDefaultObject(): InputAxisDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAxisDelegateBinding;
	static C(Other: UObject | any): InputAxisDelegateBinding;
}

declare class BlueprintInputAxisKeyDelegateBinding extends BlueprintInputDelegateBinding { 
	AxisKey: Key;
	FunctionNameToBind: string;
	clone() : BlueprintInputAxisKeyDelegateBinding;
	static C(Other: UObject | any): BlueprintInputAxisKeyDelegateBinding;
}

declare class InputAxisKeyDelegateBinding extends InputDelegateBinding { 
	InputAxisKeyDelegateBindings: BlueprintInputAxisKeyDelegateBinding[];
	static Load(ResourceName: string): InputAxisKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputAxisKeyDelegateBinding;
	static GetDefaultObject(): InputAxisKeyDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAxisKeyDelegateBinding;
	static C(Other: UObject | any): InputAxisKeyDelegateBinding;
}

declare class BlueprintInputKeyDelegateBinding extends BlueprintInputDelegateBinding { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	FunctionNameToBind: string;
	clone() : BlueprintInputKeyDelegateBinding;
	static C(Other: UObject | any): BlueprintInputKeyDelegateBinding;
}

declare class InputKeyDelegateBinding extends InputDelegateBinding { 
	InputKeyDelegateBindings: BlueprintInputKeyDelegateBinding[];
	static Load(ResourceName: string): InputKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputKeyDelegateBinding;
	static GetDefaultObject(): InputKeyDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeyDelegateBinding;
	static C(Other: UObject | any): InputKeyDelegateBinding;
}

declare class BlueprintInputTouchDelegateBinding extends BlueprintInputDelegateBinding { 
	InputKeyEvent: EInputEvent;
	FunctionNameToBind: string;
	clone() : BlueprintInputTouchDelegateBinding;
	static C(Other: UObject | any): BlueprintInputTouchDelegateBinding;
}

declare class InputTouchDelegateBinding extends InputDelegateBinding { 
	InputTouchDelegateBindings: BlueprintInputTouchDelegateBinding[];
	static Load(ResourceName: string): InputTouchDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputTouchDelegateBinding;
	static GetDefaultObject(): InputTouchDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTouchDelegateBinding;
	static C(Other: UObject | any): InputTouchDelegateBinding;
}

declare class InputVectorAxisDelegateBinding extends InputAxisKeyDelegateBinding { 
	static Load(ResourceName: string): InputVectorAxisDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputVectorAxisDelegateBinding;
	static GetDefaultObject(): InputVectorAxisDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputVectorAxisDelegateBinding;
	static C(Other: UObject | any): InputVectorAxisDelegateBinding;
}

declare class InstancedPlacementPartitionActor extends ISMPartitionActor { 
	PlacementGridGuid: Guid;
	static GetDefaultObject(): InstancedPlacementPartitionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedPlacementPartitionActor;
	static C(Other: UObject | any): InstancedPlacementPartitionActor;
}

declare class StringTable extends UObject { 
	static Load(ResourceName: string): StringTable;
	static Find(Outer: UObject, ResourceName: string): StringTable;
	static GetDefaultObject(): StringTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StringTable;
	static C(Other: UObject | any): StringTable;
}

declare class IntSerialization extends UObject { 
	UnsignedInt16Variable: number;
	UnsignedInt32Variable: number;
	UnsignedInt64Variable: number;
	SignedInt8Variable: number;
	SignedInt16Variable: number;
	SignedInt64Variable: number;
	UnsignedInt8Variable: number;
	SignedInt32Variable: number;
	static Load(ResourceName: string): IntSerialization;
	static Find(Outer: UObject, ResourceName: string): IntSerialization;
	static GetDefaultObject(): IntSerialization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntSerialization;
	static C(Other: UObject | any): IntSerialization;
}

declare class KillZVolume extends PhysicsVolume { 
	static GetDefaultObject(): KillZVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KillZVolume;
	static C(Other: UObject | any): KillZVolume;
}

declare class KismetArrayLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetArrayLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetArrayLibrary;
	static GetDefaultObject(): KismetArrayLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetArrayLibrary;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static FilterArray(TargetArray: Actor[],FilterClass: UnrealEngineClass,FilteredArray?: Actor[]): {FilteredArray: Actor[]};
	static Array_Swap(TargetArray: number[],FirstIndex: number,SecondIndex: number): void;
	static Array_Shuffle(TargetArray: number[]): void;
	static Array_Set(TargetArray: number[],Index: number,Item: number,bSizeToFit: boolean): void;
	static Array_Reverse(TargetArray: number[]): void;
	static Array_Resize(TargetArray: number[],Size: number): void;
	static Array_RemoveItem(TargetArray: number[],Item: number): boolean;
	static Array_Remove(TargetArray: number[],IndexToRemove: number): void;
	static Array_RandomFromStream(TargetArray: number[],RandomStream?: RandomStream,OutItem?: number,OutIndex?: number): {RandomStream: RandomStream, OutItem: number, OutIndex: number};
	static Array_Random(TargetArray: number[],OutItem?: number,OutIndex?: number): {OutItem: number, OutIndex: number};
	static Array_Length(TargetArray: number[]): number;
	static Array_LastIndex(TargetArray: number[]): number;
	static Array_IsValidIndex(TargetArray: number[],IndexToTest: number): boolean;
	static Array_IsNotEmpty(TargetArray: number[]): boolean;
	static Array_IsEmpty(TargetArray: number[]): boolean;
	static Array_Insert(TargetArray: number[],NewItem: number,Index: number): void;
	static Array_Identical(ArrayA: number[],ArrayB: number[]): boolean;
	static Array_Get(TargetArray: number[],Index: number,Item?: number): {Item: number};
	static Array_Find(TargetArray: number[],ItemToFind: number): number;
	static Array_Contains(TargetArray: number[],ItemToFind: number): boolean;
	static Array_Clear(TargetArray: number[]): void;
	static Array_Append(TargetArray: number[],SourceArray: number[]): void;
	static Array_AddUnique(TargetArray: number[],NewItem: number): number;
	static Array_Add(TargetArray: number[],NewItem: number): number;
	static C(Other: UObject | any): KismetArrayLibrary;
}

declare class KismetGuidLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetGuidLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetGuidLibrary;
	static GetDefaultObject(): KismetGuidLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetGuidLibrary;
	static Parse_StringToGuid(GuidString: string,OutGuid?: Guid,Success?: boolean): {OutGuid: Guid, Success: boolean};
	static NotEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static NewGuid(): Guid;
	static IsValid_Guid(InGuid: Guid): boolean;
	static Invalidate_Guid(InGuid?: Guid): {InGuid: Guid};
	static EqualEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static Conv_GuidToString(InGuid: Guid): string;
	static C(Other: UObject | any): KismetGuidLibrary;
}

declare class SlateModifierKeysState { 
	ModifierKeysStateMask: number;
	clone() : SlateModifierKeysState;
	static C(Other: UObject | any): SlateModifierKeysState;
	ModifierKeysState_IsAltDown(): boolean;
	ModifierKeysState_IsCommandDown(): boolean;
	ModifierKeysState_IsControlDown(): boolean;
	ModifierKeysState_IsShiftDown(): boolean;
	static ModifierKeysState_IsAltDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsCommandDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsControlDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsShiftDown(KeysState: SlateModifierKeysState): boolean;
	static GetModifierKeysState(): SlateModifierKeysState;
}

declare class KismetInputLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetInputLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetInputLibrary;
	static GetDefaultObject(): KismetInputLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetInputLibrary;
	static PointerEvent_IsTouchEvent(Input: UPointerEvent): boolean;
	static PointerEvent_IsMouseButtonDown(Input: UPointerEvent,MouseButton: Key): boolean;
	static PointerEvent_GetWheelDelta(Input: UPointerEvent): number;
	static PointerEvent_GetUserIndex(Input: UPointerEvent): number;
	static PointerEvent_GetTouchpadIndex(Input: UPointerEvent): number;
	static PointerEvent_GetScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetPointerIndex(Input: UPointerEvent): number;
	static PointerEvent_GetLastScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetGestureType(Input: UPointerEvent): ESlateGesture;
	static PointerEvent_GetGestureDelta(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetEffectingButton(Input: UPointerEvent): Key;
	static PointerEvent_GetCursorDelta(Input: UPointerEvent): Vector2D;
	static ModifierKeysState_IsShiftDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsControlDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsCommandDown(KeysState: SlateModifierKeysState): boolean;
	static ModifierKeysState_IsAltDown(KeysState: SlateModifierKeysState): boolean;
	static Key_IsVectorAxis(Key: Key): boolean;
	static Key_IsValid(Key: Key): boolean;
	static Key_IsMouseButton(Key: Key): boolean;
	static Key_IsModifierKey(Key: Key): boolean;
	static Key_IsKeyboardKey(Key: Key): boolean;
	static Key_IsGamepadKey(Key: Key): boolean;
	static Key_IsDigital(Key: Key): boolean;
	static Key_IsButtonAxis(Key: Key): boolean;
	static Key_IsAxis3D(Key: Key): boolean;
	static Key_IsAxis2D(Key: Key): boolean;
	static Key_IsAxis1D(Key: Key): boolean;
	static Key_IsAnalog(Key: Key): boolean;
	static Key_GetNavigationDirectionFromKey(InKeyEvent: KeyEvent): EUINavigation;
	static Key_GetNavigationDirectionFromAnalog(InAnalogEvent: AnalogInputEvent): EUINavigation;
	static Key_GetNavigationActionFromKey(InKeyEvent: KeyEvent): EUINavigationAction;
	static Key_GetNavigationAction(InKey: Key): EUINavigationAction;
	static Key_GetDisplayName(Key: Key,bLongDisplayName: boolean): string;
	static InputEvent_IsShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsRightShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsRightControlDown(Input: InputEvent): boolean;
	static InputEvent_IsRightCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsRightAltDown(Input: InputEvent): boolean;
	static InputEvent_IsRepeat(Input: InputEvent): boolean;
	static InputEvent_IsLeftShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftControlDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftAltDown(Input: InputEvent): boolean;
	static InputEvent_IsControlDown(Input: InputEvent): boolean;
	static InputEvent_IsCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsAltDown(Input: InputEvent): boolean;
	static InputChord_GetDisplayName(Key: InputChord): string;
	static GetUserIndex(Input: KeyEvent): number;
	static GetModifierKeysState(): SlateModifierKeysState;
	static GetKey(Input: KeyEvent): Key;
	static GetAnalogValue(Input: AnalogInputEvent): number;
	static EqualEqual_KeyKey(A: Key,B: Key): boolean;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
	static CalibrateTilt(): void;
	static C(Other: UObject | any): KismetInputLibrary;
}

declare class KismetInternationalizationLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetInternationalizationLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetInternationalizationLibrary;
	static GetDefaultObject(): KismetInternationalizationLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetInternationalizationLibrary;
	static SetCurrentLocale(Culture: string,SaveToConfig: boolean): boolean;
	static SetCurrentLanguageAndLocale(Culture: string,SaveToConfig: boolean): boolean;
	static SetCurrentLanguage(Culture: string,SaveToConfig: boolean): boolean;
	static SetCurrentCulture(Culture: string,SaveToConfig: boolean): boolean;
	static SetCurrentAssetGroupCulture(AssetGroup: string,Culture: string,SaveToConfig: boolean): boolean;
	static GetSuitableCulture(AvailableCultures: string[],CultureToMatch: string,FallbackCulture: string): string;
	static GetNativeCulture(TextCategory: ELocalizedTextSourceCategory): string;
	static GetLocalizedCultures(IncludeGame: boolean,IncludeEngine: boolean,IncludeEditor: boolean,IncludeAdditional: boolean): string[];
	static GetCurrentLocale(): string;
	static GetCurrentLanguage(): string;
	static GetCurrentCulture(): string;
	static GetCurrentAssetGroupCulture(AssetGroup: string): string;
	static GetCultureDisplayName(Culture: string,Localized: boolean): string;
	static ClearCurrentAssetGroupCulture(AssetGroup: string,SaveToConfig: boolean): void;
	static C(Other: UObject | any): KismetInternationalizationLibrary;
}

declare class KismetMaterialLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetMaterialLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetMaterialLibrary;
	static GetDefaultObject(): KismetMaterialLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetMaterialLibrary;
	static SetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	static SetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	static GetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	static GetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): number;
	static CreateDynamicMaterialInstance(WorldContextObject: UObject,Parent: MaterialInterface,OptionalName: string,CreationFlags: EMIDCreationFlags): MaterialInstanceDynamic;
	static C(Other: UObject | any): KismetMaterialLibrary;
}

declare class FloatSpringState { 
	clone() : FloatSpringState;
	static C(Other: UObject | any): FloatSpringState;
	ResetFloatSpringState(): {SpringState: FloatSpringState};
	SetFloatSpringStateVelocity(Velocity?: number): {SpringState: FloatSpringState};
	static ResetFloatSpringState(SpringState?: FloatSpringState): {SpringState: FloatSpringState};
	static SetFloatSpringStateVelocity(SpringState?: FloatSpringState,Velocity?: number): {SpringState: FloatSpringState};
}

declare class KismetMathLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetMathLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetMathLibrary;
	static GetDefaultObject(): KismetMathLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetMathLibrary;
	static Xor_IntInt(A: number,B: number): number;
	static Xor_Int64Int64(A: number,B: number): number;
	static Wrap(Value: number,Min: number,Max: number): number;
	static WeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,Weight: number): Vector;
	static WeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,Weight: number): Rotator;
	static WeightedMovingAverage_Float(CurrentSample: number,PreviousSample: number,Weight: number): number;
	static VSizeXYSquared(A: Vector): number;
	static VSizeXY(A: Vector): number;
	static VSizeSquared(A: Vector): number;
	static VSize2DSquared(A: Vector2D): number;
	static VSize2D(A: Vector2D): number;
	static VSize(A: Vector): number;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	static Vector_Zero(): Vector;
	static Vector_Up(): Vector;
	static Vector_UnwindEuler(A?: Vector): {A: Vector};
	static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
	static Vector_ToRadians(A: Vector): Vector;
	static Vector_ToDegrees(A: Vector): Vector;
	static Vector_SnappedToGrid(InVect: Vector,InGridSize: number): Vector;
	static Vector_Set(A?: Vector,X?: number,Y?: number,Z?: number): {A: Vector};
	static Vector_Right(): Vector;
	static Vector_Reciprocal(A: Vector): Vector;
	static Vector_ProjectOnToNormal(V: Vector,InNormal: Vector): Vector;
	static Vector_One(): Vector;
	static Vector_NormalUnsafe(A: Vector): Vector;
	static Vector_Normalize(A?: Vector,Tolerance?: number): {A: Vector};
	static Vector_Normal2D(A: Vector,Tolerance: number): Vector;
	static Vector_MirrorByPlane(A: Vector,InPlane: Plane): Vector;
	static Vector_Left(): Vector;
	static Vector_IsZero(A: Vector): boolean;
	static Vector_IsUnit(A: Vector,SquaredLenthTolerance: number): boolean;
	static Vector_IsUniform(A: Vector,Tolerance: number): boolean;
	static Vector_IsNormal(A: Vector): boolean;
	static Vector_IsNearlyZero(A: Vector,Tolerance: number): boolean;
	static Vector_IsNAN(A: Vector): boolean;
	static Vector_HeadingAngle(A: Vector): number;
	static Vector_GetSignVector(A: Vector): Vector;
	static Vector_GetProjection(A: Vector): Vector;
	static Vector_GetAbsMin(A: Vector): number;
	static Vector_GetAbsMax(A: Vector): number;
	static Vector_GetAbs(A: Vector): Vector;
	static Vector_Forward(): Vector;
	static Vector_Down(): Vector;
	static Vector_DistanceSquared(v1: Vector,v2: Vector): number;
	static Vector_Distance2DSquared(v1: Vector,v2: Vector): number;
	static Vector_Distance2D(v1: Vector,v2: Vector): number;
	static Vector_Distance(v1: Vector,v2: Vector): number;
	static Vector_CosineAngle2D(A: Vector,B: Vector): number;
	static Vector_ComponentMin(A: Vector,B: Vector): Vector;
	static Vector_ComponentMax(A: Vector,B: Vector): Vector;
	static Vector_ClampSizeMax2D(A: Vector,Max: number): Vector;
	static Vector_ClampSizeMax(A: Vector,Max: number): Vector;
	static Vector_ClampSize2D(A: Vector,Min: number,Max: number): Vector;
	static Vector_BoundedToCube(InVect: Vector,InRadius: number): Vector;
	static Vector_BoundedToBox(InVect: Vector,InBoxMin: Vector,InBoxMax: Vector): Vector;
	static Vector_Backward(): Vector;
	static Vector_Assign(A?: Vector,InVector?: Vector): {A: Vector};
	static Vector_AddBounded(A?: Vector,InAddVect?: Vector,InRadius?: number): {A: Vector};
	static Vector4_Zero(): Vector4;
	static Vector4_SizeSquared3(A: Vector4): number;
	static Vector4_SizeSquared(A: Vector4): number;
	static Vector4_Size3(A: Vector4): number;
	static Vector4_Size(A: Vector4): number;
	static Vector4_Set(A?: Vector4,X?: number,Y?: number,Z?: number,W?: number): {A: Vector4};
	static Vector4_NormalUnsafe3(A: Vector4): Vector4;
	static Vector4_Normalize3(A?: Vector4,Tolerance?: number): {A: Vector4};
	static Vector4_Normal3(A: Vector4,Tolerance: number): Vector4;
	static Vector4_Negated(A: Vector4): Vector4;
	static Vector4_MirrorByVector3(Direction: Vector4,SurfaceNormal: Vector4): Vector4;
	static Vector4_IsZero(A: Vector4): boolean;
	static Vector4_IsUnit3(A: Vector4,SquaredLenthTolerance: number): boolean;
	static Vector4_IsNormal3(A: Vector4): boolean;
	static Vector4_IsNearlyZero3(A: Vector4,Tolerance: number): boolean;
	static Vector4_IsNAN(A: Vector4): boolean;
	static Vector4_DotProduct3(A: Vector4,B: Vector4): number;
	static Vector4_DotProduct(A: Vector4,B: Vector4): number;
	static Vector4_CrossProduct3(A: Vector4,B: Vector4): Vector4;
	static Vector4_Assign(A?: Vector4,InVector?: Vector4): {A: Vector4};
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2D_Zero(): Vector2D;
	static Vector2D_Unit45Deg(): Vector2D;
	static Vector2D_One(): Vector2D;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static UtcNow(): DateTime;
	static TransformVector4(Matrix: Matrix,Vec4: Vector4): Vector4;
	static TransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static TransformLocation(T: Transform,Location: Vector): Vector;
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	static Transform_Determinant(Transform: Transform): number;
	static ToSign2D(A: Vector2D): Vector2D;
	static ToRounded2D(A: Vector2D): Vector2D;
	static ToDirectionAndLength2D(A: Vector2D,OutDir?: Vector2D,OutLength?: number): {OutDir: Vector2D, OutLength: number};
	static Today(): DateTime;
	static TLerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	static TimespanZeroValue(): Timespan;
	static TimespanRatio(A: Timespan,B: Timespan): number;
	static TimespanMinValue(): Timespan;
	static TimespanMaxValue(): Timespan;
	static TimespanFromString(TimespanString: string,Result?: Timespan): {Result: Timespan, $: boolean};
	static TEase(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	static Tan(A: number): number;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorFloat(A: Vector,B: number): Vector;
	static Subtract_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Subtract_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Subtract_TimespanTimespan(A: Timespan,B: Timespan): Timespan;
	static Subtract_QuatQuat(A: Quat,B: Quat): Quat;
	static Subtract_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static Subtract_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Subtract_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Subtract_IntInt(A: number,B: number): number;
	static Subtract_Int64Int64(A: number,B: number): number;
	static Subtract_DoubleDouble(A: number,B: number): number;
	static Subtract_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static Subtract_DateTimeDateTime(A: DateTime,B: DateTime): Timespan;
	static Subtract_ByteByte(A: number,B: number): number;
	static Square(A: number): number;
	static Sqrt(A: number): number;
	static Spherical2DToUnitCartesian(A: Vector2D): Vector;
	static Sin(A: number): number;
	static SignOfInteger64(A: number): number;
	static SignOfInteger(A: number): number;
	static SignOfFloat(A: number): number;
	static SetVectorSpringStateVelocity(SpringState?: VectorSpringState,Velocity?: Vector): {SpringState: VectorSpringState};
	static SetRandomStreamSeed(Stream?: RandomStream,NewSeed?: number): {Stream: RandomStream};
	static SetQuaternionSpringStateAngularVelocity(SpringState?: QuaternionSpringState,AngularVelocity?: Vector): {SpringState: QuaternionSpringState};
	static SetFloatSpringStateVelocity(SpringState?: FloatSpringState,Velocity?: number): {SpringState: FloatSpringState};
	static Set2D(A?: Vector2D,X?: number,Y?: number): {A: Vector2D};
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	static SelectString(A: string,B: string,bPickA: boolean): string;
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SelectInt(A: number,B: number,bPickA: boolean): number;
	static SelectFloat(A: number,B: number,bPickA: boolean): number;
	static SelectColor(A: LinearColor,B: LinearColor,bPickA: boolean): LinearColor;
	static SelectClass(A: UnrealEngineClass,B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	static SeedRandomStream(Stream?: RandomStream): {Stream: RandomStream};
	static SafeDivide(A: number,B: number): number;
	static Round64(A: number): number;
	static Round(A: number): number;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RLerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RGBToHSV_Vector(rgb: LinearColor,HSV?: LinearColor): {HSV: LinearColor};
	static RGBToHSV(InColor: LinearColor,H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	static RGBLinearToHSV(rgb: LinearColor): LinearColor;
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
	static ResetRandomStream(Stream: RandomStream): void;
	static ResetQuaternionSpringState(SpringState?: QuaternionSpringState): {SpringState: QuaternionSpringState};
	static ResetFloatSpringState(SpringState?: FloatSpringState): {SpringState: FloatSpringState};
	static REase(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorFromStream(Stream: RandomStream): Vector;
	static RandomUnitVector(): Vector;
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
	static RandomRotator(bRoll: boolean): Rotator;
	static RandomPointInBoundingBoxFromStream_Box(Box: Box,Stream: RandomStream): Vector;
	static RandomPointInBoundingBoxFromStream(Center: Vector,HalfSize: Vector,Stream: RandomStream): Vector;
	static RandomPointInBoundingBox_Box(Box: Box): Vector;
	static RandomPointInBoundingBox(Center: Vector,HalfSize: Vector): Vector;
	static RandomIntegerInRangeFromStream(Min: number,Max: number,Stream: RandomStream): number;
	static RandomIntegerInRange(Min: number,Max: number): number;
	static RandomIntegerFromStream(Max: number,Stream: RandomStream): number;
	static RandomInteger64InRange(Min: number,Max: number): number;
	static RandomInteger64(Max: number): number;
	static RandomInteger(Max: number): number;
	static RandomFloatInRangeFromStream(Min: number,Max: number,Stream: RandomStream): number;
	static RandomFloatInRange(Min: number,Max: number): number;
	static RandomFloatFromStream(Stream: RandomStream): number;
	static RandomFloat(): number;
	static RandomBoolWithWeightFromStream(Weight: number,RandomStream: RandomStream): boolean;
	static RandomBoolWithWeight(Weight: number): boolean;
	static RandomBoolFromStream(Stream: RandomStream): boolean;
	static RandomBool(): boolean;
	static RadiansToDegrees(A: number): number;
	static QuaternionSpringInterp(Current: Quat,Target: Quat,SpringState?: QuaternionSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bInitializeFromTarget?: boolean): {SpringState: QuaternionSpringState, $: Quat};
	static Quat_VectorUp(Q: Quat): Vector;
	static Quat_VectorRight(Q: Quat): Vector;
	static Quat_VectorForward(Q: Quat): Vector;
	static Quat_UnrotateVector(Q: Quat,V: Vector): Vector;
	static Quat_SizeSquared(Q: Quat): number;
	static Quat_Size(Q: Quat): number;
	static Quat_SetFromEuler(Q?: Quat,Euler?: Vector): {Q: Quat};
	static Quat_SetComponents(Q?: Quat,X?: number,Y?: number,Z?: number,W?: number): {Q: Quat};
	static Quat_Rotator(Q: Quat): Rotator;
	static Quat_RotateVector(Q: Quat,V: Vector): Vector;
	static Quat_Normalized(Q: Quat,Tolerance: number): Quat;
	static Quat_Normalize(Q?: Quat,Tolerance?: number): {Q: Quat};
	static Quat_MakeFromEuler(Euler: Vector): Quat;
	static Quat_Log(Q: Quat): Quat;
	static Quat_IsNormalized(Q: Quat): boolean;
	static Quat_IsNonFinite(Q: Quat): boolean;
	static Quat_IsIdentity(Q: Quat,Tolerance: number): boolean;
	static Quat_IsFinite(Q: Quat): boolean;
	static Quat_Inversed(Q: Quat): Quat;
	static Quat_Identity(): Quat;
	static Quat_GetRotationAxis(Q: Quat): Vector;
	static Quat_GetAxisZ(Q: Quat): Vector;
	static Quat_GetAxisY(Q: Quat): Vector;
	static Quat_GetAxisX(Q: Quat): Vector;
	static Quat_GetAngle(Q: Quat): number;
	static Quat_Exp(Q: Quat): Quat;
	static Quat_Euler(Q: Quat): Vector;
	static Quat_EnforceShortestArcWith(A?: Quat,B?: Quat): {A: Quat};
	static Quat_AngularDistance(A: Quat,B: Quat): number;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static PointsAreCoplanar(Points: Vector[],Tolerance: number): boolean;
	static PerlinNoise1D(Value: number): number;
	static Percent_IntInt(A: number,B: number): number;
	static Percent_Int64Int64(A: number,B: number): number;
	static Percent_FloatFloat(A: number,B: number): number;
	static Percent_ByteByte(A: number,B: number): number;
	static Or_IntInt(A: number,B: number): number;
	static Or_Int64Int64(A: number,B: number): number;
	static Now(): DateTime;
	static NotEqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static NotEqualExactly_Vector4Vector4(A: Vector4,B: Vector4): boolean;
	static NotEqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static NotEqual_Vector4Vector4(A: Vector4,B: Vector4,ErrorTolerance: number): boolean;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static NotEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static NotEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static NotEqual_QuatQuat(A: Quat,B: Quat,ErrorTolerance: number): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_NameName(A: string,B: string): boolean;
	static NotEqual_MatrixMatrix(A: Matrix,B: Matrix,Tolerance: number): boolean;
	static NotEqual_LinearColorLinearColor(A: LinearColor,B: LinearColor): boolean;
	static NotEqual_IntPointIntPoint(A: IntPoint,B: IntPoint): boolean;
	static NotEqual_IntInt(A: number,B: number): boolean;
	static NotEqual_Int64Int64(A: number,B: number): boolean;
	static NotEqual_DoubleDouble(A: number,B: number): boolean;
	static NotEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static NotEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static NotEqual_ByteByte(A: number,B: number): boolean;
	static NotEqual_BoolBool(A: boolean,B: boolean): boolean;
	static Not_PreBool(A: boolean): boolean;
	static Not_Int64(A: number): number;
	static Not_Int(A: number): number;
	static NormalSafe2D(A: Vector2D,Tolerance: number): Vector2D;
	static NormalizeToRange(Value: number,RangeMin: number,RangeMax: number): number;
	static NormalizedDeltaRotator(A: Rotator,B: Rotator): Rotator;
	static NormalizeAxis(Angle: number): number;
	static Normalize2D(A?: Vector2D,Tolerance?: number): {A: Vector2D};
	static Normal2D(A: Vector2D): Vector2D;
	static Normal(A: Vector,Tolerance: number): Vector;
	static NegateVector(A: Vector): Vector;
	static NegateRotator(A: Rotator): Rotator;
	static Negated2D(A: Vector2D): Vector2D;
	static NearlyEqual_TransformTransform(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	static NearlyEqual_FloatFloat(A: number,B: number,ErrorTolerance: number): boolean;
	static MultiplyMultiply_FloatFloat(Base: number,Exp: number): number;
	static MultiplyByPi(Value: number): number;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorFloat(A: Vector,B: number): Vector;
	static Multiply_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Multiply_TimespanFloat(A: Timespan,Scalar: number): Timespan;
	static Multiply_RotatorInt(A: Rotator,B: number): Rotator;
	static Multiply_RotatorFloat(A: Rotator,B: number): Rotator;
	static Multiply_QuatQuat(A: Quat,B: Quat): Quat;
	static Multiply_MatrixMatrix(A: Matrix,B: Matrix): Matrix;
	static Multiply_MatrixFloat(A: Matrix,B: number): Matrix;
	static Multiply_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static Multiply_LinearColorFloat(A: LinearColor,B: number): LinearColor;
	static Multiply_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Multiply_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Multiply_IntInt(A: number,B: number): number;
	static Multiply_IntFloat(A: number,B: number): number;
	static Multiply_Int64Int64(A: number,B: number): number;
	static Multiply_DoubleDouble(A: number,B: number): number;
	static Multiply_ByteByte(A: number,B: number): number;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static MinOfIntArray(IntArray: number[],IndexOfMinValue?: number,MinValue?: number): {IndexOfMinValue: number, MinValue: number};
	static MinOfFloatArray(FloatArray: number[],IndexOfMinValue?: number,MinValue?: number): {IndexOfMinValue: number, MinValue: number};
	static MinOfByteArray(ByteArray: number[],IndexOfMinValue?: number,MinValue?: number): {IndexOfMinValue: number, MinValue: number};
	static MinInt64(A: number,B: number): number;
	static MinimumAreaRectangle(WorldContextObject: UObject,InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	static MinAreaRectangle(WorldContextObject: UObject,InPoints: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutRectLengthX?: number,OutRectLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutRectLengthX: number, OutRectLengthY: number};
	static Min(A: number,B: number): number;
	static MedianOfIntArray(IntArray: number[],MedianValue?: number): {MedianValue: number};
	static MaxOfIntArray(IntArray: number[],IndexOfMaxValue?: number,MaxValue?: number): {IndexOfMaxValue: number, MaxValue: number};
	static MaxOfFloatArray(FloatArray: number[],IndexOfMaxValue?: number,MaxValue?: number): {IndexOfMaxValue: number, MaxValue: number};
	static MaxOfByteArray(ByteArray: number[],IndexOfMaxValue?: number,MaxValue?: number): {IndexOfMaxValue: number, MaxValue: number};
	static MaxInt64(A: number,B: number): number;
	static Max(A: number,B: number): number;
	static Matrix_TransformVector4(M: Matrix,V: Vector4): Vector4;
	static Matrix_TransformVector(M: Matrix,V: Vector): Vector4;
	static Matrix_TransformPosition(M: Matrix,V: Vector): Vector4;
	static Matrix_ToQuat(M: Matrix): Quat;
	static Matrix_SetOrigin(M?: Matrix,NewOrigin?: Vector): {M: Matrix};
	static Matrix_SetColumn(M?: Matrix,Column?: EMatrixColumns,Value?: Vector): {M: Matrix};
	static Matrix_SetAxis(M?: Matrix,Axis?: EAxis,AxisVector?: Vector): {M: Matrix};
	static Matrix_ScaleTranslation(M: Matrix,Scale3D: Vector): Matrix;
	static Matrix_RemoveTranslation(M: Matrix): Matrix;
	static Matrix_RemoveScaling(M?: Matrix,Tolerance?: number): {M: Matrix};
	static Matrix_Mirror(M: Matrix,MirrorAxis: EAxis,FlipAxis: EAxis): Matrix;
	static Matrix_InverseTransformVector(M: Matrix,V: Vector): Vector;
	static Matrix_InverseTransformPosition(M: Matrix,V: Vector): Vector;
	static Matrix_Identity(): Matrix;
	static Matrix_GetUnitAxis(M: Matrix,Axis: EAxis): Vector;
	static Matrix_GetUnitAxes(M: Matrix,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static Matrix_GetTransposed(M: Matrix): Matrix;
	static Matrix_GetTransposeAdjoint(M: Matrix): Matrix;
	static Matrix_GetScaleVector(M: Matrix,Tolerance: number): Vector;
	static Matrix_GetScaledAxis(M: Matrix,Axis: EAxis): Vector;
	static Matrix_GetScaledAxes(M: Matrix,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static Matrix_GetRotDeterminant(M: Matrix): number;
	static Matrix_GetRotator(M: Matrix): Rotator;
	static Matrix_GetOrigin(InMatrix: Matrix): Vector;
	static Matrix_GetMaximumAxisScale(M: Matrix): number;
	static Matrix_GetMatrixWithoutScale(M: Matrix,Tolerance: number): Matrix;
	static Matrix_GetInverse(M: Matrix): Matrix;
	static Matrix_GetFrustumTopPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumRightPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumNearPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumLeftPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumFarPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumBottomPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetDeterminant(M: Matrix): number;
	static Matrix_GetColumn(M: Matrix,Column: EMatrixColumns): Vector;
	static Matrix_ContainsNaN(M: Matrix): boolean;
	static Matrix_ConcatenateTranslation(M: Matrix,Translation: Vector): Matrix;
	static Matrix_ApplyScale(M: Matrix,Scale: number): Matrix;
	static MapRangeUnclamped(Value: number,InRangeA: number,InRangeB: number,OutRangeA: number,OutRangeB: number): number;
	static MapRangeClamped(Value: number,InRangeA: number,InRangeB: number,OutRangeA: number,OutRangeB: number): number;
	static MakeVector_NetQuantizeNormal(X: number,Y: number,Z: number): Vector_NetQuantizeNormal;
	static MakeVector_NetQuantize100(X: number,Y: number,Z: number): Vector_NetQuantize100;
	static MakeVector_NetQuantize10(X: number,Y: number,Z: number): Vector_NetQuantize10;
	static MakeVector_NetQuantize(X: number,Y: number,Z: number): Vector_NetQuantize;
	static MakeVector4(X: number,Y: number,Z: number,W: number): Vector4;
	static MakeVector2D(X: number,Y: number): Vector2D;
	static MakeVector(X: number,Y: number,Z: number): Vector;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MakeTimespan2(Days: number,Hours: number,Minutes: number,Seconds: number,FractionNano: number): Timespan;
	static MakeTimespan(Days: number,Hours: number,Minutes: number,Seconds: number,Milliseconds: number): Timespan;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRelativeTransform(A: Transform,RelativeTo: Transform): Transform;
	static MakeRandomStream(InitialSeed: number): RandomStream;
	static MakeQuat(X: number,Y: number,Z: number,W: number): Quat;
	static MakeQualifiedFrameTime(Frame: FrameNumber,FrameRate: FrameRate,SubFrame: number): QualifiedFrameTime;
	static MakePulsatingValue(InCurrentTime: number,InPulsesPerSecond: number,InPhase: number): number;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeFrameRate(Numerator: number,Denominator: number): FrameRate;
	static MakeDateTime(Year: number,Month: number,Day: number,Hour: number,Minute: number,Second: number,Millisecond: number): DateTime;
	static MakeColor(R: number,G: number,B: number,A: number): LinearColor;
	static MakeBoxSphereBounds(Origin: Vector,BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static MakeBox(Min: Vector,Max: Vector): Box;
	static Loge(A: number): number;
	static Log(A: number,Base: number): number;
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinearColorLerpUsingHSV(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static LinearColorLerp(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static LinearColor_Yellow(): LinearColor;
	static LinearColor_White(): LinearColor;
	static LinearColor_Transparent(): LinearColor;
	static LinearColor_ToRGBE(InLinearColor: LinearColor): Color;
	static LinearColor_ToNewOpacity(InColor: LinearColor,InOpacity: number): LinearColor;
	static LinearColor_SetTemperature(InOutColor?: LinearColor,InTemperature?: number): {InOutColor: LinearColor};
	static LinearColor_SetRGBA(InOutColor?: LinearColor,R?: number,G?: number,B?: number,A?: number): {InOutColor: LinearColor};
	static LinearColor_SetRandomHue(InOutColor?: LinearColor): {InOutColor: LinearColor};
	static LinearColor_SetFromSRGB(InOutColor?: LinearColor,InSRGB?: Color): {InOutColor: LinearColor};
	static LinearColor_SetFromPow22(InOutColor?: LinearColor,InColor?: Color): {InOutColor: LinearColor};
	static LinearColor_SetFromHSV(InOutColor?: LinearColor,H?: number,S?: number,V?: number,A?: number): {InOutColor: LinearColor};
	static LinearColor_Set(InOutColor?: LinearColor,InColor?: LinearColor): {InOutColor: LinearColor};
	static LinearColor_Red(): LinearColor;
	static LinearColor_QuantizeRound(InColor: LinearColor): Color;
	static LinearColor_Quantize(InColor: LinearColor): Color;
	static LinearColor_IsNearEqual(A: LinearColor,B: LinearColor,Tolerance: number): boolean;
	static LinearColor_Green(): LinearColor;
	static LinearColor_Gray(): LinearColor;
	static LinearColor_GetMin(InColor: LinearColor): number;
	static LinearColor_GetMax(InColor: LinearColor): number;
	static LinearColor_GetLuminance(InColor: LinearColor): number;
	static LinearColor_Distance(C1: LinearColor,C2: LinearColor): number;
	static LinearColor_Desaturated(InColor: LinearColor,InDesaturation: number): LinearColor;
	static LinearColor_Blue(): LinearColor;
	static LinearColor_Black(): LinearColor;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LessEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static LessEqual_IntInt(A: number,B: number): boolean;
	static LessEqual_Int64Int64(A: number,B: number): boolean;
	static LessEqual_DoubleDouble(A: number,B: number): boolean;
	static LessEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static LessEqual_ByteByte(A: number,B: number): boolean;
	static Less_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static Less_IntInt(A: number,B: number): boolean;
	static Less_Int64Int64(A: number,B: number): boolean;
	static Less_DoubleDouble(A: number,B: number): boolean;
	static Less_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static Less_ByteByte(A: number,B: number): boolean;
	static Lerp(A: number,B: number,Alpha: number): number;
	static IsZero2D(A: Vector2D): boolean;
	static IsPointInBoxWithTransform_Box(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Box): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static IsPointInBox_Box(Point: Vector,Box: Box): boolean;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsNearlyZero2D(A: Vector2D,Tolerance: number): boolean;
	static IsMorning(A: DateTime): boolean;
	static IsLeapYear(Year: number): boolean;
	static IsAfternoon(A: DateTime): boolean;
	static InvertTransform(T: Transform): Transform;
	static InverseTransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	static IntPoint_Zero(): IntPoint;
	static IntPoint_Up(): IntPoint;
	static IntPoint_Right(): IntPoint;
	static IntPoint_One(): IntPoint;
	static IntPoint_Left(): IntPoint;
	static IntPoint_Down(): IntPoint;
	static InRange_IntInt(Value: number,Min: number,Max: number,InclusiveMin: boolean,InclusiveMax: boolean): boolean;
	static InRange_Int64Int64(Value: number,Min: number,Max: number,InclusiveMin: boolean,InclusiveMax: boolean): boolean;
	static InRange_FloatFloat(Value: number,Min: number,Max: number,InclusiveMin: boolean,InclusiveMax: boolean): boolean;
	static Hypotenuse(Width: number,Height: number): number;
	static HSVToRGBLinear(HSV: LinearColor): LinearColor;
	static HSVToRGB_Vector(HSV: LinearColor,rgb?: LinearColor): {rgb: LinearColor};
	static HSVToRGB(H: number,S: number,V: number,A: number): LinearColor;
	static GridSnap_Float(Location: number,GridSize: number): number;
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static GreaterEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static GreaterEqual_IntInt(A: number,B: number): boolean;
	static GreaterEqual_Int64Int64(A: number,B: number): boolean;
	static GreaterEqual_DoubleDouble(A: number,B: number): boolean;
	static GreaterEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GreaterEqual_ByteByte(A: number,B: number): boolean;
	static Greater_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static Greater_IntInt(A: number,B: number): boolean;
	static Greater_Int64Int64(A: number,B: number): boolean;
	static Greater_DoubleDouble(A: number,B: number): boolean;
	static Greater_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static Greater_ByteByte(A: number,B: number): boolean;
	static GetYear(A: DateTime): number;
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static GetUpVector(InRot: Rotator): Vector;
	static GetTotalSeconds(A: Timespan): number;
	static GetTotalMinutes(A: Timespan): number;
	static GetTotalMilliseconds(A: Timespan): number;
	static GetTotalHours(A: Timespan): number;
	static GetTotalDays(A: Timespan): number;
	static GetTimeOfDay(A: DateTime): Timespan;
	static GetTAU(): number;
	static GetSlopeDegreeAngles(MyRightYAxis: Vector,FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	static GetSeconds(A: Timespan): number;
	static GetSecond(A: DateTime): number;
	static GetRotated2D(A: Vector2D,AngleDeg: number): Vector2D;
	static GetRightVector(InRot: Rotator): Vector;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPI(): number;
	static GetMonth(A: DateTime): number;
	static GetMinutes(A: Timespan): number;
	static GetMinute(A: DateTime): number;
	static GetMinElement(A: Vector): number;
	static GetMin2D(A: Vector2D): number;
	static GetMilliseconds(A: Timespan): number;
	static GetMillisecond(A: DateTime): number;
	static GetMaxElement(A: Vector): number;
	static GetMax2D(A: Vector2D): number;
	static GetHours(A: Timespan): number;
	static GetHour12(A: DateTime): number;
	static GetHour(A: DateTime): number;
	static GetForwardVector(InRot: Rotator): Vector;
	static GetDuration(A: Timespan): Timespan;
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetDays(A: Timespan): number;
	static GetDayOfYear(A: DateTime): number;
	static GetDay(A: DateTime): number;
	static GetDate(A: DateTime): DateTime;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static GetAbsMax2D(A: Vector2D): number;
	static GetAbs2D(A: Vector2D): Vector2D;
	static FWrap(Value: number,Min: number,Max: number): number;
	static FTruncVector(InVector: Vector): IntVector;
	static FTrunc64(A: number): number;
	static FTrunc(A: number): number;
	static FromSeconds(Seconds: number): Timespan;
	static FromMinutes(Minutes: number): Timespan;
	static FromMilliseconds(Milliseconds: number): Timespan;
	static FromHours(Hours: number): Timespan;
	static FromDays(Days: number): Timespan;
	static Fraction(A: number): number;
	static FMod64(Dividend: number,Divisor: number,Remainder?: number): {Remainder: number, $: number};
	static FMod(Dividend: number,Divisor: number,Remainder?: number): {Remainder: number, $: number};
	static FMin(A: number,B: number): number;
	static FMax(A: number,B: number): number;
	static FloatSpringInterp(Current: number,Target: number,SpringState?: FloatSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: number,MaxValue?: number,bInitializeFromTarget?: boolean): {SpringState: FloatSpringState, $: number};
	static FixedTurn(InCurrent: number,InDesired: number,InDeltaRate: number): number;
	static FInterpTo_Constant(Current: number,Target: number,DeltaTime: number,InterpSpeed: number): number;
	static FInterpTo(Current: number,Target: number,DeltaTime: number,InterpSpeed: number): number;
	static FInterpEaseInOut(A: number,B: number,Alpha: number,Exponent: number): number;
	static FindRelativeLookAtRotation(StartTransform: Transform,TargetLocation: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FFloor64(A: number): number;
	static FFloor(A: number): number;
	static FClamp(Value: number,Min: number,Max: number): number;
	static FCeil64(A: number): number;
	static FCeil(A: number): number;
	static Exp(A: number): number;
	static EqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static EqualExactly_Vector4Vector4(A: Vector4,B: Vector4): boolean;
	static EqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static EqualEqual_Vector4Vector4(A: Vector4,B: Vector4,ErrorTolerance: number): boolean;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static EqualEqual_TransformTransform(A: Transform,B: Transform): boolean;
	static EqualEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static EqualEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static EqualEqual_QuatQuat(A: Quat,B: Quat,Tolerance: number): boolean;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static EqualEqual_NameName(A: string,B: string): boolean;
	static EqualEqual_MatrixMatrix(A: Matrix,B: Matrix,Tolerance: number): boolean;
	static EqualEqual_LinearColorLinearColor(A: LinearColor,B: LinearColor): boolean;
	static EqualEqual_IntInt(A: number,B: number): boolean;
	static EqualEqual_Int64Int64(A: number,B: number): boolean;
	static EqualEqual_DoubleDouble(A: number,B: number): boolean;
	static EqualEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static EqualEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static EqualEqual_ByteByte(A: number,B: number): boolean;
	static EqualEqual_BoolBool(A: boolean,B: boolean): boolean;
	static Equal_IntPointIntPoint(A: IntPoint,B: IntPoint): boolean;
	static Ease(A: number,B: number,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): number;
	static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	static DynamicWeightedMovingAverage_Float(CurrentSample: number,PreviousSample: number,MaxDistance: number,MinWeight: number,MaxWeight: number): number;
	static DotProduct2D(A: Vector2D,B: Vector2D): number;
	static Dot_VectorVector(A: Vector,B: Vector): number;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorFloat(A: Vector,B: number): Vector;
	static Divide_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Divide_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Divide_TimespanFloat(A: Timespan,Scalar: number): Timespan;
	static Divide_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static Divide_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Divide_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Divide_IntInt(A: number,B: number): number;
	static Divide_Int64Int64(A: number,B: number): number;
	static Divide_DoubleDouble(A: number,B: number): number;
	static Divide_ByteByte(A: number,B: number): number;
	static DistanceSquared2D(v1: Vector2D,v2: Vector2D): number;
	static Distance2D(v1: Vector2D,v2: Vector2D): number;
	static DegTan(A: number): number;
	static DegSin(A: number): number;
	static DegreesToRadians(A: number): number;
	static DegCos(A: number): number;
	static DegAtan2(Y: number,X: number): number;
	static DegAtan(A: number): number;
	static DegAsin(A: number): number;
	static DegAcos(A: number): number;
	static DaysInYear(Year: number): number;
	static DaysInMonth(Year: number,Month: number): number;
	static DateTimeMinValue(): DateTime;
	static DateTimeMaxValue(): DateTime;
	static DateTimeFromString(DateTimeString: string,Result?: DateTime): {Result: DateTime, $: boolean};
	static DateTimeFromIsoString(IsoString: string,Result?: DateTime): {Result: DateTime, $: boolean};
	static CrossProduct2D(A: Vector2D,B: Vector2D): number;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static Cos(A: number): number;
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToQuaternion(InVec: Vector): Quat;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_Vector4ToVector(InVector4: Vector4): Vector;
	static Conv_Vector4ToRotator(InVec: Vector4): Rotator;
	static Conv_Vector4ToQuaternion(InVec: Vector4): Quat;
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
	static Conv_TransformToMatrix(Transform: Transform): Matrix;
	static Conv_RotatorToVector(InRot: Rotator): Vector;
	static Conv_RotatorToTransform(InRotator: Rotator): Transform;
	static Conv_RotatorToQuaternion(InRot: Rotator): Quat;
	static Conv_MatrixToTransform(InMatrix: Matrix): Transform;
	static Conv_MatrixToRotator(InMatrix: Matrix): Rotator;
	static Conv_LinearColorToVector(InLinearColor: LinearColor): Vector;
	static Conv_LinearColorToColor(InLinearColor: LinearColor,InUseSRGB: boolean): Color;
	static Conv_IntVectorToVector(InIntVector: IntVector): Vector;
	static Conv_IntToVector(inInt: number): Vector;
	static Conv_IntToIntVector(inInt: number): IntVector;
	static Conv_IntToInt64(inInt: number): number;
	static Conv_IntToFloat(inInt: number): number;
	static Conv_IntToDouble(inInt: number): number;
	static Conv_IntToByte(inInt: number): number;
	static Conv_IntToBool(inInt: number): boolean;
	static Conv_IntPointToVector2D(InIntPoint: IntPoint): Vector2D;
	static Conv_Int64ToInt(inInt: number): number;
	static Conv_Int64ToDouble(inInt: number): number;
	static Conv_Int64ToByte(inInt: number): number;
	static Conv_FloatToVector(InFloat: number): Vector;
	static Conv_FloatToLinearColor(InFloat: number): LinearColor;
	static Conv_FloatToDouble(InFloat: number): number;
	static Conv_DoubleToVector(InDouble: number): Vector;
	static Conv_DoubleToLinearColor(InDouble: number): LinearColor;
	static Conv_DoubleToInt64(InDouble: number): number;
	static Conv_DoubleToFloat(InDouble: number): number;
	static Conv_ColorToLinearColor(InColor: Color): LinearColor;
	static Conv_ByteToInt64(InByte: number): number;
	static Conv_ByteToInt(InByte: number): number;
	static Conv_ByteToFloat(InByte: number): number;
	static Conv_ByteToDouble(InByte: number): number;
	static Conv_BoolToInt(InBool: boolean): number;
	static Conv_BoolToFloat(InBool: boolean): number;
	static Conv_BoolToByte(InBool: boolean): number;
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	static ComposeRotators(A: Rotator,B: Rotator): Rotator;
	static ClassIsChildOf(TestClass: UnrealEngineClass,ParentClass: UnrealEngineClass): boolean;
	static ClampVectorSize(A: Vector,Min: number,Max: number): Vector;
	static ClampInt64(Value: number,Min: number,Max: number): number;
	static ClampAxis(Angle: number): number;
	static ClampAxes2D(A: Vector2D,MinAxisVal: number,MaxAxisVal: number): Vector2D;
	static ClampAngle(AngleDegrees: number,MinAngleDegrees: number,MaxAngleDegrees: number): number;
	static Clamp(Value: number,Min: number,Max: number): number;
	static CInterpTo(Current: LinearColor,Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	static BreakVector_NetQuantizeNormal(InVec: Vector_NetQuantizeNormal,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector_NetQuantize100(InVec: Vector_NetQuantize100,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector_NetQuantize10(InVec: Vector_NetQuantize10,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector_NetQuantize(InVec: Vector_NetQuantize,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector4(InVec: Vector4,X?: number,Y?: number,Z?: number,W?: number): {X: number, Y: number, Z: number, W: number};
	static BreakVector3f(InVec: Vector3f,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector2D(InVec: Vector2D,X?: number,Y?: number): {X: number, Y: number};
	static BreakVector(InVec: Vector,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	static BreakTimespan2(InTimespan: Timespan,Days?: number,Hours?: number,Minutes?: number,Seconds?: number,FractionNano?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number};
	static BreakTimespan(InTimespan: Timespan,Days?: number,Hours?: number,Minutes?: number,Seconds?: number,Milliseconds?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number};
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	static BreakRandomStream(InRandomStream: RandomStream,InitialSeed?: number): {InitialSeed: number};
	static BreakQuat(InQuat: Quat,X?: number,Y?: number,Z?: number,W?: number): {X: number, Y: number, Z: number, W: number};
	static BreakQualifiedFrameTime(InFrameTime: QualifiedFrameTime,Frame?: FrameNumber,FrameRate?: FrameRate,SubFrame?: number): {Frame: FrameNumber, FrameRate: FrameRate, SubFrame: number};
	static BreakFrameRate(InFrameRate: FrameRate,Numerator?: number,Denominator?: number): {Numerator: number, Denominator: number};
	static BreakDateTime(InDateTime: DateTime,Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	static BreakColor(InColor: LinearColor,R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	static BreakBoxSphereBounds(InBoxSphereBounds: BoxSphereBounds,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static BooleanXOR(A: boolean,B: boolean): boolean;
	static BooleanOR(A: boolean,B: boolean): boolean;
	static BooleanNOR(A: boolean,B: boolean): boolean;
	static BooleanNAND(A: boolean,B: boolean): boolean;
	static BooleanAND(A: boolean,B: boolean): boolean;
	static BMin(A: number,B: number): number;
	static BMax(A: number,B: number): number;
	static AverageOfIntArray(IntArray: number[],AverageValue?: number): {AverageValue: number};
	static Atan2(Y: number,X: number): number;
	static Atan(A: number): number;
	static Asin(A: number): number;
	static And_IntInt(A: number,B: number): number;
	static And_Int64Int64(A: number,B: number): number;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorFloat(A: Vector,B: number): Vector;
	static Add_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Add_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Add_TimespanTimespan(A: Timespan,B: Timespan): Timespan;
	static Add_QuatQuat(A: Quat,B: Quat): Quat;
	static Add_MatrixMatrix(A: Matrix,B: Matrix): Matrix;
	static Add_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static Add_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Add_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Add_IntInt(A: number,B: number): number;
	static Add_Int64Int64(A: number,B: number): number;
	static Add_DoubleDouble(A: number,B: number): number;
	static Add_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static Add_DateTimeDateTime(A: DateTime,B: DateTime): DateTime;
	static Add_ByteByte(A: number,B: number): number;
	static Acos(A: number): number;
	static Abs_Int64(A: number): number;
	static Abs_Int(A: number): number;
	static Abs(A: number): number;
	static C(Other: UObject | any): KismetMathLibrary;
}

declare class KismetNodeHelperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetNodeHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetNodeHelperLibrary;
	static GetDefaultObject(): KismetNodeHelperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetNodeHelperLibrary;
	static MarkBit(Data?: number,Index?: number): {Data: number};
	static HasUnmarkedBit(Data: number,NumBits: number): boolean;
	static HasMarkedBit(Data: number,NumBits: number): boolean;
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
	static GetUnmarkedBit(Data: number,StartIdx: number,NumBits: number,bRandom: boolean): number;
	static GetRandomUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	static GetFirstUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	static ClearBit(Data?: number,Index?: number): {Data: number};
	static ClearAllBits(Data?: number): {Data: number};
	static BitIsMarked(Data: number,Index: number): boolean;
	static C(Other: UObject | any): KismetNodeHelperLibrary;
}

declare class KismetRenderingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetRenderingLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetRenderingLibrary;
	static GetDefaultObject(): KismetRenderingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetRenderingLibrary;
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static ResizeRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D,Width: number,Height: number): void;
	static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
	static ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): void;
	static ReadRenderTargetUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	static ReadRenderTargetRawUVArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawPixelArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRaw(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	static ReadRenderTargetPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	static ReadRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	static MakeSkinWeightInfo(Bone0: number,Weight0: number,Bone1: number,Weight1: number,Bone2: number,Weight2: number,Bone3: number,Weight3: number): SkelMeshSkinWeightInfo;
	static ImportFileAsTexture2D(WorldContextObject: UObject,Filename: string): Texture2D;
	static ImportBufferAsTexture2D(WorldContextObject: UObject,Buffer: number[]): Texture2D;
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,Filename: string): void;
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	static CreateRenderTargetVolume(WorldContextObject: UObject,Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	static CreateRenderTarget2DArray(WorldContextObject: UObject,Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: UObject,RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	static CalculateProjectionMatrix(MinimalViewInfo: MinimalViewInfo): Matrix;
	static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo,Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static C(Other: UObject | any): KismetRenderingLibrary;
}

declare type ESearchCase = 'CaseSensitive' | 'IgnoreCase' | 'ESearchCase_MAX';
declare var ESearchCase : { CaseSensitive:'CaseSensitive',IgnoreCase:'IgnoreCase',ESearchCase_MAX:'ESearchCase_MAX', };
declare type ESearchDir = 'FromStart' | 'FromEnd' | 'ESearchDir_MAX';
declare var ESearchDir : { FromStart:'FromStart',FromEnd:'FromEnd',ESearchDir_MAX:'ESearchDir_MAX', };
declare class KismetStringLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetStringLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetStringLibrary;
	static GetDefaultObject(): KismetStringLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetStringLibrary;
	static TrimTrailing(SourceString: string): string;
	static Trim(SourceString: string): string;
	static ToUpper(SourceString: string): string;
	static ToLower(SourceString: string): string;
	static TimeSecondsToString(InSeconds: number): string;
	static StartsWith(SourceString: string,InPrefix: string,SearchCase: ESearchCase): boolean;
	static Split(SourceString: string,InStr: string,LeftS?: string,RightS?: string,SearchCase?: ESearchCase,SearchDir?: ESearchDir): {LeftS: string, RightS: string, $: boolean};
	static RightPad(SourceString: string,ChCount: number): string;
	static RightChop(SourceString: string,Count: number): string;
	static Right(SourceString: string,Count: number): string;
	static Reverse(SourceString: string): string;
	static ReplaceInline(SourceString?: string,SearchText?: string,ReplacementText?: string,SearchCase?: ESearchCase): {SourceString: string, $: number};
	static Replace(SourceString: string,From: string,To: string,SearchCase: ESearchCase): string;
	static ParseIntoArray(SourceString: string,Delimiter: string,CullEmptyStrings: boolean): string[];
	static NotEqual_StrStr(A: string,B: string): boolean;
	static NotEqual_StriStri(A: string,B: string): boolean;
	static Mid(SourceString: string,Start: number,Count: number): string;
	static MatchesWildcard(SourceString: string,wildcard: string,SearchCase: ESearchCase): boolean;
	static Len(S: string): number;
	static LeftPad(SourceString: string,ChCount: number): string;
	static LeftChop(SourceString: string,Count: number): string;
	static Left(SourceString: string,Count: number): string;
	static JoinStringArray(SourceArray: string[],Separator: string): string;
	static IsNumeric(SourceString: string): boolean;
	static IsEmpty(InString: string): boolean;
	static GetSubstring(SourceString: string,StartIndex: number,Length: number): string;
	static GetCharacterAsNumber(SourceString: string,Index: number): number;
	static GetCharacterArrayFromString(SourceString: string): string[];
	static FindSubstring(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean,StartPosition: number): number;
	static EqualEqual_StrStr(A: string,B: string): boolean;
	static EqualEqual_StriStri(A: string,B: string): boolean;
	static EndsWith(SourceString: string,InSuffix: string,SearchCase: ESearchCase): boolean;
	static CullArray(SourceString: string,inArray?: string[]): {inArray: string[], $: number};
	static Conv_VectorToString(InVec: Vector): string;
	static Conv_Vector3fToString(InVec: Vector3f): string;
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Conv_TransformToString(InTrans: Transform): string;
	static Conv_StringToVector3f(InString: string,OutConvertedVector?: Vector3f,OutIsValid?: boolean): {OutConvertedVector: Vector3f, OutIsValid: boolean};
	static Conv_StringToVector2D(InString: string,OutConvertedVector2D?: Vector2D,OutIsValid?: boolean): {OutConvertedVector2D: Vector2D, OutIsValid: boolean};
	static Conv_StringToVector(InString: string,OutConvertedVector?: Vector,OutIsValid?: boolean): {OutConvertedVector: Vector, OutIsValid: boolean};
	static Conv_StringToRotator(InString: string,OutConvertedRotator?: Rotator,OutIsValid?: boolean): {OutConvertedRotator: Rotator, OutIsValid: boolean};
	static Conv_StringToName(InString: string): string;
	static Conv_StringToInt64(InString: string): number;
	static Conv_StringToInt(InString: string): number;
	static Conv_StringToDouble(InString: string): number;
	static Conv_StringToColor(InString: string,OutConvertedColor?: LinearColor,OutIsValid?: boolean): {OutConvertedColor: LinearColor, OutIsValid: boolean};
	static Conv_RotatorToString(InRot: Rotator): string;
	static Conv_PlatformUserIdToString(InPlatformUserId: PlatformUserId): string;
	static Conv_ObjectToString(InObj: UObject): string;
	static Conv_NameToString(InName: string): string;
	static Conv_MatrixToString(InMatrix: Matrix): string;
	static Conv_IntVectorToString(InIntVec: IntVector): string;
	static Conv_IntToString(inInt: number): string;
	static Conv_IntPointToString(InIntPoint: IntPoint): string;
	static Conv_Int64ToString(inInt: number): string;
	static Conv_InputDeviceIdToString(InDeviceId: InputDeviceId): string;
	static Conv_DoubleToString(InDouble: number): string;
	static Conv_ColorToString(InColor: LinearColor): string;
	static Conv_ByteToString(InByte: number): string;
	static Conv_BoolToString(InBool: boolean): string;
	static Contains(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean): boolean;
	static Concat_StrStr(A: string,B: string): string;
	static BuildString_Vector2d(AppendTo: string,Prefix: string,InVector2D: Vector2D,Suffix: string): string;
	static BuildString_Vector(AppendTo: string,Prefix: string,InVector: Vector,Suffix: string): string;
	static BuildString_Rotator(AppendTo: string,Prefix: string,InRot: Rotator,Suffix: string): string;
	static BuildString_Object(AppendTo: string,Prefix: string,InObj: UObject,Suffix: string): string;
	static BuildString_Name(AppendTo: string,Prefix: string,InName: string,Suffix: string): string;
	static BuildString_IntVector(AppendTo: string,Prefix: string,InIntVector: IntVector,Suffix: string): string;
	static BuildString_Int(AppendTo: string,Prefix: string,inInt: number,Suffix: string): string;
	static BuildString_Double(AppendTo: string,Prefix: string,InDouble: number,Suffix: string): string;
	static BuildString_Color(AppendTo: string,Prefix: string,InColor: LinearColor,Suffix: string): string;
	static BuildString_Bool(AppendTo: string,Prefix: string,InBool: boolean,Suffix: string): string;
	static C(Other: UObject | any): KismetStringLibrary;
}

declare class KismetStringTableLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetStringTableLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetStringTableLibrary;
	static GetDefaultObject(): KismetStringTableLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetStringTableLibrary;
	static IsRegisteredTableId(TableId: string): boolean;
	static IsRegisteredTableEntry(TableId: string,Key: string): boolean;
	static GetTableNamespace(TableId: string): string;
	static GetTableEntrySourceString(TableId: string,Key: string): string;
	static GetTableEntryMetaData(TableId: string,Key: string,MetaDataId: string): string;
	static GetRegisteredStringTables(): string[];
	static GetMetaDataIdsFromStringTableEntry(TableId: string,Key: string): string[];
	static GetKeysFromStringTable(TableId: string): string[];
	static C(Other: UObject | any): KismetStringTableLibrary;
}

declare class UserActivity { 
	ActionName: string;
	clone() : UserActivity;
	static C(Other: UObject | any): UserActivity;
	SetUserActivity(): void;
	static SetUserActivity(UserActivity: UserActivity): void;
}

declare class KismetSystemLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetSystemLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetSystemLibrary;
	static GetDefaultObject(): KismetSystemLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetSystemLibrary;
	static UnregisterForRemoteNotifications(): void;
	static UnloadPrimaryAssetList(PrimaryAssetIdList: PrimaryAssetId[]): void;
	static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;
	static TransactObject(UObject: UObject): void;
	static StackTrace(): void;
	static SphereTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereOverlapComponents(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SphereOverlapActors(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static SnapshotObject(UObject: UObject): void;
	static ShowPlatformSpecificLeaderboardScreen(CategoryName: string): void;
	static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
	static ShowInterstitialAd(): void;
	static ShowAdBanner(AdIdIndex: number,bShowOnBottomOfScreen: boolean): void;
	static SetWindowTitle(Title: string): void;
	static SetVolumeButtonsHandledBySystem(bEnabled: boolean): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetUserActivity(UserActivity: UserActivity): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetSuppressViewportTransitionMessage(WorldContextObject: UObject,bState: boolean): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetGamepadsBlockDeviceFeedback(bBlock: boolean): void;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static RetriggerableDelay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static ResetGamepadAssignmentToController(ControllerId: number): void;
	static ResetGamepadAssignments(): void;
	static RegisterForRemoteNotifications(): void;
	static QuitGame(WorldContextObject: UObject,SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	static QuitEditor(): void;
	static PrintWarning(InString: string): void;
	static PrintText(WorldContextObject: UObject,InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static PrintString(WorldContextObject: UObject,InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static ParseParamValue(InString: string,InParam: string,OutValue?: string): {OutValue: string, $: boolean};
	static ParseParam(InString: string,InParam: string): boolean;
	static ParseCommandLine(InCmdLine: string,OutTokens?: string[],OutSwitches?: string[],OutParams?: Map<string, string>): {OutTokens: string[], OutSwitches: string[], OutParams: Map<string, string>};
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static NotEqual_SoftClassReference(A: Class,B: Class): boolean;
	static NotEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static NotEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static NormalizeFilename(InFilename: string): string;
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static MakeSoftObjectPath(PathString: string): SoftObjectPath;
	static MakeSoftClassPath(PathString: string): SoftClassPath;
	static MakeLiteralText(Value: string): string;
	static MakeLiteralString(Value: string): string;
	static MakeLiteralName(Value: string): string;
	static MakeLiteralInt64(Value: number): number;
	static MakeLiteralInt(Value: number): number;
	static MakeLiteralDouble(Value: number): number;
	static MakeLiteralByte(Value: number): number;
	static MakeLiteralBool(Value: boolean): boolean;
	static MakeARFilter(PackageNames: string[],PackagePaths: string[],SoftObjectPaths: SoftObjectPath[],ClassPaths: TopLevelAssetPath[],RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>,ClassNames: string[],RecursiveClassesExclusionSet: Set<string>,bRecursivePaths: boolean,bRecursiveClasses: boolean,bIncludeOnlyOnDiskAssets: boolean): ARFilter;
	static LogString(InString: string,bPrintToLog: boolean): void;
	static LoadInterstitialAd(AdIdIndex: number): void;
	static LoadClassAsset_Blocking(AssetClass: Class): UnrealEngineClass;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static LineTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LaunchURL(URL: string): void;
	static K2_UnPauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_TimerExistsHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_PauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_IsValidTimerHandle(Handle: TimerHandle): boolean;
	static K2_IsTimerPausedHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerActiveHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_InvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle, $: TimerHandle};
	static K2_GetTimerRemainingTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerElapsedTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_ClearTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_ClearAndInvalidateTimerHandle(WorldContextObject: UObject,Handle?: TimerHandle): {Handle: TimerHandle};
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static IsValidSoftClassReference(SoftClassReference: Class): boolean;
	static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;
	static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;
	static IsValidClass(Class: UnrealEngineClass): boolean;
	static IsValid(UObject: UObject): boolean;
	static IsUnattended(): boolean;
	static IsStandalone(WorldContextObject: UObject): boolean;
	static IsSplitScreen(WorldContextObject: UObject): boolean;
	static IsServer(WorldContextObject: UObject): boolean;
	static IsScreensaverEnabled(): boolean;
	static IsPackagedForDistribution(): boolean;
	static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
	static IsInterstitialAdRequested(): boolean;
	static IsInterstitialAdAvailable(): boolean;
	static IsDedicatedServer(WorldContextObject: UObject): boolean;
	static IsControllerAssignedToGamepad(ControllerId: number): boolean;
	static HideAdBanner(): void;
	static HasMultipleLocalPlayers(WorldContextObject: UObject): boolean;
	static GetVolumeButtonsHandledBySystem(): boolean;
	static GetUniqueDeviceId(): string;
	static GetSystemPath(UObject: UObject): string;
	static GetSupportedFullscreenResolutions(Resolutions?: IntPoint[]): {Resolutions: IntPoint[], $: boolean};
	static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetSoftObjectPath(UObject: UObject): SoftObjectPath;
	static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Class;
	static GetSoftClassPath(Class: UnrealEngineClass): SoftClassPath;
	static GetRenderingMaterialQualityLevel(): number;
	static GetRenderingDetailMode(): number;
	static GetProjectSavedDirectory(): string;
	static GetProjectDirectory(): string;
	static GetProjectContentDirectory(): string;
	static GetPrimaryAssetsWithBundleState(RequiredBundles: string[],ExcludedBundles: string[],ValidTypes: PrimaryAssetType[],bForceCurrentState: boolean,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: Class): PrimaryAssetId;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromClass(Class: UnrealEngineClass): PrimaryAssetId;
	static GetPreferredLanguages(): string[];
	static GetPlatformUserName(): string;
	static GetPlatformUserDir(): string;
	static GetPathName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetObjectName(UObject: UObject): string;
	static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetMinYResolutionForUI(): number;
	static GetMinYResolutionFor3DView(): number;
	static GetLocalCurrencySymbol(): string;
	static GetLocalCurrencyCode(): string;
	static GetGameTimeInSeconds(WorldContextObject: UObject): number;
	static GetGamepadControllerName(ControllerId: number): string;
	static GetGamepadButtonGlyph(ButtonKey: string,ControllerIndex: number): Texture2D;
	static GetGameName(): string;
	static GetGameBundleId(): string;
	static GetFrameCount(): number;
	static GetEngineVersion(): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetDisplayName(UObject: UObject): string;
	static GetDeviceId(): string;
	static GetDefaultLocale(): string;
	static GetDefaultLanguage(): string;
	static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId,bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	static GetConvenientWindowedResolutions(Resolutions?: IntPoint[]): {Resolutions: IntPoint[], $: boolean};
	static GetConsoleVariableIntValue(VariableName: string): number;
	static GetConsoleVariableFloatValue(VariableName: string): number;
	static GetConsoleVariableBoolValue(VariableName: string): boolean;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static GetCommandLine(): string;
	static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UnrealEngineClass;
	static GetClassDisplayName(Class: UnrealEngineClass): string;
	static GetBuildVersion(): string;
	static GetBuildConfiguration(): string;
	static GetAdIDCount(): number;
	static GetActorListFromComponentList(ComponentList: PrimitiveComponent[],ActorClassFilter: UnrealEngineClass,OutActorList?: Actor[]): {OutActorList: Actor[]};
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ForceCloseAdBanner(): void;
	static FlushPersistentDebugLines(WorldContextObject: UObject): void;
	static FlushDebugStrings(WorldContextObject: UObject): void;
	static ExecuteConsoleCommand(WorldContextObject: UObject,Command: string,SpecificPlayer: PlayerController): void;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static EqualEqual_SoftClassReference(A: Class,B: Class): boolean;
	static EqualEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static EqualEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static EndTransaction(): number;
	static DrawDebugString(WorldContextObject: UObject,TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	static DrawDebugSphere(WorldContextObject: UObject,Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugPoint(WorldContextObject: UObject,Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	static DrawDebugPlane(WorldContextObject: UObject,PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	static DrawDebugLine(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFrustum(WorldContextObject: UObject,FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFloatHistoryTransform(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFloatHistoryLocation(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugCylinder(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCoordinateSystem(WorldContextObject: UObject,AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	static DrawDebugConeInDegrees(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCone(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCircle(WorldContextObject: UObject,Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	static DrawDebugCapsule(WorldContextObject: UObject,Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCamera(CameraActor: CameraActor,CameraColor: LinearColor,Duration: number): void;
	static DrawDebugBox(WorldContextObject: UObject,Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	static DrawDebugArrow(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static DelayUntilNextTick(WorldContextObject: UObject,LatentInfo: LatentActionInfo): void;
	static Delay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static ConvertToRelativePath(Filename: string): string;
	static ConvertToAbsolutePath(Filename: string): string;
	static Conv_SoftObjRefToSoftObjPath(SoftObjectReference: UObject): SoftObjectPath;
	static Conv_SoftObjRefToSoftClassPath(SoftClassReference: Class): SoftClassPath;
	static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftClassReferenceToString(SoftClassReference: Class): string;
	static Conv_SoftClassReferenceToClass(softclass: Class): UnrealEngineClass;
	static Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath): Class;
	static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;
	static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ClassToSoftClassReference(Class: UnrealEngineClass): Class;
	static ControlScreensaver(bAllowScreenSaver: boolean): void;
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CollectGarbage(): void;
	static CapsuleTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleOverlapComponents(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static CapsuleOverlapActors(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CanLaunchURL(URL: string): boolean;
	static CancelTransaction(Index: number): void;
	static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath,PathString?: string): {PathString: string};
	static BreakSoftClassPath(InSoftClassPath: SoftClassPath,PathString?: string): {PathString: string};
	static BreakARFilter(InARFilter: ARFilter,PackageNames?: string[],PackagePaths?: string[],SoftObjectPaths?: SoftObjectPath[],ClassPaths?: TopLevelAssetPath[],RecursiveClassPathsExclusionSet?: Set<TopLevelAssetPath>,ClassNames?: string[],RecursiveClassesExclusionSet?: Set<string>,bRecursivePaths?: boolean,bRecursiveClasses?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {PackageNames: string[], PackagePaths: string[], SoftObjectPaths: SoftObjectPath[], ClassPaths: TopLevelAssetPath[], RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>, ClassNames: string[], RecursiveClassesExclusionSet: Set<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean};
	static BoxTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxOverlapComponents(WorldContextObject: UObject,BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static BoxOverlapActors(WorldContextObject: UObject,BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static BeginTransaction(Context: string,Description: string,PrimaryObject: UObject): number;
	static AddFloatHistorySample(Value: number,FloatHistory: DebugFloatHistory): DebugFloatHistory;
	static C(Other: UObject | any): KismetSystemLibrary;
}

declare class BlueprintPathsLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintPathsLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintPathsLibrary;
	static GetDefaultObject(): BlueprintPathsLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintPathsLibrary;
	static VideoCaptureDir(): string;
	static ValidatePath(InPath: string,bDidSucceed?: boolean,OutReason?: string): {bDidSucceed: boolean, OutReason: string};
	static Split(InPath: string,PathPart?: string,FilenamePart?: string,ExtensionPart?: string): {PathPart: string, FilenamePart: string, ExtensionPart: string};
	static SourceConfigDir(): string;
	static ShouldSaveToUserDir(): boolean;
	static ShaderWorkingDir(): string;
	static SetProjectFilePath(NewGameProjectFilePath: string): void;
	static SetExtension(InPath: string,InNewExtension: string): string;
	static ScreenShotDir(): string;
	static SandboxesDir(): string;
	static RootDir(): string;
	static RemoveDuplicateSlashes(InPath: string,OutPath?: string): {OutPath: string};
	static ProjectUserDir(): string;
	static ProjectSavedDir(): string;
	static ProjectPluginsDir(): string;
	static ProjectPersistentDownloadDir(): string;
	static ProjectModsDir(): string;
	static ProjectLogDir(): string;
	static ProjectIntermediateDir(): string;
	static ProjectDir(): string;
	static ProjectContentDir(): string;
	static ProjectConfigDir(): string;
	static ProfilingDir(): string;
	static NormalizeFilename(InPath: string,OutPath?: string): {OutPath: string};
	static NormalizeDirectoryName(InPath: string,OutPath?: string): {OutPath: string};
	static MakeValidFileName(InString: string,InReplacementChar: string): string;
	static MakeStandardFilename(InPath: string,OutPath?: string): {OutPath: string};
	static MakePlatformFilename(InPath: string,OutPath?: string): {OutPath: string};
	static MakePathRelativeTo(InPath: string,InRelativeTo: string,OutPath?: string): {OutPath: string, $: boolean};
	static LaunchDir(): string;
	static IsSamePath(PathA: string,PathB: string): boolean;
	static IsRestrictedPath(InPath: string): boolean;
	static IsRelative(InPath: string): boolean;
	static IsProjectFilePathSet(): boolean;
	static IsDrive(InPath: string): boolean;
	static HasProjectPersistentDownloadDir(): boolean;
	static GetToolTipLocalizationPaths(): string[];
	static GetRestrictedFolderNames(): string[];
	static GetRelativePathToRoot(): string;
	static GetPropertyNameLocalizationPaths(): string[];
	static GetProjectFilePath(): string;
	static GetPath(InPath: string): string;
	static GetInvalidFileSystemChars(): string;
	static GetGameLocalizationPaths(): string[];
	static GetExtension(InPath: string,bIncludeDot: boolean): string;
	static GetEngineLocalizationPaths(): string[];
	static GetEditorLocalizationPaths(): string[];
	static GetCleanFilename(InPath: string): string;
	static GetBaseFilename(InPath: string,bRemovePath: boolean): string;
	static GeneratedConfigDir(): string;
	static GameUserDeveloperDir(): string;
	static GameSourceDir(): string;
	static GameDevelopersDir(): string;
	static GameAgnosticSavedDir(): string;
	static FileExists(InPath: string): boolean;
	static FeaturePackDir(): string;
	static EnterprisePluginsDir(): string;
	static EnterpriseFeaturePackDir(): string;
	static EnterpriseDir(): string;
	static EngineVersionAgnosticUserDir(): string;
	static EngineUserDir(): string;
	static EngineSourceDir(): string;
	static EngineSavedDir(): string;
	static EnginePluginsDir(): string;
	static EngineIntermediateDir(): string;
	static EngineDir(): string;
	static EngineContentDir(): string;
	static EngineConfigDir(): string;
	static DirectoryExists(InPath: string): boolean;
	static DiffDir(): string;
	static CreateTempFilename(Path: string,Prefix: string,Extension: string): string;
	static ConvertToSandboxPath(InPath: string,InSandboxName: string): string;
	static ConvertRelativePathToFull(InPath: string,InBasePath: string): string;
	static ConvertFromSandboxPath(InPath: string,InSandboxName: string): string;
	static Combine(InPaths: string[]): string;
	static CollapseRelativeDirectories(InPath: string,OutPath?: string): {OutPath: string, $: boolean};
	static CloudDir(): string;
	static ChangeExtension(InPath: string,InNewExtension: string): string;
	static BugItDir(): string;
	static AutomationTransientDir(): string;
	static AutomationLogDir(): string;
	static AutomationDir(): string;
	static C(Other: UObject | any): BlueprintPathsLibrary;
}

declare type EApplicationState = 'Unknown' | 'Inactive' | 'Background' | 'Active' | 'EApplicationState_MAX';
declare var EApplicationState : { Unknown:'Unknown',Inactive:'Inactive',Background:'Background',Active:'Active',EApplicationState_MAX:'EApplicationState_MAX', };
declare type EScreenOrientation = 'Unknown' | 'Portrait' | 'PortraitUpsideDown' | 'LandscapeLeft' | 'LandscapeRight' | 'FaceUp' | 'FaceDown' | 'PortraitSensor' | 'LandscapeSensor' | 'FullSensor' | 'EScreenOrientation_MAX';
declare var EScreenOrientation : { Unknown:'Unknown',Portrait:'Portrait',PortraitUpsideDown:'PortraitUpsideDown',LandscapeLeft:'LandscapeLeft',LandscapeRight:'LandscapeRight',FaceUp:'FaceUp',FaceDown:'FaceDown',PortraitSensor:'PortraitSensor',LandscapeSensor:'LandscapeSensor',FullSensor:'FullSensor',EScreenOrientation_MAX:'EScreenOrientation_MAX', };
declare class PlatformGameInstance extends GameInstance { 
	ApplicationWillDeactivateDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationHasReactivatedDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationWillEnterBackgroundDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationHasEnteredForegroundDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationWillTerminateDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationShouldUnloadResourcesDelegate: UnrealEngineMulticastDelegate<() => void>;
	ApplicationReceivedStartupArgumentsDelegate: UnrealEngineMulticastDelegate<(StartupArguments: string[]) => void>;
	ApplicationRegisteredForRemoteNotificationsDelegate: UnrealEngineMulticastDelegate<(inArray: number[]) => void>;
	ApplicationRegisteredForUserNotificationsDelegate: UnrealEngineMulticastDelegate<(inInt: number) => void>;
	ApplicationFailedToRegisterForRemoteNotificationsDelegate: UnrealEngineMulticastDelegate<(InString: string) => void>;
	ApplicationReceivedRemoteNotificationDelegate: UnrealEngineMulticastDelegate<(InString: string, inAppState: EApplicationState) => void>;
	ApplicationReceivedLocalNotificationDelegate: UnrealEngineMulticastDelegate<(InString: string, inInt: number, inAppState: EApplicationState) => void>;
	ApplicationReceivedScreenOrientationChangedNotificationDelegate: UnrealEngineMulticastDelegate<(inScreenOrientation: EScreenOrientation) => void>;
	static Load(ResourceName: string): PlatformGameInstance;
	static Find(Outer: UObject, ResourceName: string): PlatformGameInstance;
	static GetDefaultObject(): PlatformGameInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformGameInstance;
	static C(Other: UObject | any): PlatformGameInstance;
}

declare class BlueprintPlatformLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintPlatformLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintPlatformLibrary;
	static GetDefaultObject(): BlueprintPlatformLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintPlatformLibrary;
	static SetAllowedDeviceOrientation(NewAllowedDeviceOrientation: EScreenOrientation): void;
	static ScheduleLocalNotificationFromNow(inSecondsFromNow: number,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	static ScheduleLocalNotificationBadgeFromNow(inSecondsFromNow: number,ActivationEvent: string): void;
	static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime,LocalTime: boolean,ActivationEvent: string): number;
	static ScheduleLocalNotificationAtTime(FireDateTime: DateTime,LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	static GetLaunchNotification(NotificationLaunchedApp?: boolean,ActivationEvent?: string,FireDate?: number): {NotificationLaunchedApp: boolean, ActivationEvent: string, FireDate: number};
	static GetDeviceOrientation(): EScreenOrientation;
	static GetAllowedDeviceOrientation(): EScreenOrientation;
	static ClearAllLocalNotifications(): void;
	static CancelLocalNotificationById(NotificationId: number): void;
	static CancelLocalNotification(ActivationEvent: string): void;
	static C(Other: UObject | any): BlueprintPlatformLibrary;
}

declare class BlueprintTypeConversions extends UObject { 
	static Load(ResourceName: string): BlueprintTypeConversions;
	static Find(Outer: UObject, ResourceName: string): BlueprintTypeConversions;
	static GetDefaultObject(): BlueprintTypeConversions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintTypeConversions;
	static ConvertSetType(InSet: Set<number>): Set<number>;
	static ConvertMapType(InMap: Map<number, number>): Map<number, number>;
	static ConvertFVector4fToFVector4d(InFromData: number): number;
	static ConvertFVector4dToFVector4f(InFromData: number): number;
	static ConvertFVector3fToFVector3d(InFromData: number): number;
	static ConvertFVector3dToFVector3f(InFromData: number): number;
	static ConvertFVector2fToFVector2d(InFromData: number): number;
	static ConvertFVector2dToFVector2f(InFromData: number): number;
	static ConvertFTransform3fToFTransform3d(InFromData: number): number;
	static ConvertFTransform3dToFTransform3f(InFromData: number): number;
	static ConvertFRotator3fToFRotator3d(InFromData: number): number;
	static ConvertFRotator3dToFRotator3f(InFromData: number): number;
	static ConvertFQuat4fToFQuat4d(InFromData: number): number;
	static ConvertFQuat4dToFQuat4f(InFromData: number): number;
	static ConvertFPlane4fToFPlane4d(InFromData: number): number;
	static ConvertFPlane4dToFPlane4f(InFromData: number): number;
	static ConvertFMatrix44fToFMatrix44d(InFromData: number): number;
	static ConvertFMatrix44dToFMatrix44f(InFromData: number): number;
	static ConvertFBox2fToFBox2d(InFromData: number): number;
	static ConvertFBox2dToFBox2f(InFromData: number): number;
	static ConvertArrayType(inArray: number[]): number[];
	static C(Other: UObject | any): BlueprintTypeConversions;
}

declare class ImportanceSamplingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ImportanceSamplingLibrary;
	static Find(Outer: UObject, ResourceName: string): ImportanceSamplingLibrary;
	static GetDefaultObject(): ImportanceSamplingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImportanceSamplingLibrary;
	static RandomSobolFloat(Index: number,Dimension: number,Seed: number): number;
	static RandomSobolCell3D(Index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static RandomSobolCell2D(Index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static NextSobolFloat(Index: number,Dimension: number,PreviousValue: number): number;
	static NextSobolCell3D(Index: number,NumCells: number,PreviousValue: Vector): Vector;
	static NextSobolCell2D(Index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static MakeImportanceTexture(Texture: Texture2D,WeightingFunc: EImportanceWeight): ImportanceTexture;
	static ImportanceSample(Texture: ImportanceTexture,Rand: Vector2D,Samples: number,Intensity: number,SamplePosition?: Vector2D,SampleColor?: LinearColor,SampleIntensity?: number,SampleSize?: number): {SamplePosition: Vector2D, SampleColor: LinearColor, SampleIntensity: number, SampleSize: number};
	static BreakImportanceTexture(ImportanceTexture: ImportanceTexture,Texture?: Texture2D,WeightingFunc?: EImportanceWeight): {Texture: Texture2D, WeightingFunc: EImportanceWeight};
	static C(Other: UObject | any): ImportanceSamplingLibrary;
}

declare class ActorContainer extends UObject { 
	Actors: Map<string, Actor>;
	static Load(ResourceName: string): ActorContainer;
	static Find(Outer: UObject, ResourceName: string): ActorContainer;
	static GetDefaultObject(): ActorContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorContainer;
	static C(Other: UObject | any): ActorContainer;
}

declare class LevelBounds extends Actor { 
	BoxComponent: BoxComponent;
	bAutoUpdateBounds: boolean;
	static GetDefaultObject(): LevelBounds;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelBounds;
	static C(Other: UObject | any): LevelBounds;
}

declare type ELevelInstanceRuntimeBehavior = 'None' | 'Embedded_Deprecated' | 'Partitioned' | 'LevelStreaming' | 'ELevelInstanceRuntimeBehavior_MAX';
declare var ELevelInstanceRuntimeBehavior : { None:'None',Embedded_Deprecated:'Embedded_Deprecated',Partitioned:'Partitioned',LevelStreaming:'LevelStreaming',ELevelInstanceRuntimeBehavior_MAX:'ELevelInstanceRuntimeBehavior_MAX', };
declare class LevelInstance extends Actor { 
	WorldAsset: World;
	CookedWorldAsset: World;
	LevelInstanceSpawnGuid: Guid;
	DesiredRuntimeBehavior: ELevelInstanceRuntimeBehavior;
	static GetDefaultObject(): LevelInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstance;
	OnRep_LevelInstanceSpawnGuid(): void;
	static C(Other: UObject | any): LevelInstance;
}

declare class LevelInstanceComponent extends SceneComponent { 
	static Load(ResourceName: string): LevelInstanceComponent;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceComponent;
	static GetDefaultObject(): LevelInstanceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceComponent;
	static C(Other: UObject | any): LevelInstanceComponent;
}

declare class LevelInstanceEditorInstanceActor extends Actor { 
	static GetDefaultObject(): LevelInstanceEditorInstanceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceEditorInstanceActor;
	static C(Other: UObject | any): LevelInstanceEditorInstanceActor;
}

declare class LevelStreamingLevelInstanceEditor extends LevelStreamingAlwaysLoaded { 
	static Load(ResourceName: string): LevelStreamingLevelInstanceEditor;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingLevelInstanceEditor;
	static GetDefaultObject(): LevelStreamingLevelInstanceEditor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingLevelInstanceEditor;
	static C(Other: UObject | any): LevelStreamingLevelInstanceEditor;
}

declare class LevelInstanceEditorObject extends UObject { 
	bMovedActors: boolean;
	OtherPackagesToSave: Package[];
	static Load(ResourceName: string): LevelInstanceEditorObject;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceEditorObject;
	static GetDefaultObject(): LevelInstanceEditorObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceEditorObject;
	static C(Other: UObject | any): LevelInstanceEditorObject;
}

declare class LevelInstancePivot extends Actor { 
	static GetDefaultObject(): LevelInstancePivot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstancePivot;
	static C(Other: UObject | any): LevelInstancePivot;
}

declare class LevelInstanceInterface extends Interface { 
	static Load(ResourceName: string): LevelInstanceInterface;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceInterface;
	static GetDefaultObject(): LevelInstanceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceInterface;
	static C(Other: UObject | any): LevelInstanceInterface;
}

declare class LevelStreamingLevelInstance extends LevelStreamingDynamic { 
	static Load(ResourceName: string): LevelStreamingLevelInstance;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingLevelInstance;
	static GetDefaultObject(): LevelStreamingLevelInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingLevelInstance;
	static C(Other: UObject | any): LevelStreamingLevelInstance;
}

declare class LevelInstanceSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): LevelInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceSubsystem;
	static GetDefaultObject(): LevelInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceSubsystem;
	static C(Other: UObject | any): LevelInstanceSubsystem;
}

declare class LightmappedSurfaceCollection extends UObject { 
	SourceModel: Model;
	Surfaces: number[];
	static Load(ResourceName: string): LightmappedSurfaceCollection;
	static Find(Outer: UObject, ResourceName: string): LightmappedSurfaceCollection;
	static GetDefaultObject(): LightmappedSurfaceCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmappedSurfaceCollection;
	static C(Other: UObject | any): LightmappedSurfaceCollection;
}

declare class LightmassCharacterIndirectDetailVolume extends Volume { 
	static GetDefaultObject(): LightmassCharacterIndirectDetailVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassCharacterIndirectDetailVolume;
	static C(Other: UObject | any): LightmassCharacterIndirectDetailVolume;
}

declare class LightmassImportanceVolume extends Volume { 
	static GetDefaultObject(): LightmassImportanceVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassImportanceVolume;
	static C(Other: UObject | any): LightmassImportanceVolume;
}

declare class LightmassPrimitiveSettingsObject extends UObject { 
	LightmassSettings: LightmassPrimitiveSettings;
	static Load(ResourceName: string): LightmassPrimitiveSettingsObject;
	static Find(Outer: UObject, ResourceName: string): LightmassPrimitiveSettingsObject;
	static GetDefaultObject(): LightmassPrimitiveSettingsObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassPrimitiveSettingsObject;
	static C(Other: UObject | any): LightmassPrimitiveSettingsObject;
}

declare class LightWeightInstanceBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LightWeightInstanceBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): LightWeightInstanceBlueprintFunctionLibrary;
	static GetDefaultObject(): LightWeightInstanceBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceBlueprintFunctionLibrary;
	static CreateNewLightWeightInstance(ActorClass: UnrealEngineClass,Transform: Transform,Layer: DataLayerInstance,World: World): ActorInstanceHandle;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static C(Other: UObject | any): LightWeightInstanceBlueprintFunctionLibrary;
}

declare class ActorInstanceHandleInterface extends UObject { 
	static Load(ResourceName: string): ActorInstanceHandleInterface;
	static Find(Outer: UObject, ResourceName: string): ActorInstanceHandleInterface;
	static GetDefaultObject(): ActorInstanceHandleInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorInstanceHandleInterface;
	static C(Other: UObject | any): ActorInstanceHandleInterface;
}

declare class LightWeightInstanceManager extends Actor { 
	RepresentedClass: UnrealEngineClass;
	AcceptedClass: UnrealEngineClass;
	InstanceTransforms: Transform[];
	FreeIndices: number[];
	ValidIndices: boolean[];
	static GetDefaultObject(): LightWeightInstanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceManager;
	OnRep_Transforms(): void;
	static C(Other: UObject | any): LightWeightInstanceManager;
}

declare class LightWeightInstanceStaticMeshManager extends LightWeightInstanceManager { 
	StaticMesh: StaticMesh;
	InstancedStaticMeshComponent: HierarchicalInstancedStaticMeshComponent;
	RenderingIndicesToDataIndices: number[];
	DataIndicesToRenderingIndices: number[];
	static GetDefaultObject(): LightWeightInstanceStaticMeshManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceStaticMeshManager;
	OnRep_StaticMesh(): void;
	static C(Other: UObject | any): LightWeightInstanceStaticMeshManager;
}

declare class LocationVolume extends Volume { 
	DebugColor: Color;
	bIsRuntime: boolean;
	static GetDefaultObject(): LocationVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocationVolume;
	Unload(): void;
	Load(): void;
	IsLoaded(): boolean;
	static C(Other: UObject | any): LocationVolume;
}

declare class MaterialInstanceActor extends Actor { 
	TargetActors: Actor[];
	static GetDefaultObject(): MaterialInstanceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceActor;
	static C(Other: UObject | any): MaterialInstanceActor;
}

declare class MaterialInstanceEditorOnlyData extends MaterialInterfaceEditorOnlyData { 
	StaticParameters: StaticParameterSetEditorOnlyData;
	static Load(ResourceName: string): MaterialInstanceEditorOnlyData;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceEditorOnlyData;
	static GetDefaultObject(): MaterialInstanceEditorOnlyData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceEditorOnlyData;
	static C(Other: UObject | any): MaterialInstanceEditorOnlyData;
}

declare class MeshMergeCullingVolume extends Volume { 
	static GetDefaultObject(): MeshMergeCullingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshMergeCullingVolume;
	static C(Other: UObject | any): MeshMergeCullingVolume;
}

declare class MeshSimplificationSettings extends DeveloperSettings { 
	MeshReductionModuleName: string;
	bMeshReductionBackwardCompatible: boolean;
	static Load(ResourceName: string): MeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): MeshSimplificationSettings;
	static GetDefaultObject(): MeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSimplificationSettings;
	static C(Other: UObject | any): MeshSimplificationSettings;
}

declare class MeshVertexPainterKismetLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MeshVertexPainterKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): MeshVertexPainterKismetLibrary;
	static GetDefaultObject(): MeshVertexPainterKismetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshVertexPainterKismetLibrary;
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	static C(Other: UObject | any): MeshVertexPainterKismetLibrary;
}

declare class SimulatedClientNetConnection extends NetConnection { 
	static Load(ResourceName: string): SimulatedClientNetConnection;
	static Find(Outer: UObject, ResourceName: string): SimulatedClientNetConnection;
	static GetDefaultObject(): SimulatedClientNetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimulatedClientNetConnection;
	static C(Other: UObject | any): SimulatedClientNetConnection;
}

declare class NetworkEmulationProfileDescription { 
	ProfileName: string;
	Tooltip: string;
	clone() : NetworkEmulationProfileDescription;
	static C(Other: UObject | any): NetworkEmulationProfileDescription;
}

declare class NetworkSettings extends DeveloperSettings { 
	bVerifyPeer: boolean;
	bEnableMultiplayerWorldOriginRebasing: boolean;
	NetworkEmulationProfiles: NetworkEmulationProfileDescription[];
	static Load(ResourceName: string): NetworkSettings;
	static Find(Outer: UObject, ResourceName: string): NetworkSettings;
	static GetDefaultObject(): NetworkSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkSettings;
	static C(Other: UObject | any): NetworkSettings;
}

declare class BandwidthTestItem { 
	Kilobyte: number[];
	clone() : BandwidthTestItem;
	static C(Other: UObject | any): BandwidthTestItem;
}

declare class BandwidthTestGenerator { 
	ReplicatedBuffers: BandwidthTestItem[];
	clone() : BandwidthTestGenerator;
	static C(Other: UObject | any): BandwidthTestGenerator;
}

declare class BandwidthTestActor extends Actor { 
	BandwidthGenerator: BandwidthTestGenerator;
	static GetDefaultObject(): BandwidthTestActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BandwidthTestActor;
	static C(Other: UObject | any): BandwidthTestActor;
}

declare class NetFaultConfig extends EscalationManagerConfig { 
	static Load(ResourceName: string): NetFaultConfig;
	static Find(Outer: UObject, ResourceName: string): NetFaultConfig;
	static GetDefaultObject(): NetFaultConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetFaultConfig;
	static C(Other: UObject | any): NetFaultConfig;
}

declare class NetPushModelHelpers extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): NetPushModelHelpers;
	static Find(Outer: UObject, ResourceName: string): NetPushModelHelpers;
	static GetDefaultObject(): NetPushModelHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetPushModelHelpers;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static C(Other: UObject | any): NetPushModelHelpers;
}

declare class RPCAnalyticsThreshold { 
	RPC: string;
	CountPerSec: number;
	TimePerSec: number;
	clone() : RPCAnalyticsThreshold;
	static C(Other: UObject | any): RPCAnalyticsThreshold;
}

declare class RPCDoSDetectionConfig extends UObject { 
	bRPCDoSDetection: boolean;
	bRPCDoSAnalytics: boolean;
	HitchTimeQuotaMS: number;
	HitchSuspendDetectionTimeMS: number;
	DetectionSeverity: string[];
	InitialConnectToleranceMS: number;
	RPCBlockWhitelist: string[];
	RPCBlockAllowlist: string[];
	RPCAnalyticsThresholds: RPCAnalyticsThreshold[];
	RPCAnalyticsOverrideChance: number;
	static Load(ResourceName: string): RPCDoSDetectionConfig;
	static Find(Outer: UObject, ResourceName: string): RPCDoSDetectionConfig;
	static GetDefaultObject(): RPCDoSDetectionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RPCDoSDetectionConfig;
	static C(Other: UObject | any): RPCDoSDetectionConfig;
}

declare class NetworkSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): NetworkSubsystem;
	static Find(Outer: UObject, ResourceName: string): NetworkSubsystem;
	static GetDefaultObject(): NetworkSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkSubsystem;
	static C(Other: UObject | any): NetworkSubsystem;
}

declare class Note extends Actor { 
	Text: string;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): Note;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Note;
	static C(Other: UObject | any): Note;
}

declare class ObjectLibrary extends UObject { 
	ObjectBaseClass: UnrealEngineClass;
	bHasBlueprintClasses: boolean;
	Objects: UObject[];
	WeakObjects: UObject[];
	bUseWeakReferences: boolean;
	bIsFullyLoaded: boolean;
	static Load(ResourceName: string): ObjectLibrary;
	static Find(Outer: UObject, ResourceName: string): ObjectLibrary;
	static GetDefaultObject(): ObjectLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectLibrary;
	static C(Other: UObject | any): ObjectLibrary;
}

declare class ObjectReferencer extends UObject { 
	ReferencedObjects: UObject[];
	static Load(ResourceName: string): ObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): ObjectReferencer;
	static GetDefaultObject(): ObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectReferencer;
	static C(Other: UObject | any): ObjectReferencer;
}

declare class ObjectTraceWorldSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): ObjectTraceWorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): ObjectTraceWorldSubsystem;
	static GetDefaultObject(): ObjectTraceWorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectTraceWorldSubsystem;
	static C(Other: UObject | any): ObjectTraceWorldSubsystem;
}

declare class OnlineBlueprintCallProxyBase extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): OnlineBlueprintCallProxyBase;
	static Find(Outer: UObject, ResourceName: string): OnlineBlueprintCallProxyBase;
	static GetDefaultObject(): OnlineBlueprintCallProxyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBlueprintCallProxyBase;
	static C(Other: UObject | any): OnlineBlueprintCallProxyBase;
}

declare class OnlineEngineInterface extends UObject { 
	static Load(ResourceName: string): OnlineEngineInterface;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterface;
	static GetDefaultObject(): OnlineEngineInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterface;
	static C(Other: UObject | any): OnlineEngineInterface;
}

declare class PackageMapClient extends PackageMap { 
	static Load(ResourceName: string): PackageMapClient;
	static Find(Outer: UObject, ResourceName: string): PackageMapClient;
	static GetDefaultObject(): PackageMapClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMapClient;
	static C(Other: UObject | any): PackageMapClient;
}

declare class PackedLevelActor extends LevelInstance { 
	PackedBPDependencies: Blueprint[];
	PackedVersion: Guid;
	static GetDefaultObject(): PackedLevelActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackedLevelActor;
	static C(Other: UObject | any): PackedLevelActor;
}

declare class EngineHandlerComponentFactory extends HandlerComponentFactory { 
	static Load(ResourceName: string): EngineHandlerComponentFactory;
	static Find(Outer: UObject, ResourceName: string): EngineHandlerComponentFactory;
	static GetDefaultObject(): EngineHandlerComponentFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineHandlerComponentFactory;
	static C(Other: UObject | any): EngineHandlerComponentFactory;
}

declare class PainCausingVolume extends PhysicsVolume { 
	bPainCausing: boolean;
	DamagePerSec: number;
	DamageType: UnrealEngineClass;
	PainInterval: number;
	bEntryPain: boolean;
	BACKUP_bPainCausing: boolean;
	DamageInstigator: Controller;
	static GetDefaultObject(): PainCausingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PainCausingVolume;
	static C(Other: UObject | any): PainCausingVolume;
}

declare class ConstraintInstanceBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ConstraintInstanceBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ConstraintInstanceBlueprintLibrary;
	static GetDefaultObject(): ConstraintInstanceBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintInstanceBlueprintLibrary;
	static SetProjectionParams(Accessor?: ConstraintInstanceAccessor,bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor};
	static SetParentDominates(Accessor?: ConstraintInstanceAccessor,bParentDominates?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetOrientationDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetOrientationDriveSLERP(Accessor?: ConstraintInstanceAccessor,bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearVelocityTarget(Accessor?: ConstraintInstanceAccessor,InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetLinearVelocityDrive(Accessor?: ConstraintInstanceAccessor,bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearSoftLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPositionTarget(Accessor?: ConstraintInstanceAccessor,InPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPositionDrive(Accessor?: ConstraintInstanceAccessor,bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPlasticity(Accessor?: ConstraintInstanceAccessor,bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor};
	static SetLinearLimits(Accessor?: ConstraintInstanceAccessor,XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearDriveParams(Accessor?: ConstraintInstanceAccessor,PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearBreakable(Accessor?: ConstraintInstanceAccessor,bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static SetDisableCollision(Accessor?: ConstraintInstanceAccessor,bDisableCollision?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetContactTransferScale(Accessor?: ConstraintInstanceAccessor,ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityTarget(Accessor?: ConstraintInstanceAccessor,InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityDriveSLERP(Accessor?: ConstraintInstanceAccessor,bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetAngularSoftTwistLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularSoftSwingLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularPlasticity(Accessor?: ConstraintInstanceAccessor,bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularOrientationTarget(Accessor?: ConstraintInstanceAccessor,InPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor};
	static SetAngularLimits(Accessor?: ConstraintInstanceAccessor,Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularDriveParams(Accessor?: ConstraintInstanceAccessor,PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularDriveMode(Accessor?: ConstraintInstanceAccessor,DriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor};
	static SetAngularBreakable(Accessor?: ConstraintInstanceAccessor,bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static GetProjectionParams(Accessor?: ConstraintInstanceAccessor,bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor, bEnableProjection: boolean, ProjectionLinearAlpha: number, ProjectionAngularAlpha: number};
	static GetParentDominates(Accessor?: ConstraintInstanceAccessor): {Accessor: ConstraintInstanceAccessor, $: boolean};
	static GetOrientationDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	static GetOrientationDriveSLERP(Accessor?: ConstraintInstanceAccessor,bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	static GetLinearVelocityTarget(Accessor?: ConstraintInstanceAccessor,OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	static GetLinearVelocityDrive(Accessor?: ConstraintInstanceAccessor,bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	static GetLinearSoftLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftLinearLimit: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, LinearLimitRestitution: number, LinearLimitContactDistance: number};
	static GetLinearPositionTarget(Accessor?: ConstraintInstanceAccessor,OutPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Vector};
	static GetLinearPositionDrive(Accessor?: ConstraintInstanceAccessor,bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	static GetLinearPlasticity(Accessor?: ConstraintInstanceAccessor,bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor, bLinearPlasticity: boolean, LinearPlasticityThreshold: number, PlasticityType: EConstraintPlasticityType};
	static GetLinearLimits(Accessor?: ConstraintInstanceAccessor,XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor, XMotion: ELinearConstraintMotion, YMotion: ELinearConstraintMotion, ZMotion: ELinearConstraintMotion, Limit: number};
	static GetLinearDriveParams(Accessor?: ConstraintInstanceAccessor,OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	static GetLinearBreakable(Accessor?: ConstraintInstanceAccessor,bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bLinearBreakable: boolean, LinearBreakThreshold: number};
	static GetDisableCollsion(Accessor?: ConstraintInstanceAccessor): {Accessor: ConstraintInstanceAccessor, $: boolean};
	static GetContactTransferScale(Accessor?: ConstraintInstanceAccessor,ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor, ContactTransferScale: number};
	static GetAttachedBodyNames(Accessor?: ConstraintInstanceAccessor,ParentBody?: string,ChildBody?: string): {Accessor: ConstraintInstanceAccessor, ParentBody: string, ChildBody: string};
	static GetAngularVelocityTarget(Accessor?: ConstraintInstanceAccessor,OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	static GetAngularVelocityDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	static GetAngularVelocityDriveSLERP(Accessor?: ConstraintInstanceAccessor,bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	static GetAngularSoftTwistLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftTwistLimit: boolean, TwistLimitStiffness: number, TwistLimitDamping: number, TwistLimitRestitution: number, TwistLimitContactDistance: number};
	static GetAngularSoftSwingLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftSwingLimit: boolean, SwingLimitStiffness: number, SwingLimitDamping: number, SwingLimitRestitution: number, SwingLimitContactDistance: number};
	static GetAngularPlasticity(Accessor?: ConstraintInstanceAccessor,bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularPlasticity: boolean, AngularPlasticityThreshold: number};
	static GetAngularOrientationTarget(Accessor?: ConstraintInstanceAccessor,OutPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Rotator};
	static GetAngularLimits(Accessor?: ConstraintInstanceAccessor,Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor, Swing1MotionType: EAngularConstraintMotion, Swing1LimitAngle: number, Swing2MotionType: EAngularConstraintMotion, Swing2LimitAngle: number, TwistMotionType: EAngularConstraintMotion, TwistLimitAngle: number};
	static GetAngularDriveParams(Accessor?: ConstraintInstanceAccessor,OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	static GetAngularDriveMode(Accessor?: ConstraintInstanceAccessor,OutDriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor, OutDriveMode: EAngularDriveMode};
	static GetAngularBreakable(Accessor?: ConstraintInstanceAccessor,bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularBreakable: boolean, AngularBreakThreshold: number};
	static CopyParams(Accessor?: ConstraintInstanceAccessor,SourceAccessor?: ConstraintInstanceAccessor,bKeepPosition?: boolean,bKeepRotation?: boolean): {Accessor: ConstraintInstanceAccessor, SourceAccessor: ConstraintInstanceAccessor};
	static C(Other: UObject | any): ConstraintInstanceBlueprintLibrary;
}

declare class PhysicalAnimationComponent extends ActorComponent { 
	StrengthMultiplyer: number;
	SkeletalMeshComponent: SkeletalMeshComponent;
	static Load(ResourceName: string): PhysicalAnimationComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicalAnimationComponent;
	static GetDefaultObject(): PhysicalAnimationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalAnimationComponent;
	SetStrengthMultiplyer(InStrengthMultiplyer: number): void;
	SetSkeletalMeshComponent(InSkeletalMeshComponent: SkeletalMeshComponent): void;
	GetBodyTargetTransform(BodyName: string): Transform;
	ApplyPhysicalAnimationSettingsBelow(BodyName: string,PhysicalAnimationData: PhysicalAnimationData,bIncludeSelf: boolean): void;
	ApplyPhysicalAnimationSettings(BodyName: string,PhysicalAnimationData: PhysicalAnimationData): void;
	ApplyPhysicalAnimationProfileBelow(BodyName: string,ProfileName: string,bIncludeSelf: boolean,bClearNotFound: boolean): void;
	static C(Other: UObject | any): PhysicalAnimationComponent;
}

declare class ConstrainComponentPropName { 
	ComponentName: string;
	clone() : ConstrainComponentPropName;
	static C(Other: UObject | any): ConstrainComponentPropName;
}

declare type EConstraintFrame = 'Frame1' | 'Frame2' | 'EConstraintFrame_MAX';
declare var EConstraintFrame : { Frame1:'Frame1',Frame2:'Frame2',EConstraintFrame_MAX:'EConstraintFrame_MAX', };
declare class PhysicsConstraintComponent extends SceneComponent { 
	ConstraintActor1: Actor;
	ComponentName1: ConstrainComponentPropName;
	ConstraintActor2: Actor;
	ComponentName2: ConstrainComponentPropName;
	ConstraintSetup: PhysicsConstraintTemplate;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	OnPlasticDeformation: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	ConstraintInstance: ConstraintInstance;
	static Load(ResourceName: string): PhysicsConstraintComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsConstraintComponent;
	static GetDefaultObject(): PhysicsConstraintComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintComponent;
	SetOrientationDriveTwistAndSwing(bEnableTwistDrive: boolean,bEnableSwingDrive: boolean): void;
	SetOrientationDriveSLERP(bEnableSLERP: boolean): void;
	SetLinearZLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearYLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearXLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearVelocityTarget(InVelTarget: Vector): void;
	SetLinearVelocityDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearPositionTarget(InPosTarget: Vector): void;
	SetLinearPositionDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearPlasticity(bLinearPlasticity: boolean,LinearPlasticityThreshold: number,PlasticityType: EConstraintPlasticityType): void;
	SetLinearDriveParams(PositionStrength: number,VelocityStrength: number,InForceLimit: number): void;
	SetLinearBreakable(bLinearBreakable: boolean,LinearBreakThreshold: number): void;
	SetDisableCollision(bDisableCollision: boolean): void;
	SetContactTransferScale(ContactTransferScale: number): void;
	SetConstraintReferencePosition(Frame: EConstraintFrame,RefPosition: Vector): void;
	SetConstraintReferenceOrientation(Frame: EConstraintFrame,PriAxis: Vector,SecAxis: Vector): void;
	SetConstraintReferenceFrame(Frame: EConstraintFrame,RefFrame: Transform): void;
	SetConstrainedComponents(Component1: PrimitiveComponent,BoneName1: string,Component2: PrimitiveComponent,BoneName2: string): void;
	SetAngularVelocityTarget(InVelTarget: Vector): void;
	SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive: boolean,bEnableSwingDrive: boolean): void;
	SetAngularVelocityDriveSLERP(bEnableSLERP: boolean): void;
	SetAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularTwistLimit(ConstraintType: EAngularConstraintMotion,TwistLimitAngle: number): void;
	SetAngularSwing2Limit(MotionType: EAngularConstraintMotion,Swing2LimitAngle: number): void;
	SetAngularSwing1Limit(MotionType: EAngularConstraintMotion,Swing1LimitAngle: number): void;
	SetAngularPlasticity(bAngularPlasticity: boolean,AngularPlasticityThreshold: number): void;
	SetAngularOrientationTarget(InPosTarget: Rotator): void;
	SetAngularOrientationDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularDriveParams(PositionStrength: number,VelocityStrength: number,InForceLimit: number): void;
	SetAngularDriveMode(DriveMode: EAngularDriveMode): void;
	SetAngularBreakable(bAngularBreakable: boolean,AngularBreakThreshold: number): void;
	IsBroken(): boolean;
	GetCurrentTwist(): number;
	GetCurrentSwing2(): number;
	GetCurrentSwing1(): number;
	GetConstraintForce(OutLinearForce?: Vector,OutAngularForce?: Vector): {OutLinearForce: Vector, OutAngularForce: Vector};
	GetConstraint(): ConstraintInstanceAccessor;
	GetConstrainedComponents(OutComponent1?: PrimitiveComponent,OutBoneName1?: string,OutComponent2?: PrimitiveComponent,OutBoneName2?: string): {OutComponent1: PrimitiveComponent, OutBoneName1: string, OutComponent2: PrimitiveComponent, OutBoneName2: string};
	BreakConstraint(): void;
	static C(Other: UObject | any): PhysicsConstraintComponent;
}

declare class PhysicsConstraintActor extends RigidBodyBase { 
	ConstraintComp: PhysicsConstraintComponent;
	ConstraintActor1: Actor;
	ConstraintActor2: Actor;
	bDisableCollision: boolean;
	static GetDefaultObject(): PhysicsConstraintActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintActor;
	static C(Other: UObject | any): PhysicsConstraintActor;
}

declare class PhysicsHandleComponent extends ActorComponent { 
	GrabbedComponent: PrimitiveComponent;
	bSoftAngularConstraint: boolean;
	bSoftLinearConstraint: boolean;
	bInterpolateTarget: boolean;
	LinearDamping: number;
	LinearStiffness: number;
	AngularDamping: number;
	AngularStiffness: number;
	InterpolationSpeed: number;
	static Load(ResourceName: string): PhysicsHandleComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsHandleComponent;
	static GetDefaultObject(): PhysicsHandleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsHandleComponent;
	SetTargetRotation(NewRotation: Rotator): void;
	SetTargetLocationAndRotation(NewLocation: Vector,NewRotation: Rotator): void;
	SetTargetLocation(NewLocation: Vector): void;
	SetLinearStiffness(NewLinearStiffness: number): void;
	SetLinearDamping(NewLinearDamping: number): void;
	SetInterpolationSpeed(NewInterpolationSpeed: number): void;
	SetAngularStiffness(NewAngularStiffness: number): void;
	SetAngularDamping(NewAngularDamping: number): void;
	ReleaseComponent(): void;
	GrabComponentAtLocationWithRotation(Component: PrimitiveComponent,InBoneName: string,Location: Vector,Rotation: Rotator): void;
	GrabComponentAtLocation(Component: PrimitiveComponent,InBoneName: string,GrabLocation: Vector): void;
	GrabComponent(Component: PrimitiveComponent,InBoneName: string,GrabLocation: Vector,bConstrainRotation: boolean): void;
	GetTargetLocationAndRotation(TargetLocation?: Vector,TargetRotation?: Rotator): {TargetLocation: Vector, TargetRotation: Rotator};
	GetGrabbedComponent(): PrimitiveComponent;
	static C(Other: UObject | any): PhysicsHandleComponent;
}

declare class RigidBodyErrorCorrection { 
	PingExtrapolation: number;
	PingLimit: number;
	ErrorPerLinearDifference: number;
	ErrorPerAngularDifference: number;
	MaxRestoredStateError: number;
	MaxLinearHardSnapDistance: number;
	PositionLerp: number;
	AngleLerp: number;
	LinearVelocityCoefficient: number;
	AngularVelocityCoefficient: number;
	ErrorAccumulationSeconds: number;
	ErrorAccumulationDistanceSq: number;
	ErrorAccumulationSimilarity: number;
	clone() : RigidBodyErrorCorrection;
	static C(Other: UObject | any): RigidBodyErrorCorrection;
}

declare type ESettingsLockedAxis = 'None' | 'X' | 'Y' | 'Z' | 'Invalid' | 'ESettingsLockedAxis_MAX';
declare var ESettingsLockedAxis : { None:'None',X:'X',Y:'Y',Z:'Z',Invalid:'Invalid',ESettingsLockedAxis_MAX:'ESettingsLockedAxis_MAX', };
declare type ESettingsDOF = 'Full3D' | 'YZPlane' | 'XZPlane' | 'XYPlane' | 'ESettingsDOF_MAX';
declare var ESettingsDOF : { Full3D:'Full3D',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane',ESettingsDOF_MAX:'ESettingsDOF_MAX', };
declare class PhysicalSurfaceName { 
	Type: EPhysicalSurface;
	Name: string;
	clone() : PhysicalSurfaceName;
	static C(Other: UObject | any): PhysicalSurfaceName;
}

declare type EChaosThreadingMode = 'DedicatedThread' | 'TaskGraph' | 'SingleThread' | 'Num' | 'Invalid' | 'EChaosThreadingMode_MAX';
declare var EChaosThreadingMode : { DedicatedThread:'DedicatedThread',TaskGraph:'TaskGraph',SingleThread:'SingleThread',Num:'Num',Invalid:'Invalid',EChaosThreadingMode_MAX:'EChaosThreadingMode_MAX', };
declare type EChaosSolverTickMode = 'Fixed' | 'Variable' | 'VariableCapped' | 'VariableCappedWithTarget' | 'EChaosSolverTickMode_MAX';
declare var EChaosSolverTickMode : { Fixed:'Fixed',Variable:'Variable',VariableCapped:'VariableCapped',VariableCappedWithTarget:'VariableCappedWithTarget',EChaosSolverTickMode_MAX:'EChaosSolverTickMode_MAX', };
declare type EChaosBufferMode = 'Double' | 'Triple' | 'Num' | 'Invalid' | 'EChaosBufferMode_MAX';
declare var EChaosBufferMode : { Double:'Double',Triple:'Triple',Num:'Num',Invalid:'Invalid',EChaosBufferMode_MAX:'EChaosBufferMode_MAX', };
declare class ChaosPhysicsSettings { 
	DefaultThreadingModel: EChaosThreadingMode;
	DedicatedThreadTickMode: EChaosSolverTickMode;
	DedicatedThreadBufferMode: EChaosBufferMode;
	clone() : ChaosPhysicsSettings;
	static C(Other: UObject | any): ChaosPhysicsSettings;
}

declare class PhysicsSettings extends PhysicsSettingsCore { 
	PhysicErrorCorrection: RigidBodyErrorCorrection;
	LockedAxis: ESettingsLockedAxis;
	DefaultDegreesOfFreedom: ESettingsDOF;
	bSuppressFaceRemapTable: boolean;
	bSupportUVFromHitResults: boolean;
	bDisableActiveActors: boolean;
	bDisableKinematicStaticPairs: boolean;
	bDisableKinematicKinematicPairs: boolean;
	bDisableCCD: boolean;
	bEnableEnhancedDeterminism: boolean;
	AnimPhysicsMinDeltaTime: number;
	bSimulateAnimPhysicsAfterReset: boolean;
	MinPhysicsDeltaTime: number;
	MaxPhysicsDeltaTime: number;
	bSubstepping: boolean;
	bSubsteppingAsync: boolean;
	bTickPhysicsAsync: boolean;
	AsyncFixedTimeStepSize: number;
	MaxSubstepDeltaTime: number;
	MaxSubsteps: number;
	SyncSceneSmoothingFactor: number;
	InitialAverageFrameRate: number;
	PhysXTreeRebuildRate: number;
	PhysicalSurfaces: PhysicalSurfaceName[];
	DefaultBroadphaseSettings: BroadphaseSettings;
	MinDeltaVelocityForHitEvents: number;
	ChaosSettings: ChaosPhysicsSettings;
	static Load(ResourceName: string): PhysicsSettings;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettings;
	static GetDefaultObject(): PhysicsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettings;
	static C(Other: UObject | any): PhysicsSettings;
}

declare class PhysicsThruster extends RigidBodyBase { 
	ThrusterComponent: PhysicsThrusterComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): PhysicsThruster;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsThruster;
	static C(Other: UObject | any): PhysicsThruster;
}

declare class PhysicsFieldStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): PhysicsFieldStatics;
	static Find(Outer: UObject, ResourceName: string): PhysicsFieldStatics;
	static GetDefaultObject(): PhysicsFieldStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsFieldStatics;
	static EvalPhysicsVectorField(WorldContextObject: UObject,WorldPosition: Vector,VectorType: EFieldVectorType): Vector;
	static EvalPhysicsScalarField(WorldContextObject: UObject,WorldPosition: Vector,ScalarType: EFieldScalarType): number;
	static EvalPhysicsIntegerField(WorldContextObject: UObject,WorldPosition: Vector,IntegerType: EFieldIntegerType): number;
	static C(Other: UObject | any): PhysicsFieldStatics;
}

declare class PlatformInputDeviceMapperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): PlatformInputDeviceMapperLibrary;
	static Find(Outer: UObject, ResourceName: string): PlatformInputDeviceMapperLibrary;
	static GetDefaultObject(): PlatformInputDeviceMapperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformInputDeviceMapperLibrary;
	static PlatformUserId_None(): PlatformUserId;
	static NotEqual_PlatformUserId(A: PlatformUserId,B: PlatformUserId): boolean;
	static NotEqual_InputDeviceId(A: InputDeviceId,B: InputDeviceId): boolean;
	static IsValidPlatformId(UserId: PlatformUserId): boolean;
	static IsValidInputDevice(DeviceID: InputDeviceId): boolean;
	static IsUnpairedUserId(PlatformId: PlatformUserId): boolean;
	static IsInputDeviceMappedToUnpairedUser(InputDevice: InputDeviceId): boolean;
	static InputDeviceId_None(): InputDeviceId;
	static GetUserForUnpairedInputDevices(): PlatformUserId;
	static GetUserForInputDevice(DeviceID: InputDeviceId): PlatformUserId;
	static GetPrimaryInputDeviceForUser(UserId: PlatformUserId): InputDeviceId;
	static GetInputDeviceConnectionState(DeviceID: InputDeviceId): EInputDeviceConnectionState;
	static GetDefaultInputDevice(): InputDeviceId;
	static GetAllInputDevicesForUser(UserId: PlatformUserId,OutInputDevices?: InputDeviceId[]): {OutInputDevices: InputDeviceId[], $: number};
	static GetAllInputDevices(OutInputDevices?: InputDeviceId[]): {OutInputDevices: InputDeviceId[], $: number};
	static GetAllConnectedInputDevices(OutInputDevices?: InputDeviceId[]): {OutInputDevices: InputDeviceId[], $: number};
	static GetAllActiveUsers(OutUsers?: PlatformUserId[]): {OutUsers: PlatformUserId[], $: number};
	static EqualEqual_PlatformUserId(A: PlatformUserId,B: PlatformUserId): boolean;
	static EqualEqual_InputDeviceId(A: InputDeviceId,B: InputDeviceId): boolean;
	static C(Other: UObject | any): PlatformInputDeviceMapperLibrary;
}

declare class PlayerStart extends NavigationObjectBase { 
	PlayerStartTag: string;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): PlayerStart;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStart;
	static C(Other: UObject | any): PlayerStart;
}

declare class PlayerStartPIE extends PlayerStart { 
	static GetDefaultObject(): PlayerStartPIE;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStartPIE;
	static C(Other: UObject | any): PlayerStartPIE;
}

declare class PostProcessVolume extends Volume { 
	Settings: PostProcessSettings;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	bEnabled: boolean;
	bUnbound: boolean;
	static GetDefaultObject(): PostProcessVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PostProcessVolume;
	static C(Other: UObject | any): PostProcessVolume;
}

declare class PrecomputedVisibilityVolume extends Volume { 
	static GetDefaultObject(): PrecomputedVisibilityVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityVolume;
	static C(Other: UObject | any): PrecomputedVisibilityVolume;
}

declare class CollectionReference { 
	CollectionName: string;
	clone() : CollectionReference;
	static C(Other: UObject | any): CollectionReference;
}

declare class PrimaryAssetLabel extends PrimaryDataAsset { 
	Rules: PrimaryAssetRules;
	bLabelAssetsInMyDirectory: boolean;
	bIsRuntimeLabel: boolean;
	ExplicitAssets: UObject[];
	ExplicitBlueprints: Class[];
	AssetCollection: CollectionReference;
	static Load(ResourceName: string): PrimaryAssetLabel;
	static Find(Outer: UObject, ResourceName: string): PrimaryAssetLabel;
	static GetDefaultObject(): PrimaryAssetLabel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimaryAssetLabel;
	static C(Other: UObject | any): PrimaryAssetLabel;
}

declare class HealthSnapshotBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HealthSnapshotBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): HealthSnapshotBlueprintLibrary;
	static GetDefaultObject(): HealthSnapshotBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HealthSnapshotBlueprintLibrary;
	static StopPerformanceSnapshots(): void;
	static StartPerformanceSnapshots(): void;
	static LogPerformanceSnapshot(SnapshotTitle: string,bResetStats: boolean): void;
	static C(Other: UObject | any): HealthSnapshotBlueprintLibrary;
}

declare class ProxyLODMeshSimplificationSettings extends DeveloperSettings { 
	ProxyLODMeshReductionModuleName: string;
	static Load(ResourceName: string): ProxyLODMeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): ProxyLODMeshSimplificationSettings;
	static GetDefaultObject(): ProxyLODMeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProxyLODMeshSimplificationSettings;
	static C(Other: UObject | any): ProxyLODMeshSimplificationSettings;
}

declare class RectLight extends Light { 
	RectLightComponent: RectLightComponent;
	static GetDefaultObject(): RectLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectLight;
	static C(Other: UObject | any): RectLight;
}

declare type EMobileShadingPath = 'Forward' | 'Deferred' | 'EMobileShadingPath_MAX';
declare var EMobileShadingPath : { Forward:'Forward',Deferred:'Deferred',EMobileShadingPath_MAX:'EMobileShadingPath_MAX', };
declare type EMobileAntiAliasingMethod = 'None' | 'FXAA' | 'TemporalAA' | 'MSAA' | 'EMobileAntiAliasingMethod_MAX';
declare var EMobileAntiAliasingMethod : { None:'None',FXAA:'FXAA',TemporalAA:'TemporalAA',MSAA:'MSAA',EMobileAntiAliasingMethod_MAX:'EMobileAntiAliasingMethod_MAX', };
declare type EMobileFloatPrecisionMode = 'Half' | 'Full_MaterialExpressionOnly' | 'Full' | 'EMobileFloatPrecisionMode_MAX';
declare var EMobileFloatPrecisionMode : { Half:'Half',Full_MaterialExpressionOnly:'Full_MaterialExpressionOnly',Full:'Full',EMobileFloatPrecisionMode_MAX:'EMobileFloatPrecisionMode_MAX', };
declare type EShaderCompressionFormat = 'None' | 'LZ4' | 'Oodle' | 'Zlib' | 'EShaderCompressionFormat_MAX';
declare var EShaderCompressionFormat : { None:'None',LZ4:'LZ4',Oodle:'Oodle',Zlib:'Zlib',EShaderCompressionFormat_MAX:'EShaderCompressionFormat_MAX', };
declare type EWorkingColorSpace = 'sRGB' | 'Rec2020' | 'ACESAP0' | 'ACESAP1' | 'P3DCI' | 'P3D65' | 'Custom' | 'EWorkingColorSpace_MAX';
declare var EWorkingColorSpace : { sRGB:'sRGB',Rec2020:'Rec2020',ACESAP0:'ACESAP0',ACESAP1:'ACESAP1',P3DCI:'P3DCI',P3D65:'P3D65',Custom:'Custom',EWorkingColorSpace_MAX:'EWorkingColorSpace_MAX', };
declare type ELumenRayLightingMode = 'SurfaceCache' | 'HitLighting' | 'ELumenRayLightingMode_MAX';
declare var ELumenRayLightingMode : { SurfaceCache:'SurfaceCache',HitLighting:'HitLighting',ELumenRayLightingMode_MAX:'ELumenRayLightingMode_MAX', };
declare type ELumenSoftwareTracingMode = 'DetailTracing' | 'GlobalTracing' | 'ELumenSoftwareTracingMode_MAX';
declare var ELumenSoftwareTracingMode : { DetailTracing:'DetailTracing',GlobalTracing:'GlobalTracing',ELumenSoftwareTracingMode_MAX:'ELumenSoftwareTracingMode_MAX', };
declare type EShadowMapMethod = 'ShadowMaps' | 'VirtualShadowMaps' | 'EShadowMapMethod_MAX';
declare var EShadowMapMethod : { ShadowMaps:'ShadowMaps',VirtualShadowMaps:'VirtualShadowMaps',EShadowMapMethod_MAX:'EShadowMapMethod_MAX', };
declare type ETranslucentSortPolicy = 'SortByDistance' | 'SortByProjectedZ' | 'SortAlongAxis' | 'ETranslucentSortPolicy_MAX';
declare var ETranslucentSortPolicy : { SortByDistance:'SortByDistance',SortByProjectedZ:'SortByProjectedZ',SortAlongAxis:'SortAlongAxis',ETranslucentSortPolicy_MAX:'ETranslucentSortPolicy_MAX', };
declare type EFixedFoveationLevels = 'Disabled' | 'Low' | 'Medium' | 'High' | 'HighTop' | 'EFixedFoveationLevels_MAX';
declare var EFixedFoveationLevels : { Disabled:'Disabled',Low:'Low',Medium:'Medium',High:'High',HighTop:'HighTop',EFixedFoveationLevels_MAX:'EFixedFoveationLevels_MAX', };
declare type ECustomDepthStencil = 'Disabled' | 'Enabled' | 'EnabledOnDemand' | 'EnabledWithStencil' | 'ECustomDepthStencil_MAX';
declare var ECustomDepthStencil : { Disabled:'Disabled',Enabled:'Enabled',EnabledOnDemand:'EnabledOnDemand',EnabledWithStencil:'EnabledWithStencil',ECustomDepthStencil_MAX:'ECustomDepthStencil_MAX', };
declare type EAlphaChannelMode = 'Disabled' | 'LinearColorSpaceOnly' | 'AllowThroughTonemapper' | 'EAlphaChannelMode_MAX';
declare var EAlphaChannelMode : { Disabled:'Disabled',LinearColorSpaceOnly:'LinearColorSpaceOnly',AllowThroughTonemapper:'AllowThroughTonemapper',EAlphaChannelMode_MAX:'EAlphaChannelMode_MAX', };
declare type EAutoExposureMethodUI = 'AEM_Histogram' | 'AEM_Basic' | 'AEM_Manual' | 'AEM_MAX';
declare var EAutoExposureMethodUI : { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic',AEM_Manual:'AEM_Manual',AEM_MAX:'AEM_MAX', };
declare type EAntiAliasingMethod = 'AAM_None' | 'AAM_FXAA' | 'AAM_TemporalAA' | 'AAM_MSAA' | 'AAM_TSR' | 'AAM_MAX';
declare var EAntiAliasingMethod : { AAM_None:'AAM_None',AAM_FXAA:'AAM_FXAA',AAM_TemporalAA:'AAM_TemporalAA',AAM_MSAA:'AAM_MSAA',AAM_TSR:'AAM_TSR',AAM_MAX:'AAM_MAX', };
declare type ECompositingSampleCount = 'One' | 'Two' | 'Four' | 'Eight' | 'ECompositingSampleCount_MAX';
declare var ECompositingSampleCount : { One:'One',Two:'Two',Four:'Four',Eight:'Eight',ECompositingSampleCount_MAX:'ECompositingSampleCount_MAX', };
declare type EDefaultBackBufferPixelFormat = 'DBBPF_B8G8R8A8' | 'DBBPF_A16B16G16R16_DEPRECATED' | 'DBBPF_FloatRGB_DEPRECATED' | 'DBBPF_FloatRGBA' | 'DBBPF_A2B10G10R10' | 'DBBPF_MAX';
declare var EDefaultBackBufferPixelFormat : { DBBPF_B8G8R8A8:'DBBPF_B8G8R8A8',DBBPF_A16B16G16R16_DEPRECATED:'DBBPF_A16B16G16R16_DEPRECATED',DBBPF_FloatRGB_DEPRECATED:'DBBPF_FloatRGB_DEPRECATED',DBBPF_FloatRGBA:'DBBPF_FloatRGBA',DBBPF_A2B10G10R10:'DBBPF_A2B10G10R10',DBBPF_MAX:'DBBPF_MAX', };
declare type EEarlyZPass = 'None' | 'OpaqueOnly' | 'OpaqueAndMasked' | 'Auto' | 'EEarlyZPass_MAX';
declare var EEarlyZPass : { None:'None',OpaqueOnly:'OpaqueOnly',OpaqueAndMasked:'OpaqueAndMasked',Auto:'Auto',EEarlyZPass_MAX:'EEarlyZPass_MAX', };
declare type EClearSceneOptions = 'NoClear' | 'HardwareClear' | 'QuadAtMaxZ' | 'EClearSceneOptions_MAX';
declare var EClearSceneOptions : { NoClear:'NoClear',HardwareClear:'HardwareClear',QuadAtMaxZ:'QuadAtMaxZ',EClearSceneOptions_MAX:'EClearSceneOptions_MAX', };
declare type EVelocityOutputPass = 'DepthPass' | 'BasePass' | 'AfterBasePass' | 'EVelocityOutputPass_MAX';
declare var EVelocityOutputPass : { DepthPass:'DepthPass',BasePass:'BasePass',AfterBasePass:'AfterBasePass',EVelocityOutputPass_MAX:'EVelocityOutputPass_MAX', };
declare type EVertexDeformationOutputsVelocity = 'Off' | 'On' | 'Auto' | 'EVertexDeformationOutputsVelocity_MAX';
declare var EVertexDeformationOutputsVelocity : { Off:'Off',On:'On',Auto:'Auto',EVertexDeformationOutputsVelocity_MAX:'EVertexDeformationOutputsVelocity_MAX', };
declare type EGBufferFormat = 'Force8BitsPerChannel' | 'Default' | 'HighPrecisionNormals' | 'Force16BitsPerChannel' | 'EGBufferFormat_MAX';
declare var EGBufferFormat : { Force8BitsPerChannel:'Force8BitsPerChannel',Default:'Default',HighPrecisionNormals:'HighPrecisionNormals',Force16BitsPerChannel:'Force16BitsPerChannel',EGBufferFormat_MAX:'EGBufferFormat_MAX', };
declare type ESkinCacheDefaultBehavior = 'Exclusive' | 'Inclusive' | 'ESkinCacheDefaultBehavior_MAX';
declare var ESkinCacheDefaultBehavior : { Exclusive:'Exclusive',Inclusive:'Inclusive',ESkinCacheDefaultBehavior_MAX:'ESkinCacheDefaultBehavior_MAX', };
declare type EMobilePlanarReflectionMode = 'Usual' | 'MobilePPRExclusive' | 'MobilePPR' | 'EMobilePlanarReflectionMode_MAX';
declare var EMobilePlanarReflectionMode : { Usual:'Usual',MobilePPRExclusive:'MobilePPRExclusive',MobilePPR:'MobilePPR',EMobilePlanarReflectionMode_MAX:'EMobilePlanarReflectionMode_MAX', };
declare class RendererSettings extends DeveloperSettings { 
	MobileShadingPath: EMobileShadingPath;
	bMobileSupportGPUScene: boolean;
	MobileAntiAliasing: EMobileAntiAliasingMethod;
	MobileFloatPrecisionMode: EMobileFloatPrecisionMode;
	bMobileAllowDitheredLODTransition: boolean;
	bMobileVirtualTextures: boolean;
	bDiscardUnusedQualityLevels: boolean;
	ShaderCompressionFormat: EShaderCompressionFormat;
	bOcclusionCulling: boolean;
	MinScreenRadiusForLights: number;
	MinScreenRadiusForEarlyZPass: number;
	MinScreenRadiusForCSMdepth: number;
	bPrecomputedVisibilityWarning: boolean;
	bTextureStreaming: boolean;
	bUseDXT5NormalMaps: boolean;
	bVirtualTextures: boolean;
	bVirtualTextureEnableAutoImport: boolean;
	bVirtualTexturedLightmaps: boolean;
	bVirtualTextureAnisotropicFiltering: boolean;
	bEnableVirtualTextureOpacityMask: boolean;
	VirtualTextureTileSize: number;
	VirtualTextureTileBorderSize: number;
	VirtualTextureFeedbackFactor: number;
	WorkingColorSpaceChoice: EWorkingColorSpace;
	RedChromaticityCoordinate: Vector2D;
	GreenChromaticityCoordinate: Vector2D;
	BlueChromaticityCoordinate: Vector2D;
	WhiteChromaticityCoordinate: Vector2D;
	bClearCoatEnableSecondNormal: boolean;
	DynamicGlobalIllumination: EDynamicGlobalIlluminationMethod;
	Reflections: EReflectionMethod;
	ReflectionCaptureResolution: number;
	ReflectionEnvironmentLightmapMixBasedOnRoughness: boolean;
	bUseHardwareRayTracingForLumen: boolean;
	LumenRayLightingMode: ELumenRayLightingMode;
	LumenFrontLayerTranslucencyReflections: boolean;
	LumenSoftwareTracingMode: ELumenSoftwareTracingMode;
	ShadowMapMethod: EShadowMapMethod;
	bEnableRayTracing: boolean;
	bEnableRayTracingShadows: boolean;
	bEnableRayTracingSkylight: boolean;
	bEnableRayTracingTextureLOD: boolean;
	bEnablePathTracing: boolean;
	bGenerateMeshDistanceFields: boolean;
	DistanceFieldVoxelDensity: number;
	bNanite: boolean;
	bAllowStaticLighting: boolean;
	bUseNormalMapsForStaticLighting: boolean;
	bForwardShading: boolean;
	bVertexFoggingForOpaque: boolean;
	bSeparateTranslucency: boolean;
	TranslucentSortPolicy: ETranslucentSortPolicy;
	TranslucentSortAxis: Vector;
	HMDFixedFoveationLevel: EFixedFoveationLevels;
	bHMDFixedFoveationDynamic: boolean;
	CustomDepthStencil: ECustomDepthStencil;
	bCustomDepthTaaJitter: boolean;
	bEnableAlphaChannelInPostProcessing: EAlphaChannelMode;
	bDefaultFeatureBloom: boolean;
	bDefaultFeatureAmbientOcclusion: boolean;
	bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
	bDefaultFeatureAutoExposure: boolean;
	DefaultFeatureAutoExposure: EAutoExposureMethodUI;
	DefaultFeatureAutoExposureBias: number;
	bExtendDefaultLuminanceRangeInAutoExposureSettings: boolean;
	bDefaultFeatureMotionBlur: boolean;
	bDefaultFeatureLensFlare: boolean;
	bTemporalUpsampling: boolean;
	DefaultFeatureAntiAliasing: EAntiAliasingMethod;
	MSAASampleCount: ECompositingSampleCount;
	DefaultLightUnits: ELightUnits;
	DefaultBackBufferPixelFormat: EDefaultBackBufferPixelFormat;
	bRenderUnbuiltPreviewShadowsInGame: boolean;
	bStencilForLODDither: boolean;
	EarlyZPass: EEarlyZPass;
	bEarlyZPassOnlyMaterialMasking: boolean;
	bEnableCSMCaching: boolean;
	bDBuffer: boolean;
	ClearSceneMethod: EClearSceneOptions;
	VelocityPass: EVelocityOutputPass;
	VertexDeformationOutputsVelocity: EVertexDeformationOutputsVelocity;
	bSelectiveBasePassOutputs: boolean;
	bDefaultParticleCutouts: boolean;
	GPUSimulationTextureSizeX: number;
	GPUSimulationTextureSizeY: number;
	bGlobalClipPlane: boolean;
	GBufferFormat: EGBufferFormat;
	bUseGPUMorphTargets: boolean;
	bNvidiaAftermathEnabled: boolean;
	bMultiView: boolean;
	bMobilePostProcessing: boolean;
	bMobileMultiView: boolean;
	bMobileUseHWsRGBEncoding: boolean;
	bRoundRobinOcclusion: boolean;
	bMeshStreaming: boolean;
	bEnableHeterogeneousVolumes: boolean;
	WireframeCullThreshold: number;
	bSupportStationarySkylight: boolean;
	bSupportLowQualityLightmaps: boolean;
	bSupportPointLightWholeSceneShadows: boolean;
	bSupportSkyAtmosphere: boolean;
	bSupportSkyAtmosphereAffectsHeightFog: boolean;
	bSupportCloudShadowOnForwardLitTranslucent: boolean;
	bSupportTranslucentPerObjectShadow: boolean;
	bSupportCloudShadowOnSingleLayerWater: boolean;
	bEnableStrata: boolean;
	StrataBytePerPixel: number;
	StrataOpaqueMaterialRoughRefraction: boolean;
	StrataDebugAdvancedVisualizationShaders: boolean;
	bMaterialRoughDiffuse: boolean;
	bMaterialEnergyConservation: boolean;
	bOrderedIndependentTransparencyEnable: boolean;
	bSupportSkinCacheShaders: boolean;
	bSkipCompilingGPUSkinVF: boolean;
	DefaultSkinCacheBehavior: ESkinCacheDefaultBehavior;
	SkinCacheSceneMemoryLimitInMB: number;
	bMobileEnableStaticAndCSMShadowReceivers: boolean;
	bMobileEnableMovableLightCSMShaderCulling: boolean;
	bMobileForwardEnableLocalLights: boolean;
	bMobileForwardEnableClusteredReflections: boolean;
	bMobileEnableNoPrecomputedLightingCSMShader: boolean;
	bMobileAllowDistanceFieldShadows: boolean;
	bMobileAllowMovableDirectionalLights: boolean;
	bMobileAllowMovableSpotlightShadows: boolean;
	bSupport16BitBoneIndex: boolean;
	bGPUSkinLimit2BoneInfluences: boolean;
	bSupportDepthOnlyIndexBuffers: boolean;
	bSupportReversedIndexBuffers: boolean;
	bMobileAmbientOcclusion: boolean;
	bUseUnlimitedBoneInfluences: boolean;
	UnlimitedBonInfluencesThreshold: number;
	MaxSkinBones: PerPlatformInt;
	MobilePlanarReflectionMode: EMobilePlanarReflectionMode;
	bMobileSupportsGen4TAA: boolean;
	bStreamSkeletalMeshLODs: PerPlatformBool;
	bDiscardSkeletalMeshOptionalLODs: PerPlatformBool;
	VisualizeCalibrationColorMaterialPath: SoftObjectPath;
	VisualizeCalibrationCustomMaterialPath: SoftObjectPath;
	VisualizeCalibrationGrayscaleMaterialPath: SoftObjectPath;
	static Load(ResourceName: string): RendererSettings;
	static Find(Outer: UObject, ResourceName: string): RendererSettings;
	static GetDefaultObject(): RendererSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererSettings;
	static C(Other: UObject | any): RendererSettings;
}

declare class RendererOverrideSettings extends DeveloperSettings { 
	bSupportAllShaderPermutations: boolean;
	static Load(ResourceName: string): RendererOverrideSettings;
	static Find(Outer: UObject, ResourceName: string): RendererOverrideSettings;
	static GetDefaultObject(): RendererOverrideSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererOverrideSettings;
	static C(Other: UObject | any): RendererOverrideSettings;
}

declare class ReplayNetConnection extends NetConnection { 
	static Load(ResourceName: string): ReplayNetConnection;
	static Find(Outer: UObject, ResourceName: string): ReplayNetConnection;
	static GetDefaultObject(): ReplayNetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplayNetConnection;
	static C(Other: UObject | any): ReplayNetConnection;
}

declare class ReplaySubsystem extends GameInstanceSubsystem { 
	bLoadDefaultMapOnStop: boolean;
	static Load(ResourceName: string): ReplaySubsystem;
	static Find(Outer: UObject, ResourceName: string): ReplaySubsystem;
	static GetDefaultObject(): ReplaySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplaySubsystem;
	RequestCheckpoint(): void;
	IsRecording(): boolean;
	IsPlaying(): boolean;
	GetReplayCurrentTime(): number;
	GetActiveReplayName(): string;
	static C(Other: UObject | any): ReplaySubsystem;
}

declare class RuntimeOptionsBase extends UObject { 
	static Load(ResourceName: string): RuntimeOptionsBase;
	static Find(Outer: UObject, ResourceName: string): RuntimeOptionsBase;
	static GetDefaultObject(): RuntimeOptionsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeOptionsBase;
	static C(Other: UObject | any): RuntimeOptionsBase;
}

declare class SkeletalMeshSimplificationSettings extends DeveloperSettings { 
	SkeletalMeshReductionModuleName: string;
	static Load(ResourceName: string): SkeletalMeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshSimplificationSettings;
	static GetDefaultObject(): SkeletalMeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSimplificationSettings;
	static C(Other: UObject | any): SkeletalMeshSimplificationSettings;
}

declare class ButtonStyleAsset extends UObject { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonStyleAsset;
	static Find(Outer: UObject, ResourceName: string): ButtonStyleAsset;
	static GetDefaultObject(): ButtonStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonStyleAsset;
	static C(Other: UObject | any): ButtonStyleAsset;
}

declare class CheckBoxStyleAsset extends UObject { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxStyleAsset;
	static Find(Outer: UObject, ResourceName: string): CheckBoxStyleAsset;
	static GetDefaultObject(): CheckBoxStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxStyleAsset;
	static C(Other: UObject | any): CheckBoxStyleAsset;
}

declare class SlateTextureAtlasInterface extends Interface { 
	static Load(ResourceName: string): SlateTextureAtlasInterface;
	static Find(Outer: UObject, ResourceName: string): SlateTextureAtlasInterface;
	static GetDefaultObject(): SlateTextureAtlasInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTextureAtlasInterface;
	static C(Other: UObject | any): SlateTextureAtlasInterface;
}

declare class SoundNodeAssetReferencer extends SoundNode { 
	static Load(ResourceName: string): SoundNodeAssetReferencer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAssetReferencer;
	static GetDefaultObject(): SoundNodeAssetReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAssetReferencer;
	static C(Other: UObject | any): SoundNodeAssetReferencer;
}

declare class SoundNodeAttenuation extends SoundNode { 
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	bOverrideAttenuation: boolean;
	static Load(ResourceName: string): SoundNodeAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAttenuation;
	static GetDefaultObject(): SoundNodeAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAttenuation;
	static C(Other: UObject | any): SoundNodeAttenuation;
}

declare class SoundNodeBranch extends SoundNode { 
	BoolParameterName: string;
	static Load(ResourceName: string): SoundNodeBranch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeBranch;
	static GetDefaultObject(): SoundNodeBranch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeBranch;
	static C(Other: UObject | any): SoundNodeBranch;
}

declare class SoundNodeConcatenator extends SoundNode { 
	InputVolume: number[];
	static Load(ResourceName: string): SoundNodeConcatenator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeConcatenator;
	static GetDefaultObject(): SoundNodeConcatenator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeConcatenator;
	static C(Other: UObject | any): SoundNodeConcatenator;
}

declare class SoundNodeDelay extends SoundNode { 
	DelayMin: number;
	DelayMax: number;
	static Load(ResourceName: string): SoundNodeDelay;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDelay;
	static GetDefaultObject(): SoundNodeDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDelay;
	static C(Other: UObject | any): SoundNodeDelay;
}

declare class DialogueWaveParameter { 
	DialogueWave: DialogueWave;
	Context: DialogueContext;
	clone() : DialogueWaveParameter;
	static C(Other: UObject | any): DialogueWaveParameter;
}

declare class SoundNodeDialoguePlayer extends SoundNode { 
	DialogueWaveParameter: DialogueWaveParameter;
	bLooping: boolean;
	static Load(ResourceName: string): SoundNodeDialoguePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDialoguePlayer;
	static GetDefaultObject(): SoundNodeDialoguePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDialoguePlayer;
	static C(Other: UObject | any): SoundNodeDialoguePlayer;
}

declare class DistanceDatum { 
	FadeInDistanceStart: number;
	FadeInDistanceEnd: number;
	FadeOutDistanceStart: number;
	FadeOutDistanceEnd: number;
	Volume: number;
	clone() : DistanceDatum;
	static C(Other: UObject | any): DistanceDatum;
}

declare class SoundNodeDistanceCrossFade extends SoundNode { 
	CrossFadeInput: DistanceDatum[];
	static Load(ResourceName: string): SoundNodeDistanceCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDistanceCrossFade;
	static GetDefaultObject(): SoundNodeDistanceCrossFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDistanceCrossFade;
	static C(Other: UObject | any): SoundNodeDistanceCrossFade;
}

declare class SoundNodeDoppler extends SoundNode { 
	DopplerIntensity: number;
	bUseSmoothing: boolean;
	SmoothingInterpSpeed: number;
	static Load(ResourceName: string): SoundNodeDoppler;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDoppler;
	static GetDefaultObject(): SoundNodeDoppler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDoppler;
	static C(Other: UObject | any): SoundNodeDoppler;
}

declare class SoundNodeEnveloper extends SoundNode { 
	LoopStart: number;
	LoopEnd: number;
	DurationAfterLoop: number;
	LoopCount: number;
	bLoopIndefinitely: boolean;
	bLoop: boolean;
	VolumeInterpCurve: DistributionFloatConstantCurve;
	PitchInterpCurve: DistributionFloatConstantCurve;
	VolumeCurve: RuntimeFloatCurve;
	PitchCurve: RuntimeFloatCurve;
	PitchMin: number;
	PitchMax: number;
	VolumeMin: number;
	VolumeMax: number;
	static Load(ResourceName: string): SoundNodeEnveloper;
	static Find(Outer: UObject, ResourceName: string): SoundNodeEnveloper;
	static GetDefaultObject(): SoundNodeEnveloper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeEnveloper;
	static C(Other: UObject | any): SoundNodeEnveloper;
}

declare class SoundNodeGroupControl extends SoundNode { 
	GroupSizes: number[];
	static Load(ResourceName: string): SoundNodeGroupControl;
	static Find(Outer: UObject, ResourceName: string): SoundNodeGroupControl;
	static GetDefaultObject(): SoundNodeGroupControl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeGroupControl;
	static C(Other: UObject | any): SoundNodeGroupControl;
}

declare class SoundNodeLooping extends SoundNode { 
	LoopCount: number;
	bLoopIndefinitely: boolean;
	static Load(ResourceName: string): SoundNodeLooping;
	static Find(Outer: UObject, ResourceName: string): SoundNodeLooping;
	static GetDefaultObject(): SoundNodeLooping;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeLooping;
	static C(Other: UObject | any): SoundNodeLooping;
}

declare class SoundNodeMature extends SoundNode { 
	static Load(ResourceName: string): SoundNodeMature;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMature;
	static GetDefaultObject(): SoundNodeMature;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMature;
	static C(Other: UObject | any): SoundNodeMature;
}

declare class SoundNodeMixer extends SoundNode { 
	InputVolume: number[];
	static Load(ResourceName: string): SoundNodeMixer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMixer;
	static GetDefaultObject(): SoundNodeMixer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMixer;
	static C(Other: UObject | any): SoundNodeMixer;
}

declare class SoundNodeModulator extends SoundNode { 
	PitchMin: number;
	PitchMax: number;
	VolumeMin: number;
	VolumeMax: number;
	static Load(ResourceName: string): SoundNodeModulator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulator;
	static GetDefaultObject(): SoundNodeModulator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulator;
	static C(Other: UObject | any): SoundNodeModulator;
}

declare class SoundNodeOscillator extends SoundNode { 
	bModulateVolume: boolean;
	bModulatePitch: boolean;
	AmplitudeMin: number;
	AmplitudeMax: number;
	FrequencyMin: number;
	FrequencyMax: number;
	OffsetMin: number;
	OffsetMax: number;
	CenterMin: number;
	CenterMax: number;
	static Load(ResourceName: string): SoundNodeOscillator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeOscillator;
	static GetDefaultObject(): SoundNodeOscillator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeOscillator;
	static C(Other: UObject | any): SoundNodeOscillator;
}

declare class SoundNodeParamCrossFade extends SoundNodeDistanceCrossFade { 
	ParamName: string;
	static Load(ResourceName: string): SoundNodeParamCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeParamCrossFade;
	static GetDefaultObject(): SoundNodeParamCrossFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeParamCrossFade;
	static C(Other: UObject | any): SoundNodeParamCrossFade;
}

declare class SoundNodeQualityLevel extends SoundNode { 
	CookedQualityLevelIndex: number;
	static Load(ResourceName: string): SoundNodeQualityLevel;
	static Find(Outer: UObject, ResourceName: string): SoundNodeQualityLevel;
	static GetDefaultObject(): SoundNodeQualityLevel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeQualityLevel;
	static C(Other: UObject | any): SoundNodeQualityLevel;
}

declare class SoundNodeRandom extends SoundNode { 
	Weights: number[];
	HasBeenUsed: boolean[];
	NumRandomUsed: number;
	PreselectAtLevelLoad: number;
	bShouldExcludeFromBranchCulling: boolean;
	bSoundCueExcludedFromBranchCulling: boolean;
	bRandomizeWithoutReplacement: boolean;
	PIEHiddenNodes: number[];
	static Load(ResourceName: string): SoundNodeRandom;
	static Find(Outer: UObject, ResourceName: string): SoundNodeRandom;
	static GetDefaultObject(): SoundNodeRandom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeRandom;
	static C(Other: UObject | any): SoundNodeRandom;
}

declare class SoundNodeSoundClass extends SoundNode { 
	SoundClassOverride: SoundClass;
	static Load(ResourceName: string): SoundNodeSoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSoundClass;
	static GetDefaultObject(): SoundNodeSoundClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSoundClass;
	static C(Other: UObject | any): SoundNodeSoundClass;
}

declare class SoundNodeSwitch extends SoundNode { 
	IntParameterName: string;
	static Load(ResourceName: string): SoundNodeSwitch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSwitch;
	static GetDefaultObject(): SoundNodeSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSwitch;
	static C(Other: UObject | any): SoundNodeSwitch;
}

declare class SoundNodeWaveParam extends SoundNode { 
	WaveParameterName: string;
	static Load(ResourceName: string): SoundNodeWaveParam;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWaveParam;
	static GetDefaultObject(): SoundNodeWaveParam;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWaveParam;
	static C(Other: UObject | any): SoundNodeWaveParam;
}

declare class SoundNodeWavePlayer extends SoundNodeAssetReferencer { 
	SoundWaveAssetPtr: SoundWave;
	SoundWave: SoundWave;
	bLooping: boolean;
	static Load(ResourceName: string): SoundNodeWavePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWavePlayer;
	static GetDefaultObject(): SoundNodeWavePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWavePlayer;
	static C(Other: UObject | any): SoundNodeWavePlayer;
}

declare class SoundfieldSubmix extends SoundSubmixWithParentBase { 
	SoundfieldEncodingFormat: string;
	EncodingSettings: SoundfieldEncodingSettingsBase;
	SoundfieldEffectChain: SoundfieldEffectBase[];
	EncodingSettingsClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundfieldSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundfieldSubmix;
	static GetDefaultObject(): SoundfieldSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldSubmix;
	static C(Other: UObject | any): SoundfieldSubmix;
}

declare class EndpointSubmix extends SoundSubmixBase { 
	EndpointType: string;
	EndpointSettingsClass: UnrealEngineClass;
	EndpointSettings: AudioEndpointSettingsBase;
	static Load(ResourceName: string): EndpointSubmix;
	static Find(Outer: UObject, ResourceName: string): EndpointSubmix;
	static GetDefaultObject(): EndpointSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndpointSubmix;
	static C(Other: UObject | any): EndpointSubmix;
}

declare class SoundfieldEndpointSubmix extends SoundSubmixBase { 
	SoundfieldEndpointType: string;
	EndpointSettingsClass: UnrealEngineClass;
	EndpointSettings: SoundfieldEndpointSettingsBase;
	EncodingSettingsClass: UnrealEngineClass;
	EncodingSettings: SoundfieldEncodingSettingsBase;
	SoundfieldEffectChain: SoundfieldEffectBase[];
	static Load(ResourceName: string): SoundfieldEndpointSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSubmix;
	static GetDefaultObject(): SoundfieldEndpointSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSubmix;
	static C(Other: UObject | any): SoundfieldEndpointSubmix;
}

declare class SpectatorPawnMovement extends FloatingPawnMovement { 
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): SpectatorPawnMovement;
	static Find(Outer: UObject, ResourceName: string): SpectatorPawnMovement;
	static GetDefaultObject(): SpectatorPawnMovement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawnMovement;
	static C(Other: UObject | any): SpectatorPawnMovement;
}

declare class SplineMeshActor extends Actor { 
	SplineMeshComponent: SplineMeshComponent;
	static GetDefaultObject(): SplineMeshActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshActor;
	static C(Other: UObject | any): SplineMeshActor;
}

declare class StereoLayerFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): StereoLayerFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): StereoLayerFunctionLibrary;
	static GetDefaultObject(): StereoLayerFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerFunctionLibrary;
	static ShowSplashScreen(): void;
	static SetSplashScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static HideSplashScreen(): void;
	static EnableAutoLoadingSplashScreen(InAutoShowEnabled: boolean): void;
	static C(Other: UObject | any): StereoLayerFunctionLibrary;
}

declare class StreamableTexture { 
	Name: string;
	Guid: Guid;
	clone() : StreamableTexture;
	static C(Other: UObject | any): StreamableTexture;
}

declare class ActorTextureStreamingBuildDataComponent extends ActorComponent { 
	StreamableTextures: StreamableTexture[];
	PackedTextureStreamingQualityLevelFeatureLevel: number;
	static Load(ResourceName: string): ActorTextureStreamingBuildDataComponent;
	static Find(Outer: UObject, ResourceName: string): ActorTextureStreamingBuildDataComponent;
	static GetDefaultObject(): ActorTextureStreamingBuildDataComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTextureStreamingBuildDataComponent;
	static C(Other: UObject | any): ActorTextureStreamingBuildDataComponent;
}

declare class TextureMipDataProviderFactory extends AssetUserData { 
	static Load(ResourceName: string): TextureMipDataProviderFactory;
	static Find(Outer: UObject, ResourceName: string): TextureMipDataProviderFactory;
	static GetDefaultObject(): TextureMipDataProviderFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureMipDataProviderFactory;
	static C(Other: UObject | any): TextureMipDataProviderFactory;
}

declare class AudioSubsystemCollectionRoot extends UObject { 
	static Load(ResourceName: string): AudioSubsystemCollectionRoot;
	static Find(Outer: UObject, ResourceName: string): AudioSubsystemCollectionRoot;
	static GetDefaultObject(): AudioSubsystemCollectionRoot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSubsystemCollectionRoot;
	static C(Other: UObject | any): AudioSubsystemCollectionRoot;
}

declare class SubsystemBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubsystemBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SubsystemBlueprintLibrary;
	static GetDefaultObject(): SubsystemBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsystemBlueprintLibrary;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static GetLocalPlayerSubSystemFromPlayerController(PlayerController: PlayerController,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetEngineSubsystem(Class: UnrealEngineClass): EngineSubsystem;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static C(Other: UObject | any): SubsystemBlueprintLibrary;
}

declare class TargetPoint extends Actor { 
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): TargetPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TargetPoint;
	static C(Other: UObject | any): TargetPoint;
}

declare class EditorMapPerformanceTestDefinition { 
	PerformanceTestmap: SoftObjectPath;
	TestTimer: number;
	clone() : EditorMapPerformanceTestDefinition;
	static C(Other: UObject | any): EditorMapPerformanceTestDefinition;
}

declare class ImportFactorySettingValues { 
	SettingName: string;
	Value: string;
	clone() : ImportFactorySettingValues;
	static C(Other: UObject | any): ImportFactorySettingValues;
}

declare class EditorImportWorkflowDefinition { 
	ImportFilePath: FilePath;
	FactorySettings: ImportFactorySettingValues[];
	clone() : EditorImportWorkflowDefinition;
	static C(Other: UObject | any): EditorImportWorkflowDefinition;
}

declare class BuildPromotionImportWorkflowSettings { 
	Diffuse: EditorImportWorkflowDefinition;
	Normal: EditorImportWorkflowDefinition;
	StaticMesh: EditorImportWorkflowDefinition;
	ReimportStaticMesh: EditorImportWorkflowDefinition;
	BlendShapeMesh: EditorImportWorkflowDefinition;
	MorphMesh: EditorImportWorkflowDefinition;
	SkeletalMesh: EditorImportWorkflowDefinition;
	Animation: EditorImportWorkflowDefinition;
	Sound: EditorImportWorkflowDefinition;
	SurroundSound: EditorImportWorkflowDefinition;
	OtherAssetsToImport: EditorImportWorkflowDefinition[];
	clone() : BuildPromotionImportWorkflowSettings;
	static C(Other: UObject | any): BuildPromotionImportWorkflowSettings;
}

declare class BuildPromotionOpenAssetSettings { 
	BlueprintAsset: FilePath;
	MaterialAsset: FilePath;
	ParticleSystemAsset: FilePath;
	SkeletalMeshAsset: FilePath;
	StaticMeshAsset: FilePath;
	TextureAsset: FilePath;
	clone() : BuildPromotionOpenAssetSettings;
	static C(Other: UObject | any): BuildPromotionOpenAssetSettings;
}

declare class BuildPromotionNewProjectSettings { 
	NewProjectFolderOverride: DirectoryPath;
	NewProjectNameOverride: string;
	clone() : BuildPromotionNewProjectSettings;
	static C(Other: UObject | any): BuildPromotionNewProjectSettings;
}

declare class BuildPromotionTestSettings { 
	DefaultStaticMeshAsset: FilePath;
	ImportWorkflow: BuildPromotionImportWorkflowSettings;
	OpenAssets: BuildPromotionOpenAssetSettings;
	NewProjectSettings: BuildPromotionNewProjectSettings;
	SourceControlMaterial: FilePath;
	clone() : BuildPromotionTestSettings;
	static C(Other: UObject | any): BuildPromotionTestSettings;
}

declare class MaterialEditorPromotionSettings { 
	DefaultMaterialAsset: FilePath;
	DefaultDiffuseTexture: FilePath;
	DefaultNormalTexture: FilePath;
	clone() : MaterialEditorPromotionSettings;
	static C(Other: UObject | any): MaterialEditorPromotionSettings;
}

declare class ParticleEditorPromotionSettings { 
	DefaultParticleAsset: FilePath;
	clone() : ParticleEditorPromotionSettings;
	static C(Other: UObject | any): ParticleEditorPromotionSettings;
}

declare class BlueprintEditorPromotionSettings { 
	FirstMeshPath: FilePath;
	SecondMeshPath: FilePath;
	DefaultParticleAsset: FilePath;
	clone() : BlueprintEditorPromotionSettings;
	static C(Other: UObject | any): BlueprintEditorPromotionSettings;
}

declare class ExternalToolDefinition { 
	ToolName: string;
	ExecutablePath: FilePath;
	CommandLineOptions: string;
	WorkingDirectory: DirectoryPath;
	ScriptExtension: string;
	ScriptDirectory: DirectoryPath;
	clone() : ExternalToolDefinition;
	static C(Other: UObject | any): ExternalToolDefinition;
}

declare class EditorImportExportTestDefinition { 
	ImportFilePath: FilePath;
	ExportFileExtension: string;
	bSkipExport: boolean;
	FactorySettings: ImportFactorySettingValues[];
	clone() : EditorImportExportTestDefinition;
	static C(Other: UObject | any): EditorImportExportTestDefinition;
}

declare class LaunchOnTestSettings { 
	LaunchOnTestmap: FilePath;
	DeviceID: string;
	clone() : LaunchOnTestSettings;
	static C(Other: UObject | any): LaunchOnTestSettings;
}

declare class AutomationTestSettings extends UObject { 
	EngineTestModules: string[];
	EditorTestModules: string[];
	AutomationTestmap: SoftObjectPath;
	EditorPerformanceTestMaps: EditorMapPerformanceTestDefinition[];
	AssetsToOpen: string[];
	MapsToPIETest: string[];
	bUseAllProjectMapsToPlayInPIE: boolean;
	BuildPromotionTest: BuildPromotionTestSettings;
	MaterialEditorPromotionTest: MaterialEditorPromotionSettings;
	ParticleEditorPromotionTest: ParticleEditorPromotionSettings;
	BlueprintEditorPromotionTest: BlueprintEditorPromotionSettings;
	TestLevelFolders: string[];
	ExternalTools: ExternalToolDefinition[];
	ImportExportTestDefinitions: EditorImportExportTestDefinition[];
	LaunchOnSettings: LaunchOnTestSettings[];
	DefaultScreenshotResolution: IntPoint;
	PIETestDuration: number;
	DefaultInteractiveFramerate: number;
	DefaultInteractiveFramerateWaitTime: number;
	DefaultInteractiveFramerateDuration: number;
	static Load(ResourceName: string): AutomationTestSettings;
	static Find(Outer: UObject, ResourceName: string): AutomationTestSettings;
	static GetDefaultObject(): AutomationTestSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationTestSettings;
	static C(Other: UObject | any): AutomationTestSettings;
}

declare class TransactionDiffingTestObject extends UObject { 
	NamesArray: string[];
	AdditionalName: string;
	ObjectsArray: UObject[];
	AdditionalObject: UObject;
	SoftObjectsArray: UObject[];
	AdditionalSoftObject: UObject;
	PropertyData: number;
	static Load(ResourceName: string): TransactionDiffingTestObject;
	static Find(Outer: UObject, ResourceName: string): TransactionDiffingTestObject;
	static GetDefaultObject(): TransactionDiffingTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransactionDiffingTestObject;
	static C(Other: UObject | any): TransactionDiffingTestObject;
}

declare class TextureCubeArray extends Texture { 
	SourceTextures: TextureCube[];
	bSourceGeneratedFromSourceTexturesArray: boolean;
	static Load(ResourceName: string): TextureCubeArray;
	static Find(Outer: UObject, ResourceName: string): TextureCubeArray;
	static GetDefaultObject(): TextureCubeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCubeArray;
	static C(Other: UObject | any): TextureCubeArray;
}

declare type ETextureEncodeEffort = 'Default' | 'Low' | 'Normal' | 'High' | 'ETextureEncodeEffort_MAX';
declare var ETextureEncodeEffort : { Default:'Default',Low:'Low',Normal:'Normal',High:'High',ETextureEncodeEffort_MAX:'ETextureEncodeEffort_MAX', };
declare type ETextureUniversalTiling = 'Disabled' | 'Enabled_256KB' | 'Enabled_64KB' | 'ETextureUniversalTiling_MAX';
declare var ETextureUniversalTiling : { Disabled:'Disabled',Enabled_256KB:'Enabled_256KB',Enabled_64KB:'Enabled_64KB',ETextureUniversalTiling_MAX:'ETextureUniversalTiling_MAX', };
declare type ETextureEncodeSpeed = 'Final' | 'FinalIfAvailable' | 'Fast' | 'ETextureEncodeSpeed_MAX';
declare var ETextureEncodeSpeed : { Final:'Final',FinalIfAvailable:'FinalIfAvailable',Fast:'Fast',ETextureEncodeSpeed_MAX:'ETextureEncodeSpeed_MAX', };
declare class TextureEncodingProjectSettings extends DeveloperSettings { 
	bFinalUsesRDO: boolean;
	FinalRDOLambda: number;
	FinalEffortLevel: ETextureEncodeEffort;
	FinalUniversalTiling: ETextureUniversalTiling;
	bFastUsesRDO: boolean;
	FastRDOLambda: number;
	FastEffortLevel: ETextureEncodeEffort;
	FastUniversalTiling: ETextureUniversalTiling;
	CookUsesSpeed: ETextureEncodeSpeed;
	EditorUsesSpeed: ETextureEncodeSpeed;
	static Load(ResourceName: string): TextureEncodingProjectSettings;
	static Find(Outer: UObject, ResourceName: string): TextureEncodingProjectSettings;
	static GetDefaultObject(): TextureEncodingProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureEncodingProjectSettings;
	static C(Other: UObject | any): TextureEncodingProjectSettings;
}

declare type ETextureEncodeSpeedOverride = 'Disabled' | 'Final' | 'FinalIfAvailable' | 'Fast' | 'ETextureEncodeSpeedOverride_MAX';
declare var ETextureEncodeSpeedOverride : { Disabled:'Disabled',Final:'Final',FinalIfAvailable:'FinalIfAvailable',Fast:'Fast',ETextureEncodeSpeedOverride_MAX:'ETextureEncodeSpeedOverride_MAX', };
declare class TextureEncodingUserSettings extends DeveloperSettings { 
	ForceEncodeSpeed: ETextureEncodeSpeedOverride;
	static Load(ResourceName: string): TextureEncodingUserSettings;
	static Find(Outer: UObject, ResourceName: string): TextureEncodingUserSettings;
	static GetDefaultObject(): TextureEncodingUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureEncodingUserSettings;
	static C(Other: UObject | any): TextureEncodingUserSettings;
}

declare class TriggerVolume extends Volume { 
	static GetDefaultObject(): TriggerVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerVolume;
	static C(Other: UObject | any): TriggerVolume;
}

declare class UserDefinedEnum extends Enum { 
	UniqueNameIndex: number;
	EnumDescription: string;
	DisplayNameMap: Map<string, string>;
	CachedCookedMetaDataPtr: EnumCookedMetaData;
	static Load(ResourceName: string): UserDefinedEnum;
	static Find(Outer: UObject, ResourceName: string): UserDefinedEnum;
	static GetDefaultObject(): UserDefinedEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedEnum;
	static C(Other: UObject | any): UserDefinedEnum;
}

declare type ERenderFocusRule = 'Always' | 'NonPointer' | 'NavigationOnly' | 'Never' | 'ERenderFocusRule_MAX';
declare var ERenderFocusRule : { Always:'Always',NonPointer:'NonPointer',NavigationOnly:'NavigationOnly',Never:'Never',ERenderFocusRule_MAX:'ERenderFocusRule_MAX', };
declare class HardwareCursorReference { 
	CursorPath: string;
	Hotspot: Vector2D;
	clone() : HardwareCursorReference;
	static C(Other: UObject | any): HardwareCursorReference;
}

declare type EUIScalingRule = 'ShortestSide' | 'LongestSide' | 'Horizontal' | 'Vertical' | 'ScaleToFit' | 'Custom' | 'EUIScalingRule_MAX';
declare var EUIScalingRule : { ShortestSide:'ShortestSide',LongestSide:'LongestSide',Horizontal:'Horizontal',Vertical:'Vertical',ScaleToFit:'ScaleToFit',Custom:'Custom',EUIScalingRule_MAX:'EUIScalingRule_MAX', };
declare class UserInterfaceSettings extends DeveloperSettings { 
	RenderFocusRule: ERenderFocusRule;
	HardwareCursors: Map<EMouseCursor, HardwareCursorReference>;
	SoftwareCursors: Map<EMouseCursor, SoftClassPath>;
	DefaultCursor: SoftClassPath;
	TextEditBeamCursor: SoftClassPath;
	CrosshairsCursor: SoftClassPath;
	HandCursor: SoftClassPath;
	GrabHandCursor: SoftClassPath;
	GrabHandClosedCursor: SoftClassPath;
	SlashedCircleCursor: SoftClassPath;
	ApplicationScale: number;
	UIScaleRule: EUIScalingRule;
	CustomScalingRuleClass: SoftClassPath;
	UIScaleCurve: RuntimeFloatCurve;
	bAllowHighDPIInGameMode: boolean;
	DesignScreenSize: IntPoint;
	bLoadWidgetsOnDedicatedServer: boolean;
	CursorClasses: UObject[];
	CustomScalingRuleClassInstance: UnrealEngineClass;
	CustomScalingRule: DPICustomScalingRule;
	static Load(ResourceName: string): UserInterfaceSettings;
	static Find(Outer: UObject, ResourceName: string): UserInterfaceSettings;
	static GetDefaultObject(): UserInterfaceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserInterfaceSettings;
	static C(Other: UObject | any): UserInterfaceSettings;
}

declare class InputAxisProperties { 
	DeadZone: number;
	Sensitivity: number;
	Exponent: number;
	bInvert: boolean;
	clone() : InputAxisProperties;
	static C(Other: UObject | any): InputAxisProperties;
}

declare class InputAxisConfigEntry { 
	AxisKeyName: string;
	AxisProperties: InputAxisProperties;
	clone() : InputAxisConfigEntry;
	static C(Other: UObject | any): InputAxisConfigEntry;
}

declare class InputActionKeyMapping { 
	ActionName: string;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	Key: Key;
	clone() : InputActionKeyMapping;
	static C(Other: UObject | any): InputActionKeyMapping;
}

declare class InputAxisKeyMapping { 
	AxisName: string;
	Scale: number;
	Key: Key;
	clone() : InputAxisKeyMapping;
	static C(Other: UObject | any): InputAxisKeyMapping;
}

declare class InputActionSpeechMapping { 
	ActionName: string;
	SpeechKeyword: string;
	clone() : InputActionSpeechMapping;
	static C(Other: UObject | any): InputActionSpeechMapping;
}

declare class InputSettings extends UObject { 
	AxisConfig: InputAxisConfigEntry[];
	bAltEnterTogglesFullscreen: boolean;
	bF11TogglesFullscreen: boolean;
	bUseMouseForTouch: boolean;
	bEnableMouseSmoothing: boolean;
	bEnableFOVScaling: boolean;
	bCaptureMouseOnLaunch: boolean;
	bEnableLegacyInputScales: boolean;
	bEnableMotionControls: boolean;
	bFilterInputByPlatformUser: boolean;
	bShouldFlushPressedKeysOnViewportFocusLost: boolean;
	bEnableDynamicComponentInputBinding: boolean;
	bAlwaysShowTouchInterface: boolean;
	bShowConsoleOnFourFingerTap: boolean;
	bEnableGestureRecognizer: boolean;
	bUseAutocorrect: boolean;
	ExcludedAutocorrectOS: string[];
	ExcludedAutocorrectCultures: string[];
	ExcludedAutocorrectDeviceModels: string[];
	DefaultViewportMouseCaptureMode: EMouseCaptureMode;
	DefaultViewportMouseLockMode: EMouseLockMode;
	FOVScale: number;
	DoubleClickTime: number;
	ActionMappings: InputActionKeyMapping[];
	AxisMappings: InputAxisKeyMapping[];
	SpeechMappings: InputActionSpeechMapping[];
	DefaultPlayerInputClass: Class;
	DefaultInputComponentClass: Class;
	DefaultTouchInterface: SoftObjectPath;
	ConsoleKeys: Key[];
	static Load(ResourceName: string): InputSettings;
	static Find(Outer: UObject, ResourceName: string): InputSettings;
	static GetDefaultObject(): InputSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputSettings;
	SaveKeyMappings(): void;
	RemoveAxisMapping(KeyMapping: InputAxisKeyMapping,bForceRebuildKeymaps: boolean): void;
	RemoveActionMapping(KeyMapping: InputActionKeyMapping,bForceRebuildKeymaps: boolean): void;
	static GetInputSettings(): InputSettings;
	GetAxisNames(AxisNames?: string[]): {AxisNames: string[]};
	GetAxisMappingByName(InAxisName: string,OutMappings?: InputAxisKeyMapping[]): {OutMappings: InputAxisKeyMapping[]};
	GetActionNames(ActionNames?: string[]): {ActionNames: string[]};
	GetActionMappingByName(InActionName: string,OutMappings?: InputActionKeyMapping[]): {OutMappings: InputActionKeyMapping[]};
	ForceRebuildKeymaps(): void;
	AddAxisMapping(KeyMapping: InputAxisKeyMapping,bForceRebuildKeymaps: boolean): void;
	AddActionMapping(KeyMapping: InputActionKeyMapping,bForceRebuildKeymaps: boolean): void;
	static C(Other: UObject | any): InputSettings;
}

declare class VectorFieldVolume extends Actor { 
	VectorFieldComponent: VectorFieldComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): VectorFieldVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldVolume;
	static C(Other: UObject | any): VectorFieldVolume;
}

declare class TireType extends DataAsset { 
	FrictionScale: number;
	static Load(ResourceName: string): TireType;
	static Find(Outer: UObject, ResourceName: string): TireType;
	static GetDefaultObject(): TireType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TireType;
	static C(Other: UObject | any): TireType;
}

declare class VisualLoggerAutomationTests extends UObject { 
	static Load(ResourceName: string): VisualLoggerAutomationTests;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerAutomationTests;
	static GetDefaultObject(): VisualLoggerAutomationTests;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerAutomationTests;
	static C(Other: UObject | any): VisualLoggerAutomationTests;
}

declare class VisualLoggerFilterVolume extends Volume { 
	static GetDefaultObject(): VisualLoggerFilterVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerFilterVolume;
	static C(Other: UObject | any): VisualLoggerFilterVolume;
}

declare class VisualLoggerKismetLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): VisualLoggerKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerKismetLibrary;
	static GetDefaultObject(): VisualLoggerKismetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerKismetLibrary;
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static LogText(WorldContextObject: UObject,Text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogSegment(WorldContextObject: UObject,SegmentStart: Vector,SegmentEnd: Vector,Text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	static LogLocation(WorldContextObject: UObject,Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogBox(WorldContextObject: UObject,BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	static EnableRecording(bEnabled: boolean): void;
	static C(Other: UObject | any): VisualLoggerKismetLibrary;
}

declare class VoiceChannel extends Channel { 
	static Load(ResourceName: string): VoiceChannel;
	static Find(Outer: UObject, ResourceName: string): VoiceChannel;
	static GetDefaultObject(): VoiceChannel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VoiceChannel;
	static C(Other: UObject | any): VoiceChannel;
}

declare class VoiceSettings { 
	ComponentToAttachTo: SceneComponent;
	AttenuationSettings: SoundAttenuation;
	SourceEffectChain: SoundEffectSourcePresetChain;
	clone() : VoiceSettings;
	static C(Other: UObject | any): VoiceSettings;
}

declare class VOIPTalker extends ActorComponent { 
	Settings: VoiceSettings;
	static Load(ResourceName: string): VOIPTalker;
	static Find(Outer: UObject, ResourceName: string): VOIPTalker;
	static GetDefaultObject(): VOIPTalker;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VOIPTalker;
	RegisterWithPlayerState(OwningState: PlayerState): void;
	GetVoiceLevel(): number;
	static CreateTalkerForPlayer(OwningState: PlayerState): VOIPTalker;
	BPOnTalkingEnd(): void;
	BPOnTalkingBegin(AudioComponent: AudioComponent): void;
	static C(Other: UObject | any): VOIPTalker;
}

declare class VOIPStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): VOIPStatics;
	static Find(Outer: UObject, ResourceName: string): VOIPStatics;
	static GetDefaultObject(): VOIPStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VOIPStatics;
	static SetMicThreshold(InThreshold: number): void;
	static C(Other: UObject | any): VOIPStatics;
}

declare class VolumetricLightmapDensityVolume extends Volume { 
	AllowedMipLevelRange: Int32Interval;
	static GetDefaultObject(): VolumetricLightmapDensityVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricLightmapDensityVolume;
	static C(Other: UObject | any): VolumetricLightmapDensityVolume;
}

declare class LightMapVirtualTexture2D extends Texture2D { 
	TypeToLayer: number[];
	static Load(ResourceName: string): LightMapVirtualTexture2D;
	static Find(Outer: UObject, ResourceName: string): LightMapVirtualTexture2D;
	static GetDefaultObject(): LightMapVirtualTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapVirtualTexture2D;
	static C(Other: UObject | any): LightMapVirtualTexture2D;
}

declare class RuntimeVirtualTextureVolume extends Actor { 
	VirtualTextureComponent: RuntimeVirtualTextureComponent;
	Box: BoxComponent;
	static GetDefaultObject(): RuntimeVirtualTextureVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureVolume;
	static C(Other: UObject | any): RuntimeVirtualTextureVolume;
}

declare class VirtualTexture extends UObject { 
	static Load(ResourceName: string): VirtualTexture;
	static Find(Outer: UObject, ResourceName: string): VirtualTexture;
	static GetDefaultObject(): VirtualTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexture;
	static C(Other: UObject | any): VirtualTexture;
}

declare class LightMapVirtualTexture extends VirtualTexture { 
	static Load(ResourceName: string): LightMapVirtualTexture;
	static Find(Outer: UObject, ResourceName: string): LightMapVirtualTexture;
	static GetDefaultObject(): LightMapVirtualTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapVirtualTexture;
	static C(Other: UObject | any): LightMapVirtualTexture;
}

declare class VirtualTextureSpacePoolConfig { 
	MinTileSize: number;
	MaxTileSize: number;
	Formats: EPixelFormat[];
	SizeInMegabyte: number;
	bEnableResidencyMipMapBias: boolean;
	bAllowSizeScale: boolean;
	ScalabilityGroup: number;
	MinScaledSizeInMegabyte: number;
	MaxScaledSizeInMegabyte: number;
	clone() : VirtualTextureSpacePoolConfig;
	static C(Other: UObject | any): VirtualTextureSpacePoolConfig;
}

declare class VirtualTexturePoolConfig extends UObject { 
	DefaultSizeInMegabyte: number;
	Pools: VirtualTextureSpacePoolConfig[];
	static Load(ResourceName: string): VirtualTexturePoolConfig;
	static Find(Outer: UObject, ResourceName: string): VirtualTexturePoolConfig;
	static GetDefaultObject(): VirtualTexturePoolConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexturePoolConfig;
	static C(Other: UObject | any): VirtualTexturePoolConfig;
}

declare class WindDirectionalSource extends Info { 
	Component: WindDirectionalSourceComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): WindDirectionalSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSource;
	static C(Other: UObject | any): WindDirectionalSource;
}

declare class WorldPartitionBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): WorldPartitionBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionBlueprintLibrary;
	static GetDefaultObject(): WorldPartitionBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionBlueprintLibrary;
	static UnloadActors(InActorsToLoad: Guid[]): void;
	static LoadActors(InActorsToLoad: Guid[]): void;
	static GetRuntimeWorldBounds(): Box;
	static GetIntersectingActorDescs(InBox: Box,OutActorDescs?: ActorDesc[]): {OutActorDescs: ActorDesc[], $: boolean};
	static GetEditorWorldBounds(): Box;
	static GetActorDescs(OutActorDescs?: ActorDesc[]): {OutActorDescs: ActorDesc[], $: boolean};
	static C(Other: UObject | any): WorldPartitionBlueprintLibrary;
}

declare class ContentBundleDescriptor extends UObject { 
	DisplayName: string;
	Guid: Guid;
	PackageRoot: string;
	static Load(ResourceName: string): ContentBundleDescriptor;
	static Find(Outer: UObject, ResourceName: string): ContentBundleDescriptor;
	static GetDefaultObject(): ContentBundleDescriptor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBundleDescriptor;
	static C(Other: UObject | any): ContentBundleDescriptor;
}

declare class ContentBundleUnsavedActorMonitor extends UObject { 
	UnsavedActors: Actor[];
	static Load(ResourceName: string): ContentBundleUnsavedActorMonitor;
	static Find(Outer: UObject, ResourceName: string): ContentBundleUnsavedActorMonitor;
	static GetDefaultObject(): ContentBundleUnsavedActorMonitor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBundleUnsavedActorMonitor;
	static C(Other: UObject | any): ContentBundleUnsavedActorMonitor;
}

declare class ContentBundleEngineSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): ContentBundleEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): ContentBundleEngineSubsystem;
	static GetDefaultObject(): ContentBundleEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBundleEngineSubsystem;
	static C(Other: UObject | any): ContentBundleEngineSubsystem;
}

declare class DataLayerSubsystem extends WorldSubsystem { 
	OnDataLayerRuntimeStateChanged: UnrealEngineMulticastDelegate<(DataLayer: DataLayerInstance, State: EDataLayerRuntimeState) => void>;
	static Load(ResourceName: string): DataLayerSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataLayerSubsystem;
	static GetDefaultObject(): DataLayerSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerSubsystem;
	SetDataLayerStateByLabel(InDataLayerLabel: string,InState: EDataLayerState): void;
	SetDataLayerState(InDataLayer: ActorDataLayer,InState: EDataLayerState): void;
	SetDataLayerRuntimeStateByLabel(InDataLayerLabel: string,InState: EDataLayerRuntimeState,bInIsRecursive: boolean): void;
	SetDataLayerRuntimeState(InDataLayer: ActorDataLayer,InState: EDataLayerRuntimeState,bInIsRecursive: boolean): void;
	SetDataLayerInstanceRuntimeState(InDataLayerAsset: DataLayerAsset,InState: EDataLayerRuntimeState,bInIsRecursive: boolean): void;
	GetLoadedDataLayerNames(): Set<string>;
	GetDataLayerStateByLabel(InDataLayerLabel: string): EDataLayerState;
	GetDataLayerState(InDataLayer: ActorDataLayer): EDataLayerState;
	GetDataLayerRuntimeStateByLabel(InDataLayerLabel: string): EDataLayerRuntimeState;
	GetDataLayerRuntimeState(InDataLayer: ActorDataLayer): EDataLayerRuntimeState;
	GetDataLayerInstanceRuntimeState(InDataLayerAsset: DataLayerAsset): EDataLayerRuntimeState;
	GetDataLayerInstanceFromAsset(InDataLayerAsset: DataLayerAsset): DataLayerInstance;
	GetDataLayerInstanceEffectiveRuntimeState(InDataLayerAsset: DataLayerAsset): EDataLayerRuntimeState;
	GetDataLayerFromName(InDataLayerName: string): DataLayerInstance;
	GetDataLayerFromLabel(InDataLayerLabel: string): DataLayerInstance;
	GetDataLayerEffectiveRuntimeStateByLabel(InDataLayerLabel: string): EDataLayerRuntimeState;
	GetDataLayerEffectiveRuntimeState(InDataLayer: ActorDataLayer): EDataLayerRuntimeState;
	GetDataLayer(InDataLayer: ActorDataLayer): DataLayerInstance;
	GetActiveDataLayerNames(): Set<string>;
	static C(Other: UObject | any): DataLayerSubsystem;
}

declare class ActorContainerID { 
	ID: number;
	clone() : ActorContainerID;
	static C(Other: UObject | any): ActorContainerID;
}

declare class HLODSubActor { 
	ActorGuid: Guid;
	ActorPackage: string;
	ActorPath: string;
	ContainerID: ActorContainerID;
	ContainerPackage: string;
	ContainerTransform: Transform;
	clone() : HLODSubActor;
	static C(Other: UObject | any): HLODSubActor;
}

declare class WorldPartitionHLOD extends Actor { 
	HLODSubActors: HLODSubActor[];
	SubActorsHLODLayer: HLODLayer;
	HLODBounds: Box;
	MinVisibleDistance: number;
	HLODHash: number;
	HLODStats: Map<string, number>;
	LODLevel: number;
	bRequireWarmup: boolean;
	SourceCell: WorldPartitionRuntimeCell;
	SourceCellName: string;
	static GetDefaultObject(): WorldPartitionHLOD;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionHLOD;
	static C(Other: UObject | any): WorldPartitionHLOD;
}

declare class NullHLODBuilder extends HLODBuilder { 
	static Load(ResourceName: string): NullHLODBuilder;
	static Find(Outer: UObject, ResourceName: string): NullHLODBuilder;
	static GetDefaultObject(): NullHLODBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullHLODBuilder;
	static C(Other: UObject | any): NullHLODBuilder;
}

declare class HLODSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): HLODSubsystem;
	static Find(Outer: UObject, ResourceName: string): HLODSubsystem;
	static GetDefaultObject(): HLODSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODSubsystem;
	static C(Other: UObject | any): HLODSubsystem;
}

declare class NavigationDataChunkActor extends PartitionActor { 
	NavDataChunks: NavigationDataChunk[];
	DataChunkActorBounds: Box;
	static GetDefaultObject(): NavigationDataChunkActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunkActor;
	static C(Other: UObject | any): NavigationDataChunkActor;
}

declare class WorldPartitionActorLoaderInterface extends Interface { 
	static Load(ResourceName: string): WorldPartitionActorLoaderInterface;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionActorLoaderInterface;
	static GetDefaultObject(): WorldPartitionActorLoaderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionActorLoaderInterface;
	static C(Other: UObject | any): WorldPartitionActorLoaderInterface;
}

declare class WorldPartitionEditorPerProjectUserSettings extends UObject { 
	bHideEditorDataLayers: boolean;
	bHideRuntimeDataLayers: boolean;
	bHideDataLayerActors: boolean;
	bHideUnloadedActors: boolean;
	bShowOnlySelectedActors: boolean;
	bHighlightSelectedDataLayers: boolean;
	bHideLevelInstanceContent: boolean;
	bDisableLoadingOfLastLoadedRegions: boolean;
	bBugItGoLoadRegion: boolean;
	bShowCellCoords: boolean;
	PerWorldEditorSettings: Map<World, WorldPartitionPerWorldSettings>;
	static Load(ResourceName: string): WorldPartitionEditorPerProjectUserSettings;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorPerProjectUserSettings;
	static GetDefaultObject(): WorldPartitionEditorPerProjectUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorPerProjectUserSettings;
	static C(Other: UObject | any): WorldPartitionEditorPerProjectUserSettings;
}

declare class WorldPartitionEditorSpatialHash extends WorldPartitionEditorHash { 
	CellSize: number;
	WorldImage: SoftObjectPath;
	WorldImageTopLeftW: Vector2D;
	WorldImageBottomRightW: Vector2D;
	static Load(ResourceName: string): WorldPartitionEditorSpatialHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorSpatialHash;
	static GetDefaultObject(): WorldPartitionEditorSpatialHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorSpatialHash;
	static C(Other: UObject | any): WorldPartitionEditorSpatialHash;
}

declare class WorldPartitionRuntimeSpatialHashCell extends WorldPartitionRuntimeCell { 
	Position: Vector;
	Extent: number;
	Level: number;
	UnsavedActorsContainer: ActorContainer;
	static Load(ResourceName: string): WorldPartitionRuntimeSpatialHashCell;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeSpatialHashCell;
	static GetDefaultObject(): WorldPartitionRuntimeSpatialHashCell;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeSpatialHashCell;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHashCell;
}

declare class WorldPartitionRuntimeCellObjectMapping { 
	Package: string;
	Path: string;
	ContainerID: ActorContainerID;
	ContainerTransform: Transform;
	ContainerPackage: string;
	WorldPackage: string;
	ContentBundleGuid: Guid;
	LoadedPath: string;
	clone() : WorldPartitionRuntimeCellObjectMapping;
	static C(Other: UObject | any): WorldPartitionRuntimeCellObjectMapping;
}

declare class WorldPartitionRuntimeLevelStreamingCell extends WorldPartitionRuntimeSpatialHashCell { 
	Packages: WorldPartitionRuntimeCellObjectMapping[];
	LevelStreaming: WorldPartitionLevelStreamingDynamic;
	static Load(ResourceName: string): WorldPartitionRuntimeLevelStreamingCell;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeLevelStreamingCell;
	static GetDefaultObject(): WorldPartitionRuntimeLevelStreamingCell;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeLevelStreamingCell;
	OnLevelShown(): void;
	OnLevelHidden(): void;
	static C(Other: UObject | any): WorldPartitionRuntimeLevelStreamingCell;
}

declare class WorldPartitionLevelStreamingDynamic extends LevelStreamingDynamic { 
	RuntimeLevel: Level;
	bShouldBeAlwaysLoaded: boolean;
	UnsavedActorsContainer: ActorContainer;
	StreamingCell: WorldPartitionRuntimeLevelStreamingCell;
	OuterWorldPartition: WorldPartition;
	static Load(ResourceName: string): WorldPartitionLevelStreamingDynamic;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionLevelStreamingDynamic;
	static GetDefaultObject(): WorldPartitionLevelStreamingDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionLevelStreamingDynamic;
	static C(Other: UObject | any): WorldPartitionLevelStreamingDynamic;
}

declare class WorldPartitionLevelStreamingPolicy extends WorldPartitionStreamingPolicy { 
	ActorToCellRemapping: Map<string, string>;
	SubObjectsToCellRemapping: Map<string, string>;
	static Load(ResourceName: string): WorldPartitionLevelStreamingPolicy;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionLevelStreamingPolicy;
	static GetDefaultObject(): WorldPartitionLevelStreamingPolicy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionLevelStreamingPolicy;
	static C(Other: UObject | any): WorldPartitionLevelStreamingPolicy;
}

declare class WorldPartitionMiniMap extends Info { 
	MiniMapWorldBounds: Box;
	UVOffset: Box2D;
	MiniMapTexture: Texture2D;
	ExcludedDataLayers: Set<ActorDataLayer>;
	WorldUnitsPerPixel: number;
	BuilderCellSize: number;
	CaptureSource: ESceneCaptureSource;
	CaptureWarmupFrames: number;
	MiniMapTileSize: number;
	static GetDefaultObject(): WorldPartitionMiniMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionMiniMap;
	static C(Other: UObject | any): WorldPartitionMiniMap;
}

declare class WorldPartitionMiniMapVolume extends Volume { 
	static GetDefaultObject(): WorldPartitionMiniMapVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionMiniMapVolume;
	static C(Other: UObject | any): WorldPartitionMiniMapVolume;
}

declare class WorldPartitionReplay extends Actor { 
	StreamingSourceNames: string[];
	static GetDefaultObject(): WorldPartitionReplay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionReplay;
	static C(Other: UObject | any): WorldPartitionReplay;
}

declare class SpatialHashRuntimeGrid { 
	GridName: string;
	CellSize: number;
	LoadingRange: number;
	bBlockOnSlowStreaming: boolean;
	Priority: number;
	DebugColor: LinearColor;
	bClientOnlyVisible: boolean;
	HLODLayer: HLODLayer;
	clone() : SpatialHashRuntimeGrid;
	static C(Other: UObject | any): SpatialHashRuntimeGrid;
}

declare class SpatialHashRuntimeGridInfo extends Info { 
	GridSettings: SpatialHashRuntimeGrid;
	static GetDefaultObject(): SpatialHashRuntimeGridInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpatialHashRuntimeGridInfo;
	static C(Other: UObject | any): SpatialHashRuntimeGridInfo;
}

declare class SpatialHashStreamingGridLayerCell { 
	GridCells: WorldPartitionRuntimeSpatialHashCell[];
	clone() : SpatialHashStreamingGridLayerCell;
	static C(Other: UObject | any): SpatialHashStreamingGridLayerCell;
}

declare class SpatialHashStreamingGridLevel { 
	LayerCells: SpatialHashStreamingGridLayerCell[];
	LayerCellsMapping: Map<number, number>;
	clone() : SpatialHashStreamingGridLevel;
	static C(Other: UObject | any): SpatialHashStreamingGridLevel;
}

declare class SpatialHashStreamingGrid { 
	GridName: string;
	Origin: Vector;
	CellSize: number;
	LoadingRange: number;
	bBlockOnSlowStreaming: boolean;
	DebugColor: LinearColor;
	GridLevels: SpatialHashStreamingGridLevel[];
	WorldBounds: Box;
	bClientOnlyVisible: boolean;
	HLODLayer: HLODLayer;
	clone() : SpatialHashStreamingGrid;
	static C(Other: UObject | any): SpatialHashStreamingGrid;
}

declare class RuntimeSpatialHashExternalStreamingObject extends RuntimeHashExternalStreamingObjectBase { 
	StreamingGrids: SpatialHashStreamingGrid[];
	CellToLevelStreamingPackage: Map<string, string>;
	static Load(ResourceName: string): RuntimeSpatialHashExternalStreamingObject;
	static Find(Outer: UObject, ResourceName: string): RuntimeSpatialHashExternalStreamingObject;
	static GetDefaultObject(): RuntimeSpatialHashExternalStreamingObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeSpatialHashExternalStreamingObject;
	static C(Other: UObject | any): RuntimeSpatialHashExternalStreamingObject;
}

declare class WorldPartitionRuntimeSpatialHashGridPreviewer { 
	Material: Material;
	Mid: MaterialInstanceDynamic;
	Volume: PostProcessVolume;
	clone() : WorldPartitionRuntimeSpatialHashGridPreviewer;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHashGridPreviewer;
}

declare class WorldPartitionRuntimeSpatialHash extends WorldPartitionRuntimeHash { 
	Grids: SpatialHashRuntimeGrid[];
	bPreviewGrids: boolean;
	GridPreviewer: WorldPartitionRuntimeSpatialHashGridPreviewer;
	bEnableZCulling: boolean;
	StreamingGrids: SpatialHashStreamingGrid[];
	ExternalStreamingObjects: RuntimeSpatialHashExternalStreamingObject[];
	static Load(ResourceName: string): WorldPartitionRuntimeSpatialHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeSpatialHash;
	static GetDefaultObject(): WorldPartitionRuntimeSpatialHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeSpatialHash;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHash;
}

declare type EWorldPartitionRuntimeCellState = 'Unloaded' | 'Loaded' | 'Activated' | 'EWorldPartitionRuntimeCellState_MAX';
declare var EWorldPartitionRuntimeCellState : { Unloaded:'Unloaded',Loaded:'Loaded',Activated:'Activated',EWorldPartitionRuntimeCellState_MAX:'EWorldPartitionRuntimeCellState_MAX', };
declare class WorldPartitionStreamingQuerySource { 
	Location: Vector;
	Radius: number;
	bUseGridLoadingRange: boolean;
	DataLayers: string[];
	bDataLayersOnly: boolean;
	bSpatialQuery: boolean;
	clone() : WorldPartitionStreamingQuerySource;
	static C(Other: UObject | any): WorldPartitionStreamingQuerySource;
}

declare class WorldPartitionSubsystem extends TickableWorldSubsystem { 
	static Load(ResourceName: string): WorldPartitionSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionSubsystem;
	static GetDefaultObject(): WorldPartitionSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionSubsystem;
	IsStreamingCompleted(QueryState: EWorldPartitionRuntimeCellState,QuerySources: WorldPartitionStreamingQuerySource[],bExactState: boolean): boolean;
	IsAllStreamingCompleted(): boolean;
	static C(Other: UObject | any): WorldPartitionSubsystem;
}

declare class WorldPartitionVolume extends Volume { 
	static GetDefaultObject(): WorldPartitionVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionVolume;
	static C(Other: UObject | any): WorldPartitionVolume;
}

declare class MoviePlayerSettings extends UObject { 
	bWaitForMoviesToComplete: boolean;
	bMoviesAreSkippable: boolean;
	StartupMovies: string[];
	static Load(ResourceName: string): MoviePlayerSettings;
	static Find(Outer: UObject, ResourceName: string): MoviePlayerSettings;
	static GetDefaultObject(): MoviePlayerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MoviePlayerSettings;
	static C(Other: UObject | any): MoviePlayerSettings;
}

declare class SHAHashData { 
	Hash: number;
	clone() : SHAHashData;
	static C(Other: UObject | any): SHAHashData;
}

declare class ChunkPartData { 
	Guid: Guid;
	Offset: number;
	Size: number;
	clone() : ChunkPartData;
	static C(Other: UObject | any): ChunkPartData;
}

declare class FileManifestData { 
	Filename: string;
	FileHash: SHAHashData;
	FileChunkParts: ChunkPartData[];
	InstallTags: string[];
	bIsUnixExecutable: boolean;
	SymlinkTarget: string;
	bIsReadOnly: boolean;
	bIsCompressed: boolean;
	clone() : FileManifestData;
	static C(Other: UObject | any): FileManifestData;
}

declare class ChunkInfoData { 
	Guid: Guid;
	Hash: number;
	ShaHash: SHAHashData;
	FileSize: number;
	GroupNumber: number;
	clone() : ChunkInfoData;
	static C(Other: UObject | any): ChunkInfoData;
}

declare class CustomFieldData { 
	Key: string;
	Value: string;
	clone() : CustomFieldData;
	static C(Other: UObject | any): CustomFieldData;
}

declare class BuildPatchManifest extends UObject { 
	ManifestFileVersion: number;
	bIsFileData: boolean;
	AppID: number;
	AppName: string;
	BuildVersion: string;
	LaunchExe: string;
	LaunchCommand: string;
	PrereqIds: Set<string>;
	PrereqName: string;
	PrereqPath: string;
	PrereqArgs: string;
	FileManifestList: FileManifestData[];
	ChunkList: ChunkInfoData[];
	CustomFields: CustomFieldData[];
	static Load(ResourceName: string): BuildPatchManifest;
	static Find(Outer: UObject, ResourceName: string): BuildPatchManifest;
	static GetDefaultObject(): BuildPatchManifest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BuildPatchManifest;
	static C(Other: UObject | any): BuildPatchManifest;
}

declare class SoundFactory extends Factory { 
	bAutoCreateCue: boolean;
	bIncludeAttenuationNode: boolean;
	bIncludeLoopingNode: boolean;
	bIncludeModulatorNode: boolean;
	CueVolume: number;
	CuePackageSuffix: string;
	static Load(ResourceName: string): SoundFactory;
	static Find(Outer: UObject, ResourceName: string): SoundFactory;
	static GetDefaultObject(): SoundFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundFactory;
	static C(Other: UObject | any): SoundFactory;
}

declare class ReimportSoundFactory extends SoundFactory { 
	static Load(ResourceName: string): ReimportSoundFactory;
	static Find(Outer: UObject, ResourceName: string): ReimportSoundFactory;
	static GetDefaultObject(): ReimportSoundFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportSoundFactory;
	static C(Other: UObject | any): ReimportSoundFactory;
}

declare type EClusterConnectionTypeEnum = 'Chaos_PointImplicit' | 'Chaos_DelaunayTriangulation' | 'Chaos_MinimalSpanningSubsetDelaunayTriangulation' | 'Chaos_PointImplicitAugmentedWithMinimalDelaunay' | 'Chaos_BoundsOverlapFilteredDelaunayTriangulation' | 'Chaos_None' | 'Chaos_EClsuterCreationParameters_Max' | 'Chaos_MAX';
declare var EClusterConnectionTypeEnum : { Chaos_PointImplicit:'Chaos_PointImplicit',Chaos_DelaunayTriangulation:'Chaos_DelaunayTriangulation',Chaos_MinimalSpanningSubsetDelaunayTriangulation:'Chaos_MinimalSpanningSubsetDelaunayTriangulation',Chaos_PointImplicitAugmentedWithMinimalDelaunay:'Chaos_PointImplicitAugmentedWithMinimalDelaunay',Chaos_BoundsOverlapFilteredDelaunayTriangulation:'Chaos_BoundsOverlapFilteredDelaunayTriangulation',Chaos_None:'Chaos_None',Chaos_EClsuterCreationParameters_Max:'Chaos_EClsuterCreationParameters_Max',Chaos_MAX:'Chaos_MAX', };
declare class ChaosDebugSubstepControl { 
	bPause: boolean;
	bSubstep: boolean;
	bStep: boolean;
	clone() : ChaosDebugSubstepControl;
	static C(Other: UObject | any): ChaosDebugSubstepControl;
}

declare class ChaosEventListenerComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosEventListenerComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosEventListenerComponent;
	static GetDefaultObject(): ChaosEventListenerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosEventListenerComponent;
	static C(Other: UObject | any): ChaosEventListenerComponent;
}

declare class ChaosHandlerSet { 
	ChaosHandlers: Set<UObject>;
	clone() : ChaosHandlerSet;
	static C(Other: UObject | any): ChaosHandlerSet;
}

declare class BreakEventCallbackWrapper { 
	clone() : BreakEventCallbackWrapper;
	static C(Other: UObject | any): BreakEventCallbackWrapper;
}

declare class RemovalEventCallbackWrapper { 
	clone() : RemovalEventCallbackWrapper;
	static C(Other: UObject | any): RemovalEventCallbackWrapper;
}

declare class CrumblingEventCallbackWrapper { 
	clone() : CrumblingEventCallbackWrapper;
	static C(Other: UObject | any): CrumblingEventCallbackWrapper;
}

declare class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent { 
	CollisionEventRegistrations: Map<PrimitiveComponent, ChaosHandlerSet>;
	BreakEventRegistrations: Map<PrimitiveComponent, BreakEventCallbackWrapper>;
	RemovalEventRegistrations: Map<PrimitiveComponent, RemovalEventCallbackWrapper>;
	CrumblingEventRegistrations: Map<PrimitiveComponent, CrumblingEventCallbackWrapper>;
	static Load(ResourceName: string): ChaosGameplayEventDispatcher;
	static Find(Outer: UObject, ResourceName: string): ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosGameplayEventDispatcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosGameplayEventDispatcher;
	static C(Other: UObject | any): ChaosGameplayEventDispatcher;
}

declare class ChaosSolverActor extends Actor { 
	Properties: ChaosSolverConfiguration;
	TimeStepMultiplier: number;
	CollisionIterations: number;
	PushOutIterations: number;
	PushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterConnectionTypeEnum;
	DoGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	DoGenerateBreakingData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	DoGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	MassScale: number;
	bHasFloor: boolean;
	FloorHeight: number;
	ChaosDebugSubstepControl: ChaosDebugSubstepControl;
	SpriteComponent: BillboardComponent;
	GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosSolverActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverActor;
	SetSolverActive(bActive: boolean): void;
	SetAsCurrentWorldSolver(): void;
	static C(Other: UObject | any): ChaosSolverActor;
}

declare class LinuxTargetSettings extends UObject { 
	SpatializationPlugin: string;
	SourceDataOverridePlugin: string;
	ReverbPlugin: string;
	OcclusionPlugin: string;
	SoundCueCookQualityIndex: number;
	TargetedRHIs: string[];
	static Load(ResourceName: string): LinuxTargetSettings;
	static Find(Outer: UObject, ResourceName: string): LinuxTargetSettings;
	static GetDefaultObject(): LinuxTargetSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinuxTargetSettings;
	static C(Other: UObject | any): LinuxTargetSettings;
}

declare class VirtualizationFilterSettings extends UObject { 
	ExcludePackagePaths: string[];
	IncludePackagePaths: string[];
	static Load(ResourceName: string): VirtualizationFilterSettings;
	static Find(Outer: UObject, ResourceName: string): VirtualizationFilterSettings;
	static GetDefaultObject(): VirtualizationFilterSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualizationFilterSettings;
	static C(Other: UObject | any): VirtualizationFilterSettings;
}

declare class AudioBusFactory extends Factory { 
	static Load(ResourceName: string): AudioBusFactory;
	static Find(Outer: UObject, ResourceName: string): AudioBusFactory;
	static GetDefaultObject(): AudioBusFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioBusFactory;
	static C(Other: UObject | any): AudioBusFactory;
}

declare class AudioEditorSettings extends DeveloperSettings { 
	bPinSoundCueInAssetMenu: boolean;
	bPinSoundCueTemplateInAssetMenu: boolean;
	bPinSoundAttenuationInAssetMenu: boolean;
	bPinSoundConcurrencyInAssetMenu: boolean;
	static Load(ResourceName: string): AudioEditorSettings;
	static Find(Outer: UObject, ResourceName: string): AudioEditorSettings;
	static GetDefaultObject(): AudioEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEditorSettings;
	static C(Other: UObject | any): AudioEditorSettings;
}

declare class DialogueVoiceFactory extends Factory { 
	static Load(ResourceName: string): DialogueVoiceFactory;
	static Find(Outer: UObject, ResourceName: string): DialogueVoiceFactory;
	static GetDefaultObject(): DialogueVoiceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueVoiceFactory;
	static C(Other: UObject | any): DialogueVoiceFactory;
}

declare class DialogueWaveFactory extends Factory { 
	InitialSoundWave: SoundWave;
	InitialSpeakerVoice: DialogueVoice;
	HasSetInitialTargetVoice: boolean;
	InitialTargetVoices: DialogueVoice[];
	static Load(ResourceName: string): DialogueWaveFactory;
	static Find(Outer: UObject, ResourceName: string): DialogueWaveFactory;
	static GetDefaultObject(): DialogueWaveFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueWaveFactory;
	static C(Other: UObject | any): DialogueWaveFactory;
}

declare class ReverbEffectFactory extends Factory { 
	static Load(ResourceName: string): ReverbEffectFactory;
	static Find(Outer: UObject, ResourceName: string): ReverbEffectFactory;
	static GetDefaultObject(): ReverbEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffectFactory;
	static C(Other: UObject | any): ReverbEffectFactory;
}

declare class SoundAttenuationFactory extends Factory { 
	static Load(ResourceName: string): SoundAttenuationFactory;
	static Find(Outer: UObject, ResourceName: string): SoundAttenuationFactory;
	static GetDefaultObject(): SoundAttenuationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuationFactory;
	static C(Other: UObject | any): SoundAttenuationFactory;
}

declare class SoundClassFactory extends Factory { 
	static Load(ResourceName: string): SoundClassFactory;
	static Find(Outer: UObject, ResourceName: string): SoundClassFactory;
	static GetDefaultObject(): SoundClassFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassFactory;
	static C(Other: UObject | any): SoundClassFactory;
}

declare class SoundClassGraph extends EdGraph { 
	static Load(ResourceName: string): SoundClassGraph;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraph;
	static GetDefaultObject(): SoundClassGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraph;
	static C(Other: UObject | any): SoundClassGraph;
}

declare class SoundClassGraphNode extends EdGraphNode { 
	SoundClass: SoundClass;
	static Load(ResourceName: string): SoundClassGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraphNode;
	static GetDefaultObject(): SoundClassGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphNode;
	static C(Other: UObject | any): SoundClassGraphNode;
}

declare class SoundClassGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundClassGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraphSchema;
	static GetDefaultObject(): SoundClassGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphSchema;
	static C(Other: UObject | any): SoundClassGraphSchema;
}

declare class SoundEffectSourcePresetClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SoundEffectSourcePresetClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePresetClassTemplate;
	static GetDefaultObject(): SoundEffectSourcePresetClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePresetClassTemplate;
	static C(Other: UObject | any): SoundEffectSourcePresetClassTemplate;
}

declare class SoundEffectSubmixPresetClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SoundEffectSubmixPresetClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSubmixPresetClassTemplate;
	static GetDefaultObject(): SoundEffectSubmixPresetClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSubmixPresetClassTemplate;
	static C(Other: UObject | any): SoundEffectSubmixPresetClassTemplate;
}

declare class SynthComponentClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SynthComponentClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SynthComponentClassTemplate;
	static GetDefaultObject(): SynthComponentClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponentClassTemplate;
	static C(Other: UObject | any): SynthComponentClassTemplate;
}

declare class SoundConcurrencyFactory extends Factory { 
	static Load(ResourceName: string): SoundConcurrencyFactory;
	static Find(Outer: UObject, ResourceName: string): SoundConcurrencyFactory;
	static GetDefaultObject(): SoundConcurrencyFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundConcurrencyFactory;
	static C(Other: UObject | any): SoundConcurrencyFactory;
}

declare class SoundCueFactoryNew extends Factory { 
	InitialSoundWave: SoundWave;
	InitialSoundWaves: SoundWave[];
	InitialDialogueWave: DialogueWave;
	InitialDialogueWaves: DialogueWave[];
	static Load(ResourceName: string): SoundCueFactoryNew;
	static Find(Outer: UObject, ResourceName: string): SoundCueFactoryNew;
	static GetDefaultObject(): SoundCueFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueFactoryNew;
	static C(Other: UObject | any): SoundCueFactoryNew;
}

declare class SoundCueGraph extends EdGraph { 
	static Load(ResourceName: string): SoundCueGraph;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraph;
	static GetDefaultObject(): SoundCueGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraph;
	static C(Other: UObject | any): SoundCueGraph;
}

declare class SoundCueGraphNode_Base extends EdGraphNode { 
	static Load(ResourceName: string): SoundCueGraphNode_Base;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode_Base;
	static GetDefaultObject(): SoundCueGraphNode_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Base;
	static C(Other: UObject | any): SoundCueGraphNode_Base;
}

declare class SoundCueGraphNode extends SoundCueGraphNode_Base { 
	SoundNode: SoundNode;
	static Load(ResourceName: string): SoundCueGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode;
	static GetDefaultObject(): SoundCueGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode;
	static C(Other: UObject | any): SoundCueGraphNode;
}

declare class SoundCueGraphNode_Root extends SoundCueGraphNode_Base { 
	static Load(ResourceName: string): SoundCueGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode_Root;
	static GetDefaultObject(): SoundCueGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Root;
	static C(Other: UObject | any): SoundCueGraphNode_Root;
}

declare class SoundCueGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundCueGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphSchema;
	static GetDefaultObject(): SoundCueGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphSchema;
	static C(Other: UObject | any): SoundCueGraphSchema;
}

declare class SoundMixFactory extends Factory { 
	static Load(ResourceName: string): SoundMixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundMixFactory;
	static GetDefaultObject(): SoundMixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMixFactory;
	static C(Other: UObject | any): SoundMixFactory;
}

declare class SoundSourceBusFactory extends Factory { 
	static Load(ResourceName: string): SoundSourceBusFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceBusFactory;
	static GetDefaultObject(): SoundSourceBusFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceBusFactory;
	static C(Other: UObject | any): SoundSourceBusFactory;
}

declare class SoundSourceEffectFactory extends Factory { 
	SoundEffectSourcepresetClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundSourceEffectFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceEffectFactory;
	static GetDefaultObject(): SoundSourceEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceEffectFactory;
	static C(Other: UObject | any): SoundSourceEffectFactory;
}

declare class SoundSourceEffectChainFactory extends Factory { 
	static Load(ResourceName: string): SoundSourceEffectChainFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceEffectChainFactory;
	static GetDefaultObject(): SoundSourceEffectChainFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceEffectChainFactory;
	static C(Other: UObject | any): SoundSourceEffectChainFactory;
}

declare class SoundSubmixEffectFactory extends Factory { 
	SoundEffectSubmixPresetClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundSubmixEffectFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixEffectFactory;
	static GetDefaultObject(): SoundSubmixEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixEffectFactory;
	static C(Other: UObject | any): SoundSubmixEffectFactory;
}

declare class SoundSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixFactory;
	static GetDefaultObject(): SoundSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixFactory;
	static C(Other: UObject | any): SoundSubmixFactory;
}

declare class SoundfieldSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundfieldSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundfieldSubmixFactory;
	static GetDefaultObject(): SoundfieldSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldSubmixFactory;
	static C(Other: UObject | any): SoundfieldSubmixFactory;
}

declare class EndpointSubmixFactory extends Factory { 
	static Load(ResourceName: string): EndpointSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): EndpointSubmixFactory;
	static GetDefaultObject(): EndpointSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndpointSubmixFactory;
	static C(Other: UObject | any): EndpointSubmixFactory;
}

declare class SoundfieldEndpointSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundfieldEndpointSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSubmixFactory;
	static GetDefaultObject(): SoundfieldEndpointSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSubmixFactory;
	static C(Other: UObject | any): SoundfieldEndpointSubmixFactory;
}

declare class SoundSubmixGraph extends EdGraph { 
	RootSoundSubmix: SoundSubmixBase;
	StaleRoots: SoundSubmixBase[];
	static Load(ResourceName: string): SoundSubmixGraph;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraph;
	static GetDefaultObject(): SoundSubmixGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraph;
	static C(Other: UObject | any): SoundSubmixGraph;
}

declare class SoundSubmixGraphNode extends EdGraphNode { 
	SoundSubmix: SoundSubmixBase;
	SubmixNodeUserWidget: UserWidget;
	static Load(ResourceName: string): SoundSubmixGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraphNode;
	static GetDefaultObject(): SoundSubmixGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraphNode;
	static C(Other: UObject | any): SoundSubmixGraphNode;
}

declare class SoundSubmixGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundSubmixGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraphSchema;
	static GetDefaultObject(): SoundSubmixGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraphSchema;
	static C(Other: UObject | any): SoundSubmixGraphSchema;
}

declare class AnimationModifier extends UObject { 
	bReapplyPostOwnerChange: boolean;
	RevisionGuid: Guid;
	AppliedGuid: Guid;
	StoredNativeRevision: number;
	PreviouslyAppliedModifier: AnimationModifier;
	static Load(ResourceName: string): AnimationModifier;
	static Find(Outer: UObject, ResourceName: string): AnimationModifier;
	static GetDefaultObject(): AnimationModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifier;
	OnRevert(AnimationSequence: AnimSequence): void;
	OnApply(AnimationSequence: AnimSequence): void;
	static C(Other: UObject | any): AnimationModifier;
}

declare class AnimationModifiersAssetUserData extends AssetUserData { 
	AnimationModifierInstances: AnimationModifier[];
	static Load(ResourceName: string): AnimationModifiersAssetUserData;
	static Find(Outer: UObject, ResourceName: string): AnimationModifiersAssetUserData;
	static GetDefaultObject(): AnimationModifiersAssetUserData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifiersAssetUserData;
	static C(Other: UObject | any): AnimationModifiersAssetUserData;
}

declare class AnimationModifierSettings extends DeveloperSettings { 
	DefaultAnimationModifiers: UnrealEngineClass[];
	bApplyAnimationModifiersOnImport: boolean;
	static Load(ResourceName: string): AnimationModifierSettings;
	static Find(Outer: UObject, ResourceName: string): AnimationModifierSettings;
	static GetDefaultObject(): AnimationModifierSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifierSettings;
	static C(Other: UObject | any): AnimationModifierSettings;
}

declare class ChaosDebugDrawComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosDebugDrawComponent;
	static GetDefaultObject(): ChaosDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDebugDrawComponent;
	static C(Other: UObject | any): ChaosDebugDrawComponent;
}

declare class ChaosNotifyHandlerInterface extends Interface { 
	static Load(ResourceName: string): ChaosNotifyHandlerInterface;
	static Find(Outer: UObject, ResourceName: string): ChaosNotifyHandlerInterface;
	static GetDefaultObject(): ChaosNotifyHandlerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosNotifyHandlerInterface;
	static C(Other: UObject | any): ChaosNotifyHandlerInterface;
}

declare class ChaosPhysicsCollisionInfo { 
	Component: PrimitiveComponent;
	OtherComponent: PrimitiveComponent;
	Location: Vector;
	Normal: Vector;
	AccumulatedImpulse: Vector;
	Velocity: Vector;
	OtherVelocity: Vector;
	AngularVelocity: Vector;
	OtherAngularVelocity: Vector;
	Mass: number;
	OtherMass: number;
	clone() : ChaosPhysicsCollisionInfo;
	static C(Other: UObject | any): ChaosPhysicsCollisionInfo;
	ConvertPhysicsCollisionToHitResult(): HitResult;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
}

declare class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static GetDefaultObject(): ChaosSolverEngineBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverEngineBlueprintLibrary;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
	static C(Other: UObject | any): ChaosSolverEngineBlueprintLibrary;
}

declare class ChaosSolver extends UObject { 
	static Load(ResourceName: string): ChaosSolver;
	static Find(Outer: UObject, ResourceName: string): ChaosSolver;
	static GetDefaultObject(): ChaosSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolver;
	static C(Other: UObject | any): ChaosSolver;
}

declare class ChaosSolverSettings extends DeveloperSettings { 
	DefaultChaosSolverActorClass: SoftClassPath;
	static Load(ResourceName: string): ChaosSolverSettings;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverSettings;
	static GetDefaultObject(): ChaosSolverSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverSettings;
	static C(Other: UObject | any): ChaosSolverSettings;
}

declare class FieldSystem extends UObject { 
	static Load(ResourceName: string): FieldSystem;
	static Find(Outer: UObject, ResourceName: string): FieldSystem;
	static GetDefaultObject(): FieldSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystem;
	static C(Other: UObject | any): FieldSystem;
}

declare class FieldNodeBase extends ActorComponent { 
	static Load(ResourceName: string): FieldNodeBase;
	static Find(Outer: UObject, ResourceName: string): FieldNodeBase;
	static GetDefaultObject(): FieldNodeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeBase;
	static C(Other: UObject | any): FieldNodeBase;
}

declare class FieldSystemMetaData extends ActorComponent { 
	static Load(ResourceName: string): FieldSystemMetaData;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaData;
	static GetDefaultObject(): FieldSystemMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaData;
	static C(Other: UObject | any): FieldSystemMetaData;
}

declare class FieldObjectCommands { 
	TargetNames: string[];
	RootNodes: FieldNodeBase[];
	MetaDatas: FieldSystemMetaData[];
	clone() : FieldObjectCommands;
	static C(Other: UObject | any): FieldObjectCommands;
}

declare type EFieldPhysicsType = 'Field_None' | 'Field_DynamicState' | 'Field_LinearForce' | 'Field_ExternalClusterStrain' | 'Field_Kill' | 'Field_LinearVelocity' | 'Field_AngularVelociy' | 'Field_AngularTorque' | 'Field_InternalClusterStrain' | 'Field_DisableThreshold' | 'Field_SleepingThreshold' | 'Field_PositionStatic' | 'Field_PositionAnimated' | 'Field_PositionTarget' | 'Field_DynamicConstraint' | 'Field_CollisionGroup' | 'Field_ActivateDisabled' | 'Field_InitialLinearVelocity' | 'Field_InitialAngularVelocity' | 'Field_LinearImpulse' | 'Field_PhysicsType_Max';
declare var EFieldPhysicsType : { Field_None:'Field_None',Field_DynamicState:'Field_DynamicState',Field_LinearForce:'Field_LinearForce',Field_ExternalClusterStrain:'Field_ExternalClusterStrain',Field_Kill:'Field_Kill',Field_LinearVelocity:'Field_LinearVelocity',Field_AngularVelociy:'Field_AngularVelociy',Field_AngularTorque:'Field_AngularTorque',Field_InternalClusterStrain:'Field_InternalClusterStrain',Field_DisableThreshold:'Field_DisableThreshold',Field_SleepingThreshold:'Field_SleepingThreshold',Field_PositionStatic:'Field_PositionStatic',Field_PositionAnimated:'Field_PositionAnimated',Field_PositionTarget:'Field_PositionTarget',Field_DynamicConstraint:'Field_DynamicConstraint',Field_CollisionGroup:'Field_CollisionGroup',Field_ActivateDisabled:'Field_ActivateDisabled',Field_InitialLinearVelocity:'Field_InitialLinearVelocity',Field_InitialAngularVelocity:'Field_InitialAngularVelocity',Field_LinearImpulse:'Field_LinearImpulse',Field_PhysicsType_Max:'Field_PhysicsType_Max', };
declare class FieldSystemComponent extends PrimitiveComponent { 
	FieldSystem: FieldSystem;
	bIsWorldField: boolean;
	bIsChaosField: boolean;
	SupportedSolvers: ChaosSolverActor[];
	ConstructionCommands: FieldObjectCommands;
	BufferCommands: FieldObjectCommands;
	static Load(ResourceName: string): FieldSystemComponent;
	static Find(Outer: UObject, ResourceName: string): FieldSystemComponent;
	static GetDefaultObject(): FieldSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemComponent;
	ResetFieldSystem(): void;
	RemovePersistentFields(): void;
	ApplyUniformVectorFalloffForce(Enabled: boolean,Position: Vector,Direction: Vector,Radius: number,Magnitude: number): void;
	ApplyStrainField(Enabled: boolean,Position: Vector,Radius: number,Magnitude: number,Iterations: number): void;
	ApplyStayDynamicField(Enabled: boolean,Position: Vector,Radius: number): void;
	ApplyRadialVectorFalloffForce(Enabled: boolean,Position: Vector,Radius: number,Magnitude: number): void;
	ApplyRadialForce(Enabled: boolean,Position: Vector,Magnitude: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearForce(Enabled: boolean,Direction: Vector,Magnitude: number): void;
	AddPersistentField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	AddFieldCommand(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	static C(Other: UObject | any): FieldSystemComponent;
}

declare class FieldSystemActor extends Actor { 
	FieldSystemComponent: FieldSystemComponent;
	static GetDefaultObject(): FieldSystemActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemActor;
	static C(Other: UObject | any): FieldSystemActor;
}

declare class FieldSystemMetaDataIteration extends FieldSystemMetaData { 
	Iterations: number;
	static Load(ResourceName: string): FieldSystemMetaDataIteration;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataIteration;
	static GetDefaultObject(): FieldSystemMetaDataIteration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataIteration;
	SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;
	static C(Other: UObject | any): FieldSystemMetaDataIteration;
}

declare type EFieldResolutionType = 'Field_Resolution_Minimal' | 'Field_Resolution_DisabledParents' | 'Field_Resolution_Maximum' | 'Field_Resolution_Max';
declare var EFieldResolutionType : { Field_Resolution_Minimal:'Field_Resolution_Minimal',Field_Resolution_DisabledParents:'Field_Resolution_DisabledParents',Field_Resolution_Maximum:'Field_Resolution_Maximum',Field_Resolution_Max:'Field_Resolution_Max', };
declare class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData { 
	ResolutionType: EFieldResolutionType;
	static Load(ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static GetDefaultObject(): FieldSystemMetaDataProcessingResolution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataProcessingResolution;
	SetMetaDataaProcessingResolutionType(ResolutionType: EFieldResolutionType): FieldSystemMetaDataProcessingResolution;
	static C(Other: UObject | any): FieldSystemMetaDataProcessingResolution;
}

declare type EFieldFilterType = 'Field_Filter_Dynamic' | 'Field_Filter_Kinematic' | 'Field_Filter_Static' | 'Field_Filter_All' | 'Field_Filter_Sleeping' | 'Field_Filter_Disabled' | 'Field_Filter_Max';
declare var EFieldFilterType : { Field_Filter_Dynamic:'Field_Filter_Dynamic',Field_Filter_Kinematic:'Field_Filter_Kinematic',Field_Filter_Static:'Field_Filter_Static',Field_Filter_All:'Field_Filter_All',Field_Filter_Sleeping:'Field_Filter_Sleeping',Field_Filter_Disabled:'Field_Filter_Disabled',Field_Filter_Max:'Field_Filter_Max', };
declare type EFieldObjectType = 'Field_Object_Rigid' | 'Field_Object_Cloth' | 'Field_Object_Destruction' | 'Field_Object_Character' | 'Field_Object_All' | 'Field_Object_Max';
declare var EFieldObjectType : { Field_Object_Rigid:'Field_Object_Rigid',Field_Object_Cloth:'Field_Object_Cloth',Field_Object_Destruction:'Field_Object_Destruction',Field_Object_Character:'Field_Object_Character',Field_Object_All:'Field_Object_All',Field_Object_Max:'Field_Object_Max', };
declare type EFieldPositionType = 'Field_Position_CenterOfMass' | 'Field_Position_PivotPoint' | 'Field_Position_Max';
declare var EFieldPositionType : { Field_Position_CenterOfMass:'Field_Position_CenterOfMass',Field_Position_PivotPoint:'Field_Position_PivotPoint',Field_Position_Max:'Field_Position_Max', };
declare class FieldSystemMetaDataFilter extends FieldSystemMetaData { 
	FilterType: EFieldFilterType;
	ObjectType: EFieldObjectType;
	PositionType: EFieldPositionType;
	static Load(ResourceName: string): FieldSystemMetaDataFilter;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataFilter;
	static GetDefaultObject(): FieldSystemMetaDataFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataFilter;
	SetMetaDataFilterType(FilterType: EFieldFilterType,ObjectType: EFieldObjectType,PositionType: EFieldPositionType): FieldSystemMetaDataFilter;
	static C(Other: UObject | any): FieldSystemMetaDataFilter;
}

declare class FieldNodeInt extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeInt;
	static Find(Outer: UObject, ResourceName: string): FieldNodeInt;
	static GetDefaultObject(): FieldNodeInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeInt;
	static C(Other: UObject | any): FieldNodeInt;
}

declare class FieldNodeFloat extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeFloat;
	static Find(Outer: UObject, ResourceName: string): FieldNodeFloat;
	static GetDefaultObject(): FieldNodeFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeFloat;
	static C(Other: UObject | any): FieldNodeFloat;
}

declare class FieldNodeVector extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeVector;
	static Find(Outer: UObject, ResourceName: string): FieldNodeVector;
	static GetDefaultObject(): FieldNodeVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeVector;
	static C(Other: UObject | any): FieldNodeVector;
}

declare class UniformInteger extends FieldNodeInt { 
	Magnitude: number;
	static Load(ResourceName: string): UniformInteger;
	static Find(Outer: UObject, ResourceName: string): UniformInteger;
	static GetDefaultObject(): UniformInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformInteger;
	SetUniformInteger(Magnitude: number): UniformInteger;
	static C(Other: UObject | any): UniformInteger;
}

declare type ESetMaskConditionType = 'Field_Set_Always' | 'Field_Set_IFF_NOT_Interior' | 'Field_Set_IFF_NOT_Exterior' | 'Field_MaskCondition_Max' | 'Field_MAX';
declare var ESetMaskConditionType : { Field_Set_Always:'Field_Set_Always',Field_Set_IFF_NOT_Interior:'Field_Set_IFF_NOT_Interior',Field_Set_IFF_NOT_Exterior:'Field_Set_IFF_NOT_Exterior',Field_MaskCondition_Max:'Field_MaskCondition_Max',Field_MAX:'Field_MAX', };
declare class RadialIntMask extends FieldNodeInt { 
	Radius: number;
	Position: Vector;
	InteriorValue: number;
	ExteriorValue: number;
	SetMaskCondition: ESetMaskConditionType;
	static Load(ResourceName: string): RadialIntMask;
	static Find(Outer: UObject, ResourceName: string): RadialIntMask;
	static GetDefaultObject(): RadialIntMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialIntMask;
	SetRadialIntMask(Radius: number,Position: Vector,InteriorValue: number,ExteriorValue: number,SetMaskConditionIn: ESetMaskConditionType): RadialIntMask;
	static C(Other: UObject | any): RadialIntMask;
}

declare class UniformScalar extends FieldNodeFloat { 
	Magnitude: number;
	static Load(ResourceName: string): UniformScalar;
	static Find(Outer: UObject, ResourceName: string): UniformScalar;
	static GetDefaultObject(): UniformScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScalar;
	SetUniformScalar(Magnitude: number): UniformScalar;
	static C(Other: UObject | any): UniformScalar;
}

declare type EWaveFunctionType = 'Field_Wave_Cosine' | 'Field_Wave_Gaussian' | 'Field_Wave_Falloff' | 'Field_Wave_Decay' | 'Field_Wave_Max';
declare var EWaveFunctionType : { Field_Wave_Cosine:'Field_Wave_Cosine',Field_Wave_Gaussian:'Field_Wave_Gaussian',Field_Wave_Falloff:'Field_Wave_Falloff',Field_Wave_Decay:'Field_Wave_Decay',Field_Wave_Max:'Field_Wave_Max', };
declare type EFieldFalloffType = 'Field_FallOff_None' | 'Field_Falloff_Linear' | 'Field_Falloff_Inverse' | 'Field_Falloff_Squared' | 'Field_Falloff_Logarithmic' | 'Field_Falloff_Max';
declare var EFieldFalloffType : { Field_FallOff_None:'Field_FallOff_None',Field_Falloff_Linear:'Field_Falloff_Linear',Field_Falloff_Inverse:'Field_Falloff_Inverse',Field_Falloff_Squared:'Field_Falloff_Squared',Field_Falloff_Logarithmic:'Field_Falloff_Logarithmic',Field_Falloff_Max:'Field_Falloff_Max', };
declare class WaveScalar extends FieldNodeFloat { 
	Magnitude: number;
	Position: Vector;
	Wavelength: number;
	Period: number;
	UFunction: EWaveFunctionType;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): WaveScalar;
	static Find(Outer: UObject, ResourceName: string): WaveScalar;
	static GetDefaultObject(): WaveScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveScalar;
	SetWaveScalar(Magnitude: number,Position: Vector,Wavelength: number,Period: number,Time: number,UFunction: EWaveFunctionType,Falloff: EFieldFalloffType): WaveScalar;
	static C(Other: UObject | any): WaveScalar;
}

declare class RadialFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Radius: number;
	Position: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): RadialFalloff;
	static Find(Outer: UObject, ResourceName: string): RadialFalloff;
	static GetDefaultObject(): RadialFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialFalloff;
	SetRadialFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Radius: number,Position: Vector,Falloff: EFieldFalloffType): RadialFalloff;
	static C(Other: UObject | any): RadialFalloff;
}

declare class PlaneFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Distance: number;
	Position: Vector;
	Normal: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): PlaneFalloff;
	static Find(Outer: UObject, ResourceName: string): PlaneFalloff;
	static GetDefaultObject(): PlaneFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneFalloff;
	SetPlaneFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Distance: number,Position: Vector,Normal: Vector,Falloff: EFieldFalloffType): PlaneFalloff;
	static C(Other: UObject | any): PlaneFalloff;
}

declare class BoxFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Transform: Transform;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): BoxFalloff;
	static Find(Outer: UObject, ResourceName: string): BoxFalloff;
	static GetDefaultObject(): BoxFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxFalloff;
	SetBoxFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Transform: Transform,Falloff: EFieldFalloffType): BoxFalloff;
	static C(Other: UObject | any): BoxFalloff;
}

declare class NoiseField extends FieldNodeFloat { 
	MinRange: number;
	MaxRange: number;
	Transform: Transform;
	static Load(ResourceName: string): NoiseField;
	static Find(Outer: UObject, ResourceName: string): NoiseField;
	static GetDefaultObject(): NoiseField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NoiseField;
	SetNoiseField(MinRange: number,MaxRange: number,Transform: Transform): NoiseField;
	static C(Other: UObject | any): NoiseField;
}

declare class UniformVector extends FieldNodeVector { 
	Magnitude: number;
	Direction: Vector;
	static Load(ResourceName: string): UniformVector;
	static Find(Outer: UObject, ResourceName: string): UniformVector;
	static GetDefaultObject(): UniformVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformVector;
	SetUniformVector(Magnitude: number,Direction: Vector): UniformVector;
	static C(Other: UObject | any): UniformVector;
}

declare class RadialVector extends FieldNodeVector { 
	Magnitude: number;
	Position: Vector;
	static Load(ResourceName: string): RadialVector;
	static Find(Outer: UObject, ResourceName: string): RadialVector;
	static GetDefaultObject(): RadialVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialVector;
	SetRadialVector(Magnitude: number,Position: Vector): RadialVector;
	static C(Other: UObject | any): RadialVector;
}

declare class RandomVector extends FieldNodeVector { 
	Magnitude: number;
	static Load(ResourceName: string): RandomVector;
	static Find(Outer: UObject, ResourceName: string): RandomVector;
	static GetDefaultObject(): RandomVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RandomVector;
	SetRandomVector(Magnitude: number): RandomVector;
	static C(Other: UObject | any): RandomVector;
}

declare type EFieldOperationType = 'Field_Multiply' | 'Field_Divide' | 'Field_Add' | 'Field_Substract' | 'Field_Operation_Max';
declare var EFieldOperationType : { Field_Multiply:'Field_Multiply',Field_Divide:'Field_Divide',Field_Add:'Field_Add',Field_Substract:'Field_Substract',Field_Operation_Max:'Field_Operation_Max', };
declare class OperatorField extends FieldNodeBase { 
	Magnitude: number;
	RightField: FieldNodeBase;
	LeftField: FieldNodeBase;
	Operation: EFieldOperationType;
	static Load(ResourceName: string): OperatorField;
	static Find(Outer: UObject, ResourceName: string): OperatorField;
	static GetDefaultObject(): OperatorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OperatorField;
	SetOperatorField(Magnitude: number,LeftField: FieldNodeBase,RightField: FieldNodeBase,Operation: EFieldOperationType): OperatorField;
	static C(Other: UObject | any): OperatorField;
}

declare class ToIntegerField extends FieldNodeInt { 
	FloatField: FieldNodeFloat;
	static Load(ResourceName: string): ToIntegerField;
	static Find(Outer: UObject, ResourceName: string): ToIntegerField;
	static GetDefaultObject(): ToIntegerField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToIntegerField;
	SetToIntegerField(FloatField: FieldNodeFloat): ToIntegerField;
	static C(Other: UObject | any): ToIntegerField;
}

declare class ToFloatField extends FieldNodeFloat { 
	IntField: FieldNodeInt;
	static Load(ResourceName: string): ToFloatField;
	static Find(Outer: UObject, ResourceName: string): ToFloatField;
	static GetDefaultObject(): ToFloatField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToFloatField;
	SetToFloatField(IntegerField: FieldNodeInt): ToFloatField;
	static C(Other: UObject | any): ToFloatField;
}

declare type EFieldCullingOperationType = 'Field_Culling_Inside' | 'Field_Culling_Outside' | 'Field_Culling_Operation_Max' | 'Field_Culling_MAX';
declare var EFieldCullingOperationType : { Field_Culling_Inside:'Field_Culling_Inside',Field_Culling_Outside:'Field_Culling_Outside',Field_Culling_Operation_Max:'Field_Culling_Operation_Max',Field_Culling_MAX:'Field_Culling_MAX', };
declare class CullingField extends FieldNodeBase { 
	Culling: FieldNodeBase;
	Field: FieldNodeBase;
	Operation: EFieldCullingOperationType;
	static Load(ResourceName: string): CullingField;
	static Find(Outer: UObject, ResourceName: string): CullingField;
	static GetDefaultObject(): CullingField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullingField;
	SetCullingField(Culling: FieldNodeBase,Field: FieldNodeBase,Operation: EFieldCullingOperationType): CullingField;
	static C(Other: UObject | any): CullingField;
}

declare class ReturnResultsTerminal extends FieldNodeBase { 
	static Load(ResourceName: string): ReturnResultsTerminal;
	static Find(Outer: UObject, ResourceName: string): ReturnResultsTerminal;
	static GetDefaultObject(): ReturnResultsTerminal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReturnResultsTerminal;
	SetReturnResultsTerminal(): ReturnResultsTerminal;
	static C(Other: UObject | any): ReturnResultsTerminal;
}

declare class DataflowEdNode extends EdGraphNode { 
	static Load(ResourceName: string): DataflowEdNode;
	static Find(Outer: UObject, ResourceName: string): DataflowEdNode;
	static GetDefaultObject(): DataflowEdNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataflowEdNode;
	static C(Other: UObject | any): DataflowEdNode;
}

declare class Dataflow extends EdGraph { 
	bActive: boolean;
	Targets: UObject[];
	static Load(ResourceName: string): Dataflow;
	static Find(Outer: UObject, ResourceName: string): Dataflow;
	static GetDefaultObject(): Dataflow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Dataflow;
	static C(Other: UObject | any): Dataflow;
}

declare class GeometryCollectionISMPoolComponent extends SceneComponent { 
	static Load(ResourceName: string): GeometryCollectionISMPoolComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionISMPoolComponent;
	static GetDefaultObject(): GeometryCollectionISMPoolComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionISMPoolComponent;
	static C(Other: UObject | any): GeometryCollectionISMPoolComponent;
}

declare class GeometryCollectionISMPoolActor extends Actor { 
	ISMPoolComp: GeometryCollectionISMPoolComponent;
	static GetDefaultObject(): GeometryCollectionISMPoolActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionISMPoolActor;
	static C(Other: UObject | any): GeometryCollectionISMPoolActor;
}

declare type EChaosCollisionSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByHighestImpulse' | 'SortByNearestFirst' | 'Count' | 'EChaosCollisionSortMethod_MAX';
declare var EChaosCollisionSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByHighestImpulse:'SortByHighestImpulse',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosCollisionSortMethod_MAX:'EChaosCollisionSortMethod_MAX', };
declare class ChaosCollisionEventRequestSettings { 
	MaxNumberResults: number;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	MaxDistance: number;
	SortMethod: EChaosCollisionSortMethod;
	clone() : ChaosCollisionEventRequestSettings;
	static C(Other: UObject | any): ChaosCollisionEventRequestSettings;
}

declare type EChaosBreakingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosBreakingSortMethod_MAX';
declare var EChaosBreakingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosBreakingSortMethod_MAX:'EChaosBreakingSortMethod_MAX', };
declare class ChaosBreakingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinRadius: number;
	MinSpeed: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosBreakingSortMethod;
	clone() : ChaosBreakingEventRequestSettings;
	static C(Other: UObject | any): ChaosBreakingEventRequestSettings;
}

declare type EChaosTrailingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosTrailingSortMethod_MAX';
declare var EChaosTrailingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosTrailingSortMethod_MAX:'EChaosTrailingSortMethod_MAX', };
declare class ChaosTrailingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MinSpeed: number;
	MinAngularSpeed: number;
	MaxDistance: number;
	SortMethod: EChaosTrailingSortMethod;
	clone() : ChaosTrailingEventRequestSettings;
	static C(Other: UObject | any): ChaosTrailingEventRequestSettings;
}

declare type EChaosRemovalSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByNearestFirst' | 'Count' | 'EChaosRemovalSortMethod_MAX';
declare var EChaosRemovalSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosRemovalSortMethod_MAX:'EChaosRemovalSortMethod_MAX', };
declare class ChaosRemovalEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosRemovalSortMethod;
	clone() : ChaosRemovalEventRequestSettings;
	static C(Other: UObject | any): ChaosRemovalEventRequestSettings;
}

declare class GeometryCollectionDamagePropagationData { 
	bEnabled: boolean;
	BreakDamagePropagationFactor: number;
	ShockDamagePropagationFactor: number;
	clone() : GeometryCollectionDamagePropagationData;
	static C(Other: UObject | any): GeometryCollectionDamagePropagationData;
}

declare class GeometryCollectionSource { 
	SourceGeometryObject: SoftObjectPath;
	LocalTransform: Transform;
	SourceMaterial: MaterialInterface[];
	bAddInternalMaterials: boolean;
	bSplitComponents: boolean;
	clone() : GeometryCollectionSource;
	static C(Other: UObject | any): GeometryCollectionSource;
}

declare class GeometryCollectionEmbeddedExemplar { 
	StaticMeshExemplar: SoftObjectPath;
	StartCullDistance: number;
	EndCullDistance: number;
	InstanceCount: number;
	clone() : GeometryCollectionEmbeddedExemplar;
	static C(Other: UObject | any): GeometryCollectionEmbeddedExemplar;
}

declare class GeometryCollectionAutoInstanceMesh { 
	StaticMesh: SoftObjectPath;
	Materials: MaterialInterface[];
	clone() : GeometryCollectionAutoInstanceMesh;
	static C(Other: UObject | any): GeometryCollectionAutoInstanceMesh;
}

declare type ECollisionTypeEnum = 'Chaos_Volumetric' | 'Chaos_Surface_Volumetric' | 'Chaos_Max';
declare var ECollisionTypeEnum : { Chaos_Volumetric:'Chaos_Volumetric',Chaos_Surface_Volumetric:'Chaos_Surface_Volumetric',Chaos_Max:'Chaos_Max', };
declare type EImplicitTypeEnum = 'Chaos_Implicit_Box' | 'Chaos_Implicit_Sphere' | 'Chaos_Implicit_Capsule' | 'Chaos_Implicit_LevelSet' | 'Chaos_Implicit_None' | 'Chaos_Implicit_Convex' | 'Chaos_Max';
declare var EImplicitTypeEnum : { Chaos_Implicit_Box:'Chaos_Implicit_Box',Chaos_Implicit_Sphere:'Chaos_Implicit_Sphere',Chaos_Implicit_Capsule:'Chaos_Implicit_Capsule',Chaos_Implicit_LevelSet:'Chaos_Implicit_LevelSet',Chaos_Implicit_None:'Chaos_Implicit_None',Chaos_Implicit_Convex:'Chaos_Implicit_Convex',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionLevelSetData { 
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	clone() : GeometryCollectionLevelSetData;
	static C(Other: UObject | any): GeometryCollectionLevelSetData;
}

declare class GeometryCollectionCollisionParticleData { 
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	clone() : GeometryCollectionCollisionParticleData;
	static C(Other: UObject | any): GeometryCollectionCollisionParticleData;
}

declare class GeometryCollectionCollisionTypeData { 
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	LevelSet: GeometryCollectionLevelSetData;
	CollisionParticles: GeometryCollectionCollisionParticleData;
	CollisionObjectReductionPercentage: number;
	CollisionMarginFraction: number;
	clone() : GeometryCollectionCollisionTypeData;
	static C(Other: UObject | any): GeometryCollectionCollisionTypeData;
}

declare class GeometryCollectionSizeSpecificData { 
	MaxSize: number;
	CollisionShapes: GeometryCollectionCollisionTypeData[];
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	DamageThreshold: number;
	clone() : GeometryCollectionSizeSpecificData;
	static C(Other: UObject | any): GeometryCollectionSizeSpecificData;
}

declare class GeometryCollection extends UObject { 
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	PerClusterOnlyDamageThreshold: boolean;
	DamagePropagationData: GeometryCollectionDamagePropagationData;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	ConnectionGraphBoundsFilteringMargin: number;
	GeometrySource: GeometryCollectionSource[];
	Materials: MaterialInterface[];
	EmbeddedGeometryExemplar: GeometryCollectionEmbeddedExemplar[];
	bUseFullPrecisionUVs: boolean;
	AutoInstanceMeshes: GeometryCollectionAutoInstanceMesh[];
	RootProxy: SoftObjectPath;
	bStripOnCook: boolean;
	EnableNanite: boolean;
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	bMassAsDensity: boolean;
	Mass: number;
	MinimumMassClamp: number;
	bImportCollisionFromSource: boolean;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	bRemoveOnMaxSleep: boolean;
	MaximumSleepTime: Vector2D;
	RemovalDuration: Vector2D;
	bSlowMovingAsSleeping: boolean;
	SlowMovingVelocityThreshold: number;
	SizeSpecificData: GeometryCollectionSizeSpecificData[];
	EnableRemovePiecesOnFracture: boolean;
	RemoveOnFractureMaterials: MaterialInterface[];
	ThumbnailInfo: ThumbnailInfo;
	Dataflow: Dataflow;
	PersistentGuid: Guid;
	StateGuid: Guid;
	BoneSelectedMaterialIndex: number;
	static Load(ResourceName: string): GeometryCollection;
	static Find(Outer: UObject, ResourceName: string): GeometryCollection;
	static GetDefaultObject(): GeometryCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollection;
	static C(Other: UObject | any): GeometryCollection;
}

declare type EObjectStateTypeEnum = 'Chaos_NONE' | 'Chaos_Object_Sleeping' | 'Chaos_Object_Kinematic' | 'Chaos_Object_Static' | 'Chaos_Object_Dynamic' | 'Chaos_Object_UserDefined' | 'Chaos_Max';
declare var EObjectStateTypeEnum : { Chaos_NONE:'Chaos_NONE',Chaos_Object_Sleeping:'Chaos_Object_Sleeping',Chaos_Object_Kinematic:'Chaos_Object_Kinematic',Chaos_Object_Static:'Chaos_Object_Static',Chaos_Object_Dynamic:'Chaos_Object_Dynamic',Chaos_Object_UserDefined:'Chaos_Object_UserDefined',Chaos_Max:'Chaos_Max', };
declare type EInitialVelocityTypeEnum = 'Chaos_Initial_Velocity_User_Defined' | 'Chaos_Initial_Velocity_None' | 'Chaos_Max';
declare var EInitialVelocityTypeEnum : { Chaos_Initial_Velocity_User_Defined:'Chaos_Initial_Velocity_User_Defined',Chaos_Initial_Velocity_None:'Chaos_Initial_Velocity_None',Chaos_Max:'Chaos_Max', };
declare type EGeometryCollectionCacheType = 'None' | 'Record' | 'Play' | 'RecordAndPlay' | 'EGeometryCollectionCacheType_MAX';
declare var EGeometryCollectionCacheType : { None:'None',Record:'Record',Play:'Play',RecordAndPlay:'RecordAndPlay',EGeometryCollectionCacheType_MAX:'EGeometryCollectionCacheType_MAX', };
declare class SolverCollisionData { 
	Location: Vector;
	AccumulatedImpulse: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	AngularVelocity1: Vector;
	AngularVelocity2: Vector;
	Mass1: number;
	Mass2: number;
	ParticleIndex: number;
	LevelsetIndex: number;
	ParticleIndexMesh: number;
	LevelsetIndexMesh: number;
	clone() : SolverCollisionData;
	static C(Other: UObject | any): SolverCollisionData;
}

declare class SolverBreakingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverBreakingData;
	static C(Other: UObject | any): SolverBreakingData;
}

declare class SolverTrailingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverTrailingData;
	static C(Other: UObject | any): SolverTrailingData;
}

declare class RecordedFrame { 
	Transforms: Transform[];
	TransformIndices: number[];
	PreviousTransformIndices: number[];
	DisabledFlags: boolean[];
	Collisions: SolverCollisionData[];
	Breakings: SolverBreakingData[];
	Trailings: Set<SolverTrailingData>;
	Timestamp: number;
	clone() : RecordedFrame;
	static C(Other: UObject | any): RecordedFrame;
}

declare class RecordedTransformTrack { 
	Records: RecordedFrame[];
	clone() : RecordedTransformTrack;
	static C(Other: UObject | any): RecordedTransformTrack;
}

declare class GeometryCollectionCache extends UObject { 
	RecordedData: RecordedTransformTrack;
	SupportedCollection: GeometryCollection;
	CompatibleCollectionState: Guid;
	static Load(ResourceName: string): GeometryCollectionCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionCache;
	static GetDefaultObject(): GeometryCollectionCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionCache;
	static C(Other: UObject | any): GeometryCollectionCache;
}

declare class GeomComponentCacheParameters { 
	CacheMode: EGeometryCollectionCacheType;
	TargetCache: GeometryCollectionCache;
	ReverseCacheBeginTime: number;
	SaveCollisionData: boolean;
	DoGenerateCollisionData: boolean;
	CollisionDataSizeMax: number;
	DoCollisionDataSpatialHash: boolean;
	CollisionDataSpatialHashRadius: number;
	MaxCollisionPerCell: number;
	SaveBreakingData: boolean;
	DoGenerateBreakingData: boolean;
	BreakingDataSizeMax: number;
	DoBreakingDataSpatialHash: boolean;
	BreakingDataSpatialHashRadius: number;
	MaxBreakingPerCell: number;
	SaveTrailingData: boolean;
	DoGenerateTrailingData: boolean;
	TrailingDataSizeMax: number;
	TrailingMinSpeedThreshold: number;
	TrailingMinVolumeThreshold: number;
	clone() : GeomComponentCacheParameters;
	static C(Other: UObject | any): GeomComponentCacheParameters;
}

declare class ChaosBreakEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	Index: number;
	clone() : ChaosBreakEvent;
	static C(Other: UObject | any): ChaosBreakEvent;
}

declare class ChaosRemovalEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Mass: number;
	clone() : ChaosRemovalEvent;
	static C(Other: UObject | any): ChaosRemovalEvent;
}

declare class ChaosCrumblingEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Orientation: Quat;
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	LocalBounds: Box;
	Children: number[];
	clone() : ChaosCrumblingEvent;
	static C(Other: UObject | any): ChaosCrumblingEvent;
}

declare class GeometryCollectionRepData { 
	clone() : GeometryCollectionRepData;
	static C(Other: UObject | any): GeometryCollectionRepData;
}

declare type EGeometryCollectionPhysicsTypeEnum = 'Chaos_AngularVelocity' | 'Chaos_DynamicState' | 'Chaos_LinearVelocity' | 'Chaos_InitialAngularVelocity' | 'Chaos_InitialLinearVelocity' | 'Chaos_CollisionGroup' | 'Chaos_LinearForce' | 'Chaos_AngularTorque' | 'Chaos_DisableThreshold' | 'Chaos_SleepingThreshold' | 'Chaos_ExternalClusterStrain' | 'Chaos_InternalClusterStrain' | 'Chaos_LinearImpulse' | 'Chaos_Max';
declare var EGeometryCollectionPhysicsTypeEnum : { Chaos_AngularVelocity:'Chaos_AngularVelocity',Chaos_DynamicState:'Chaos_DynamicState',Chaos_LinearVelocity:'Chaos_LinearVelocity',Chaos_InitialAngularVelocity:'Chaos_InitialAngularVelocity',Chaos_InitialLinearVelocity:'Chaos_InitialLinearVelocity',Chaos_CollisionGroup:'Chaos_CollisionGroup',Chaos_LinearForce:'Chaos_LinearForce',Chaos_AngularTorque:'Chaos_AngularTorque',Chaos_DisableThreshold:'Chaos_DisableThreshold',Chaos_SleepingThreshold:'Chaos_SleepingThreshold',Chaos_ExternalClusterStrain:'Chaos_ExternalClusterStrain',Chaos_InternalClusterStrain:'Chaos_InternalClusterStrain',Chaos_LinearImpulse:'Chaos_LinearImpulse',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionComponent extends MeshComponent { 
	ChaosSolverActor: ChaosSolverActor;
	RestCollection: GeometryCollection;
	InitializationFields: FieldSystemActor[];
	Simulating: boolean;
	ObjectType: EObjectStateTypeEnum;
	bForceMotionBlur: boolean;
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	DamagePropagationData: GeometryCollectionDamagePropagationData;
	bAllowRemovalOnSleep: boolean;
	bAllowRemovalOnBreak: boolean;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	CollisionGroup: number;
	CollisionSampleFraction: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	PhysicalMaterial: ChaosPhysicalMaterial;
	InitialVelocityType: EInitialVelocityTypeEnum;
	InitialLinearVelocity: Vector;
	InitialAngularVelocity: Vector;
	PhysicalMaterialOverride: PhysicalMaterial;
	CacheParameters: GeomComponentCacheParameters;
	RestTransforms: Transform[];
	NotifyGeometryCollectionPhysicsStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	NotifyGeometryCollectionPhysicsLoadingStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	OnChaosBreakEvent: UnrealEngineMulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
	OnChaosRemovalEvent: UnrealEngineMulticastDelegate<(RemovalEvent: ChaosRemovalEvent) => void>;
	OnChaosCrumblingEvent: UnrealEngineMulticastDelegate<(CrumbleEvent: ChaosCrumblingEvent) => void>;
	DesiredCacheTime: number;
	CachePlayback: boolean;
	OnChaosPhysicsCollision: UnrealEngineMulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
	bNotifyBreaks: boolean;
	bNotifyCollisions: boolean;
	bNotifyTrailing: boolean;
	bNotifyRemovals: boolean;
	bNotifyCrumblings: boolean;
	bCrumblingEventIncludesChildren: boolean;
	bStoreVelocities: boolean;
	bShowBoneColors: boolean;
	bEnableRunTimeDataCollection: boolean;
	RunTimeDataCollectionGuid: Guid;
	ISMPool: GeometryCollectionISMPoolActor;
	bEnableReplication: boolean;
	bEnableAbandonAfterLevel: boolean;
	ReplicationAbandonClusterLevel: number;
	ReplicationAbandonAfterLevel: number;
	RepData: GeometryCollectionRepData;
	SelectedBones: number[];
	HighlightedBones: number[];
	DummyBodySetup: BodySetup;
	EditorActor: Actor;
	EmbeddedGeometryComponents: InstancedStaticMeshComponent[];
	static Load(ResourceName: string): GeometryCollectionComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionComponent;
	static GetDefaultObject(): GeometryCollectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionComponent;
	SetRestCollection(RestCollectionIn: GeometryCollection): void;
	SetNotifyRemovals(bNewNotifyRemovals: boolean): void;
	SetNotifyCrumblings(bNewNotifyCrumblings: boolean): void;
	SetNotifyBreaks(bNewNotifyBreaks: boolean): void;
	RemoveAllAnchors(): void;
	ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
	GetMassAndExtents(ItemIndex: number,OutMass?: number,OutExtents?: Box): {OutMass: number, OutExtents: Box};
	GetInitialLevel(ItemIndex: number): number;
	CrumbleCluster(ItemIndex: number): void;
	CrumbleActiveClusters(): void;
	ApplyPhysicsField(Enabled: boolean,Target: EGeometryCollectionPhysicsTypeEnum,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearVelocity(ItemIndex: number,LinearVelocity: Vector): void;
	ApplyKinematicField(Radius: number,Position: Vector): void;
	ApplyInternalStrain(ItemIndex: number,Location: Vector,Radius: number,PropagationDepth: number,PropagationFactor: number,Strain: number): void;
	ApplyExternalStrain(ItemIndex: number,Location: Vector,Radius: number,PropagationDepth: number,PropagationFactor: number,Strain: number): void;
	ApplyBreakingLinearVelocity(ItemIndex: number,LinearVelocity: Vector): void;
	ApplyBreakingAngularVelocity(ItemIndex: number,AngularVelocity: Vector): void;
	ApplyAngularVelocity(ItemIndex: number,AngularVelocity: Vector): void;
	static C(Other: UObject | any): GeometryCollectionComponent;
}

declare class GeometryCollectionDebugDrawWarningMessage { 
	clone() : GeometryCollectionDebugDrawWarningMessage;
	static C(Other: UObject | any): GeometryCollectionDebugDrawWarningMessage;
}

declare class GeometryCollectionDebugDrawActorSelectedRigidBody { 
	ID: number;
	Solver: ChaosSolverActor;
	GeometryCollection: GeometryCollectionActor;
	clone() : GeometryCollectionDebugDrawActorSelectedRigidBody;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActorSelectedRigidBody;
}

declare type EGeometryCollectionDebugDrawActorHideGeometry = 'HideNone' | 'HideWithCollision' | 'HideSelected' | 'HideWholeCollection' | 'HideAll' | 'EGeometryCollectionDebugDrawActorHideGeometry_MAX';
declare var EGeometryCollectionDebugDrawActorHideGeometry : { HideNone:'HideNone',HideWithCollision:'HideWithCollision',HideSelected:'HideSelected',HideWholeCollection:'HideWholeCollection',HideAll:'HideAll',EGeometryCollectionDebugDrawActorHideGeometry_MAX:'EGeometryCollectionDebugDrawActorHideGeometry_MAX', };
declare class GeometryCollectionDebugDrawActor extends Actor { 
	WarningMessage: GeometryCollectionDebugDrawWarningMessage;
	SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
	bDebugDrawWholeCollection: boolean;
	bDebugDrawHierarchy: boolean;
	bDebugDrawClustering: boolean;
	HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
	bShowRigidBodyId: boolean;
	bShowRigidBodyCollision: boolean;
	bCollisionAtOrigin: boolean;
	bShowRigidBodyTransform: boolean;
	bShowRigidBodyInertia: boolean;
	bShowRigidBodyVelocity: boolean;
	bShowRigidBodyForce: boolean;
	bShowRigidBodyInfos: boolean;
	bShowTransformIndex: boolean;
	bShowTransform: boolean;
	bShowParent: boolean;
	bShowLevel: boolean;
	bShowConnectivityEdges: boolean;
	bShowGeometryIndex: boolean;
	bShowGeometryTransform: boolean;
	bShowBoundingBox: boolean;
	bShowFaces: boolean;
	bShowFaceIndices: boolean;
	bShowFaceNormals: boolean;
	bShowSingleFace: boolean;
	SingleFaceIndex: number;
	bShowVertices: boolean;
	bShowVertexIndices: boolean;
	bShowVertexNormals: boolean;
	bUseActiveVisualization: boolean;
	PointThickness: number;
	LineThickness: number;
	bTextShadow: boolean;
	TextScale: number;
	NormalScale: number;
	AxisScale: number;
	ArrowScale: number;
	RigidBodyIdColor: Color;
	RigidBodyTransformScale: number;
	RigidBodyCollisionColor: Color;
	RigidBodyInertiaColor: Color;
	RigidBodyVelocityColor: Color;
	RigidBodyForceColor: Color;
	RigidBodyInfoColor: Color;
	TransformIndexColor: Color;
	TransformScale: number;
	LevelColor: Color;
	ParentColor: Color;
	ConnectivityEdgeThickness: number;
	GeometryIndexColor: Color;
	GeometryTransformScale: number;
	BoundingBoxColor: Color;
	FaceColor: Color;
	FaceIndexColor: Color;
	FaceNormalColor: Color;
	SingleFaceColor: Color;
	VertexColor: Color;
	VertexIndexColor: Color;
	VertexNormalColor: Color;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawActor;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActor;
}

declare class GeometryCollectionRenderLevelSetActor extends Actor { 
	TargetVolumeTexture: VolumeTexture;
	RayMarchMaterial: Material;
	SurfaceTolerance: number;
	Isovalue: number;
	Enabled: boolean;
	RenderVolumeBoundingBox: boolean;
	static GetDefaultObject(): GeometryCollectionRenderLevelSetActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionRenderLevelSetActor;
	static C(Other: UObject | any): GeometryCollectionRenderLevelSetActor;
}

declare class GeometryCollectionDebugDrawComponent extends ActorComponent { 
	GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
	GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;
	static Load(ResourceName: string): GeometryCollectionDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawComponent;
	static C(Other: UObject | any): GeometryCollectionDebugDrawComponent;
}

declare class GeometryCollectionActor extends Actor { 
	GeometryCollectionComponent: GeometryCollectionComponent;
	GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionActor;
	RaycastSingle(Start: Vector,End: Vector,OutHit?: HitResult): {OutHit: HitResult, $: boolean};
	static C(Other: UObject | any): GeometryCollectionActor;
}

declare class ChaosCollisionEventData { 
	Location: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	Mass1: number;
	Mass2: number;
	Impulse: Vector;
	clone() : ChaosCollisionEventData;
	static C(Other: UObject | any): ChaosCollisionEventData;
}

declare class ChaosBreakingEventData { 
	Location: Vector;
	Velocity: Vector;
	Mass: number;
	clone() : ChaosBreakingEventData;
	static C(Other: UObject | any): ChaosBreakingEventData;
}

declare class ChaosTrailingEventData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosTrailingEventData;
	static C(Other: UObject | any): ChaosTrailingEventData;
}

declare class ChaosRemovalEventData { 
	Location: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosRemovalEventData;
	static C(Other: UObject | any): ChaosRemovalEventData;
}

declare class ChaosDestructionListener extends SceneComponent { 
	bIsCollisionEventListeningEnabled: boolean;
	bIsBreakingEventListeningEnabled: boolean;
	bIsTrailingEventListeningEnabled: boolean;
	bIsRemovalEventListeningEnabled: boolean;
	CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
	BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
	TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
	RemovalEventRequestSettings: ChaosRemovalEventRequestSettings;
	ChaosSolverActors: Set<ChaosSolverActor>;
	GeometryCollectionActors: Set<GeometryCollectionActor>;
	OnCollisionEvents: UnrealEngineMulticastDelegate<(CollisionEvents: ChaosCollisionEventData[]) => void>;
	OnBreakingEvents: UnrealEngineMulticastDelegate<(BreakingEvents: ChaosBreakingEventData[]) => void>;
	OnTrailingEvents: UnrealEngineMulticastDelegate<(TrailingEvents: ChaosTrailingEventData[]) => void>;
	OnRemovalEvents: UnrealEngineMulticastDelegate<(RemovalEvents: ChaosRemovalEventData[]) => void>;
	static Load(ResourceName: string): ChaosDestructionListener;
	static Find(Outer: UObject, ResourceName: string): ChaosDestructionListener;
	static GetDefaultObject(): ChaosDestructionListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDestructionListener;
	SortTrailingEvents(TrailingEvents?: ChaosTrailingEventData[],SortMethod?: EChaosTrailingSortMethod): {TrailingEvents: ChaosTrailingEventData[]};
	SortRemovalEvents(RemovalEvents?: ChaosRemovalEventData[],SortMethod?: EChaosRemovalSortMethod): {RemovalEvents: ChaosRemovalEventData[]};
	SortCollisionEvents(CollisionEvents?: ChaosCollisionEventData[],SortMethod?: EChaosCollisionSortMethod): {CollisionEvents: ChaosCollisionEventData[]};
	SortBreakingEvents(BreakingEvents?: ChaosBreakingEventData[],SortMethod?: EChaosBreakingSortMethod): {BreakingEvents: ChaosBreakingEventData[]};
	SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;
	SetTrailingEventEnabled(bIsEnabled: boolean): void;
	SetRemovalEventRequestSettings(InSettings: ChaosRemovalEventRequestSettings): void;
	SetRemovalEventEnabled(bIsEnabled: boolean): void;
	SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;
	SetCollisionEventEnabled(bIsEnabled: boolean): void;
	SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;
	SetBreakingEventEnabled(bIsEnabled: boolean): void;
	RemoveGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	RemoveChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	IsEventListening(): boolean;
	AddGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	AddChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	static C(Other: UObject | any): ChaosDestructionListener;
}

declare class ParticleTransformTrack { 
	RawTransformTrack: RawAnimSequenceTrack;
	BeginOffset: number;
	bDeactivateOnEnd: boolean;
	KeyTimestamps: number[];
	clone() : ParticleTransformTrack;
	static C(Other: UObject | any): ParticleTransformTrack;
}

declare class PerParticleCacheData { 
	TransformData: ParticleTransformTrack;
	CurveData: Map<string, RichCurve>;
	clone() : PerParticleCacheData;
	static C(Other: UObject | any): PerParticleCacheData;
}

declare class RichCurves { 
	RichCurves: RichCurve[];
	clone() : RichCurves;
	static C(Other: UObject | any): RichCurves;
}

declare class CacheEventTrack { 
	Name: string;
	struct: ScriptStruct;
	TimeStamps: number[];
	clone() : CacheEventTrack;
	static C(Other: UObject | any): CacheEventTrack;
}

declare class CacheSpawnableTemplate { 
	DuplicatedTemplate: UObject;
	InitialTransform: Transform;
	ComponentTransform: Transform;
	clone() : CacheSpawnableTemplate;
	static C(Other: UObject | any): CacheSpawnableTemplate;
}

declare class ChaosCache extends UObject { 
	RecordedDuration: number;
	NumRecordedFrames: number;
	TrackToParticle: number[];
	ParticleTracks: PerParticleCacheData[];
	ChannelsTracks: Map<string, RichCurves>;
	CurveData: Map<string, RichCurve>;
	EventTracks: Map<string, CacheEventTrack>;
	Spawnable: CacheSpawnableTemplate;
	AdapterGuid: Guid;
	Version: number;
	static Load(ResourceName: string): ChaosCache;
	static Find(Outer: UObject, ResourceName: string): ChaosCache;
	static GetDefaultObject(): ChaosCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCache;
	static C(Other: UObject | any): ChaosCache;
}

declare class ChaosCacheCollection extends UObject { 
	Caches: ChaosCache[];
	static Load(ResourceName: string): ChaosCacheCollection;
	static Find(Outer: UObject, ResourceName: string): ChaosCacheCollection;
	static GetDefaultObject(): ChaosCacheCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCacheCollection;
	static C(Other: UObject | any): ChaosCacheCollection;
}

declare type ECacheMode = 'None' | 'Play' | 'Record' | 'ECacheMode_MAX';
declare var ECacheMode : { None:'None',Play:'Play',Record:'Record',ECacheMode_MAX:'ECacheMode_MAX', };
declare type EStartMode = 'Timed' | 'Triggered' | 'EStartMode_MAX';
declare var EStartMode : { Timed:'Timed',Triggered:'Triggered',EStartMode_MAX:'EStartMode_MAX', };
declare class SoftComponentReference extends BaseComponentReference { 
	OtherActor: Actor;
	clone() : SoftComponentReference;
	static C(Other: UObject | any): SoftComponentReference;
}

declare class ObservedComponent { 
	CacheName: string;
	ComponentRef: ComponentReference;
	SoftComponentRef: SoftComponentReference;
	bIsSimulating: boolean;
	clone() : ObservedComponent;
	static C(Other: UObject | any): ObservedComponent;
}

declare class ChaosCacheManager extends Actor { 
	CacheCollection: ChaosCacheCollection;
	CacheMode: ECacheMode;
	StartMode: EStartMode;
	StartTime: number;
	ObservedComponents: ObservedComponent[];
	static GetDefaultObject(): ChaosCacheManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCacheManager;
	TriggerComponentByCache(InCacheName: string): void;
	TriggerComponent(InComponent: PrimitiveComponent): void;
	TriggerAll(): void;
	SetStartTime(InStartTime: number): void;
	ResetSingleTransform(InIndex: number): void;
	ResetAllComponentTransforms(): void;
	static C(Other: UObject | any): ChaosCacheManager;
}

declare class ChaosCachePlayer extends ChaosCacheManager { 
	static GetDefaultObject(): ChaosCachePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCachePlayer;
	static C(Other: UObject | any): ChaosCachePlayer;
}

declare class MovieSceneBaseCacheParams { 
	FirstLoopStartFrameOffset: FrameNumber;
	StartFrameOffset: FrameNumber;
	EndFrameOffset: FrameNumber;
	PlayRate: number;
	bReverse: boolean;
	clone() : MovieSceneBaseCacheParams;
	static C(Other: UObject | any): MovieSceneBaseCacheParams;
}

declare class MovieSceneChaosCacheParams extends MovieSceneBaseCacheParams { 
	CacheCollection: ChaosCacheCollection;
	clone() : MovieSceneChaosCacheParams;
	static C(Other: UObject | any): MovieSceneChaosCacheParams;
}

declare class MovieSceneChaosCacheSection extends MovieSceneBaseCacheSection { 
	Params: MovieSceneChaosCacheParams;
	static Load(ResourceName: string): MovieSceneChaosCacheSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneChaosCacheSection;
	static GetDefaultObject(): MovieSceneChaosCacheSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneChaosCacheSection;
	static C(Other: UObject | any): MovieSceneChaosCacheSection;
}

declare class MovieSceneChaosCacheTrack extends MovieSceneNameableTrack { 
	AnimationSections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneChaosCacheTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneChaosCacheTrack;
	static GetDefaultObject(): MovieSceneChaosCacheTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneChaosCacheTrack;
	static C(Other: UObject | any): MovieSceneChaosCacheTrack;
}

declare type EClothMassMode = 'UniformMass' | 'TotalMass' | 'Density' | 'MaxClothMassMode' | 'EClothMassMode_MAX';
declare var EClothMassMode : { UniformMass:'UniformMass',TotalMass:'TotalMass',Density:'Density',MaxClothMassMode:'MaxClothMassMode',EClothMassMode_MAX:'EClothMassMode_MAX', };
declare class ChaosClothWeightedValue { 
	Low: number;
	High: number;
	clone() : ChaosClothWeightedValue;
	static C(Other: UObject | any): ChaosClothWeightedValue;
}

declare type EChaosClothTetherMode = 'FastTetherFastLength' | 'AccurateTetherFastLength' | 'AccurateTetherAccurateLength' | 'MaxChaosClothTetherMode' | 'EChaosClothTetherMode_MAX';
declare var EChaosClothTetherMode : { FastTetherFastLength:'FastTetherFastLength',AccurateTetherFastLength:'AccurateTetherFastLength',AccurateTetherAccurateLength:'AccurateTetherAccurateLength',MaxChaosClothTetherMode:'MaxChaosClothTetherMode',EChaosClothTetherMode_MAX:'EChaosClothTetherMode_MAX', };
declare class ChaosClothConfig extends ClothConfigCommon { 
	MassMode: EClothMassMode;
	UniformMass: number;
	TotalMass: number;
	Density: number;
	MinPerParticleMass: number;
	EdgeStiffnessWeighted: ChaosClothWeightedValue;
	BendingStiffnessWeighted: ChaosClothWeightedValue;
	bUseBendingElements: boolean;
	BucklingRatio: number;
	BucklingStiffnessWeighted: ChaosClothWeightedValue;
	AreaStiffnessWeighted: ChaosClothWeightedValue;
	VolumeStiffness: number;
	TetherStiffness: ChaosClothWeightedValue;
	TetherScale: ChaosClothWeightedValue;
	bUseGeodesicDistance: boolean;
	ShapeTargetStiffness: number;
	CollisionThickness: number;
	FrictionCoefficient: number;
	bUseCCD: boolean;
	bUseSelfCollisions: boolean;
	SelfCollisionThickness: number;
	SelfCollisionFriction: number;
	bUseSelfIntersections: boolean;
	bUseLegacyBackstop: boolean;
	DampingCoefficient: number;
	LocalDampingCoefficient: number;
	bUsePointBasedWindModel: boolean;
	Drag: ChaosClothWeightedValue;
	Lift: ChaosClothWeightedValue;
	bUseGravityOverride: boolean;
	GravityScale: number;
	Gravity: Vector;
	Pressure: ChaosClothWeightedValue;
	AnimDriveStiffness: ChaosClothWeightedValue;
	AnimDriveDamping: ChaosClothWeightedValue;
	LinearVelocityScale: Vector;
	AngularVelocityScale: number;
	FictitiousAngularScale: number;
	bUseTetrahedralConstraints: boolean;
	bUseThinShellVolumeConstraints: boolean;
	bUseContinuousCollisionDetection: boolean;
	EdgeStiffness: number;
	BendingStiffness: number;
	AreaStiffness: number;
	TetherMode: EChaosClothTetherMode;
	LimitScale: number;
	DragCoefficient: number;
	LiftCoefficient: number;
	AnimDriveSpringStiffness: number;
	StrainLimitingStiffness: number;
	static Load(ResourceName: string): ChaosClothConfig;
	static Find(Outer: UObject, ResourceName: string): ChaosClothConfig;
	static GetDefaultObject(): ChaosClothConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothConfig;
	static C(Other: UObject | any): ChaosClothConfig;
}

declare class ChaosClothSharedSimConfig extends ClothSharedConfigCommon { 
	IterationCount: number;
	MaxIterationCount: number;
	SubdivisionCount: number;
	SelfCollisionThickness: number;
	CollisionThickness: number;
	bUseDampingOverride: boolean;
	Damping: number;
	bUseGravityOverride: boolean;
	GravityScale: number;
	Gravity: Vector;
	bUseLocalSpaceSimulation: boolean;
	bUseXPBDConstraints: boolean;
	static Load(ResourceName: string): ChaosClothSharedSimConfig;
	static Find(Outer: UObject, ResourceName: string): ChaosClothSharedSimConfig;
	static GetDefaultObject(): ChaosClothSharedSimConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothSharedSimConfig;
	static C(Other: UObject | any): ChaosClothSharedSimConfig;
}

declare class ChaosClothingSimulationFactory extends ClothingSimulationFactory { 
	static Load(ResourceName: string): ChaosClothingSimulationFactory;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingSimulationFactory;
	static GetDefaultObject(): ChaosClothingSimulationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingSimulationFactory;
	static C(Other: UObject | any): ChaosClothingSimulationFactory;
}

declare class ChaosClothingInteractor extends ClothingInteractor { 
	static Load(ResourceName: string): ChaosClothingInteractor;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingInteractor;
	static GetDefaultObject(): ChaosClothingInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingInteractor;
	SetWind(Drag: Vector2D,Lift: Vector2D,AirDensity: number,WindVelocity: Vector): void;
	SetVelocityScale(LinearVelocityScale: Vector,AngularVelocityScale: number,FictitiousAngularScale: number): void;
	SetPressure(Pressure: Vector2D): void;
	SetMaterialLinear(EdgeStiffness: number,BendingStiffness: number,AreaStiffness: number): void;
	SetMaterial(EdgeStiffness: Vector2D,BendingStiffness: Vector2D,AreaStiffness: Vector2D): void;
	SetLongRangeAttachmentLinear(TetherStiffness: number,TetherScale: number): void;
	SetLongRangeAttachment(TetherStiffness: Vector2D,TetherScale: Vector2D): void;
	SetGravity(GravityScale: number,bIsGravityOverridden: boolean,GravityOverride: Vector): void;
	SetDamping(DampingCoefficient: number,LocalDampingCoefficient: number): void;
	SetCollision(CollisionThickness: number,FrictionCoefficient: number,bUseCCD: boolean,SelfCollisionThickness: number): void;
	SetBackstop(bEnabled: boolean): void;
	SetAnimDriveLinear(AnimDriveStiffness: number): void;
	SetAnimDrive(AnimDriveStiffness: Vector2D,AnimDriveDamping: Vector2D): void;
	SetAerodynamics(DragCoefficient: number,LiftCoefficient: number,WindVelocity: Vector): void;
	ResetAndTeleport(bReset: boolean,bTeleport: boolean): void;
	static C(Other: UObject | any): ChaosClothingInteractor;
}

declare class ChaosClothingSimulationInteractor extends ClothingSimulationInteractor { 
	static Load(ResourceName: string): ChaosClothingSimulationInteractor;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingSimulationInteractor;
	static GetDefaultObject(): ChaosClothingSimulationInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingSimulationInteractor;
	static C(Other: UObject | any): ChaosClothingSimulationInteractor;
}

declare class VariantDependency { 
	VariantSet: VariantSet;
	Variant: Variant;
	bEnabled: boolean;
	clone() : VariantDependency;
	static C(Other: UObject | any): VariantDependency;
}

declare class CapturedPropSegment { 
	PropertyName: string;
	PropertyIndex: number;
	ComponentName: string;
	clone() : CapturedPropSegment;
	static C(Other: UObject | any): CapturedPropSegment;
}

declare type EPropertyValueCategory = 'Undefined' | 'Generic' | 'RelativeLocation' | 'RelativeRotation' | 'RelativeScale3D' | 'Visibility' | 'Material' | 'Color' | 'Option' | 'EPropertyValueCategory_MAX';
declare var EPropertyValueCategory : { Undefined:'Undefined',Generic:'Generic',RelativeLocation:'RelativeLocation',RelativeRotation:'RelativeRotation',RelativeScale3D:'RelativeScale3D',Visibility:'Visibility',Material:'Material',Color:'Color',Option:'Option',EPropertyValueCategory_MAX:'EPropertyValueCategory_MAX', };
declare class PropertyValue extends UObject { 
	Properties: any[];
	PropertyIndices: number[];
	CapturedPropSegments: CapturedPropSegment[];
	FullDisplayString: string;
	PropertySetterName: string;
	PropertySetterParameterDefaults: Map<string, string>;
	bHasRecordedData: boolean;
	LeafPropertyClass: UnrealEngineClass;
	ValueBytes: number[];
	PropCategory: EPropertyValueCategory;
	DisplayOrder: number;
	static Load(ResourceName: string): PropertyValue;
	static Find(Outer: UObject, ResourceName: string): PropertyValue;
	static GetDefaultObject(): PropertyValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValue;
	HasRecordedData(): boolean;
	GetPropertyTooltip(): string;
	GetFullDisplayString(): string;
	static C(Other: UObject | any): PropertyValue;
	Apply(): void;
	GetPropertyTypeString(): string;
	GetValueBool(): boolean;
	GetValueColor(): Color;
	GetValueFloat(): number;
	GetValueInt(): number;
	GetValueIntPoint(): IntPoint;
	GetValueLinearColor(): LinearColor;
	GetValueObject(): UObject;
	GetValueQuat(): Quat;
	GetValueRotator(): Rotator;
	GetValueString(): string;
	GetValueVector(): Vector;
	GetValueVector2D(): Vector2D;
	GetValueVector4(): Vector4;
	Record(): void;
	SetValueBool(InValue: boolean): void;
	SetValueColor(InValue: Color): void;
	SetValueFloat(InValue: number): void;
	SetValueInt(InValue: number): void;
	SetValueIntPoint(InValue: IntPoint): void;
	SetValueLinearColor(InValue: LinearColor): void;
	SetValueObject(InValue: UObject): void;
	SetValueQuat(InValue: Quat): void;
	SetValueRotator(InValue: Rotator): void;
	SetValueString(InValue: string): void;
	SetValueVector(InValue: Vector): void;
	SetValueVector2D(InValue: Vector2D): void;
	SetValueVector4(InValue: Vector4): void;
	static Apply(PropVal: PropertyValue): void;
	static GetPropertyTypeString(PropVal: PropertyValue): string;
	static GetValueBool(Property: PropertyValue): boolean;
	static GetValueColor(Property: PropertyValue): Color;
	static GetValueFloat(Property: PropertyValue): number;
	static GetValueInt(Property: PropertyValue): number;
	static GetValueIntPoint(Property: PropertyValue): IntPoint;
	static GetValueLinearColor(Property: PropertyValue): LinearColor;
	static GetValueObject(Property: PropertyValue): UObject;
	static GetValueQuat(Property: PropertyValue): Quat;
	static GetValueRotator(Property: PropertyValue): Rotator;
	static GetValueString(Property: PropertyValue): string;
	static GetValueVector(Property: PropertyValue): Vector;
	static GetValueVector2D(Property: PropertyValue): Vector2D;
	static GetValueVector4(Property: PropertyValue): Vector4;
	static Record(PropVal: PropertyValue): void;
	static SetValueBool(Property: PropertyValue,InValue: boolean): void;
	static SetValueColor(Property: PropertyValue,InValue: Color): void;
	static SetValueFloat(Property: PropertyValue,InValue: number): void;
	static SetValueInt(Property: PropertyValue,InValue: number): void;
	static SetValueIntPoint(Property: PropertyValue,InValue: IntPoint): void;
	static SetValueLinearColor(Property: PropertyValue,InValue: LinearColor): void;
	static SetValueObject(Property: PropertyValue,InValue: UObject): void;
	static SetValueQuat(Property: PropertyValue,InValue: Quat): void;
	static SetValueRotator(Property: PropertyValue,InValue: Rotator): void;
	static SetValueString(Property: PropertyValue,InValue: string): void;
	static SetValueVector(Property: PropertyValue,InValue: Vector): void;
	static SetValueVector2D(Property: PropertyValue,InValue: Vector2D): void;
	static SetValueVector4(Property: PropertyValue,InValue: Vector4): void;
}

declare class FunctionCaller { 
	FunctionName: string;
	FunctionEntry: UObject;
	DisplayOrder: number;
	clone() : FunctionCaller;
	static C(Other: UObject | any): FunctionCaller;
}

declare class VariantObjectBinding extends UObject { 
	CachedActorLabel: string;
	ObjectPtr: SoftObjectPath;
	LazyObjectPtr: UObject;
	CapturedProperties: PropertyValue[];
	FunctionCallers: FunctionCaller[];
	static Load(ResourceName: string): VariantObjectBinding;
	static Find(Outer: UObject, ResourceName: string): VariantObjectBinding;
	static GetDefaultObject(): VariantObjectBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VariantObjectBinding;
	static C(Other: UObject | any): VariantObjectBinding;
}

declare class Variant extends UObject { 
	Dependencies: VariantDependency[];
	DisplayText: string;
	ObjectBindings: VariantObjectBinding[];
	Thumbnail: Texture2D;
	static Load(ResourceName: string): Variant;
	static Find(Outer: UObject, ResourceName: string): Variant;
	static GetDefaultObject(): Variant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Variant;
	SwitchOn(): void;
	SetThumbnailFromTexture(NewThumbnail: Texture2D): void;
	SetThumbnailFromFile(FilePath: string): void;
	SetThumbnailFromEditorViewport(): void;
	SetThumbnailFromCamera(WorldContextObject: UObject,CameraTransform: Transform,FOVDegrees: number,MinZ: number,Gamma: number): void;
	SetDisplayText(NewDisplayText: string): void;
	SetDependency(Index: number,Dependency?: VariantDependency): {Dependency: VariantDependency};
	IsActive(): boolean;
	GetThumbnail(): Texture2D;
	GetParent(): VariantSet;
	GetNumDependencies(): number;
	GetNumActors(): number;
	GetDisplayText(): string;
	GetDependents(LevelVariantSets: LevelVariantSets,bOnlyEnabledDependencies: boolean): Variant[];
	GetDependency(Index: number): VariantDependency;
	GetActor(ActorIndex: number): Actor;
	DeleteDependency(Index: number): void;
	AddDependency(Dependency?: VariantDependency): {Dependency: VariantDependency, $: number};
	static C(Other: UObject | any): Variant;
	AddActorBinding(Actor: Actor): void;
	AddDependency(Dependency?: VariantDependency): {Dependency: VariantDependency, $: number};
	CaptureProperty(Actor: Actor,PropertyPath: string): PropertyValue;
	DeleteDependency(Index: number): void;
	GetCapturedProperties(Actor: Actor): PropertyValue[];
	RemoveActorBinding(Actor: Actor): void;
	RemoveActorBindingByName(ActorName: string): void;
	RemoveCapturedProperty(Actor: Actor,Property: PropertyValue): void;
	RemoveCapturedPropertyByName(Actor: Actor,PropertyPath: string): void;
	SetDependency(Index: number,Dependency?: VariantDependency): {Dependency: VariantDependency};
	static AddActorBinding(Variant: Variant,Actor: Actor): void;
	static AddDependency(Variant: Variant,Dependency?: VariantDependency): {Dependency: VariantDependency, $: number};
	static CaptureProperty(Variant: Variant,Actor: Actor,PropertyPath: string): PropertyValue;
	static DeleteDependency(Variant: Variant,Index: number): void;
	static GetCapturedProperties(Variant: Variant,Actor: Actor): PropertyValue[];
	static RemoveActorBinding(Variant: Variant,Actor: Actor): void;
	static RemoveActorBindingByName(Variant: Variant,ActorName: string): void;
	static RemoveCapturedProperty(Variant: Variant,Actor: Actor,Property: PropertyValue): void;
	static RemoveCapturedPropertyByName(Variant: Variant,Actor: Actor,PropertyPath: string): void;
	static SetDependency(Variant: Variant,Index: number,Dependency?: VariantDependency): {Dependency: VariantDependency};
}

declare class VariantSet extends UObject { 
	DisplayText: string;
	bExpanded: boolean;
	Variants: Variant[];
	Thumbnail: Texture2D;
	static Load(ResourceName: string): VariantSet;
	static Find(Outer: UObject, ResourceName: string): VariantSet;
	static GetDefaultObject(): VariantSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VariantSet;
	SetThumbnailFromTexture(NewThumbnail: Texture2D): void;
	SetThumbnailFromFile(FilePath: string): void;
	SetThumbnailFromEditorViewport(): void;
	SetThumbnailFromCamera(WorldContextObject: UObject,CameraTransform: Transform,FOVDegrees: number,MinZ: number,Gamma: number): void;
	SetDisplayText(NewDisplayText: string): void;
	GetVariantByName(VariantName: string): Variant;
	GetVariant(VariantIndex: number): Variant;
	GetThumbnail(): Texture2D;
	GetParent(): LevelVariantSets;
	GetNumVariants(): number;
	GetDisplayText(): string;
	static C(Other: UObject | any): VariantSet;
	AddVariant(Variant: Variant): void;
	RemoveVariant(Variant: Variant): void;
	RemoveVariantByName(VariantName: string): void;
	static AddVariant(VariantSet: VariantSet,Variant: Variant): void;
	static RemoveVariant(VariantSet: VariantSet,Variant: Variant): void;
	static RemoveVariantByName(VariantSet: VariantSet,VariantName: string): void;
}

declare class LevelVariantSetsFunctionDirector extends UObject { 
	static Load(ResourceName: string): LevelVariantSetsFunctionDirector;
	static Find(Outer: UObject, ResourceName: string): LevelVariantSetsFunctionDirector;
	static GetDefaultObject(): LevelVariantSetsFunctionDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSetsFunctionDirector;
	static C(Other: UObject | any): LevelVariantSetsFunctionDirector;
}

declare class LevelVariantSetsActor extends Actor { 
	LevelVariantSets: SoftObjectPath;
	DirectorInstances: Map<UnrealEngineClass, LevelVariantSetsFunctionDirector>;
	static GetDefaultObject(): LevelVariantSetsActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSetsActor;
	SwitchOnVariantByName(VariantSetName: string,VariantName: string): boolean;
	SwitchOnVariantByIndex(VariantSetIndex: number,VariantIndex: number): boolean;
	SetLevelVariantSets(InVariantSets: LevelVariantSets): void;
	GetLevelVariantSets(bLoad: boolean): LevelVariantSets;
	static C(Other: UObject | any): LevelVariantSetsActor;
}

declare class LevelVariantSets extends UObject { 
	DirectorBlueprint: UObject;
	DirectorClass: UnrealEngineClass;
	VariantSets: VariantSet[];
	static Load(ResourceName: string): LevelVariantSets;
	static Find(Outer: UObject, ResourceName: string): LevelVariantSets;
	static GetDefaultObject(): LevelVariantSets;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSets;
	GetVariantSetByName(VariantSetName: string): VariantSet;
	GetVariantSet(VariantSetIndex: number): VariantSet;
	GetNumVariantSets(): number;
	static C(Other: UObject | any): LevelVariantSets;
	AddVariantSet(VariantSet: VariantSet): void;
	CreateLevelVariantSetsActor(): LevelVariantSetsActor;
	RemoveVariantSet(VariantSet: VariantSet): void;
	RemoveVariantSetByName(VariantSetName: string): void;
	static AddVariantSet(LevelVariantSets: LevelVariantSets,VariantSet: VariantSet): void;
	static CreateLevelVariantSetsActor(LevelVariantSetsAsset: LevelVariantSets): LevelVariantSetsActor;
	static RemoveVariantSet(LevelVariantSets: LevelVariantSets,VariantSet: VariantSet): void;
	static RemoveVariantSetByName(LevelVariantSets: LevelVariantSets,VariantSetName: string): void;
}

declare class PropertyValueTransform extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueTransform;
	static Find(Outer: UObject, ResourceName: string): PropertyValueTransform;
	static GetDefaultObject(): PropertyValueTransform;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueTransform;
	static C(Other: UObject | any): PropertyValueTransform;
}

declare class PropertyValueVisibility extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueVisibility;
	static Find(Outer: UObject, ResourceName: string): PropertyValueVisibility;
	static GetDefaultObject(): PropertyValueVisibility;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueVisibility;
	static C(Other: UObject | any): PropertyValueVisibility;
}

declare class PropertyValueColor extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueColor;
	static Find(Outer: UObject, ResourceName: string): PropertyValueColor;
	static GetDefaultObject(): PropertyValueColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueColor;
	static C(Other: UObject | any): PropertyValueColor;
}

declare class PropertyValueMaterial extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueMaterial;
	static Find(Outer: UObject, ResourceName: string): PropertyValueMaterial;
	static GetDefaultObject(): PropertyValueMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueMaterial;
	static C(Other: UObject | any): PropertyValueMaterial;
}

declare class PropertyValueOption extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueOption;
	static Find(Outer: UObject, ResourceName: string): PropertyValueOption;
	static GetDefaultObject(): PropertyValueOption;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueOption;
	static C(Other: UObject | any): PropertyValueOption;
}

declare class PropertyValueSoftObject extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueSoftObject;
	static Find(Outer: UObject, ResourceName: string): PropertyValueSoftObject;
	static GetDefaultObject(): PropertyValueSoftObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueSoftObject;
	static C(Other: UObject | any): PropertyValueSoftObject;
}

declare class SwitchActor extends Actor { 
	SceneComponent: SceneComponent;
	LastSelectedOption: number;
	static GetDefaultObject(): SwitchActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SwitchActor;
	SelectOption(OptionIndex: number): void;
	GetSelectedOption(): number;
	GetOptions(): Actor[];
	static C(Other: UObject | any): SwitchActor;
}

declare class DatasmithActorTemplate extends DatasmithObjectTemplate { 
	Layers: Set<string>;
	Tags: Set<string>;
	static Load(ResourceName: string): DatasmithActorTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithActorTemplate;
	static GetDefaultObject(): DatasmithActorTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithActorTemplate;
	static C(Other: UObject | any): DatasmithActorTemplate;
}

declare class DatasmithAdditionalData extends UObject { 
	static Load(ResourceName: string): DatasmithAdditionalData;
	static Find(Outer: UObject, ResourceName: string): DatasmithAdditionalData;
	static GetDefaultObject(): DatasmithAdditionalData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithAdditionalData;
	static C(Other: UObject | any): DatasmithAdditionalData;
}

declare type EDatasmithAreaLightActorType = 'Point' | 'Spot' | 'Rect' | 'EDatasmithAreaLightActorType_MAX';
declare var EDatasmithAreaLightActorType : { Point:'Point',Spot:'Spot',Rect:'Rect',EDatasmithAreaLightActorType_MAX:'EDatasmithAreaLightActorType_MAX', };
declare type EDatasmithAreaLightActorShape = 'Rectangle' | 'Disc' | 'Sphere' | 'Cylinder' | 'None' | 'EDatasmithAreaLightActorShape_MAX';
declare var EDatasmithAreaLightActorShape : { Rectangle:'Rectangle',Disc:'Disc',Sphere:'Sphere',Cylinder:'Cylinder',None:'None',EDatasmithAreaLightActorShape_MAX:'EDatasmithAreaLightActorShape_MAX', };
declare class DatasmithAreaLightActor extends Actor { 
	Mobility: EComponentMobility;
	LightType: EDatasmithAreaLightActorType;
	LightShape: EDatasmithAreaLightActorShape;
	Dimensions: Vector2D;
	Intensity: number;
	IntensityUnits: ELightUnits;
	Color: LinearColor;
	Temperature: number;
	IESTexture: TextureLightProfile;
	bUseIESBrightness: boolean;
	IESBrightnessScale: number;
	Rotation: Rotator;
	SourceRadius: number;
	SourceLength: number;
	AttenuationRadius: number;
	SpotlightInnerAngle: number;
	SpotlightOuterAngle: number;
	static GetDefaultObject(): DatasmithAreaLightActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithAreaLightActor;
	static C(Other: UObject | any): DatasmithAreaLightActor;
}

declare class DatasmithAreaLightActorTemplate extends DatasmithObjectTemplate { 
	LightType: EDatasmithAreaLightActorType;
	LightShape: EDatasmithAreaLightActorShape;
	Dimensions: Vector2D;
	Color: LinearColor;
	Intensity: number;
	IntensityUnits: ELightUnits;
	Temperature: number;
	IESTexture: TextureLightProfile;
	bUseIESBrightness: boolean;
	IESBrightnessScale: number;
	Rotation: Rotator;
	SourceRadius: number;
	SourceLength: number;
	AttenuationRadius: number;
	static Load(ResourceName: string): DatasmithAreaLightActorTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithAreaLightActorTemplate;
	static GetDefaultObject(): DatasmithAreaLightActorTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithAreaLightActorTemplate;
	static C(Other: UObject | any): DatasmithAreaLightActorTemplate;
}

declare class DatasmithAssetImportOptions { 
	PackagePath: string;
	clone() : DatasmithAssetImportOptions;
	static C(Other: UObject | any): DatasmithAssetImportOptions;
}

declare class DatasmithImportInfo { 
	SourceUri: string;
	SourceHash: string;
	clone() : DatasmithImportInfo;
	static C(Other: UObject | any): DatasmithImportInfo;
}

declare class DatasmithAssetImportData extends AssetImportData { 
	AssetImportOptions: DatasmithAssetImportOptions;
	AdditionalData: DatasmithAdditionalData[];
	DatasmithImportInfo: DatasmithImportInfo;
	static Load(ResourceName: string): DatasmithAssetImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithAssetImportData;
	static GetDefaultObject(): DatasmithAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithAssetImportData;
	static C(Other: UObject | any): DatasmithAssetImportData;
}

declare type EDatasmithImportLightmapMin = 'LIGHTMAP_16' | 'LIGHTMAP_32' | 'LIGHTMAP_64' | 'LIGHTMAP_128' | 'LIGHTMAP_256' | 'LIGHTMAP_512' | 'LIGHTMAP_MAX';
declare var EDatasmithImportLightmapMin : { LIGHTMAP_16:'LIGHTMAP_16',LIGHTMAP_32:'LIGHTMAP_32',LIGHTMAP_64:'LIGHTMAP_64',LIGHTMAP_128:'LIGHTMAP_128',LIGHTMAP_256:'LIGHTMAP_256',LIGHTMAP_512:'LIGHTMAP_512',LIGHTMAP_MAX:'LIGHTMAP_MAX', };
declare type EDatasmithImportLightmapMax = 'LIGHTMAP_64' | 'LIGHTMAP_128' | 'LIGHTMAP_256' | 'LIGHTMAP_512' | 'LIGHTMAP_1024' | 'LIGHTMAP_2048' | 'LIGHTMAP_4096' | 'LIGHTMAP_MAX';
declare var EDatasmithImportLightmapMax : { LIGHTMAP_64:'LIGHTMAP_64',LIGHTMAP_128:'LIGHTMAP_128',LIGHTMAP_256:'LIGHTMAP_256',LIGHTMAP_512:'LIGHTMAP_512',LIGHTMAP_1024:'LIGHTMAP_1024',LIGHTMAP_2048:'LIGHTMAP_2048',LIGHTMAP_4096:'LIGHTMAP_4096',LIGHTMAP_MAX:'LIGHTMAP_MAX', };
declare class DatasmithStaticMeshImportOptions { 
	MinLightmapResolution: EDatasmithImportLightmapMin;
	MaxLightmapResolution: EDatasmithImportLightmapMax;
	bGenerateLightmapUVs: boolean;
	bRemoveDegenerates: boolean;
	clone() : DatasmithStaticMeshImportOptions;
	static C(Other: UObject | any): DatasmithStaticMeshImportOptions;
}

declare class DatasmithStaticMeshImportData extends DatasmithAssetImportData { 
	ImportOptions: DatasmithStaticMeshImportOptions;
	static Load(ResourceName: string): DatasmithStaticMeshImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshImportData;
	static GetDefaultObject(): DatasmithStaticMeshImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshImportData;
	static C(Other: UObject | any): DatasmithStaticMeshImportData;
}

declare type EDatasmithCADStitchingTechnique = 'StitchingNone' | 'StitchingHeal' | 'StitchingSew' | 'EDatasmithCADStitchingTechnique_MAX';
declare var EDatasmithCADStitchingTechnique : { StitchingNone:'StitchingNone',StitchingHeal:'StitchingHeal',StitchingSew:'StitchingSew',EDatasmithCADStitchingTechnique_MAX:'EDatasmithCADStitchingTechnique_MAX', };
declare class DatasmithTessellationOptions { 
	ChordTolerance: number;
	MaxEdgeLength: number;
	NormalTolerance: number;
	StitchingTechnique: EDatasmithCADStitchingTechnique;
	clone() : DatasmithTessellationOptions;
	static C(Other: UObject | any): DatasmithTessellationOptions;
}

declare class DatasmithStaticMeshCADImportData extends DatasmithStaticMeshImportData { 
	TessellationOptions: DatasmithTessellationOptions;
	ModelUnit: number;
	ModelTolerance: number;
	ResourcePath: string;
	ResourceFilename: string;
	AuxiliaryFilenames: string[];
	static Load(ResourceName: string): DatasmithStaticMeshCADImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshCADImportData;
	static GetDefaultObject(): DatasmithStaticMeshCADImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshCADImportData;
	static C(Other: UObject | any): DatasmithStaticMeshCADImportData;
}

declare type EDatasmithImportScene = 'NewLevel' | 'CurrentLevel' | 'AssetsOnly' | 'EDatasmithImportScene_MAX';
declare var EDatasmithImportScene : { NewLevel:'NewLevel',CurrentLevel:'CurrentLevel',AssetsOnly:'AssetsOnly',EDatasmithImportScene_MAX:'EDatasmithImportScene_MAX', };
declare class DatasmithImportBaseOptions { 
	SceneHandling: EDatasmithImportScene;
	bIncludeGeometry: boolean;
	bIncludeMaterial: boolean;
	bIncludeLight: boolean;
	bIncludeCamera: boolean;
	bIncludeAnimation: boolean;
	AssetOptions: DatasmithAssetImportOptions;
	StaticMeshOptions: DatasmithStaticMeshImportOptions;
	clone() : DatasmithImportBaseOptions;
	static C(Other: UObject | any): DatasmithImportBaseOptions;
}

declare class DatasmithSceneImportData extends AssetImportData { 
	BaseOptions: DatasmithImportBaseOptions;
	DatasmithImportInfo: DatasmithImportInfo;
	static Load(ResourceName: string): DatasmithSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithSceneImportData;
	static GetDefaultObject(): DatasmithSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithSceneImportData;
	static C(Other: UObject | any): DatasmithSceneImportData;
}

declare class DatasmithOptionsBase extends UObject { 
	static Load(ResourceName: string): DatasmithOptionsBase;
	static Find(Outer: UObject, ResourceName: string): DatasmithOptionsBase;
	static GetDefaultObject(): DatasmithOptionsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithOptionsBase;
	static C(Other: UObject | any): DatasmithOptionsBase;
}

declare class DatasmithTranslatedSceneImportData extends DatasmithSceneImportData { 
	AdditionalOptions: DatasmithOptionsBase[];
	static Load(ResourceName: string): DatasmithTranslatedSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithTranslatedSceneImportData;
	static GetDefaultObject(): DatasmithTranslatedSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithTranslatedSceneImportData;
	static C(Other: UObject | any): DatasmithTranslatedSceneImportData;
}

declare class DatasmithCADImportSceneData extends DatasmithSceneImportData { 
	TessellationOptions: DatasmithTessellationOptions;
	static Load(ResourceName: string): DatasmithCADImportSceneData;
	static Find(Outer: UObject, ResourceName: string): DatasmithCADImportSceneData;
	static GetDefaultObject(): DatasmithCADImportSceneData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithCADImportSceneData;
	static C(Other: UObject | any): DatasmithCADImportSceneData;
}

declare class DatasmithMDLSceneImportData extends DatasmithSceneImportData { 
	static Load(ResourceName: string): DatasmithMDLSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithMDLSceneImportData;
	static GetDefaultObject(): DatasmithMDLSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithMDLSceneImportData;
	static C(Other: UObject | any): DatasmithMDLSceneImportData;
}

declare class DatasmithGLTFSceneImportData extends DatasmithSceneImportData { 
	Generator: string;
	Version: number;
	Author: string;
	License: string;
	Source: string;
	static Load(ResourceName: string): DatasmithGLTFSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithGLTFSceneImportData;
	static GetDefaultObject(): DatasmithGLTFSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithGLTFSceneImportData;
	static C(Other: UObject | any): DatasmithGLTFSceneImportData;
}

declare class DatasmithStaticMeshGLTFImportData extends DatasmithStaticMeshImportData { 
	SourceMeshName: string;
	static Load(ResourceName: string): DatasmithStaticMeshGLTFImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshGLTFImportData;
	static GetDefaultObject(): DatasmithStaticMeshGLTFImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshGLTFImportData;
	static C(Other: UObject | any): DatasmithStaticMeshGLTFImportData;
}

declare class DatasmithFBXSceneImportData extends DatasmithSceneImportData { 
	bGenerateLightmapUVs: boolean;
	TexturesDir: string;
	IntermediateSerialization: number;
	bColorizeMaterials: boolean;
	static Load(ResourceName: string): DatasmithFBXSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithFBXSceneImportData;
	static GetDefaultObject(): DatasmithFBXSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithFBXSceneImportData;
	static C(Other: UObject | any): DatasmithFBXSceneImportData;
}

declare class DatasmithDeltaGenAssetImportData extends DatasmithAssetImportData { 
	static Load(ResourceName: string): DatasmithDeltaGenAssetImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithDeltaGenAssetImportData;
	static GetDefaultObject(): DatasmithDeltaGenAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithDeltaGenAssetImportData;
	static C(Other: UObject | any): DatasmithDeltaGenAssetImportData;
}

declare class DatasmithDeltaGenSceneImportData extends DatasmithFBXSceneImportData { 
	bMergeNodes: boolean;
	bOptimizeDuplicatedNodes: boolean;
	bRemoveInvisibleNodes: boolean;
	bSimplifyNodeHierarchy: boolean;
	bImportVar: boolean;
	VarPath: string;
	bImportPos: boolean;
	PosPath: string;
	bImportTml: boolean;
	TmlPath: string;
	static Load(ResourceName: string): DatasmithDeltaGenSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithDeltaGenSceneImportData;
	static GetDefaultObject(): DatasmithDeltaGenSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithDeltaGenSceneImportData;
	static C(Other: UObject | any): DatasmithDeltaGenSceneImportData;
}

declare class DatasmithVREDAssetImportData extends DatasmithAssetImportData { 
	static Load(ResourceName: string): DatasmithVREDAssetImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithVREDAssetImportData;
	static GetDefaultObject(): DatasmithVREDAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithVREDAssetImportData;
	static C(Other: UObject | any): DatasmithVREDAssetImportData;
}

declare class DatasmithVREDSceneImportData extends DatasmithFBXSceneImportData { 
	bMergeNodes: boolean;
	bOptimizeDuplicatedNodes: boolean;
	bImportMats: boolean;
	MatsPath: string;
	bImportVar: boolean;
	bCleanVar: boolean;
	VarPath: string;
	bImportLightInfo: boolean;
	LightInfoPath: string;
	bImportClipInfo: boolean;
	ClipInfoPath: string;
	static Load(ResourceName: string): DatasmithVREDSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithVREDSceneImportData;
	static GetDefaultObject(): DatasmithVREDSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithVREDSceneImportData;
	static C(Other: UObject | any): DatasmithVREDSceneImportData;
}

declare class DatasmithIFCSceneImportData extends DatasmithSceneImportData { 
	static Load(ResourceName: string): DatasmithIFCSceneImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithIFCSceneImportData;
	static GetDefaultObject(): DatasmithIFCSceneImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithIFCSceneImportData;
	static C(Other: UObject | any): DatasmithIFCSceneImportData;
}

declare class DatasmithStaticMeshIFCImportData extends DatasmithStaticMeshImportData { 
	SourceGlobalId: string;
	static Load(ResourceName: string): DatasmithStaticMeshIFCImportData;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshIFCImportData;
	static GetDefaultObject(): DatasmithStaticMeshIFCImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshIFCImportData;
	static C(Other: UObject | any): DatasmithStaticMeshIFCImportData;
}

declare class DatasmithCameraLookatTrackingSettingsTemplate { 
	bEnableLookAtTracking: boolean;
	bAllowRoll: boolean;
	ActorToTrack: Actor;
	clone() : DatasmithCameraLookatTrackingSettingsTemplate;
	static C(Other: UObject | any): DatasmithCameraLookatTrackingSettingsTemplate;
}

declare class DatasmithCineCameraActorTemplate extends DatasmithObjectTemplate { 
	LookatTrackingSettings: DatasmithCameraLookatTrackingSettingsTemplate;
	static Load(ResourceName: string): DatasmithCineCameraActorTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithCineCameraActorTemplate;
	static GetDefaultObject(): DatasmithCineCameraActorTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithCineCameraActorTemplate;
	static C(Other: UObject | any): DatasmithCineCameraActorTemplate;
}

declare class DatasmithCameraFilmbackSettingsTemplate { 
	SensorWidth: number;
	SensorHeight: number;
	clone() : DatasmithCameraFilmbackSettingsTemplate;
	static C(Other: UObject | any): DatasmithCameraFilmbackSettingsTemplate;
}

declare class DatasmithCameraLensSettingsTemplate { 
	MaxFStop: number;
	clone() : DatasmithCameraLensSettingsTemplate;
	static C(Other: UObject | any): DatasmithCameraLensSettingsTemplate;
}

declare class DatasmithCameraFocusSettingsTemplate { 
	FocusMethod: ECameraFocusMethod;
	ManualFocusDistance: number;
	clone() : DatasmithCameraFocusSettingsTemplate;
	static C(Other: UObject | any): DatasmithCameraFocusSettingsTemplate;
}

declare class DatasmithPostProcessSettingsTemplate { 
	bOverride_WhiteTemp: boolean;
	bOverride_ColorSaturation: boolean;
	bOverride_VignetteIntensity: boolean;
	bOverride_AutoExposureMethod: boolean;
	bOverride_CameraISO: boolean;
	bOverride_CameraShutterSpeed: boolean;
	bOverride_DepthOfFieldFstop: boolean;
	WhiteTemp: number;
	VignetteIntensity: number;
	ColorSaturation: Vector4;
	AutoExposureMethod: EAutoExposureMethod;
	CameraISO: number;
	CameraShutterSpeed: number;
	DepthOfFieldFstop: number;
	clone() : DatasmithPostProcessSettingsTemplate;
	static C(Other: UObject | any): DatasmithPostProcessSettingsTemplate;
}

declare class DatasmithCineCameraComponentTemplate extends DatasmithObjectTemplate { 
	FilmbackSettings: DatasmithCameraFilmbackSettingsTemplate;
	LensSettings: DatasmithCameraLensSettingsTemplate;
	FocusSettings: DatasmithCameraFocusSettingsTemplate;
	CurrentFocalLength: number;
	CurrentAperture: number;
	PostProcessSettings: DatasmithPostProcessSettingsTemplate;
	static Load(ResourceName: string): DatasmithCineCameraComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithCineCameraComponentTemplate;
	static GetDefaultObject(): DatasmithCineCameraComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithCineCameraComponentTemplate;
	static C(Other: UObject | any): DatasmithCineCameraComponentTemplate;
}

declare class DatasmithContentBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): DatasmithContentBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): DatasmithContentBlueprintLibrary;
	static GetDefaultObject(): DatasmithContentBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithContentBlueprintLibrary;
	static GetDatasmithUserDataValuesForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string[];
	static GetDatasmithUserDataValueForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string;
	static GetDatasmithUserDataKeysAndValuesForValue(UObject: UObject,StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	static GetDatasmithUserData(UObject: UObject): DatasmithAssetUserData;
	static GetAllObjectsAndValuesForKey(Key: string,ObjectClass: UnrealEngineClass,OutObjects?: UObject[],OutValues?: string[]): {OutObjects: UObject[], OutValues: string[]};
	static GetAllDatasmithUserData(ObjectClass: UnrealEngineClass,OutUserData?: DatasmithAssetUserData[]): {OutUserData: DatasmithAssetUserData[]};
	static C(Other: UObject | any): DatasmithContentBlueprintLibrary;
}

declare class DatasmithCustomActionBase extends UObject { 
	static Load(ResourceName: string): DatasmithCustomActionBase;
	static Find(Outer: UObject, ResourceName: string): DatasmithCustomActionBase;
	static GetDefaultObject(): DatasmithCustomActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithCustomActionBase;
	static C(Other: UObject | any): DatasmithCustomActionBase;
}

declare class DatasmithDecalComponentTemplate extends DatasmithObjectTemplate { 
	SortOrder: number;
	DecalSize: Vector;
	Material: MaterialInterface;
	static Load(ResourceName: string): DatasmithDecalComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithDecalComponentTemplate;
	static GetDefaultObject(): DatasmithDecalComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithDecalComponentTemplate;
	static C(Other: UObject | any): DatasmithDecalComponentTemplate;
}

declare class DatasmithImportedSequencesActor extends Actor { 
	ImportedSequences: LevelSequence[];
	static GetDefaultObject(): DatasmithImportedSequencesActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithImportedSequencesActor;
	PlayLevelSequence(SequenceToPlay: LevelSequence): void;
	static C(Other: UObject | any): DatasmithImportedSequencesActor;
}

declare class DatasmithCommonTessellationOptions extends DatasmithOptionsBase { 
	Options: DatasmithTessellationOptions;
	static Load(ResourceName: string): DatasmithCommonTessellationOptions;
	static Find(Outer: UObject, ResourceName: string): DatasmithCommonTessellationOptions;
	static GetDefaultObject(): DatasmithCommonTessellationOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithCommonTessellationOptions;
	static C(Other: UObject | any): DatasmithCommonTessellationOptions;
}

declare type EDatasmithImportSearchPackagePolicy = 'Current' | 'All' | 'EDatasmithImportSearchPackagePolicy_MAX';
declare var EDatasmithImportSearchPackagePolicy : { Current:'Current',All:'All',EDatasmithImportSearchPackagePolicy_MAX:'EDatasmithImportSearchPackagePolicy_MAX', };
declare type EDatasmithImportAssetConflictPolicy = 'Replace' | 'Update' | 'Use' | 'Ignore' | 'EDatasmithImportAssetConflictPolicy_MAX';
declare var EDatasmithImportAssetConflictPolicy : { Replace:'Replace',Update:'Update',Use:'Use',Ignore:'Ignore',EDatasmithImportAssetConflictPolicy_MAX:'EDatasmithImportAssetConflictPolicy_MAX', };
declare type EDatasmithImportActorPolicy = 'Update' | 'Full' | 'Ignore' | 'EDatasmithImportActorPolicy_MAX';
declare var EDatasmithImportActorPolicy : { Update:'Update',Full:'Full',Ignore:'Ignore',EDatasmithImportActorPolicy_MAX:'EDatasmithImportActorPolicy_MAX', };
declare type EDatasmithImportMaterialQuality = 'UseNoFresnelCurves' | 'UseSimplifierFresnelCurves' | 'UseRealFresnelCurves' | 'EDatasmithImportMaterialQuality_MAX';
declare var EDatasmithImportMaterialQuality : { UseNoFresnelCurves:'UseNoFresnelCurves',UseSimplifierFresnelCurves:'UseSimplifierFresnelCurves',UseRealFresnelCurves:'UseRealFresnelCurves',EDatasmithImportMaterialQuality_MAX:'EDatasmithImportMaterialQuality_MAX', };
declare class DatasmithReimportOptions { 
	bUpdateActors: boolean;
	bRespawnDeletedActors: boolean;
	clone() : DatasmithReimportOptions;
	static C(Other: UObject | any): DatasmithReimportOptions;
}

declare class DatasmithImportOptions extends DatasmithOptionsBase { 
	SearchPackagePolicy: EDatasmithImportSearchPackagePolicy;
	MaterialConflictPolicy: EDatasmithImportAssetConflictPolicy;
	TextureConflictPolicy: EDatasmithImportAssetConflictPolicy;
	StaticMeshActorImportPolicy: EDatasmithImportActorPolicy;
	LightImportPolicy: EDatasmithImportActorPolicy;
	CameraImportPolicy: EDatasmithImportActorPolicy;
	OtherActorImportPolicy: EDatasmithImportActorPolicy;
	MaterialQuality: EDatasmithImportMaterialQuality;
	BaseOptions: DatasmithImportBaseOptions;
	ReimportOptions: DatasmithReimportOptions;
	Filename: string;
	FilePath: string;
	SourceUri: string;
	static Load(ResourceName: string): DatasmithImportOptions;
	static Find(Outer: UObject, ResourceName: string): DatasmithImportOptions;
	static GetDefaultObject(): DatasmithImportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithImportOptions;
	static C(Other: UObject | any): DatasmithImportOptions;
}

declare class DatasmithLandscapeTemplate extends DatasmithObjectTemplate { 
	LandscapeMaterial: MaterialInterface;
	StaticLightingLOD: number;
	static Load(ResourceName: string): DatasmithLandscapeTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithLandscapeTemplate;
	static GetDefaultObject(): DatasmithLandscapeTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithLandscapeTemplate;
	static C(Other: UObject | any): DatasmithLandscapeTemplate;
}

declare class DatasmithLightComponentTemplate extends DatasmithObjectTemplate { 
	bVisible: boolean;
	CastShadows: boolean;
	bUseTemperature: boolean;
	bUseIESBrightness: boolean;
	Intensity: number;
	Temperature: number;
	IESBrightnessScale: number;
	LightColor: LinearColor;
	LightFunctionMaterial: MaterialInterface;
	IESTexture: TextureLightProfile;
	static Load(ResourceName: string): DatasmithLightComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithLightComponentTemplate;
	static GetDefaultObject(): DatasmithLightComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithLightComponentTemplate;
	static C(Other: UObject | any): DatasmithLightComponentTemplate;
}

declare class DatasmithStaticParameterSetTemplate { 
	StaticSwitchParameters: Map<string, boolean>;
	clone() : DatasmithStaticParameterSetTemplate;
	static C(Other: UObject | any): DatasmithStaticParameterSetTemplate;
}

declare class DatasmithMaterialInstanceTemplate extends DatasmithObjectTemplate { 
	ParentMaterial: MaterialInterface;
	ScalarParameterValues: Map<string, number>;
	VectorParameterValues: Map<string, LinearColor>;
	TextureParameterValues: Map<string, Texture>;
	StaticParameters: DatasmithStaticParameterSetTemplate;
	static Load(ResourceName: string): DatasmithMaterialInstanceTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithMaterialInstanceTemplate;
	static GetDefaultObject(): DatasmithMaterialInstanceTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithMaterialInstanceTemplate;
	static C(Other: UObject | any): DatasmithMaterialInstanceTemplate;
}

declare class DatasmithPointLightComponentTemplate extends DatasmithObjectTemplate { 
	IntensityUnits: ELightUnits;
	SourceRadius: number;
	SourceLength: number;
	AttenuationRadius: number;
	static Load(ResourceName: string): DatasmithPointLightComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithPointLightComponentTemplate;
	static GetDefaultObject(): DatasmithPointLightComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithPointLightComponentTemplate;
	static C(Other: UObject | any): DatasmithPointLightComponentTemplate;
}

declare class DatasmithPostProcessVolumeTemplate extends DatasmithObjectTemplate { 
	Settings: DatasmithPostProcessSettingsTemplate;
	bEnabled: boolean;
	bUnbound: boolean;
	static Load(ResourceName: string): DatasmithPostProcessVolumeTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithPostProcessVolumeTemplate;
	static GetDefaultObject(): DatasmithPostProcessVolumeTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithPostProcessVolumeTemplate;
	static C(Other: UObject | any): DatasmithPostProcessVolumeTemplate;
}

declare class DatasmithScene extends UObject { 
	AssetImportData: DatasmithSceneImportData;
	BulkDataVersion: number;
	StaticMeshes: Map<string, StaticMesh>;
	Clothes: Map<string, UObject>;
	Textures: Map<string, Texture>;
	MaterialFunctions: Map<string, MaterialFunction>;
	Materials: Map<string, MaterialInterface>;
	LevelSequences: Map<string, LevelSequence>;
	LevelVariantSets: Map<string, LevelVariantSets>;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): DatasmithScene;
	static Find(Outer: UObject, ResourceName: string): DatasmithScene;
	static GetDefaultObject(): DatasmithScene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithScene;
	static C(Other: UObject | any): DatasmithScene;
}

declare class DatasmithSceneActor extends Actor { 
	Scene: DatasmithScene;
	RelatedActors: Map<string, Actor>;
	static GetDefaultObject(): DatasmithSceneActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithSceneActor;
	static C(Other: UObject | any): DatasmithSceneActor;
}

declare class DatasmithSceneComponentTemplate extends DatasmithObjectTemplate { 
	RelativeTransform: Transform;
	Mobility: EComponentMobility;
	AttachParent: SceneComponent;
	bVisible: boolean;
	bCastShadow: boolean;
	Tags: Set<string>;
	static Load(ResourceName: string): DatasmithSceneComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithSceneComponentTemplate;
	static GetDefaultObject(): DatasmithSceneComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithSceneComponentTemplate;
	static C(Other: UObject | any): DatasmithSceneComponentTemplate;
}

declare class DatasmithSkyLightComponentTemplate extends DatasmithObjectTemplate { 
	SourceType: ESkyLightSourceType;
	CubemapResolution: number;
	Cubemap: TextureCube;
	static Load(ResourceName: string): DatasmithSkyLightComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithSkyLightComponentTemplate;
	static GetDefaultObject(): DatasmithSkyLightComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithSkyLightComponentTemplate;
	static C(Other: UObject | any): DatasmithSkyLightComponentTemplate;
}

declare class DatasmithSpotLightComponentTemplate extends DatasmithObjectTemplate { 
	InnerConeAngle: number;
	OuterConeAngle: number;
	static Load(ResourceName: string): DatasmithSpotLightComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithSpotLightComponentTemplate;
	static GetDefaultObject(): DatasmithSpotLightComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithSpotLightComponentTemplate;
	static C(Other: UObject | any): DatasmithSpotLightComponentTemplate;
}

declare class DatasmithStaticMeshComponentTemplate extends DatasmithObjectTemplate { 
	StaticMesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	static Load(ResourceName: string): DatasmithStaticMeshComponentTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshComponentTemplate;
	static GetDefaultObject(): DatasmithStaticMeshComponentTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshComponentTemplate;
	static C(Other: UObject | any): DatasmithStaticMeshComponentTemplate;
}

declare class DatasmithMeshSectionInfoTemplate { 
	MaterialIndex: number;
	clone() : DatasmithMeshSectionInfoTemplate;
	static C(Other: UObject | any): DatasmithMeshSectionInfoTemplate;
}

declare class DatasmithMeshSectionInfoMapTemplate { 
	Map: Map<number, DatasmithMeshSectionInfoTemplate>;
	clone() : DatasmithMeshSectionInfoMapTemplate;
	static C(Other: UObject | any): DatasmithMeshSectionInfoMapTemplate;
}

declare class DatasmithMeshBuildSettingsTemplate { 
	bUseMikkTSpace: boolean;
	bRecomputeNormals: boolean;
	bRecomputeTangents: boolean;
	bRemoveDegenerates: boolean;
	bUseHighPrecisionTangentBasis: boolean;
	bUseFullPrecisionUVs: boolean;
	bGenerateLightmapUVs: boolean;
	MinLightmapResolution: number;
	SrcLightmapIndex: number;
	DstLightmapIndex: number;
	clone() : DatasmithMeshBuildSettingsTemplate;
	static C(Other: UObject | any): DatasmithMeshBuildSettingsTemplate;
}

declare class DatasmithStaticMaterialTemplate { 
	MaterialSlotName: string;
	MaterialInterface: MaterialInterface;
	clone() : DatasmithStaticMaterialTemplate;
	static C(Other: UObject | any): DatasmithStaticMaterialTemplate;
}

declare class DatasmithStaticMeshTemplate extends DatasmithObjectTemplate { 
	SectionInfoMap: DatasmithMeshSectionInfoMapTemplate;
	LightMapCoordinateIndex: number;
	LightMapResolution: number;
	BuildSettings: DatasmithMeshBuildSettingsTemplate[];
	StaticMaterials: DatasmithStaticMaterialTemplate[];
	static Load(ResourceName: string): DatasmithStaticMeshTemplate;
	static Find(Outer: UObject, ResourceName: string): DatasmithStaticMeshTemplate;
	static GetDefaultObject(): DatasmithStaticMeshTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DatasmithStaticMeshTemplate;
	static C(Other: UObject | any): DatasmithStaticMeshTemplate;
}

declare class GLTFMaterialAnalyzer extends MaterialInstance { 
	static Load(ResourceName: string): GLTFMaterialAnalyzer;
	static Find(Outer: UObject, ResourceName: string): GLTFMaterialAnalyzer;
	static GetDefaultObject(): GLTFMaterialAnalyzer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFMaterialAnalyzer;
	static C(Other: UObject | any): GLTFMaterialAnalyzer;
}

declare type EGLTFMaterialBakeMode = 'Disabled' | 'Simple' | 'UseMeshData' | 'EGLTFMaterialBakeMode_MAX';
declare var EGLTFMaterialBakeMode : { Disabled:'Disabled',Simple:'Simple',UseMeshData:'UseMeshData',EGLTFMaterialBakeMode_MAX:'EGLTFMaterialBakeMode_MAX', };
declare type EGLTFMaterialBakeSizePOT = 'POT_1' | 'POT_2' | 'POT_4' | 'POT_8' | 'POT_16' | 'POT_32' | 'POT_64' | 'POT_128' | 'POT_256' | 'POT_512' | 'POT_1024' | 'POT_2048' | 'POT_4096' | 'POT_8192' | 'POT_MAX';
declare var EGLTFMaterialBakeSizePOT : { POT_1:'POT_1',POT_2:'POT_2',POT_4:'POT_4',POT_8:'POT_8',POT_16:'POT_16',POT_32:'POT_32',POT_64:'POT_64',POT_128:'POT_128',POT_256:'POT_256',POT_512:'POT_512',POT_1024:'POT_1024',POT_2048:'POT_2048',POT_4096:'POT_4096',POT_8192:'POT_8192',POT_MAX:'POT_MAX', };
declare type EGLTFMaterialPropertyGroup = 'None' | 'BaseColorOpacity' | 'MetallicRoughness' | 'EmissiveColor' | 'Normal' | 'AmbientOcclusion' | 'ClearCoatRoughness' | 'ClearCoatBottomNormal' | 'EGLTFMaterialPropertyGroup_MAX';
declare var EGLTFMaterialPropertyGroup : { None:'None',BaseColorOpacity:'BaseColorOpacity',MetallicRoughness:'MetallicRoughness',EmissiveColor:'EmissiveColor',Normal:'Normal',AmbientOcclusion:'AmbientOcclusion',ClearCoatRoughness:'ClearCoatRoughness',ClearCoatBottomNormal:'ClearCoatBottomNormal',EGLTFMaterialPropertyGroup_MAX:'EGLTFMaterialPropertyGroup_MAX', };
declare class GLTFOverrideMaterialBakeSettings { 
	bOverrideSize: boolean;
	Size: EGLTFMaterialBakeSizePOT;
	bOverrideFilter: boolean;
	Filter: TextureFilter;
	bOverrideTiling: boolean;
	Tiling: TextureAddress;
	clone() : GLTFOverrideMaterialBakeSettings;
	static C(Other: UObject | any): GLTFOverrideMaterialBakeSettings;
}

declare type EGLTFTextureImageFormat = 'None' | 'PNG' | 'JPEG' | 'EGLTFTextureImageFormat_MAX';
declare var EGLTFTextureImageFormat : { None:'None',PNG:'PNG',JPEG:'JPEG',EGLTFTextureImageFormat_MAX:'EGLTFTextureImageFormat_MAX', };
declare type EGLTFTextureHDREncoding = 'None' | 'RGBM' | 'EGLTFTextureHDREncoding_MAX';
declare var EGLTFTextureHDREncoding : { None:'None',RGBM:'RGBM',EGLTFTextureHDREncoding_MAX:'EGLTFTextureHDREncoding_MAX', };
declare type EGLTFVariantSetsMode = 'None' | 'Khronos' | 'Epic' | 'EGLTFVariantSetsMode_MAX';
declare var EGLTFVariantSetsMode : { None:'None',Khronos:'Khronos',Epic:'Epic',EGLTFVariantSetsMode_MAX:'EGLTFVariantSetsMode_MAX', };
declare type EGLTFMaterialVariantMode = 'None' | 'Simple' | 'UseMeshData' | 'EGLTFMaterialVariantMode_MAX';
declare var EGLTFMaterialVariantMode : { None:'None',Simple:'Simple',UseMeshData:'UseMeshData',EGLTFMaterialVariantMode_MAX:'EGLTFMaterialVariantMode_MAX', };
declare class GLTFExportOptions extends UObject { 
	ExportUniformScale: number;
	bExportPreviewMesh: boolean;
	bStrictCompliance: boolean;
	bSkipNearDefaultValues: boolean;
	bIncludeGeneratorVersion: boolean;
	bExportProxyMaterials: boolean;
	bExportUnlitMaterials: boolean;
	bExportClearCoatMaterials: boolean;
	bExportExtraBlendModes: boolean;
	BakeMaterialInputs: EGLTFMaterialBakeMode;
	DefaultMaterialBakeSize: EGLTFMaterialBakeSizePOT;
	DefaultMaterialBakeFilter: TextureFilter;
	DefaultMaterialBakeTiling: TextureAddress;
	DefaultInputBakeSettings: Map<EGLTFMaterialPropertyGroup, GLTFOverrideMaterialBakeSettings>;
	DefaultLevelOfDetail: number;
	bExportVertexColors: boolean;
	bExportVertexSkinWeights: boolean;
	bUseMeshQuantization: boolean;
	bExportLevelSequences: boolean;
	bExportAnimationSequences: boolean;
	bExportPlaybackSettings: boolean;
	TextureImageFormat: EGLTFTextureImageFormat;
	TextureImageQuality: number;
	NoLossyImageFormatFor: number;
	bExportTextureTransforms: boolean;
	bExportLightmaps: boolean;
	TextureHDREncoding: EGLTFTextureHDREncoding;
	bAdjustNormalmaps: boolean;
	bExportHiddenInGame: boolean;
	ExportLights: number;
	bExportCameras: boolean;
	bExportHDRIBackdrops: boolean;
	bExportSkySpheres: boolean;
	VariantSetsMode: EGLTFVariantSetsMode;
	ExportMaterialVariants: EGLTFMaterialVariantMode;
	bExportMeshVariants: boolean;
	bExportVisibilityVariants: boolean;
	static Load(ResourceName: string): GLTFExportOptions;
	static Find(Outer: UObject, ResourceName: string): GLTFExportOptions;
	static GetDefaultObject(): GLTFExportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFExportOptions;
	ResetToDefault(): void;
	static C(Other: UObject | any): GLTFExportOptions;
}

declare class GLTFExportMessages { 
	Suggestions: string[];
	Warnings: string[];
	Errors: string[];
	clone() : GLTFExportMessages;
	static C(Other: UObject | any): GLTFExportMessages;
}

declare class GLTFExporter extends Exporter { 
	static Load(ResourceName: string): GLTFExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFExporter;
	static GetDefaultObject(): GLTFExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFExporter;
	static ExportToGLTF(UObject: UObject,FilePath: string,Options: GLTFExportOptions,SelectedActors: Set<Actor>,OutMessages?: GLTFExportMessages): {OutMessages: GLTFExportMessages, $: boolean};
	static C(Other: UObject | any): GLTFExporter;
}

declare class GLTFAnimSequenceExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFAnimSequenceExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFAnimSequenceExporter;
	static GetDefaultObject(): GLTFAnimSequenceExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFAnimSequenceExporter;
	static C(Other: UObject | any): GLTFAnimSequenceExporter;
}

declare class GLTFLevelExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFLevelExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFLevelExporter;
	static GetDefaultObject(): GLTFLevelExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFLevelExporter;
	static C(Other: UObject | any): GLTFLevelExporter;
}

declare class GLTFLevelSequenceExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFLevelSequenceExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFLevelSequenceExporter;
	static GetDefaultObject(): GLTFLevelSequenceExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFLevelSequenceExporter;
	static C(Other: UObject | any): GLTFLevelSequenceExporter;
}

declare class GLTFLevelVariantSetsExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFLevelVariantSetsExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFLevelVariantSetsExporter;
	static GetDefaultObject(): GLTFLevelVariantSetsExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFLevelVariantSetsExporter;
	static C(Other: UObject | any): GLTFLevelVariantSetsExporter;
}

declare class GLTFMaterialExporter extends GLTFExporter { 
	DefaultPreviewMesh: StaticMesh;
	static Load(ResourceName: string): GLTFMaterialExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFMaterialExporter;
	static GetDefaultObject(): GLTFMaterialExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFMaterialExporter;
	static C(Other: UObject | any): GLTFMaterialExporter;
}

declare class GLTFMaterialExportOptions extends AssetUserData { 
	Proxy: MaterialInterface;
	Default: GLTFOverrideMaterialBakeSettings;
	Inputs: Map<EGLTFMaterialPropertyGroup, GLTFOverrideMaterialBakeSettings>;
	static Load(ResourceName: string): GLTFMaterialExportOptions;
	static Find(Outer: UObject, ResourceName: string): GLTFMaterialExportOptions;
	static GetDefaultObject(): GLTFMaterialExportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFMaterialExportOptions;
	static C(Other: UObject | any): GLTFMaterialExportOptions;
}

declare class GLTFProxyOptions extends UObject { 
	bBakeMaterialInputs: boolean;
	DefaultMaterialBakeSize: EGLTFMaterialBakeSizePOT;
	DefaultMaterialBakeFilter: TextureFilter;
	DefaultMaterialBakeTiling: TextureAddress;
	DefaultInputBakeSettings: Map<EGLTFMaterialPropertyGroup, GLTFOverrideMaterialBakeSettings>;
	static Load(ResourceName: string): GLTFProxyOptions;
	static Find(Outer: UObject, ResourceName: string): GLTFProxyOptions;
	static GetDefaultObject(): GLTFProxyOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFProxyOptions;
	ResetToDefault(): void;
	static C(Other: UObject | any): GLTFProxyOptions;
}

declare class GLTFSkeletalMeshExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFSkeletalMeshExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFSkeletalMeshExporter;
	static GetDefaultObject(): GLTFSkeletalMeshExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFSkeletalMeshExporter;
	static C(Other: UObject | any): GLTFSkeletalMeshExporter;
}

declare class GLTFStaticMeshExporter extends GLTFExporter { 
	static Load(ResourceName: string): GLTFStaticMeshExporter;
	static Find(Outer: UObject, ResourceName: string): GLTFStaticMeshExporter;
	static GetDefaultObject(): GLTFStaticMeshExporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GLTFStaticMeshExporter;
	static C(Other: UObject | any): GLTFStaticMeshExporter;
}

declare class NamedInterface { 
	InterfaceName: string;
	InterfaceObject: UObject;
	clone() : NamedInterface;
	static C(Other: UObject | any): NamedInterface;
}

declare class NamedInterfaceDef { 
	InterfaceName: string;
	InterfaceClassName: string;
	clone() : NamedInterfaceDef;
	static C(Other: UObject | any): NamedInterfaceDef;
}

declare class NamedInterfaces extends UObject { 
	NamedInterfaces: NamedInterface[];
	NamedInterfaceDefs: NamedInterfaceDef[];
	static Load(ResourceName: string): NamedInterfaces;
	static Find(Outer: UObject, ResourceName: string): NamedInterfaces;
	static GetDefaultObject(): NamedInterfaces;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedInterfaces;
	static C(Other: UObject | any): NamedInterfaces;
}

declare class TurnBasedMatchInterface extends Interface { 
	static Load(ResourceName: string): TurnBasedMatchInterface;
	static Find(Outer: UObject, ResourceName: string): TurnBasedMatchInterface;
	static GetDefaultObject(): TurnBasedMatchInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedMatchInterface;
	OnMatchReceivedTurn(Match: string,bDidBecomeActive: boolean): void;
	OnMatchEnded(Match: string): void;
	static C(Other: UObject | any): TurnBasedMatchInterface;
}

declare class AchievementBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AchievementBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AchievementBlueprintLibrary;
	static GetDefaultObject(): AchievementBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementBlueprintLibrary;
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static C(Other: UObject | any): AchievementBlueprintLibrary;
}

declare class AchievementQueryCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AchievementQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementQueryCallbackProxy;
	static GetDefaultObject(): AchievementQueryCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementQueryCallbackProxy;
	static CacheAchievements(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	static CacheAchievementDescriptions(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	static C(Other: UObject | any): AchievementQueryCallbackProxy;
}

declare class AchievementWriteCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	static Load(ResourceName: string): AchievementWriteCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementWriteCallbackProxy;
	static GetDefaultObject(): AchievementWriteCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementWriteCallbackProxy;
	static WriteAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementName: string,Progress: number,UserTag: number): AchievementWriteCallbackProxy;
	static C(Other: UObject | any): AchievementWriteCallbackProxy;
}

declare class ConnectionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	static Load(ResourceName: string): ConnectionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ConnectionCallbackProxy;
	static GetDefaultObject(): ConnectionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConnectionCallbackProxy;
	static ConnectToService(WorldContextObject: UObject,PlayerController: PlayerController): ConnectionCallbackProxy;
	static C(Other: UObject | any): ConnectionCallbackProxy;
}

declare class CreateSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): CreateSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): CreateSessionCallbackProxy;
	static GetDefaultObject(): CreateSessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CreateSessionCallbackProxy;
	static CreateSession(WorldContextObject: UObject,PlayerController: PlayerController,PublicConnections: number,bUseLAN: boolean): CreateSessionCallbackProxy;
	static C(Other: UObject | any): CreateSessionCallbackProxy;
}

declare class DestroySessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): DestroySessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): DestroySessionCallbackProxy;
	static GetDefaultObject(): DestroySessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestroySessionCallbackProxy;
	static DestroySession(WorldContextObject: UObject,PlayerController: PlayerController): DestroySessionCallbackProxy;
	static C(Other: UObject | any): DestroySessionCallbackProxy;
}

declare class EndMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): EndMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndMatchCallbackProxy;
	static GetDefaultObject(): EndMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndMatchCallbackProxy;
	static C(Other: UObject | any): EndMatchCallbackProxy;
}

declare class EndTurnCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): EndTurnCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndTurnCallbackProxy;
	static GetDefaultObject(): EndTurnCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndTurnCallbackProxy;
	static C(Other: UObject | any): EndTurnCallbackProxy;
}

declare class BlueprintSessionResult { 
	clone() : BlueprintSessionResult;
	static C(Other: UObject | any): BlueprintSessionResult;
}

declare class FindSessionsCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	static Load(ResourceName: string): FindSessionsCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindSessionsCallbackProxy;
	static GetDefaultObject(): FindSessionsCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindSessionsCallbackProxy;
	static GetServerName(Result: BlueprintSessionResult): string;
	static GetPingInMs(Result: BlueprintSessionResult): number;
	static GetMaxPlayers(Result: BlueprintSessionResult): number;
	static GetCurrentPlayers(Result: BlueprintSessionResult): number;
	static FindSessions(WorldContextObject: UObject,PlayerController: PlayerController,MaxResults: number,bUseLAN: boolean): FindSessionsCallbackProxy;
	static C(Other: UObject | any): FindSessionsCallbackProxy;
}

declare class FindTurnBasedMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	static Load(ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static GetDefaultObject(): FindTurnBasedMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindTurnBasedMatchCallbackProxy;
	static C(Other: UObject | any): FindTurnBasedMatchCallbackProxy;
}

declare type EInAppPurchaseStatus = 'Invalid' | 'Failed' | 'Deferred' | 'Canceled' | 'Purchased' | 'Restored' | 'EInAppPurchaseStatus_MAX';
declare var EInAppPurchaseStatus : { Invalid:'Invalid',Failed:'Failed',Deferred:'Deferred',Canceled:'Canceled',Purchased:'Purchased',Restored:'Restored',EInAppPurchaseStatus_MAX:'EInAppPurchaseStatus_MAX', };
declare class InAppPurchaseReceiptInfo2 { 
	ItemName: string;
	ItemId: string;
	ValidationInfo: string;
	clone() : InAppPurchaseReceiptInfo2;
	static C(Other: UObject | any): InAppPurchaseReceiptInfo2;
}

declare class InAppPurchaseProductRequest2 { 
	ProductIdentifier: string;
	bIsConsumable: boolean;
	clone() : InAppPurchaseProductRequest2;
	static C(Other: UObject | any): InAppPurchaseProductRequest2;
}

declare class InAppPurchaseCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: InAppPurchaseReceiptInfo2[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: InAppPurchaseReceiptInfo2[]) => void>;
	static Load(ResourceName: string): InAppPurchaseCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseUnprocessedPurchases(PlayerController: PlayerController): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseQueryOwned(PlayerController: PlayerController): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchase(PlayerController: PlayerController,ProductRequest: InAppPurchaseProductRequest2): InAppPurchaseCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseCallbackProxy2;
}

declare type EOnlineProxyStoreOfferDiscountType = 'NotOnSale' | 'Percentage' | 'DiscountAmount' | 'PayAmount' | 'EOnlineProxyStoreOfferDiscountType_MAX';
declare var EOnlineProxyStoreOfferDiscountType : { NotOnSale:'NotOnSale',Percentage:'Percentage',DiscountAmount:'DiscountAmount',PayAmount:'PayAmount',EOnlineProxyStoreOfferDiscountType_MAX:'EOnlineProxyStoreOfferDiscountType_MAX', };
declare class OnlineProxyStoreOffer { 
	OfferId: string;
	Title: string;
	Description: string;
	LongDescription: string;
	RegularPriceText: string;
	RegularPrice: number;
	PriceText: string;
	NumericPrice: number;
	CurrencyCode: string;
	ReleaseDate: DateTime;
	ExpirationDate: DateTime;
	DiscountType: EOnlineProxyStoreOfferDiscountType;
	DynamicFields: Map<string, string>;
	clone() : OnlineProxyStoreOffer;
	static C(Other: UObject | any): OnlineProxyStoreOffer;
}

declare class InAppPurchaseQueryCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(InAppOfferInformation: OnlineProxyStoreOffer[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(InAppOfferInformation: OnlineProxyStoreOffer[]) => void>;
	static Load(ResourceName: string): InAppPurchaseQueryCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseQueryCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseQueryCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseQueryCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseQuery(PlayerController: PlayerController,ProductIdentifiers: string[]): InAppPurchaseQueryCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseQueryCallbackProxy2;
}

declare class InAppPurchaseRestoreInfo2 { 
	ItemName: string;
	ItemId: string;
	ValidationInfo: string;
	clone() : InAppPurchaseRestoreInfo2;
	static C(Other: UObject | any): InAppPurchaseRestoreInfo2;
}

declare class InAppPurchaseRestoreCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: InAppPurchaseRestoreInfo2[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: InAppPurchaseRestoreInfo2[]) => void>;
	static Load(ResourceName: string): InAppPurchaseRestoreCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseRestoreCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseRestoreCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseRestoreCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: InAppPurchaseProductRequest2[],PlayerController: PlayerController): InAppPurchaseRestoreCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseRestoreCallbackProxy2;
}

declare class IpConnection extends NetConnection { 
	SocketErrorDisconnectDelay: number;
	static Load(ResourceName: string): IpConnection;
	static Find(Outer: UObject, ResourceName: string): IpConnection;
	static GetDefaultObject(): IpConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpConnection;
	static C(Other: UObject | any): IpConnection;
}

declare class IpNetDriver extends NetDriver { 
	LogPortUnreach: boolean;
	AllowPlayerPortUnreach: boolean;
	MaxPortCountToTry: number;
	ServerDesiredSocketReceiveBufferBytes: number;
	ServerDesiredSocketSendBufferBytes: number;
	ClientDesiredSocketReceiveBufferBytes: number;
	ClientDesiredSocketSendBufferBytes: number;
	MaxSecondsInReceive: number;
	NbPacketsBetweenReceiveTimeTest: number;
	ResolutionConnectionTimeout: number;
	static Load(ResourceName: string): IpNetDriver;
	static Find(Outer: UObject, ResourceName: string): IpNetDriver;
	static GetDefaultObject(): IpNetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpNetDriver;
	static C(Other: UObject | any): IpNetDriver;
}

declare class JoinSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): JoinSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): JoinSessionCallbackProxy;
	static GetDefaultObject(): JoinSessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JoinSessionCallbackProxy;
	static JoinSession(WorldContextObject: UObject,PlayerController: PlayerController,SearchResult: BlueprintSessionResult): JoinSessionCallbackProxy;
	static C(Other: UObject | any): JoinSessionCallbackProxy;
}

declare class LeaderboardBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LeaderboardBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): LeaderboardBlueprintLibrary;
	static GetDefaultObject(): LeaderboardBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardBlueprintLibrary;
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	static C(Other: UObject | any): LeaderboardBlueprintLibrary;
}

declare class LeaderboardFlushCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	static Load(ResourceName: string): LeaderboardFlushCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardFlushCallbackProxy;
	static GetDefaultObject(): LeaderboardFlushCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardFlushCallbackProxy;
	static CreateProxyObjectForFlush(PlayerController: PlayerController,SessionName: string): LeaderboardFlushCallbackProxy;
	static C(Other: UObject | any): LeaderboardFlushCallbackProxy;
}

declare class LeaderboardQueryCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	static Load(ResourceName: string): LeaderboardQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardQueryCallbackProxy;
	static GetDefaultObject(): LeaderboardQueryCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardQueryCallbackProxy;
	static CreateProxyObjectForIntQuery(PlayerController: PlayerController,StatName: string): LeaderboardQueryCallbackProxy;
	static C(Other: UObject | any): LeaderboardQueryCallbackProxy;
}

declare class LogoutCallbackProxy extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	static Load(ResourceName: string): LogoutCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LogoutCallbackProxy;
	static GetDefaultObject(): LogoutCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LogoutCallbackProxy;
	static Logout(WorldContextObject: UObject,PlayerController: PlayerController): LogoutCallbackProxy;
	static C(Other: UObject | any): LogoutCallbackProxy;
}

declare class OnlineBeacon extends Actor { 
	BeaconConnectionInitialTimeout: number;
	BeaconConnectionTimeout: number;
	NetDriver: NetDriver;
	static GetDefaultObject(): OnlineBeacon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeacon;
	static C(Other: UObject | any): OnlineBeacon;
}

declare class OnlineBeaconHostObject extends Actor { 
	BeaconTypeName: string;
	ClientBeaconActorClass: UnrealEngineClass;
	ClientActors: OnlineBeaconClient[];
	static GetDefaultObject(): OnlineBeaconHostObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHostObject;
	static C(Other: UObject | any): OnlineBeaconHostObject;
}

declare type EBeaconConnectionState = 'Invalid' | 'Closed' | 'Pending' | 'Open' | 'EBeaconConnectionState_MAX';
declare var EBeaconConnectionState : { Invalid:'Invalid',Closed:'Closed',Pending:'Pending',Open:'Open',EBeaconConnectionState_MAX:'EBeaconConnectionState_MAX', };
declare class OnlineBeaconClient extends OnlineBeacon { 
	BeaconOwner: OnlineBeaconHostObject;
	BeaconConnection: NetConnection;
	ConnectionState: EBeaconConnectionState;
	static GetDefaultObject(): OnlineBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconClient;
	ClientOnConnected(): void;
	static C(Other: UObject | any): OnlineBeaconClient;
}

declare class OnlineBeaconHost extends OnlineBeacon { 
	ListenPort: number;
	bAuthRequired: boolean;
	MaxAuthTokenSize: number;
	ClientActors: OnlineBeaconClient[];
	static GetDefaultObject(): OnlineBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHost;
	static C(Other: UObject | any): OnlineBeaconHost;
}

declare class OnlineEngineInterfaceImpl extends OnlineEngineInterface { 
	MappedUniqueNetIdTypes: Map<string, string>;
	CompatibleUniqueNetIdTypes: string[];
	VoiceSubsystemNameOverride: string;
	static Load(ResourceName: string): OnlineEngineInterfaceImpl;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterfaceImpl;
	static GetDefaultObject(): OnlineEngineInterfaceImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterfaceImpl;
	static C(Other: UObject | any): OnlineEngineInterfaceImpl;
}

declare class PIELoginSettingsInternal { 
	ID: string;
	Token: string;
	Type: string;
	TokenBytes: number[];
	clone() : PIELoginSettingsInternal;
	static C(Other: UObject | any): PIELoginSettingsInternal;
}

declare class OnlinePIESettings extends DeveloperSettings { 
	bOnlinePIEEnabled: boolean;
	Logins: PIELoginSettingsInternal[];
	static Load(ResourceName: string): OnlinePIESettings;
	static Find(Outer: UObject, ResourceName: string): OnlinePIESettings;
	static GetDefaultObject(): OnlinePIESettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlinePIESettings;
	static C(Other: UObject | any): OnlinePIESettings;
}

declare class OnlineServicesEngineInterfaceImpl extends OnlineEngineInterface { 
	static Load(ResourceName: string): OnlineServicesEngineInterfaceImpl;
	static Find(Outer: UObject, ResourceName: string): OnlineServicesEngineInterfaceImpl;
	static GetDefaultObject(): OnlineServicesEngineInterfaceImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineServicesEngineInterfaceImpl;
	static C(Other: UObject | any): OnlineServicesEngineInterfaceImpl;
}

declare class OnlineSessionClient extends OnlineSession { 
	bIsFromInvite: boolean;
	bHandlingDisconnect: boolean;
	static Load(ResourceName: string): OnlineSessionClient;
	static Find(Outer: UObject, ResourceName: string): OnlineSessionClient;
	static GetDefaultObject(): OnlineSessionClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSessionClient;
	static C(Other: UObject | any): OnlineSessionClient;
}

declare class PlayerReservation { 
	UniqueId: UniqueNetIdRepl;
	ValidationStr: string;
	Platform: string;
	bAllowCrossplay: boolean;
	ElapsedTime: number;
	clone() : PlayerReservation;
	static C(Other: UObject | any): PlayerReservation;
}

declare class PartyReservation { 
	TeamNum: number;
	PartyLeader: UniqueNetIdRepl;
	PartyMembers: PlayerReservation[];
	RemovedPartyMembers: PlayerReservation[];
	clone() : PartyReservation;
	static C(Other: UObject | any): PartyReservation;
}

declare type EClientRequestType = 'NonePending' | 'ExistingSessionReservation' | 'ReservationUpdate' | 'EmptyServerReservation' | 'Reconnect' | 'Abandon' | 'ReservationRemoveMembers' | 'AddOrUpdateReservation' | 'EClientRequestType_MAX';
declare var EClientRequestType : { NonePending:'NonePending',ExistingSessionReservation:'ExistingSessionReservation',ReservationUpdate:'ReservationUpdate',EmptyServerReservation:'EmptyServerReservation',Reconnect:'Reconnect',Abandon:'Abandon',ReservationRemoveMembers:'ReservationRemoveMembers',AddOrUpdateReservation:'AddOrUpdateReservation',EClientRequestType_MAX:'EClientRequestType_MAX', };
declare type EPartyReservationResult = 'NoResult' | 'RequestPending' | 'GeneralError' | 'PartyLimitReached' | 'IncorrectPlayerCount' | 'RequestTimedOut' | 'ReservationDuplicate' | 'ReservationNotFound' | 'ReservationAccepted' | 'ReservationDenied' | 'ReservationDenied_CrossPlayRestriction' | 'ReservationDenied_Banned' | 'ReservationRequestCanceled' | 'ReservationInvalid' | 'BadSessionId' | 'ReservationDenied_ContainsExistingPlayers' | 'EPartyReservationResult_MAX';
declare var EPartyReservationResult : { NoResult:'NoResult',RequestPending:'RequestPending',GeneralError:'GeneralError',PartyLimitReached:'PartyLimitReached',IncorrectPlayerCount:'IncorrectPlayerCount',RequestTimedOut:'RequestTimedOut',ReservationDuplicate:'ReservationDuplicate',ReservationNotFound:'ReservationNotFound',ReservationAccepted:'ReservationAccepted',ReservationDenied:'ReservationDenied',ReservationDenied_CrossPlayRestriction:'ReservationDenied_CrossPlayRestriction',ReservationDenied_Banned:'ReservationDenied_Banned',ReservationRequestCanceled:'ReservationRequestCanceled',ReservationInvalid:'ReservationInvalid',BadSessionId:'BadSessionId',ReservationDenied_ContainsExistingPlayers:'ReservationDenied_ContainsExistingPlayers',EPartyReservationResult_MAX:'EPartyReservationResult_MAX', };
declare class PartyBeaconClient extends OnlineBeaconClient { 
	DestSessionId: string;
	PendingReservation: PartyReservation;
	RequestType: EClientRequestType;
	bPendingReservationSent: boolean;
	bCancelReservation: boolean;
	static GetDefaultObject(): PartyBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconClient;
	ServerUpdateReservationRequest(SessionId: string,ReservationUpdate: PartyReservation): void;
	ServerReservationRequest(SessionId: string,Reservation: PartyReservation): void;
	ServerRemoveMemberFromReservationRequest(SessionId: string,ReservationUpdate: PartyReservation): void;
	ServerCancelReservationRequest(PartyLeader: UniqueNetIdRepl): void;
	ServerAddOrUpdateReservationRequest(SessionId: string,Reservation: PartyReservation): void;
	ClientSendReservationUpdates(NumRemainingReservations: number): void;
	ClientSendReservationFull(): void;
	ClientReservationResponse(ReservationResponse: EPartyReservationResult): void;
	ClientCancelReservationResponse(ReservationResponse: EPartyReservationResult): void;
	static C(Other: UObject | any): PartyBeaconClient;
}

declare class PartyBeaconCrossplayPlatformMapping { 
	PlatformName: string;
	PlatformType: string;
	clone() : PartyBeaconCrossplayPlatformMapping;
	static C(Other: UObject | any): PartyBeaconCrossplayPlatformMapping;
}

declare class PartyBeaconState extends UObject { 
	SessionName: string;
	NumConsumedReservations: number;
	MaxReservations: number;
	NumTeams: number;
	NumPlayersPerTeam: number;
	TeamAssignmentMethod: string;
	ReservedHostTeamNum: number;
	ForceTeamNum: number;
	bRestrictCrossConsole: boolean;
	PlatformCrossplayRestrictions: string[];
	PlatformTypeMapping: PartyBeaconCrossplayPlatformMapping[];
	bEnableRemovalRequests: boolean;
	Reservations: PartyReservation[];
	static Load(ResourceName: string): PartyBeaconState;
	static Find(Outer: UObject, ResourceName: string): PartyBeaconState;
	static GetDefaultObject(): PartyBeaconState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconState;
	static C(Other: UObject | any): PartyBeaconState;
}

declare class PartyBeaconHost extends OnlineBeaconHostObject { 
	State: PartyBeaconState;
	bLogoutOnSessionTimeout: boolean;
	SessionTimeoutSecs: number;
	TravelSessionTimeoutSecs: number;
	static GetDefaultObject(): PartyBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconHost;
	static C(Other: UObject | any): PartyBeaconHost;
}

declare type EMPMatchOutcome = 'None' | 'Quit' | 'Won' | 'Lost' | 'Tied' | 'TimeExpired' | 'First' | 'Second' | 'Third' | 'Fourth' | 'EMPMatchOutcome_MAX';
declare var EMPMatchOutcome : { None:'None',Quit:'Quit',Won:'Won',Lost:'Lost',Tied:'Tied',TimeExpired:'TimeExpired',First:'First',Second:'Second',Third:'Third',Fourth:'Fourth',EMPMatchOutcome_MAX:'EMPMatchOutcome_MAX', };
declare class QuitMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): QuitMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): QuitMatchCallbackProxy;
	static GetDefaultObject(): QuitMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuitMatchCallbackProxy;
	static QuitMatch(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,Outcome: EMPMatchOutcome,TurnTimeoutInSeconds: number): QuitMatchCallbackProxy;
	static C(Other: UObject | any): QuitMatchCallbackProxy;
}

declare class ShowLoginUICallbackProxy extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	static Load(ResourceName: string): ShowLoginUICallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ShowLoginUICallbackProxy;
	static GetDefaultObject(): ShowLoginUICallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShowLoginUICallbackProxy;
	static ShowExternalLoginUI(WorldContextObject: UObject,InPlayerController: PlayerController): ShowLoginUICallbackProxy;
	static C(Other: UObject | any): ShowLoginUICallbackProxy;
}

declare class SpectatorReservation { 
	SpectatorId: UniqueNetIdRepl;
	Spectator: PlayerReservation;
	clone() : SpectatorReservation;
	static C(Other: UObject | any): SpectatorReservation;
}

declare type ESpectatorClientRequestType = 'NonePending' | 'ExistingSessionReservation' | 'ReservationUpdate' | 'EmptyServerReservation' | 'Reconnect' | 'Abandon' | 'ESpectatorClientRequestType_MAX';
declare var ESpectatorClientRequestType : { NonePending:'NonePending',ExistingSessionReservation:'ExistingSessionReservation',ReservationUpdate:'ReservationUpdate',EmptyServerReservation:'EmptyServerReservation',Reconnect:'Reconnect',Abandon:'Abandon',ESpectatorClientRequestType_MAX:'ESpectatorClientRequestType_MAX', };
declare type ESpectatorReservationResult = 'NoResult' | 'RequestPending' | 'GeneralError' | 'SpectatorLimitReached' | 'IncorrectPlayerCount' | 'RequestTimedOut' | 'ReservationDuplicate' | 'ReservationNotFound' | 'ReservationAccepted' | 'ReservationDenied' | 'ReservationDenied_CrossPlayRestriction' | 'ReservationDenied_Banned' | 'ReservationRequestCanceled' | 'ReservationInvalid' | 'BadSessionId' | 'ReservationDenied_ContainsExistingPlayers' | 'ESpectatorReservationResult_MAX';
declare var ESpectatorReservationResult : { NoResult:'NoResult',RequestPending:'RequestPending',GeneralError:'GeneralError',SpectatorLimitReached:'SpectatorLimitReached',IncorrectPlayerCount:'IncorrectPlayerCount',RequestTimedOut:'RequestTimedOut',ReservationDuplicate:'ReservationDuplicate',ReservationNotFound:'ReservationNotFound',ReservationAccepted:'ReservationAccepted',ReservationDenied:'ReservationDenied',ReservationDenied_CrossPlayRestriction:'ReservationDenied_CrossPlayRestriction',ReservationDenied_Banned:'ReservationDenied_Banned',ReservationRequestCanceled:'ReservationRequestCanceled',ReservationInvalid:'ReservationInvalid',BadSessionId:'BadSessionId',ReservationDenied_ContainsExistingPlayers:'ReservationDenied_ContainsExistingPlayers',ESpectatorReservationResult_MAX:'ESpectatorReservationResult_MAX', };
declare class SpectatorBeaconClient extends OnlineBeaconClient { 
	DestSessionId: string;
	PendingReservation: SpectatorReservation;
	RequestType: ESpectatorClientRequestType;
	bPendingReservationSent: boolean;
	bCancelReservation: boolean;
	static GetDefaultObject(): SpectatorBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconClient;
	ServerReservationRequest(SessionId: string,Reservation: SpectatorReservation): void;
	ServerCancelReservationRequest(Spectator: UniqueNetIdRepl): void;
	ClientSendReservationUpdates(NumRemainingReservations: number): void;
	ClientSendReservationFull(): void;
	ClientReservationResponse(ReservationResponse: ESpectatorReservationResult): void;
	ClientCancelReservationResponse(ReservationResponse: ESpectatorReservationResult): void;
	static C(Other: UObject | any): SpectatorBeaconClient;
}

declare class SpectatorBeaconState extends UObject { 
	SessionName: string;
	NumConsumedReservations: number;
	MaxReservations: number;
	bRestrictCrossConsole: boolean;
	Reservations: SpectatorReservation[];
	static Load(ResourceName: string): SpectatorBeaconState;
	static Find(Outer: UObject, ResourceName: string): SpectatorBeaconState;
	static GetDefaultObject(): SpectatorBeaconState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconState;
	static C(Other: UObject | any): SpectatorBeaconState;
}

declare class SpectatorBeaconHost extends OnlineBeaconHostObject { 
	State: SpectatorBeaconState;
	bLogoutOnSessionTimeout: boolean;
	SessionTimeoutSecs: number;
	TravelSessionTimeoutSecs: number;
	static GetDefaultObject(): SpectatorBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconHost;
	static C(Other: UObject | any): SpectatorBeaconHost;
}

declare class TestBeaconClient extends OnlineBeaconClient { 
	static GetDefaultObject(): TestBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconClient;
	ServerPong(): void;
	ClientPing(): void;
	static C(Other: UObject | any): TestBeaconClient;
}

declare class TestBeaconHost extends OnlineBeaconHostObject { 
	static GetDefaultObject(): TestBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconHost;
	static C(Other: UObject | any): TestBeaconHost;
}

declare class TurnBasedBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): TurnBasedBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TurnBasedBlueprintLibrary;
	static GetDefaultObject(): TurnBasedBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedBlueprintLibrary;
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static C(Other: UObject | any): TurnBasedBlueprintLibrary;
}

declare class VoipListenerSynthComponent extends SynthComponent { 
	static Load(ResourceName: string): VoipListenerSynthComponent;
	static Find(Outer: UObject, ResourceName: string): VoipListenerSynthComponent;
	static GetDefaultObject(): VoipListenerSynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VoipListenerSynthComponent;
	IsIdling(): boolean;
	static C(Other: UObject | any): VoipListenerSynthComponent;
}

declare class K2Node_InAppPurchase2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchase2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchase2;
	static GetDefaultObject(): K2Node_InAppPurchase2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchase2;
	static C(Other: UObject | any): K2Node_InAppPurchase2;
}

declare class K2Node_InAppPurchaseQuery2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseQuery2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQuery2;
	static GetDefaultObject(): K2Node_InAppPurchaseQuery2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQuery2;
	static C(Other: UObject | any): K2Node_InAppPurchaseQuery2;
}

declare class K2Node_InAppPurchaseQueryOwned2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseQueryOwned2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQueryOwned2;
	static GetDefaultObject(): K2Node_InAppPurchaseQueryOwned2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQueryOwned2;
	static C(Other: UObject | any): K2Node_InAppPurchaseQueryOwned2;
}

declare class K2Node_InAppPurchaseRestore2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseRestore2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseRestore2;
	static GetDefaultObject(): K2Node_InAppPurchaseRestore2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseRestore2;
	static C(Other: UObject | any): K2Node_InAppPurchaseRestore2;
}

declare class K2Node_InAppPurchaseUnprocessed2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseUnprocessed2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseUnprocessed2;
	static GetDefaultObject(): K2Node_InAppPurchaseUnprocessed2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseUnprocessed2;
	static C(Other: UObject | any): K2Node_InAppPurchaseUnprocessed2;
}

declare class K2Node_LeaderboardFlush extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_LeaderboardFlush;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardFlush;
	static GetDefaultObject(): K2Node_LeaderboardFlush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardFlush;
	static C(Other: UObject | any): K2Node_LeaderboardFlush;
}

declare class K2Node_LeaderboardQuery extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_LeaderboardQuery;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardQuery;
	static GetDefaultObject(): K2Node_LeaderboardQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardQuery;
	static C(Other: UObject | any): K2Node_LeaderboardQuery;
}

declare class WmfMediaSettings extends UObject { 
	AllowNonStandardCodecs: boolean;
	LowLatency: boolean;
	NativeAudioOut: boolean;
	HardwareAcceleratedVideoDecoding: boolean;
	static Load(ResourceName: string): WmfMediaSettings;
	static Find(Outer: UObject, ResourceName: string): WmfMediaSettings;
	static GetDefaultObject(): WmfMediaSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WmfMediaSettings;
	static C(Other: UObject | any): WmfMediaSettings;
}

declare type EDefaultGraphicsRHI = 'DefaultGraphicsRHI_Default' | 'DefaultGraphicsRHI_DX11' | 'DefaultGraphicsRHI_DX12' | 'DefaultGraphicsRHI_Vulkan' | 'DefaultGraphicsRHI_MAX';
declare var EDefaultGraphicsRHI : { DefaultGraphicsRHI_Default:'DefaultGraphicsRHI_Default',DefaultGraphicsRHI_DX11:'DefaultGraphicsRHI_DX11',DefaultGraphicsRHI_DX12:'DefaultGraphicsRHI_DX12',DefaultGraphicsRHI_Vulkan:'DefaultGraphicsRHI_Vulkan',DefaultGraphicsRHI_MAX:'DefaultGraphicsRHI_MAX', };
declare type ECompilerVersion = 'Default' | 'VisualStudio2015' | 'VisualStudio2017' | 'VisualStudio2019' | 'VisualStudio2022' | 'ECompilerVersion_MAX';
declare var ECompilerVersion : { Default:'Default',VisualStudio2015:'VisualStudio2015',VisualStudio2017:'VisualStudio2017',VisualStudio2019:'VisualStudio2019',VisualStudio2022:'VisualStudio2022',ECompilerVersion_MAX:'ECompilerVersion_MAX', };
declare class PlatformRuntimeAudioCompressionOverrides { 
	bOverrideCompressionTimes: boolean;
	DurationThreshold: number;
	MaxNumRandomBranches: number;
	SoundCueQualityIndex: number;
	clone() : PlatformRuntimeAudioCompressionOverrides;
	static C(Other: UObject | any): PlatformRuntimeAudioCompressionOverrides;
}

declare class WindowsTargetSettings extends UObject { 
	DefaultGraphicsRHI: EDefaultGraphicsRHI;
	TargetedRHIs: string[];
	D3D12TargetedShaderFormats: string[];
	D3D11TargetedShaderFormats: string[];
	VulkanTargetedShaderFormats: string[];
	Compiler: ECompilerVersion;
	AudioSampleRate: number;
	AudioCallbackBufferFrameSize: number;
	AudioNumBuffersToEnqueue: number;
	AudioMaxChannels: number;
	AudioNumSourceWorkers: number;
	SpatializationPlugin: string;
	SourceDataOverridePlugin: string;
	ReverbPlugin: string;
	OcclusionPlugin: string;
	CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
	CacheSizeKB: number;
	MaxChunkSizeOverrideKB: number;
	bResampleForDevice: boolean;
	MaxSampleRate: number;
	HighSampleRate: number;
	MedSampleRate: number;
	LowSampleRate: number;
	MinSampleRate: number;
	CompressionQualityModifier: number;
	AutoStreamingThreshold: number;
	SoundCueCookQualityIndex: number;
	static Load(ResourceName: string): WindowsTargetSettings;
	static Find(Outer: UObject, ResourceName: string): WindowsTargetSettings;
	static GetDefaultObject(): WindowsTargetSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowsTargetSettings;
	static C(Other: UObject | any): WindowsTargetSettings;
}

declare type EPinnedCommandListType = 'Command' | 'CustomWidget' | 'EPinnedCommandListType_MAX';
declare var EPinnedCommandListType : { Command:'Command',CustomWidget:'CustomWidget',EPinnedCommandListType_MAX:'EPinnedCommandListType_MAX', };
declare class PinnedCommandListCommand { 
	Name: string;
	Binding: string;
	Type: EPinnedCommandListType;
	clone() : PinnedCommandListCommand;
	static C(Other: UObject | any): PinnedCommandListCommand;
}

declare class PinnedCommandListContext { 
	Name: string;
	Commands: PinnedCommandListCommand[];
	clone() : PinnedCommandListContext;
	static C(Other: UObject | any): PinnedCommandListContext;
}

declare class PinnedCommandListSettings extends UObject { 
	Contexts: PinnedCommandListContext[];
	static Load(ResourceName: string): PinnedCommandListSettings;
	static Find(Outer: UObject, ResourceName: string): PinnedCommandListSettings;
	static GetDefaultObject(): PinnedCommandListSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PinnedCommandListSettings;
	static C(Other: UObject | any): PinnedCommandListSettings;
}

declare class AnimationEditorPreviewActor extends Actor { 
	static GetDefaultObject(): AnimationEditorPreviewActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationEditorPreviewActor;
	static C(Other: UObject | any): AnimationEditorPreviewActor;
}

declare class AnimationSequenceBrowserContextMenuContext extends UObject { 
	SelectedObjects: UObject[];
	static Load(ResourceName: string): AnimationSequenceBrowserContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): AnimationSequenceBrowserContextMenuContext;
	static GetDefaultObject(): AnimationSequenceBrowserContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSequenceBrowserContextMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): AnimationSequenceBrowserContextMenuContext;
}

declare class AnimCurveBaseCopyObject extends UObject { 
	DisplayName: string;
	UID: number;
	CurveType: ERawCurveTrackTypes;
	Channel: ETransformCurveChannel;
	Axis: EVectorCurveChannel;
	OriginName: string;
	static Load(ResourceName: string): AnimCurveBaseCopyObject;
	static Find(Outer: UObject, ResourceName: string): AnimCurveBaseCopyObject;
	static GetDefaultObject(): AnimCurveBaseCopyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveBaseCopyObject;
	static C(Other: UObject | any): AnimCurveBaseCopyObject;
}

declare class FloatCurveCopyObject extends AnimCurveBaseCopyObject { 
	Curve: FloatCurve;
	static Load(ResourceName: string): FloatCurveCopyObject;
	static Find(Outer: UObject, ResourceName: string): FloatCurveCopyObject;
	static GetDefaultObject(): FloatCurveCopyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatCurveCopyObject;
	static C(Other: UObject | any): FloatCurveCopyObject;
}

declare class TransformCurveCopyObject extends AnimCurveBaseCopyObject { 
	Curve: TransformCurve;
	static Load(ResourceName: string): TransformCurveCopyObject;
	static Find(Outer: UObject, ResourceName: string): TransformCurveCopyObject;
	static GetDefaultObject(): TransformCurveCopyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformCurveCopyObject;
	static C(Other: UObject | any): TransformCurveCopyObject;
}

declare class VectorCurveCopyObject extends AnimCurveBaseCopyObject { 
	Curve: VectorCurve;
	static Load(ResourceName: string): VectorCurveCopyObject;
	static Find(Outer: UObject, ResourceName: string): VectorCurveCopyObject;
	static GetDefaultObject(): VectorCurveCopyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorCurveCopyObject;
	static C(Other: UObject | any): VectorCurveCopyObject;
}

declare class AnimTimelineClipboardContent extends UObject { 
	Curves: AnimCurveBaseCopyObject[];
	static Load(ResourceName: string): AnimTimelineClipboardContent;
	static Find(Outer: UObject, ResourceName: string): AnimTimelineClipboardContent;
	static GetDefaultObject(): AnimTimelineClipboardContent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimTimelineClipboardContent;
	static C(Other: UObject | any): AnimTimelineClipboardContent;
}

declare class CachedAnalysisProperties extends UObject { 
	static Load(ResourceName: string): CachedAnalysisProperties;
	static Find(Outer: UObject, ResourceName: string): CachedAnalysisProperties;
	static GetDefaultObject(): CachedAnalysisProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CachedAnalysisProperties;
	static C(Other: UObject | any): CachedAnalysisProperties;
}

declare type EAnalysisLinearAxis = 'PlusX' | 'PlusY' | 'PlusZ' | 'MinusX' | 'MinusY' | 'MinusZ' | 'EAnalysisLinearAxis_MAX';
declare var EAnalysisLinearAxis : { PlusX:'PlusX',PlusY:'PlusY',PlusZ:'PlusZ',MinusX:'MinusX',MinusY:'MinusY',MinusZ:'MinusZ',EAnalysisLinearAxis_MAX:'EAnalysisLinearAxis_MAX', };
declare type EAnalysisSpace = 'World' | 'Fixed' | 'Changing' | 'Moving' | 'EAnalysisSpace_MAX';
declare var EAnalysisSpace : { World:'World',Fixed:'Fixed',Changing:'Changing',Moving:'Moving',EAnalysisSpace_MAX:'EAnalysisSpace_MAX', };
declare class LinearAnalysisProperties extends AnalysisProperties { 
	FunctionAxis: EAnalysisLinearAxis;
	BoneSocket: BoneSocketTarget;
	Space: EAnalysisSpace;
	SpaceBoneSocket: BoneSocketTarget;
	StartTimeFraction: number;
	EndTimeFraction: number;
	static Load(ResourceName: string): LinearAnalysisProperties;
	static Find(Outer: UObject, ResourceName: string): LinearAnalysisProperties;
	static GetDefaultObject(): LinearAnalysisProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinearAnalysisProperties;
	static C(Other: UObject | any): LinearAnalysisProperties;
}

declare type EAnalysisEulerAxis = 'Roll' | 'Pitch' | 'Yaw' | 'EAnalysisEulerAxis_MAX';
declare var EAnalysisEulerAxis : { Roll:'Roll',Pitch:'Pitch',Yaw:'Yaw',EAnalysisEulerAxis_MAX:'EAnalysisEulerAxis_MAX', };
declare class EulerAnalysisProperties extends AnalysisProperties { 
	FunctionAxis: EAnalysisEulerAxis;
	BoneSocket: BoneSocketTarget;
	BoneFacingAxis: EAnalysisLinearAxis;
	BoneRightAxis: EAnalysisLinearAxis;
	Space: EAnalysisSpace;
	SpaceBoneSocket: BoneSocketTarget;
	CharacterFacingAxis: EAnalysisLinearAxis;
	CharacterUpAxis: EAnalysisLinearAxis;
	StartTimeFraction: number;
	EndTimeFraction: number;
	static Load(ResourceName: string): EulerAnalysisProperties;
	static Find(Outer: UObject, ResourceName: string): EulerAnalysisProperties;
	static GetDefaultObject(): EulerAnalysisProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EulerAnalysisProperties;
	static C(Other: UObject | any): EulerAnalysisProperties;
}

declare class PersonaManagerContext extends Interface { 
	static Load(ResourceName: string): PersonaManagerContext;
	static Find(Outer: UObject, ResourceName: string): PersonaManagerContext;
	static GetDefaultObject(): PersonaManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaManagerContext;
	static C(Other: UObject | any): PersonaManagerContext;
}

declare class PersonaEditorModeManagerContext extends UObject { 
	static Load(ResourceName: string): PersonaEditorModeManagerContext;
	static Find(Outer: UObject, ResourceName: string): PersonaEditorModeManagerContext;
	static GetDefaultObject(): PersonaEditorModeManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaEditorModeManagerContext;
	static C(Other: UObject | any): PersonaEditorModeManagerContext;
}

declare class LODInfoUILayout extends UObject { 
	LODInfo: SkeletalMeshLODInfo;
	static Load(ResourceName: string): LODInfoUILayout;
	static Find(Outer: UObject, ResourceName: string): LODInfoUILayout;
	static GetDefaultObject(): LODInfoUILayout;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODInfoUILayout;
	static C(Other: UObject | any): LODInfoUILayout;
}

declare class PersonaPreviewSceneController extends UObject { 
	static Load(ResourceName: string): PersonaPreviewSceneController;
	static Find(Outer: UObject, ResourceName: string): PersonaPreviewSceneController;
	static GetDefaultObject(): PersonaPreviewSceneController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaPreviewSceneController;
	static C(Other: UObject | any): PersonaPreviewSceneController;
}

declare class PersonaPreviewSceneAnimationController extends PersonaPreviewSceneController { 
	Animation: AnimationAsset;
	static Load(ResourceName: string): PersonaPreviewSceneAnimationController;
	static Find(Outer: UObject, ResourceName: string): PersonaPreviewSceneAnimationController;
	static GetDefaultObject(): PersonaPreviewSceneAnimationController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaPreviewSceneAnimationController;
	static C(Other: UObject | any): PersonaPreviewSceneAnimationController;
}

declare class PersonaPreviewSceneDefaultController extends PersonaPreviewSceneController { 
	static Load(ResourceName: string): PersonaPreviewSceneDefaultController;
	static Find(Outer: UObject, ResourceName: string): PersonaPreviewSceneDefaultController;
	static GetDefaultObject(): PersonaPreviewSceneDefaultController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaPreviewSceneDefaultController;
	static C(Other: UObject | any): PersonaPreviewSceneDefaultController;
}

declare class PersonaPreviewSceneDescription extends UObject { 
	PreviewController: UnrealEngineClass;
	PreviewControllerInstance: PersonaPreviewSceneController;
	PreviewControllerInstances: PersonaPreviewSceneController[];
	PreviewMesh: SkeletalMesh;
	PreviewAnimationBlueprint: AnimBlueprint;
	ApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
	LinkedAnimGraphTag: string;
	AdditionalMeshes: DataAsset;
	DefaultAdditionalMeshes: PreviewMeshCollection;
	static Load(ResourceName: string): PersonaPreviewSceneDescription;
	static Find(Outer: UObject, ResourceName: string): PersonaPreviewSceneDescription;
	static GetDefaultObject(): PersonaPreviewSceneDescription;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaPreviewSceneDescription;
	static C(Other: UObject | any): PersonaPreviewSceneDescription;
}

declare class PersonaPreviewSceneRefPoseController extends PersonaPreviewSceneController { 
	bResetBoneTransforms: boolean;
	static Load(ResourceName: string): PersonaPreviewSceneRefPoseController;
	static Find(Outer: UObject, ResourceName: string): PersonaPreviewSceneRefPoseController;
	static GetDefaultObject(): PersonaPreviewSceneRefPoseController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaPreviewSceneRefPoseController;
	static C(Other: UObject | any): PersonaPreviewSceneRefPoseController;
}

declare class PersonaToolMenuContext extends UObject { 
	static Load(ResourceName: string): PersonaToolMenuContext;
	static Find(Outer: UObject, ResourceName: string): PersonaToolMenuContext;
	static GetDefaultObject(): PersonaToolMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaToolMenuContext;
	GetSkeleton(): Skeleton;
	GetPreviewMeshComponent(): DebugSkelMeshComponent;
	GetMesh(): SkeletalMesh;
	GetAnimBlueprint(): AnimBlueprint;
	GetAnimationAsset(): AnimationAsset;
	static C(Other: UObject | any): PersonaToolMenuContext;
}

declare type EConstraintTransformComponentFlags = 'None' | 'ChildPosition' | 'ChildRotation' | 'ParentPosition' | 'ParentRotation' | 'AllChild' | 'AllParent' | 'AllPosition' | 'AllRotation' | 'All' | 'EConstraintTransformComponentFlags_MAX';
declare var EConstraintTransformComponentFlags : { None:'None',ChildPosition:'ChildPosition',ChildRotation:'ChildRotation',ParentPosition:'ParentPosition',ParentRotation:'ParentRotation',AllChild:'AllChild',AllParent:'AllParent',AllPosition:'AllPosition',AllRotation:'AllRotation',All:'All',EConstraintTransformComponentFlags_MAX:'EConstraintTransformComponentFlags_MAX', };
declare class PhysicsAssetRenderSettings { 
	CollisionViewMode: EPhysicsAssetEditorCollisionViewMode;
	ConstraintViewMode: EPhysicsAssetEditorConstraintViewMode;
	ConstraintViewportManipulationFlags: EConstraintTransformComponentFlags;
	ConstraintTransformComponentDisplayRelativeToDefaultFlags: EConstraintTransformComponentFlags;
	ConstraintDrawSize: number;
	PhysicsBlend: number;
	bHideKinematicBodies: boolean;
	bHideSimulatedBodies: boolean;
	bRenderOnlySelectedConstraints: boolean;
	bShowCOM: boolean;
	bShowConstraintsAsPoints: boolean;
	BoneUnselectedColor: Color;
	NoCollisionColor: Color;
	COMRenderColor: Color;
	COMRenderSize: number;
	InfluenceLineLength: number;
	BoneUnselectedMaterial: MaterialInterface;
	BoneNoCollisionMaterial: MaterialInterface;
	HiddenBodies: number[];
	HiddenConstraints: number[];
	clone() : PhysicsAssetRenderSettings;
	static C(Other: UObject | any): PhysicsAssetRenderSettings;
}

declare class PhysicsAssetRenderUtilities extends UObject { 
	IdToSettingsMap: Map<number, PhysicsAssetRenderSettings>;
	BoneUnselectedMaterial: MaterialInterface;
	BoneNoCollisionMaterial: MaterialInterface;
	static Load(ResourceName: string): PhysicsAssetRenderUtilities;
	static Find(Outer: UObject, ResourceName: string): PhysicsAssetRenderUtilities;
	static GetDefaultObject(): PhysicsAssetRenderUtilities;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsAssetRenderUtilities;
	static C(Other: UObject | any): PhysicsAssetRenderUtilities;
}

declare class SkinWeightImportOptions extends UObject { 
	ProfileName: string;
	FilePath: string;
	LODIndex: number;
	static Load(ResourceName: string): SkinWeightImportOptions;
	static Find(Outer: UObject, ResourceName: string): SkinWeightImportOptions;
	static GetDefaultObject(): SkinWeightImportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkinWeightImportOptions;
	static C(Other: UObject | any): SkinWeightImportOptions;
}

declare class SourceCodeAccessSettings extends UObject { 
	PreferredAccessor: string;
	static Load(ResourceName: string): SourceCodeAccessSettings;
	static Find(Outer: UObject, ResourceName: string): SourceCodeAccessSettings;
	static GetDefaultObject(): SourceCodeAccessSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceCodeAccessSettings;
	static C(Other: UObject | any): SourceCodeAccessSettings;
}

declare class LandscapeBlueprintBrush extends LandscapeBlueprintBrushBase { 
	static GetDefaultObject(): LandscapeBlueprintBrush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeBlueprintBrush;
	static C(Other: UObject | any): LandscapeBlueprintBrush;
}

declare class PropertyViewBase extends Widget { 
	UObject: UObject;
	SoftObjectPath: SoftObjectPath;
	bAutoLoadAsset: boolean;
	OnPropertyChanged: UnrealEngineMulticastDelegate<(PropertyName: string) => void>;
	static Load(ResourceName: string): PropertyViewBase;
	static Find(Outer: UObject, ResourceName: string): PropertyViewBase;
	static GetDefaultObject(): PropertyViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyViewBase;
	SetObject(NewObject: UObject): void;
	GetObject(): UObject;
	static C(Other: UObject | any): PropertyViewBase;
}

declare class DetailsView extends PropertyViewBase { 
	bAllowFiltering: boolean;
	bAllowFavoriteSystem: boolean;
	bShowModifiedPropertiesOption: boolean;
	bShowKeyablePropertiesOption: boolean;
	bShowAnimatedPropertiesOption: boolean;
	ColumnWidth: number;
	bShowScrollBar: boolean;
	bForceHiddenPropertyVisibility: boolean;
	ViewIdentifier: string;
	CategoriesToShow: string[];
	PropertiesToShow: string[];
	bShowOnlyAllowed: boolean;
	static Load(ResourceName: string): DetailsView;
	static Find(Outer: UObject, ResourceName: string): DetailsView;
	static GetDefaultObject(): DetailsView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetailsView;
	static C(Other: UObject | any): DetailsView;
}

declare class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateDragDropOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDragDropOperation;
	static GetDefaultObject(): K2Node_CreateDragDropOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDragDropOperation;
	static C(Other: UObject | any): K2Node_CreateDragDropOperation;
}

declare class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateWidget;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateWidget;
	static GetDefaultObject(): K2Node_CreateWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateWidget;
	static C(Other: UObject | any): K2Node_CreateWidget;
}

declare class K2Node_PlayAnimation extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_PlayAnimation;
	static Find(Outer: UObject, ResourceName: string): K2Node_PlayAnimation;
	static GetDefaultObject(): K2Node_PlayAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PlayAnimation;
	static C(Other: UObject | any): K2Node_PlayAnimation;
}

declare class K2Node_PlayAnimationTimeRange extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_PlayAnimationTimeRange;
	static Find(Outer: UObject, ResourceName: string): K2Node_PlayAnimationTimeRange;
	static GetDefaultObject(): K2Node_PlayAnimationTimeRange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PlayAnimationTimeRange;
	static C(Other: UObject | any): K2Node_PlayAnimationTimeRange;
}

declare class EditorPropertyPathSegment { 
	struct: Struct;
	MemberName: string;
	MemberGuid: Guid;
	IsProperty: boolean;
	clone() : EditorPropertyPathSegment;
	static C(Other: UObject | any): EditorPropertyPathSegment;
}

declare class EditorPropertyPath { 
	Segments: EditorPropertyPathSegment[];
	clone() : EditorPropertyPath;
	static C(Other: UObject | any): EditorPropertyPath;
}

declare class DelegateEditorBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourceProperty: string;
	SourcePath: EditorPropertyPath;
	MemberGuid: Guid;
	Kind: EBindingKind;
	clone() : DelegateEditorBinding;
	static C(Other: UObject | any): DelegateEditorBinding;
}

declare class WidgetAnimation_DEPRECATED { 
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	clone() : WidgetAnimation_DEPRECATED;
	static C(Other: UObject | any): WidgetAnimation_DEPRECATED;
}

declare type EWidgetCompileTimeTickPrediction = 'WontTick' | 'OnDemand' | 'WillTick' | 'EWidgetCompileTimeTickPrediction_MAX';
declare var EWidgetCompileTimeTickPrediction : { WontTick:'WontTick',OnDemand:'OnDemand',WillTick:'WillTick',EWidgetCompileTimeTickPrediction_MAX:'EWidgetCompileTimeTickPrediction_MAX', };
declare type EThumbnailPreviewSizeMode = 'MatchDesignerMode' | 'FillScreen' | 'Custom' | 'Desired' | 'EThumbnailPreviewSizeMode_MAX';
declare var EThumbnailPreviewSizeMode : { MatchDesignerMode:'MatchDesignerMode',FillScreen:'FillScreen',Custom:'Custom',Desired:'Desired',EThumbnailPreviewSizeMode_MAX:'EThumbnailPreviewSizeMode_MAX', };
declare class WidgetBlueprint extends BaseWidgetBlueprint { 
	Bindings: DelegateEditorBinding[];
	AnimationData: WidgetAnimation_DEPRECATED[];
	Animations: WidgetAnimation[];
	PaletteCategory: string;
	TickFrequency: EWidgetTickFrequency;
	TickPrediction: EWidgetCompileTimeTickPrediction;
	TickPredictionReason: string;
	PropertyBindings: number;
	ThumbnailSizeMode: EThumbnailPreviewSizeMode;
	ThumbnailCustomSize: Vector2D;
	ThumbnailImage: Texture2D;
	static Load(ResourceName: string): WidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprint;
	static GetDefaultObject(): WidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprint;
	static C(Other: UObject | any): WidgetBlueprint;
}

declare class K2Node_WidgetAnimationEvent extends K2Node_Event { 
	Action: EWidgetAnimationEvent;
	AnimationPropertyName: string;
	UserTag: string;
	SourceWidgetBlueprint: WidgetBlueprint;
	static Load(ResourceName: string): K2Node_WidgetAnimationEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_WidgetAnimationEvent;
	static GetDefaultObject(): K2Node_WidgetAnimationEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_WidgetAnimationEvent;
	static C(Other: UObject | any): K2Node_WidgetAnimationEvent;
}

declare class SinglePropertyView extends PropertyViewBase { 
	PropertyName: string;
	NameOverride: string;
	static Load(ResourceName: string): SinglePropertyView;
	static Find(Outer: UObject, ResourceName: string): SinglePropertyView;
	static GetDefaultObject(): SinglePropertyView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SinglePropertyView;
	SetPropertyName(NewPropertyName: string): void;
	SetNameOverride(NewPropertyName: string): void;
	GetPropertyName(): string;
	GetNameOverride(): string;
	static C(Other: UObject | any): SinglePropertyView;
}

declare class SlateVectorArtDataFactory extends Factory { 
	static Load(ResourceName: string): SlateVectorArtDataFactory;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtDataFactory;
	static GetDefaultObject(): SlateVectorArtDataFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtDataFactory;
	static C(Other: UObject | any): SlateVectorArtDataFactory;
}

declare type EPropertyBindingPermissionLevel = 'Allow' | 'Prevent' | 'PreventAndWarn' | 'PreventAndError' | 'EPropertyBindingPermissionLevel_MAX';
declare var EPropertyBindingPermissionLevel : { Allow:'Allow',Prevent:'Prevent',PreventAndWarn:'PreventAndWarn',PreventAndError:'PreventAndError',EPropertyBindingPermissionLevel_MAX:'EPropertyBindingPermissionLevel_MAX', };
declare class WidgetCompilerOptions { 
	bAllowBlueprintTick: boolean;
	bAllowBlueprintPaint: boolean;
	PropertyBindingRule: EPropertyBindingPermissionLevel;
	Rules: Class[];
	clone() : WidgetCompilerOptions;
	static C(Other: UObject | any): WidgetCompilerOptions;
}

declare class DirectoryWidgetCompilerOptions { 
	Directory: DirectoryPath;
	IgnoredWidgets: WidgetBlueprint[];
	Options: WidgetCompilerOptions;
	clone() : DirectoryWidgetCompilerOptions;
	static C(Other: UObject | any): DirectoryWidgetCompilerOptions;
}

declare class DebugResolution { 
	Width: number;
	Height: number;
	Description: string;
	Color: LinearColor;
	clone() : DebugResolution;
	static C(Other: UObject | any): DebugResolution;
}

declare class UMGEditorProjectSettings extends DeveloperSettings { 
	DefaultCompilerOptions: WidgetCompilerOptions;
	DirectoryCompilerOptions: DirectoryWidgetCompilerOptions[];
	bShowWidgetsFromEngineContent: boolean;
	bShowWidgetsFromDeveloperContent: boolean;
	CategoriesToHide: string[];
	WidgetClassesToHide: SoftClassPath[];
	bUseWidgetTemplateSelector: boolean;
	DefaultRootWidget: UnrealEngineClass;
	bGraphEditorHidden: boolean;
	bHideWidgetAnimationEditor: boolean;
	bUseEditorConfigPaletteFiltering: boolean;
	DefaultWidgetParentClass: Class;
	DebugResolutions: DebugResolution[];
	Version: number;
	static Load(ResourceName: string): UMGEditorProjectSettings;
	static Find(Outer: UObject, ResourceName: string): UMGEditorProjectSettings;
	static GetDefaultObject(): UMGEditorProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGEditorProjectSettings;
	static C(Other: UObject | any): UMGEditorProjectSettings;
}

declare class WidgetBlueprintExtension extends BlueprintExtension { 
	static Load(ResourceName: string): WidgetBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintExtension;
	static GetDefaultObject(): WidgetBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintExtension;
	static C(Other: UObject | any): WidgetBlueprintExtension;
}

declare class WidgetBlueprintFactory extends Factory { 
	BlueprintType: EBlueprintType;
	ParentClass: UnrealEngineClass;
	RootWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): WidgetBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintFactory;
	static GetDefaultObject(): WidgetBlueprintFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintFactory;
	static C(Other: UObject | any): WidgetBlueprintFactory;
}

declare class WidgetBlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): WidgetBlueprintThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintThumbnailRenderer;
	static GetDefaultObject(): WidgetBlueprintThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintThumbnailRenderer;
	static C(Other: UObject | any): WidgetBlueprintThumbnailRenderer;
}

declare class WidgetBlueprintToolMenuContext extends UObject { 
	static Load(ResourceName: string): WidgetBlueprintToolMenuContext;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintToolMenuContext;
	static GetDefaultObject(): WidgetBlueprintToolMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintToolMenuContext;
	static C(Other: UObject | any): WidgetBlueprintToolMenuContext;
}

declare class WidgetCompilerRule extends UObject { 
	static Load(ResourceName: string): WidgetCompilerRule;
	static Find(Outer: UObject, ResourceName: string): WidgetCompilerRule;
	static GetDefaultObject(): WidgetCompilerRule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetCompilerRule;
	static C(Other: UObject | any): WidgetCompilerRule;
}

declare type EDisplayOnCompile = 'DoC_ErrorsOrWarnings' | 'DoC_ErrorsOnly' | 'DoC_WarningsOnly' | 'DoC_Never' | 'DoC_MAX';
declare var EDisplayOnCompile : { DoC_ErrorsOrWarnings:'DoC_ErrorsOrWarnings',DoC_ErrorsOnly:'DoC_ErrorsOnly',DoC_WarningsOnly:'DoC_WarningsOnly',DoC_Never:'DoC_Never',DoC_MAX:'DoC_MAX', };
declare class WidgetPaletteFavorites extends UObject { 
	Favorites: string[];
	static Load(ResourceName: string): WidgetPaletteFavorites;
	static Find(Outer: UObject, ResourceName: string): WidgetPaletteFavorites;
	static GetDefaultObject(): WidgetPaletteFavorites;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetPaletteFavorites;
	static C(Other: UObject | any): WidgetPaletteFavorites;
}

declare class WidgetDesignerSettings extends DeveloperSettings { 
	GridSnapEnabled: boolean;
	GridSnapSize: number;
	bLockToPanelOnDragByDefault: boolean;
	bShowOutlines: boolean;
	bExecutePreConstructEvent: boolean;
	bRespectLocks: boolean;
	CreateOnCompile: EDisplayOnCompile;
	DismissOnCompile: EDisplayOnCompile;
	Favorites: WidgetPaletteFavorites;
	static Load(ResourceName: string): WidgetDesignerSettings;
	static Find(Outer: UObject, ResourceName: string): WidgetDesignerSettings;
	static GetDefaultObject(): WidgetDesignerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetDesignerSettings;
	static C(Other: UObject | any): WidgetDesignerSettings;
}

declare class WidgetEditorModeUISubsystem extends AssetEditorUISubsystem { 
	static Load(ResourceName: string): WidgetEditorModeUISubsystem;
	static Find(Outer: UObject, ResourceName: string): WidgetEditorModeUISubsystem;
	static GetDefaultObject(): WidgetEditorModeUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetEditorModeUISubsystem;
	static C(Other: UObject | any): WidgetEditorModeUISubsystem;
}

declare class WidgetGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): WidgetGraphSchema;
	static Find(Outer: UObject, ResourceName: string): WidgetGraphSchema;
	static GetDefaultObject(): WidgetGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetGraphSchema;
	static C(Other: UObject | any): WidgetGraphSchema;
}

declare class WidgetSlotPair extends UObject { 
	WidgetName: string;
	SlotPropertyNames: string[];
	SlotPropertyValues: string[];
	static Load(ResourceName: string): WidgetSlotPair;
	static Find(Outer: UObject, ResourceName: string): WidgetSlotPair;
	static GetDefaultObject(): WidgetSlotPair;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSlotPair;
	static C(Other: UObject | any): WidgetSlotPair;
}

declare class AutomationTestExcludelistEntry { 
	Map: string;
	Test: string;
	Reason: string;
	RHIs: Set<string>;
	Warn: boolean;
	clone() : AutomationTestExcludelistEntry;
	static C(Other: UObject | any): AutomationTestExcludelistEntry;
}

declare class AutomationTestExcludelist extends UObject { 
	ExcludeTest: AutomationTestExcludelistEntry[];
	static Load(ResourceName: string): AutomationTestExcludelist;
	static Find(Outer: UObject, ResourceName: string): AutomationTestExcludelist;
	static GetDefaultObject(): AutomationTestExcludelist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationTestExcludelist;
	static C(Other: UObject | any): AutomationTestExcludelist;
}

declare class AutomatedTestFilter { 
	Contains: string;
	MatchFromStart: boolean;
	MatchFromEnd: boolean;
	clone() : AutomatedTestFilter;
	static C(Other: UObject | any): AutomatedTestFilter;
}

declare class AutomatedTestGroup { 
	Name: string;
	Filters: AutomatedTestFilter[];
	clone() : AutomatedTestGroup;
	static C(Other: UObject | any): AutomatedTestGroup;
}

declare class AutomationControllerSettings extends UObject { 
	Groups: AutomatedTestGroup[];
	bSuppressLogErrors: boolean;
	bSuppressLogWarnings: boolean;
	bElevateLogWarningsToErrors: boolean;
	SuppressedLogCategories: string[];
	bKeepPIEOpen: boolean;
	bTreatLogWarningsAsTestErrors: boolean;
	CheckTestIntervalSeconds: number;
	GameInstanceLostTimerSeconds: number;
	TelemetryDirectory: string;
	bResetTelemetryStorageOnNewSession: boolean;
	static Load(ResourceName: string): AutomationControllerSettings;
	static Find(Outer: UObject, ResourceName: string): AutomationControllerSettings;
	static GetDefaultObject(): AutomationControllerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationControllerSettings;
	static C(Other: UObject | any): AutomationControllerSettings;
}

declare class AutomationEditorTask extends UObject { 
	static Load(ResourceName: string): AutomationEditorTask;
	static Find(Outer: UObject, ResourceName: string): AutomationEditorTask;
	static GetDefaultObject(): AutomationEditorTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationEditorTask;
	IsValidTask(): boolean;
	IsTaskDone(): boolean;
	static C(Other: UObject | any): AutomationEditorTask;
}

declare class AutomationBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AutomationBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): AutomationBlueprintFunctionLibrary;
	static GetDefaultObject(): AutomationBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationBlueprintFunctionLibrary;
	static TakeHighResScreenshot(ResX: number,ResY: number,Filename: string,Camera: CameraActor,bMaskEnabled: boolean,bCaptureHDR: boolean,ComparisonTolerance: EComparisonTolerance,ComparisonNotes: string,Delay: number): AutomationEditorTask;
	static TakeAutomationScreenshotOfUI(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotAtCamera(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshot(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static SetTestTelemetryStorage(StorageName: string): void;
	static SetScalabilityQualityToLow(WorldContextObject: UObject): void;
	static SetScalabilityQualityToEpic(WorldContextObject: UObject): void;
	static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: UObject,Value: number): void;
	static SetEditorViewportVisualizeBuffer(BufferName: string): void;
	static SetEditorViewportViewMode(Index: EViewModeIndex): void;
	static GetStatIncMax(StatName: string): number;
	static GetStatIncAverage(StatName: string): number;
	static GetStatExcMax(StatName: string): number;
	static GetStatExcAverage(StatName: string): number;
	static GetStatCallCount(StatName: string): number;
	static GetDefaultScreenshotOptionsForRendering(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForGameplay(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
	static FinishLoadingBeforeScreenshot(): void;
	static EnableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static DisableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static CompareImageAgainstReference(ImageFilePath: string,ComparisonName: string,ComparisonTolerance: EComparisonTolerance,ComparisonNotes: string,WorldContextObject: UObject): boolean;
	static AutomationWaitForLoading(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	static AreAutomatedTestsRunning(): boolean;
	static AddTestTelemetryData(DataPoint: string,Measurement: number,Context: string): void;
	static AddExpectedLogError(ExpectedPatternString: string,Occurrences: number,ExactMatch: boolean): void;
	static C(Other: UObject | any): AutomationBlueprintFunctionLibrary;
}

declare class FuncTestRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): FuncTestRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): FuncTestRenderingComponent;
	static GetDefaultObject(): FuncTestRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FuncTestRenderingComponent;
	static C(Other: UObject | any): FuncTestRenderingComponent;
}

declare type EFunctionalTestLogHandling = 'ProjectDefault' | 'OutputIsError' | 'OutputIgnored' | 'EFunctionalTestLogHandling_MAX';
declare var EFunctionalTestLogHandling : { ProjectDefault:'ProjectDefault',OutputIsError:'OutputIsError',OutputIgnored:'OutputIgnored',EFunctionalTestLogHandling_MAX:'EFunctionalTestLogHandling_MAX', };
declare type EFunctionalTestResult = 'Default' | 'Invalid' | 'Error' | 'Running' | 'Failed' | 'Succeeded' | 'EFunctionalTestResult_MAX';
declare var EFunctionalTestResult : { Default:'Default',Invalid:'Invalid',Error:'Error',Running:'Running',Failed:'Failed',Succeeded:'Succeeded',EFunctionalTestResult_MAX:'EFunctionalTestResult_MAX', };
declare type EComparisonMethod = 'Equal_To' | 'Not_Equal_To' | 'Greater_Than_Or_Equal_To' | 'Less_Than_Or_Equal_To' | 'Greater_Than' | 'Less_Than' | 'EComparisonMethod_MAX';
declare var EComparisonMethod : { Equal_To:'Equal_To',Not_Equal_To:'Not_Equal_To',Greater_Than_Or_Equal_To:'Greater_Than_Or_Equal_To',Less_Than_Or_Equal_To:'Less_Than_Or_Equal_To',Greater_Than:'Greater_Than',Less_Than:'Less_Than',EComparisonMethod_MAX:'EComparisonMethod_MAX', };
declare class FunctionalTest extends Actor { 
	TestLabel: string;
	Author: string;
	Description: string;
	SpriteComponent: BillboardComponent;
	bIsEnabled: boolean;
	LogErrorHandling: EFunctionalTestLogHandling;
	LogWarningHandling: EFunctionalTestLogHandling;
	ObservationPoint: Actor;
	RandomNumbersStream: RandomStream;
	Result: EFunctionalTestResult;
	PreparationTimeLimit: number;
	TimeLimit: number;
	TimesUpMessage: string;
	TimesUpResult: EFunctionalTestResult;
	OnTestPrepare: UnrealEngineMulticastDelegate<() => void>;
	OnTestStart: UnrealEngineMulticastDelegate<() => void>;
	OnTestFinished: UnrealEngineMulticastDelegate<() => void>;
	AutoDestroyActors: Actor[];
	RenderComp: FuncTestRenderingComponent;
	TestName: TextRenderComponent;
	bIsRunning: boolean;
	TotalTime: number;
	static GetDefaultObject(): FunctionalTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTest;
	SetTimeLimit(NewTimeLimit: number,ResultWhenTimeRunsOut: EFunctionalTestResult): void;
	RegisterAutoDestroyActor(ActorToAutoDestroy: Actor): void;
	ReceiveStartTest(): void;
	ReceivePrepareTest(): void;
	OnWantsReRunCheck(): boolean;
	OnAdditionalTestFinishedMessageRequest(TestResult: EFunctionalTestResult): string;
	LogMessage(Message: string): void;
	IsRunning(): boolean;
	IsReady(): boolean;
	IsEnabled(): boolean;
	GetCurrentRerunReason(): string;
	FinishTest(TestResult: EFunctionalTestResult,Message: string): void;
	DebugGatherRelevantActors(): Actor[];
	AssertValue_Int(Actual: number,ShouldBe: EComparisonMethod,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertValue_Float(Actual: number,ShouldBe: EComparisonMethod,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertValue_Double(Actual: number,ShouldBe: EComparisonMethod,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertValue_DateTime(Actual: DateTime,ShouldBe: EComparisonMethod,Expected: DateTime,What: string,ContextObject: UObject): boolean;
	AssertTrue(Condition: boolean,Message: string,ContextObject: UObject): boolean;
	AssertNotEqual_Vector4(Actual: Vector4,NotExpected: Vector4,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Vector2D(Actual: Vector2D,NotExpected: Vector2D,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Vector(Actual: Vector,NotExpected: Vector,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Transform(Actual: Transform,NotExpected: Transform,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_String(Actual: string,NotExpected: string,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Rotator(Actual: Rotator,NotExpected: Rotator,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Quat(Actual: Quat,NotExpected: Quat,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Plane(Actual: Plane,NotExpected: Plane,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Matrix(Actual: Matrix,NotExpected: Matrix,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Box2D(Actual: Box2D,NotExpected: Box2D,What: string,ContextObject: UObject): boolean;
	AssertIsValid(UObject: UObject,Message: string,ContextObject: UObject): boolean;
	AssertFalse(Condition: boolean,Message: string,ContextObject: UObject): boolean;
	AssertEqual_Vector4(Actual: Vector4,Expected: Vector4,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Vector2D(Actual: Vector2D,Expected: Vector2D,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Vector(Actual: Vector,Expected: Vector,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Transform(Actual: Transform,Expected: Transform,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_TraceQueryResults(Actual: TraceQueryTestResults,Expected: TraceQueryTestResults,What: string,ContextObject: UObject): boolean;
	AssertEqual_String(Actual: string,Expected: string,What: string,ContextObject: UObject): boolean;
	AssertEqual_Rotator(Actual: Rotator,Expected: Rotator,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Quat(Actual: Quat,Expected: Quat,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Plane(Actual: Plane,Expected: Plane,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Object(Actual: UObject,Expected: UObject,What: string,ContextObject: UObject): boolean;
	AssertEqual_Name(Actual: string,Expected: string,What: string,ContextObject: UObject): boolean;
	AssertEqual_Matrix(Actual: Matrix,Expected: Matrix,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Int(Actual: number,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertEqual_Float(Actual: number,Expected: number,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Double(Actual: number,Expected: number,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Box2D(Actual: Box2D,Expected: Box2D,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Bool(Actual: boolean,Expected: boolean,What: string,ContextObject: UObject): boolean;
	AddWarning(Message: string): void;
	AddRerun(Reason: string): void;
	AddError(Message: string): void;
	static C(Other: UObject | any): FunctionalTest;
}

declare class PendingDelayedSpawn { 
	clone() : PendingDelayedSpawn;
	static C(Other: UObject | any): PendingDelayedSpawn;
}

declare class FunctionalAITestBase extends FunctionalTest { 
	SpawnLocationRandomizationRange: number;
	SpawnedPawns: Pawn[];
	PendingDelayedSpawns: PendingDelayedSpawn[];
	CurrentSpawnSetIndex: number;
	CurrentSpawnSetName: string;
	OnAISpawned: UnrealEngineMulticastDelegate<(Controller: AIController, Pawn: Pawn) => void>;
	OnAllAISPawned: UnrealEngineMulticastDelegate<() => void>;
	NavMeshDebugOrigin: Vector;
	NavMeshDebugExtent: Vector;
	bWaitForNavMesh: boolean;
	bDebugNavMeshOnTimeout: boolean;
	static GetDefaultObject(): FunctionalAITestBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalAITestBase;
	IsOneOfSpawnedPawns(Actor: Actor): boolean;
	static C(Other: UObject | any): FunctionalAITestBase;
}

declare class AITestSpawnSetBase { 
	Name: string;
	bEnabled: boolean;
	FallbackSpawnLocation: Actor;
	clone() : AITestSpawnSetBase;
	static C(Other: UObject | any): AITestSpawnSetBase;
}

declare class AITestSpawnInfoBase { 
	SpawnLocation: Actor;
	NumberToSpawn: number;
	SpawnDelay: number;
	PreSpawnDelay: number;
	clone() : AITestSpawnInfoBase;
	static C(Other: UObject | any): AITestSpawnInfoBase;
}

declare class GenericTeamId { 
	TeamID: number;
	clone() : GenericTeamId;
	static C(Other: UObject | any): GenericTeamId;
}

declare class AITestSpawnInfo extends AITestSpawnInfoBase { 
	PawnClass: UnrealEngineClass;
	ControllerClass: UnrealEngineClass;
	TeamID: GenericTeamId;
	BehaviorTree: BehaviorTree;
	clone() : AITestSpawnInfo;
	static C(Other: UObject | any): AITestSpawnInfo;
}

declare class AITestSpawnSet extends AITestSpawnSetBase { 
	SpawnInfoContainer: AITestSpawnInfo[];
	clone() : AITestSpawnSet;
	static C(Other: UObject | any): AITestSpawnSet;
}

declare class FunctionalAITest extends FunctionalAITestBase { 
	SpawnSets: AITestSpawnSet[];
	static GetDefaultObject(): FunctionalAITest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalAITest;
	static C(Other: UObject | any): FunctionalAITest;
}

declare class AutomationPerformaceHelper extends UObject { 
	static Load(ResourceName: string): AutomationPerformaceHelper;
	static Find(Outer: UObject, ResourceName: string): AutomationPerformaceHelper;
	static GetDefaultObject(): AutomationPerformaceHelper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationPerformaceHelper;
	WriteLogFile(CaptureDir: string,CaptureExtension: string): void;
	TriggerGPUTraceIfRecordFallsBelowBudget(): void;
	Tick(DeltaSeconds: number): void;
	StopCPUProfiling(): void;
	StartCPUProfiling(): void;
	Sample(DeltaSeconds: number): void;
	OnBeginTests(): void;
	OnAllTestsComplete(): void;
	IsRecording(): boolean;
	IsCurrentRecordWithinRenderThreadBudget(): boolean;
	IsCurrentRecordWithinGPUBudget(): boolean;
	IsCurrentRecordWithinGameThreadBudget(): boolean;
	EndStatsFile(): void;
	EndRecordingBaseline(): void;
	EndRecording(): void;
	BeginStatsFile(RecordName: string): void;
	BeginRecordingBaseline(RecordName: string): void;
	BeginRecording(RecordName: string,InGPUBudget: number,InRenderThreadBudget: number,InGameThreadBudget: number): void;
	static C(Other: UObject | any): AutomationPerformaceHelper;
}

declare class FunctionalTestGameMode extends GameModeBase { 
	static GetDefaultObject(): FunctionalTestGameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestGameMode;
	static C(Other: UObject | any): FunctionalTestGameMode;
}

declare class FunctionalTestingManager extends BlueprintFunctionLibrary { 
	TestsLeft: FunctionalTest[];
	AllTests: FunctionalTest[];
	OnSetupTests: UnrealEngineMulticastDelegate<() => void>;
	OnTestsComplete: UnrealEngineMulticastDelegate<() => void>;
	OnTestsBegin: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): FunctionalTestingManager;
	static Find(Outer: UObject, ResourceName: string): FunctionalTestingManager;
	static GetDefaultObject(): FunctionalTestingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestingManager;
	static RunAllFunctionalTests(WorldContextObject: UObject,bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	static C(Other: UObject | any): FunctionalTestingManager;
}

declare class PhasedAutomationActorBase extends Actor { 
	static GetDefaultObject(): PhasedAutomationActorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhasedAutomationActorBase;
	OnFunctionalTestingComplete(): void;
	OnFunctionalTestingBegin(): void;
	static C(Other: UObject | any): PhasedAutomationActorBase;
}

declare class FunctionalTestLevelScript extends LevelScriptActor { 
	static GetDefaultObject(): FunctionalTestLevelScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestLevelScript;
	static C(Other: UObject | any): FunctionalTestLevelScript;
}

declare class FunctionalTestUtilityLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): FunctionalTestUtilityLibrary;
	static Find(Outer: UObject, ResourceName: string): FunctionalTestUtilityLibrary;
	static GetDefaultObject(): FunctionalTestUtilityLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestUtilityLibrary;
	static TraceChannelTestUtil(WorldContextObject: UObject,BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	static C(Other: UObject | any): FunctionalTestUtilityLibrary;
}

declare class ScreenshotFunctionalTestBase extends FunctionalTest { 
	Notes: string;
	ScreenshotCamera: CameraComponent;
	ScreenshotOptions: AutomationScreenshotOptions;
	static GetDefaultObject(): ScreenshotFunctionalTestBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScreenshotFunctionalTestBase;
	static C(Other: UObject | any): ScreenshotFunctionalTestBase;
}

declare type EWidgetTestAppearLocation = 'Viewport' | 'PlayerScreen' | 'EWidgetTestAppearLocation_MAX';
declare var EWidgetTestAppearLocation : { Viewport:'Viewport',PlayerScreen:'PlayerScreen',EWidgetTestAppearLocation_MAX:'EWidgetTestAppearLocation_MAX', };
declare class FunctionalUIScreenshotTest extends ScreenshotFunctionalTestBase { 
	WidgetClass: UnrealEngineClass;
	SpawnedWidget: UserWidget;
	WidgetLocation: EWidgetTestAppearLocation;
	ScreenshotRT: TextureRenderTarget2D;
	bHideDebugCanvas: boolean;
	static GetDefaultObject(): FunctionalUIScreenshotTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalUIScreenshotTest;
	static C(Other: UObject | any): FunctionalUIScreenshotTest;
}

declare class GroundTruthData extends UObject { 
	bResetGroundTruth: boolean;
	ObjectData: UObject;
	static Load(ResourceName: string): GroundTruthData;
	static Find(Outer: UObject, ResourceName: string): GroundTruthData;
	static GetDefaultObject(): GroundTruthData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroundTruthData;
	SaveObject(GroundTruth: UObject): void;
	LoadObject(): UObject;
	CanModify(): boolean;
	static C(Other: UObject | any): GroundTruthData;
}

declare class ScreenshotFunctionalTest extends ScreenshotFunctionalTestBase { 
	bCameraCutOnScreenshotPrep: boolean;
	static GetDefaultObject(): ScreenshotFunctionalTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScreenshotFunctionalTest;
	static C(Other: UObject | any): ScreenshotFunctionalTest;
}

declare class TestPhaseComponent extends SceneComponent { 
	static Load(ResourceName: string): TestPhaseComponent;
	static Find(Outer: UObject, ResourceName: string): TestPhaseComponent;
	static GetDefaultObject(): TestPhaseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestPhaseComponent;
	static C(Other: UObject | any): TestPhaseComponent;
}

declare class AIGraph extends EdGraph { 
	GraphVersion: number;
	static Load(ResourceName: string): AIGraph;
	static Find(Outer: UObject, ResourceName: string): AIGraph;
	static GetDefaultObject(): AIGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraph;
	static C(Other: UObject | any): AIGraph;
}

declare class GraphNodeClassData { 
	AssetName: string;
	GeneratedClassPackage: string;
	ClassName: string;
	Category: string;
	clone() : GraphNodeClassData;
	static C(Other: UObject | any): GraphNodeClassData;
}

declare class AIGraphNode extends EdGraphNode { 
	ClassData: GraphNodeClassData;
	NodeInstance: UObject;
	ParentNode: AIGraphNode;
	SubNodes: AIGraphNode[];
	CopySubNodeIndex: number;
	bIsReadOnly: boolean;
	bIsSubNode: boolean;
	ErrorMessage: string;
	static Load(ResourceName: string): AIGraphNode;
	static Find(Outer: UObject, ResourceName: string): AIGraphNode;
	static GetDefaultObject(): AIGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphNode;
	static C(Other: UObject | any): AIGraphNode;
}

declare class AIGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): AIGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AIGraphSchema;
	static GetDefaultObject(): AIGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphSchema;
	static C(Other: UObject | any): AIGraphSchema;
}

declare class K2Node_AIMoveTo extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_AIMoveTo;
	static Find(Outer: UObject, ResourceName: string): K2Node_AIMoveTo;
	static GetDefaultObject(): K2Node_AIMoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AIMoveTo;
	static C(Other: UObject | any): K2Node_AIMoveTo;
}

declare class BehaviorTreeDecoratorGraph extends EdGraph { 
	static Load(ResourceName: string): BehaviorTreeDecoratorGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraph;
	static GetDefaultObject(): BehaviorTreeDecoratorGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraph;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraph;
}

declare class BehaviorTreeDecoratorGraphNode extends EdGraphNode { 
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode;
}

declare class BehaviorTreeDecoratorGraphNode_Decorator extends BehaviorTreeDecoratorGraphNode { 
	NodeInstance: UObject;
	ClassData: GraphNodeClassData;
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Decorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Decorator;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode_Decorator;
}

declare type EDecoratorLogicMode = 'Sink' | 'And' | 'Or' | 'Not' | 'EDecoratorLogicMode_MAX';
declare var EDecoratorLogicMode : { Sink:'Sink',And:'And',Or:'Or',Not:'Not',EDecoratorLogicMode_MAX:'EDecoratorLogicMode_MAX', };
declare class BehaviorTreeDecoratorGraphNode_Logic extends BehaviorTreeDecoratorGraphNode { 
	LogicMode: EDecoratorLogicMode;
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Logic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Logic;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode_Logic;
}

declare class BehaviorTreeEditorTypes extends UObject { 
	static Load(ResourceName: string): BehaviorTreeEditorTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeEditorTypes;
	static GetDefaultObject(): BehaviorTreeEditorTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeEditorTypes;
	static C(Other: UObject | any): BehaviorTreeEditorTypes;
}

declare class BehaviorTreeFactory extends Factory { 
	static Load(ResourceName: string): BehaviorTreeFactory;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeFactory;
	static GetDefaultObject(): BehaviorTreeFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeFactory;
	static C(Other: UObject | any): BehaviorTreeFactory;
}

declare class BehaviorTreeGraph extends AIGraph { 
	ModCounter: number;
	bIsUsingModCounter: boolean;
	static Load(ResourceName: string): BehaviorTreeGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraph;
	static GetDefaultObject(): BehaviorTreeGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraph;
	static C(Other: UObject | any): BehaviorTreeGraph;
}

declare class BehaviorTreeGraphNode extends AIGraphNode { 
	Decorators: BehaviorTreeGraphNode[];
	Services: BehaviorTreeGraphNode[];
	bInjectedNode: boolean;
	static Load(ResourceName: string): BehaviorTreeGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode;
	static GetDefaultObject(): BehaviorTreeGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode;
	static C(Other: UObject | any): BehaviorTreeGraphNode;
}

declare class BehaviorTreeGraphNode_Composite extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Composite;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Composite;
	static GetDefaultObject(): BehaviorTreeGraphNode_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Composite;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Composite;
}

declare class BehaviorTreeGraphNode_CompositeDecorator extends BehaviorTreeGraphNode { 
	BoundGraph: EdGraph;
	CompositeName: string;
	bShowOperations: boolean;
	bCanAbortFlow: boolean;
	ParentNodeInstance: BTCompositeNode;
	CachedDescription: string;
	static Load(ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static GetDefaultObject(): BehaviorTreeGraphNode_CompositeDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_CompositeDecorator;
	static C(Other: UObject | any): BehaviorTreeGraphNode_CompositeDecorator;
}

declare class BehaviorTreeGraphNode_Decorator extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static GetDefaultObject(): BehaviorTreeGraphNode_Decorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Decorator;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Decorator;
}

declare class BehaviorTreeGraphNode_Root extends BehaviorTreeGraphNode { 
	BlackboardAsset: BlackboardData;
	static Load(ResourceName: string): BehaviorTreeGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Root;
	static GetDefaultObject(): BehaviorTreeGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Root;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Root;
}

declare class BehaviorTreeGraphNode_Service extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Service;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Service;
	static GetDefaultObject(): BehaviorTreeGraphNode_Service;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Service;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Service;
}

declare class BehaviorTreeGraphNode_SimpleParallel extends BehaviorTreeGraphNode_Composite { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static GetDefaultObject(): BehaviorTreeGraphNode_SimpleParallel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SimpleParallel;
	static C(Other: UObject | any): BehaviorTreeGraphNode_SimpleParallel;
}

declare class BehaviorTreeGraphNode_Task extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Task;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Task;
	static GetDefaultObject(): BehaviorTreeGraphNode_Task;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Task;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Task;
}

declare class BehaviorTreeGraphNode_SubtreeTask extends BehaviorTreeGraphNode_Task { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static GetDefaultObject(): BehaviorTreeGraphNode_SubtreeTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SubtreeTask;
	static C(Other: UObject | any): BehaviorTreeGraphNode_SubtreeTask;
}

declare class BlackboardDataFactory extends Factory { 
	static Load(ResourceName: string): BlackboardDataFactory;
	static Find(Outer: UObject, ResourceName: string): BlackboardDataFactory;
	static GetDefaultObject(): BlackboardDataFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardDataFactory;
	static C(Other: UObject | any): BlackboardDataFactory;
}

declare class EdGraphSchema_BehaviorTree extends AIGraphSchema { 
	static Load(ResourceName: string): EdGraphSchema_BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTree;
	static GetDefaultObject(): EdGraphSchema_BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTree;
	static C(Other: UObject | any): EdGraphSchema_BehaviorTree;
}

declare class EdGraphSchema_BehaviorTreeDecorator extends EdGraphSchema { 
	PC_Boolean: string;
	static Load(ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static GetDefaultObject(): EdGraphSchema_BehaviorTreeDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTreeDecorator;
	static C(Other: UObject | any): EdGraphSchema_BehaviorTreeDecorator;
}

declare class K2Node_LatentGameplayTaskCall extends K2Node_BaseAsyncTask { 
	SpawnParamPins: string[];
	static Load(ResourceName: string): K2Node_LatentGameplayTaskCall;
	static Find(Outer: UObject, ResourceName: string): K2Node_LatentGameplayTaskCall;
	static GetDefaultObject(): K2Node_LatentGameplayTaskCall;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LatentGameplayTaskCall;
	static C(Other: UObject | any): K2Node_LatentGameplayTaskCall;
}

declare class Overlays extends UObject { 
	static Load(ResourceName: string): Overlays;
	static Find(Outer: UObject, ResourceName: string): Overlays;
	static GetDefaultObject(): Overlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlays;
	static C(Other: UObject | any): Overlays;
}

declare class OverlayItem { 
	StartTime: Timespan;
	EndTime: Timespan;
	Text: string;
	Position: Vector2D;
	clone() : OverlayItem;
	static C(Other: UObject | any): OverlayItem;
}

declare class BasicOverlays extends Overlays { 
	Overlays: OverlayItem[];
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): BasicOverlays;
	static Find(Outer: UObject, ResourceName: string): BasicOverlays;
	static GetDefaultObject(): BasicOverlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlays;
	static C(Other: UObject | any): BasicOverlays;
}

declare class LocalizedOverlays extends Overlays { 
	DefaultOverlays: BasicOverlays;
	LocaleToOverlaysMap: Map<string, BasicOverlays>;
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): LocalizedOverlays;
	static Find(Outer: UObject, ResourceName: string): LocalizedOverlays;
	static GetDefaultObject(): LocalizedOverlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizedOverlays;
	static C(Other: UObject | any): LocalizedOverlays;
}

declare class BasicOverlaysFactory extends Factory { 
	static Load(ResourceName: string): BasicOverlaysFactory;
	static Find(Outer: UObject, ResourceName: string): BasicOverlaysFactory;
	static GetDefaultObject(): BasicOverlaysFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlaysFactory;
	static C(Other: UObject | any): BasicOverlaysFactory;
}

declare class BasicOverlaysFactoryNew extends Factory { 
	static Load(ResourceName: string): BasicOverlaysFactoryNew;
	static Find(Outer: UObject, ResourceName: string): BasicOverlaysFactoryNew;
	static GetDefaultObject(): BasicOverlaysFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlaysFactoryNew;
	static C(Other: UObject | any): BasicOverlaysFactoryNew;
}

declare class LocalizedOverlaysFactoryNew extends Factory { 
	static Load(ResourceName: string): LocalizedOverlaysFactoryNew;
	static Find(Outer: UObject, ResourceName: string): LocalizedOverlaysFactoryNew;
	static GetDefaultObject(): LocalizedOverlaysFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizedOverlaysFactoryNew;
	static C(Other: UObject | any): LocalizedOverlaysFactoryNew;
}

declare class ReimportBasicOverlaysFactory extends BasicOverlaysFactory { 
	static Load(ResourceName: string): ReimportBasicOverlaysFactory;
	static Find(Outer: UObject, ResourceName: string): ReimportBasicOverlaysFactory;
	static GetDefaultObject(): ReimportBasicOverlaysFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportBasicOverlaysFactory;
	static C(Other: UObject | any): ReimportBasicOverlaysFactory;
}

declare type EClothingWindMethodNv = 'Legacy' | 'Accurate' | 'EClothingWindMethodNv_MAX';
declare var EClothingWindMethodNv : { Legacy:'Legacy',Accurate:'Accurate',EClothingWindMethodNv_MAX:'EClothingWindMethodNv_MAX', };
declare class ClothConstraintSetupNv { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetupNv;
	static C(Other: UObject | any): ClothConstraintSetupNv;
}

declare class ClothConfigNv extends ClothConfigCommon { 
	ClothingWindMethod: EClothingWindMethodNv;
	VerticalConstraint: ClothConstraintSetupNv;
	HorizontalConstraint: ClothConstraintSetupNv;
	BendConstraint: ClothConstraintSetupNv;
	ShearConstraint: ClothConstraintSetupNv;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	GravityOverride: Vector;
	bUseGravityOverride: boolean;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	AnimDriveSpringStiffness: number;
	AnimDriveDamperStiffness: number;
	WindMethod: EClothingWindMethod_Legacy;
	VerticalConstraintConfig: ClothConstraintSetup_Legacy;
	HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
	BendConstraintConfig: ClothConstraintSetup_Legacy;
	ShearConstraintConfig: ClothConstraintSetup_Legacy;
	static Load(ResourceName: string): ClothConfigNv;
	static Find(Outer: UObject, ResourceName: string): ClothConfigNv;
	static GetDefaultObject(): ClothConfigNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigNv;
	static C(Other: UObject | any): ClothConfigNv;
}

declare class ClothingSimulationFactoryNv extends ClothingSimulationFactory { 
	static Load(ResourceName: string): ClothingSimulationFactoryNv;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationFactoryNv;
	static GetDefaultObject(): ClothingSimulationFactoryNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationFactoryNv;
	static C(Other: UObject | any): ClothingSimulationFactoryNv;
}

declare class ClothingSimulationInteractorNv extends ClothingSimulationInteractor { 
	static Load(ResourceName: string): ClothingSimulationInteractorNv;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationInteractorNv;
	static GetDefaultObject(): ClothingSimulationInteractorNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationInteractorNv;
	SetAnimDriveDamperStiffness(InStiffness: number): void;
	static C(Other: UObject | any): ClothingSimulationInteractorNv;
}

declare class ClothPhysicalMeshDataNv_Legacy extends ClothPhysicalMeshDataBase_Legacy { 
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	AnimDriveMultipliers: number[];
	static Load(ResourceName: string): ClothPhysicalMeshDataNv_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothPhysicalMeshDataNv_Legacy;
	static GetDefaultObject(): ClothPhysicalMeshDataNv_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothPhysicalMeshDataNv_Legacy;
	static C(Other: UObject | any): ClothPhysicalMeshDataNv_Legacy;
}

declare class ClothingAssetFactory extends ClothingAssetFactoryBase { 
	static Load(ResourceName: string): ClothingAssetFactory;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactory;
	static GetDefaultObject(): ClothingAssetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactory;
	static C(Other: UObject | any): ClothingAssetFactory;
}

declare class AnimDataController extends UObject { 
	Model: AnimDataModel;
	static Load(ResourceName: string): AnimDataController;
	static Find(Outer: UObject, ResourceName: string): AnimDataController;
	static GetDefaultObject(): AnimDataController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimDataController;
	static C(Other: UObject | any): AnimDataController;
}

declare type EAFSActiveType = 'None' | 'USBOnly' | 'NetworkOnly' | 'Combined' | 'EAFSActiveType_MAX';
declare var EAFSActiveType : { None:'None',USBOnly:'USBOnly',NetworkOnly:'NetworkOnly',Combined:'Combined',EAFSActiveType_MAX:'EAFSActiveType_MAX', };
declare class AndroidFileServerBPLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AndroidFileServerBPLibrary;
	static Find(Outer: UObject, ResourceName: string): AndroidFileServerBPLibrary;
	static GetDefaultObject(): AndroidFileServerBPLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AndroidFileServerBPLibrary;
	static StopFileServer(bUSB: boolean,bNetwork: boolean): boolean;
	static StartFileServer(bUSB: boolean,bNetwork: boolean,Port: number): boolean;
	static IsFileServerRunning(): EAFSActiveType;
	static C(Other: UObject | any): AndroidFileServerBPLibrary;
}

declare class BlueprintEnhancedInputActionBinding { 
	InputAction: InputAction;
	TriggerEvent: ETriggerEvent;
	FunctionNameToBind: string;
	clone() : BlueprintEnhancedInputActionBinding;
	static C(Other: UObject | any): BlueprintEnhancedInputActionBinding;
}

declare class EnhancedInputActionDelegateBinding extends InputDelegateBinding { 
	InputActionDelegateBindings: BlueprintEnhancedInputActionBinding[];
	static Load(ResourceName: string): EnhancedInputActionDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputActionDelegateBinding;
	static GetDefaultObject(): EnhancedInputActionDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputActionDelegateBinding;
	static C(Other: UObject | any): EnhancedInputActionDelegateBinding;
}

declare class EnhancedInputActionValueBinding extends InputDelegateBinding { 
	InputActionValueBindings: BlueprintEnhancedInputActionBinding[];
	static Load(ResourceName: string): EnhancedInputActionValueBinding;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputActionValueBinding;
	static GetDefaultObject(): EnhancedInputActionValueBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputActionValueBinding;
	static C(Other: UObject | any): EnhancedInputActionValueBinding;
}

declare class EnhancedInputComponent extends InputComponent { 
	static Load(ResourceName: string): EnhancedInputComponent;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputComponent;
	static GetDefaultObject(): EnhancedInputComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputComponent;
	GetBoundActionValue(Action: InputAction): InputActionValue;
	static C(Other: UObject | any): EnhancedInputComponent;
}

declare class PerPlatformSettings { 
	Settings: PlatformSettings[];
	clone() : PerPlatformSettings;
	static C(Other: UObject | any): PerPlatformSettings;
}

declare class EnhancedInputDeveloperSettings extends DeveloperSettingsBackedByCVars { 
	PlatformSettings: PerPlatformSettings;
	bShouldOnlyTriggerLastActionInChord: boolean;
	static Load(ResourceName: string): EnhancedInputDeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputDeveloperSettings;
	static GetDefaultObject(): EnhancedInputDeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputDeveloperSettings;
	static C(Other: UObject | any): EnhancedInputDeveloperSettings;
}

declare class EnhancedInputLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): EnhancedInputLibrary;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputLibrary;
	static GetDefaultObject(): EnhancedInputLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputLibrary;
	static RequestRebuildControlMappingsUsingContext(Context: InputMappingContext,bForceImmediately: boolean): void;
	static MakeInputActionValueOfType(X: number,Y: number,Z: number,ValueType: EInputActionValueType): InputActionValue;
	static MakeInputActionValue(X: number,Y: number,Z: number,MatchValueType: InputActionValue): InputActionValue;
	static GetBoundActionValue(Actor: Actor,Action: InputAction): InputActionValue;
	static Conv_InputActionValueToString(ActionValue: InputActionValue): string;
	static Conv_InputActionValueToBool(InValue: InputActionValue): boolean;
	static Conv_InputActionValueToAxis3D(ActionValue: InputActionValue): Vector;
	static Conv_InputActionValueToAxis2D(InValue: InputActionValue): Vector2D;
	static Conv_InputActionValueToAxis1D(InValue: InputActionValue): number;
	static BreakInputActionValue(InActionValue: InputActionValue,X?: number,Y?: number,Z?: number,Type?: EInputActionValueType): {X: number, Y: number, Z: number, Type: EInputActionValueType};
	static C(Other: UObject | any): EnhancedInputLibrary;
}

declare class EnhancedInputPlatformData extends UObject { 
	MappingContextRedirects: Map<InputMappingContext, InputMappingContext>;
	static Load(ResourceName: string): EnhancedInputPlatformData;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputPlatformData;
	static GetDefaultObject(): EnhancedInputPlatformData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputPlatformData;
	GetContextRedirect(InContext: InputMappingContext): InputMappingContext;
	static C(Other: UObject | any): EnhancedInputPlatformData;
}

declare class EnhancedInputPlatformSettings extends PlatformSettings { 
	InputData: Class[];
	InputDataClasses: UnrealEngineClass[];
	bShouldLogMappingContextRedirects: boolean;
	static Load(ResourceName: string): EnhancedInputPlatformSettings;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputPlatformSettings;
	static GetDefaultObject(): EnhancedInputPlatformSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputPlatformSettings;
	static C(Other: UObject | any): EnhancedInputPlatformSettings;
}

declare class ModifyContextOptions { 
	bIgnoreAllPressedKeysUntilRelease: boolean;
	bForceImmediately: boolean;
	clone() : ModifyContextOptions;
	static C(Other: UObject | any): ModifyContextOptions;
}

declare type EInputMappingRebuildType = 'None' | 'Rebuild' | 'RebuildWithFlush' | 'EInputMappingRebuildType_MAX';
declare var EInputMappingRebuildType : { None:'None',Rebuild:'Rebuild',RebuildWithFlush:'RebuildWithFlush',EInputMappingRebuildType_MAX:'EInputMappingRebuildType_MAX', };
declare class PlayerMappableInputConfig extends PrimaryDataAsset { 
	ConfigName: string;
	ConfigDisplayName: string;
	bIsDeprecated: boolean;
	MetaData: UObject;
	Contexts: Map<InputMappingContext, number>;
	static Load(ResourceName: string): PlayerMappableInputConfig;
	static Find(Outer: UObject, ResourceName: string): PlayerMappableInputConfig;
	static GetDefaultObject(): PlayerMappableInputConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerMappableInputConfig;
	ResetToDefault(): void;
	IsDeprecated(): boolean;
	GetPlayerMappableKeys(): EnhancedActionKeyMapping[];
	GetMetadata(): UObject;
	GetMappingContexts(): Map<InputMappingContext, number>;
	GetMappingByName(MappingName: string): EnhancedActionKeyMapping;
	GetKeysBoundToAction(InAction: InputAction): EnhancedActionKeyMapping[];
	GetDisplayName(): string;
	GetConfigName(): string;
	static C(Other: UObject | any): PlayerMappableInputConfig;
}

declare type EMappingQueryIssue = 'NoIssue' | 'ReservedByAction' | 'HidesExistingMapping' | 'HiddenByExistingMapping' | 'CollisionWithMappingInSameContext' | 'ForcesTypePromotion' | 'ForcesTypeDemotion' | 'EMappingQueryIssue_MAX';
declare var EMappingQueryIssue : { NoIssue:'NoIssue',ReservedByAction:'ReservedByAction',HidesExistingMapping:'HidesExistingMapping',HiddenByExistingMapping:'HiddenByExistingMapping',CollisionWithMappingInSameContext:'CollisionWithMappingInSameContext',ForcesTypePromotion:'ForcesTypePromotion',ForcesTypeDemotion:'ForcesTypeDemotion',EMappingQueryIssue_MAX:'EMappingQueryIssue_MAX', };
declare class MappingQueryIssue { 
	Issue: EMappingQueryIssue;
	BlockingContext: InputMappingContext;
	BlockingAction: InputAction;
	clone() : MappingQueryIssue;
	static C(Other: UObject | any): MappingQueryIssue;
}

declare type EMappingQueryResult = 'Error_EnhancedInputNotEnabled' | 'Error_InputContextNotInActiveContexts' | 'Error_InvalidAction' | 'NotMappable' | 'MappingAvailable' | 'EMappingQueryResult_MAX';
declare var EMappingQueryResult : { Error_EnhancedInputNotEnabled:'Error_EnhancedInputNotEnabled',Error_InputContextNotInActiveContexts:'Error_InputContextNotInActiveContexts',Error_InvalidAction:'Error_InvalidAction',NotMappable:'NotMappable',MappingAvailable:'MappingAvailable',EMappingQueryResult_MAX:'EMappingQueryResult_MAX', };
declare class EnhancedInputSubsystemInterface extends Interface { 
	static Load(ResourceName: string): EnhancedInputSubsystemInterface;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputSubsystemInterface;
	static GetDefaultObject(): EnhancedInputSubsystemInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputSubsystemInterface;
	RequestRebuildControlMappings(Options: ModifyContextOptions,RebuildType: EInputMappingRebuildType): void;
	RemovePlayerMappedKey(MappingName: string,Options: ModifyContextOptions): number;
	RemovePlayerMappableConfig(Config: PlayerMappableInputConfig,Options: ModifyContextOptions): void;
	RemoveMappingContext(MappingContext: InputMappingContext,Options: ModifyContextOptions): void;
	RemoveAllPlayerMappedKeys(Options: ModifyContextOptions): void;
	QueryMapKeyInContextSet(PrioritizedActiveContexts: InputMappingContext[],InputContext: InputMappingContext,Action: InputAction,Key: Key,OutIssues?: MappingQueryIssue[],BlockingIssues?: EMappingQueryIssue): {OutIssues: MappingQueryIssue[], $: EMappingQueryResult};
	QueryMapKeyInActiveContextSet(InputContext: InputMappingContext,Action: InputAction,Key: Key,OutIssues?: MappingQueryIssue[],BlockingIssues?: EMappingQueryIssue): {OutIssues: MappingQueryIssue[], $: EMappingQueryResult};
	QueryKeysMappedToAction(Action: InputAction): Key[];
	InjectInputVectorForAction(Action: InputAction,Value: Vector,Modifiers: InputModifier[],Triggers: InputTrigger[]): void;
	InjectInputForAction(Action: InputAction,RawValue: InputActionValue,Modifiers: InputModifier[],Triggers: InputTrigger[]): void;
	HasMappingContext(MappingContext: InputMappingContext,OutFoundPriority?: number): {OutFoundPriority: number, $: boolean};
	GetPlayerMappedKey(MappingName: string): Key;
	GetAllPlayerMappableActionKeyMappings(): EnhancedActionKeyMapping[];
	ClearAllMappings(): void;
	AddPlayerMappedKey(MappingName: string,NewKey: Key,Options: ModifyContextOptions): number;
	AddPlayerMappableConfig(Config: PlayerMappableInputConfig,Options: ModifyContextOptions): void;
	AddMappingContext(MappingContext: InputMappingContext,Priority: number,Options: ModifyContextOptions): void;
	static C(Other: UObject | any): EnhancedInputSubsystemInterface;
}

declare class EnhancedInputLocalPlayerSubsystem extends LocalPlayerSubsystem { 
	ControlMappingsRebuiltDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): EnhancedInputLocalPlayerSubsystem;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputLocalPlayerSubsystem;
	static GetDefaultObject(): EnhancedInputLocalPlayerSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputLocalPlayerSubsystem;
	static C(Other: UObject | any): EnhancedInputLocalPlayerSubsystem;
}

declare class BlueprintInputDebugKeyDelegateBinding { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	FunctionNameToBind: string;
	bExecuteWhenPaused: boolean;
	clone() : BlueprintInputDebugKeyDelegateBinding;
	static C(Other: UObject | any): BlueprintInputDebugKeyDelegateBinding;
}

declare class InputDebugKeyDelegateBinding extends InputDelegateBinding { 
	InputDebugKeyDelegateBindings: BlueprintInputDebugKeyDelegateBinding[];
	static Load(ResourceName: string): InputDebugKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputDebugKeyDelegateBinding;
	static GetDefaultObject(): InputDebugKeyDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputDebugKeyDelegateBinding;
	static C(Other: UObject | any): InputDebugKeyDelegateBinding;
}

declare type EDeadZoneType = 'Axial' | 'Radial' | 'EDeadZoneType_MAX';
declare var EDeadZoneType : { Axial:'Axial',Radial:'Radial',EDeadZoneType_MAX:'EDeadZoneType_MAX', };
declare class InputModifierDeadZone extends InputModifier { 
	LowerThreshold: number;
	UpperThreshold: number;
	Type: EDeadZoneType;
	static Load(ResourceName: string): InputModifierDeadZone;
	static Find(Outer: UObject, ResourceName: string): InputModifierDeadZone;
	static GetDefaultObject(): InputModifierDeadZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierDeadZone;
	static C(Other: UObject | any): InputModifierDeadZone;
}

declare class InputModifierScalar extends InputModifier { 
	Scalar: Vector;
	static Load(ResourceName: string): InputModifierScalar;
	static Find(Outer: UObject, ResourceName: string): InputModifierScalar;
	static GetDefaultObject(): InputModifierScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierScalar;
	static C(Other: UObject | any): InputModifierScalar;
}

declare class InputModifierScaleByDeltaTime extends InputModifier { 
	static Load(ResourceName: string): InputModifierScaleByDeltaTime;
	static Find(Outer: UObject, ResourceName: string): InputModifierScaleByDeltaTime;
	static GetDefaultObject(): InputModifierScaleByDeltaTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierScaleByDeltaTime;
	static C(Other: UObject | any): InputModifierScaleByDeltaTime;
}

declare class InputModifierNegate extends InputModifier { 
	bX: boolean;
	bY: boolean;
	bZ: boolean;
	static Load(ResourceName: string): InputModifierNegate;
	static Find(Outer: UObject, ResourceName: string): InputModifierNegate;
	static GetDefaultObject(): InputModifierNegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierNegate;
	static C(Other: UObject | any): InputModifierNegate;
}

declare class InputModifierSmooth extends InputModifier { 
	static Load(ResourceName: string): InputModifierSmooth;
	static Find(Outer: UObject, ResourceName: string): InputModifierSmooth;
	static GetDefaultObject(): InputModifierSmooth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierSmooth;
	static C(Other: UObject | any): InputModifierSmooth;
}

declare class InputModifierResponseCurveExponential extends InputModifier { 
	CurveExponent: Vector;
	static Load(ResourceName: string): InputModifierResponseCurveExponential;
	static Find(Outer: UObject, ResourceName: string): InputModifierResponseCurveExponential;
	static GetDefaultObject(): InputModifierResponseCurveExponential;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierResponseCurveExponential;
	static C(Other: UObject | any): InputModifierResponseCurveExponential;
}

declare class InputModifierResponseCurveUser extends InputModifier { 
	ResponseX: CurveFloat;
	ResponseY: CurveFloat;
	ResponseZ: CurveFloat;
	static Load(ResourceName: string): InputModifierResponseCurveUser;
	static Find(Outer: UObject, ResourceName: string): InputModifierResponseCurveUser;
	static GetDefaultObject(): InputModifierResponseCurveUser;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierResponseCurveUser;
	static C(Other: UObject | any): InputModifierResponseCurveUser;
}

declare type EFOVScalingType = 'Standard' | 'UE4_BackCompat' | 'EFOVScalingType_MAX';
declare var EFOVScalingType : { Standard:'Standard',UE4_BackCompat:'UE4_BackCompat',EFOVScalingType_MAX:'EFOVScalingType_MAX', };
declare class InputModifierFOVScaling extends InputModifier { 
	FOVScale: number;
	FOVScalingType: EFOVScalingType;
	static Load(ResourceName: string): InputModifierFOVScaling;
	static Find(Outer: UObject, ResourceName: string): InputModifierFOVScaling;
	static GetDefaultObject(): InputModifierFOVScaling;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierFOVScaling;
	static C(Other: UObject | any): InputModifierFOVScaling;
}

declare class InputModifierToWorldSpace extends InputModifier { 
	static Load(ResourceName: string): InputModifierToWorldSpace;
	static Find(Outer: UObject, ResourceName: string): InputModifierToWorldSpace;
	static GetDefaultObject(): InputModifierToWorldSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierToWorldSpace;
	static C(Other: UObject | any): InputModifierToWorldSpace;
}

declare type EInputAxisSwizzle = 'YXZ' | 'ZYX' | 'XZY' | 'YZX' | 'ZXY' | 'EInputAxisSwizzle_MAX';
declare var EInputAxisSwizzle : { YXZ:'YXZ',ZYX:'ZYX',XZY:'XZY',YZX:'YZX',ZXY:'ZXY',EInputAxisSwizzle_MAX:'EInputAxisSwizzle_MAX', };
declare class InputModifierSwizzleAxis extends InputModifier { 
	Order: EInputAxisSwizzle;
	static Load(ResourceName: string): InputModifierSwizzleAxis;
	static Find(Outer: UObject, ResourceName: string): InputModifierSwizzleAxis;
	static GetDefaultObject(): InputModifierSwizzleAxis;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierSwizzleAxis;
	static C(Other: UObject | any): InputModifierSwizzleAxis;
}

declare class InputTriggerTimedBase extends InputTrigger { 
	HeldDuration: number;
	bAffectedByTimeDilation: boolean;
	static Load(ResourceName: string): InputTriggerTimedBase;
	static Find(Outer: UObject, ResourceName: string): InputTriggerTimedBase;
	static GetDefaultObject(): InputTriggerTimedBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerTimedBase;
	static C(Other: UObject | any): InputTriggerTimedBase;
}

declare class InputTriggerDown extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerDown;
	static Find(Outer: UObject, ResourceName: string): InputTriggerDown;
	static GetDefaultObject(): InputTriggerDown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerDown;
	static C(Other: UObject | any): InputTriggerDown;
}

declare class InputTriggerPressed extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerPressed;
	static Find(Outer: UObject, ResourceName: string): InputTriggerPressed;
	static GetDefaultObject(): InputTriggerPressed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerPressed;
	static C(Other: UObject | any): InputTriggerPressed;
}

declare class InputTriggerReleased extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerReleased;
	static Find(Outer: UObject, ResourceName: string): InputTriggerReleased;
	static GetDefaultObject(): InputTriggerReleased;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerReleased;
	static C(Other: UObject | any): InputTriggerReleased;
}

declare class InputTriggerHold extends InputTriggerTimedBase { 
	HoldTimeThreshold: number;
	bIsOneShot: boolean;
	static Load(ResourceName: string): InputTriggerHold;
	static Find(Outer: UObject, ResourceName: string): InputTriggerHold;
	static GetDefaultObject(): InputTriggerHold;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerHold;
	static C(Other: UObject | any): InputTriggerHold;
}

declare class InputTriggerHoldAndRelease extends InputTriggerTimedBase { 
	HoldTimeThreshold: number;
	static Load(ResourceName: string): InputTriggerHoldAndRelease;
	static Find(Outer: UObject, ResourceName: string): InputTriggerHoldAndRelease;
	static GetDefaultObject(): InputTriggerHoldAndRelease;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerHoldAndRelease;
	static C(Other: UObject | any): InputTriggerHoldAndRelease;
}

declare class InputTriggerTap extends InputTriggerTimedBase { 
	TapReleaseTimeThreshold: number;
	static Load(ResourceName: string): InputTriggerTap;
	static Find(Outer: UObject, ResourceName: string): InputTriggerTap;
	static GetDefaultObject(): InputTriggerTap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerTap;
	static C(Other: UObject | any): InputTriggerTap;
}

declare class InputTriggerPulse extends InputTriggerTimedBase { 
	bTriggerOnStart: boolean;
	Interval: number;
	TriggerLimit: number;
	static Load(ResourceName: string): InputTriggerPulse;
	static Find(Outer: UObject, ResourceName: string): InputTriggerPulse;
	static GetDefaultObject(): InputTriggerPulse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerPulse;
	static C(Other: UObject | any): InputTriggerPulse;
}

declare class InputTriggerChordAction extends InputTrigger { 
	ChordAction: InputAction;
	static Load(ResourceName: string): InputTriggerChordAction;
	static Find(Outer: UObject, ResourceName: string): InputTriggerChordAction;
	static GetDefaultObject(): InputTriggerChordAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerChordAction;
	static C(Other: UObject | any): InputTriggerChordAction;
}

declare class InputTriggerChordBlocker extends InputTriggerChordAction { 
	static Load(ResourceName: string): InputTriggerChordBlocker;
	static Find(Outer: UObject, ResourceName: string): InputTriggerChordBlocker;
	static GetDefaultObject(): InputTriggerChordBlocker;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerChordBlocker;
	static C(Other: UObject | any): InputTriggerChordBlocker;
}

declare class InputComboStepData { 
	ComboStepAction: InputAction;
	TimeToPressKey: number;
	clone() : InputComboStepData;
	static C(Other: UObject | any): InputComboStepData;
}

declare class InputTriggerCombo extends InputTrigger { 
	CurrentComboStepIndex: number;
	CurrentTimeBetweenComboSteps: number;
	ComboActions: InputComboStepData[];
	CancelActions: InputAction[];
	static Load(ResourceName: string): InputTriggerCombo;
	static Find(Outer: UObject, ResourceName: string): InputTriggerCombo;
	static GetDefaultObject(): InputTriggerCombo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerCombo;
	static C(Other: UObject | any): InputTriggerCombo;
}

declare class K2Node_EnhancedInputAction extends K2Node { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_EnhancedInputAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnhancedInputAction;
	static GetDefaultObject(): K2Node_EnhancedInputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnhancedInputAction;
	static C(Other: UObject | any): K2Node_EnhancedInputAction;
}

declare class K2Node_EnhancedInputActionEvent extends K2Node_Event { 
	InputAction: InputAction;
	TriggerEvent: ETriggerEvent;
	static Load(ResourceName: string): K2Node_EnhancedInputActionEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnhancedInputActionEvent;
	static GetDefaultObject(): K2Node_EnhancedInputActionEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnhancedInputActionEvent;
	static C(Other: UObject | any): K2Node_EnhancedInputActionEvent;
}

declare class K2Node_GetInputActionValue extends K2Node { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_GetInputActionValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputActionValue;
	static GetDefaultObject(): K2Node_GetInputActionValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputActionValue;
	static C(Other: UObject | any): K2Node_GetInputActionValue;
}

declare class K2Node_InputActionValueAccessor extends K2Node_CallFunction { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_InputActionValueAccessor;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputActionValueAccessor;
	static GetDefaultObject(): K2Node_InputActionValueAccessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionValueAccessor;
	static C(Other: UObject | any): K2Node_InputActionValueAccessor;
}

declare class K2Node_InputDebugKey extends K2Node { 
	InputKey: Key;
	bExecuteWhenPaused: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	static Load(ResourceName: string): K2Node_InputDebugKey;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputDebugKey;
	static GetDefaultObject(): K2Node_InputDebugKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputDebugKey;
	static C(Other: UObject | any): K2Node_InputDebugKey;
}

declare class K2Node_InputDebugKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_InputDebugKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputDebugKeyEvent;
	static GetDefaultObject(): K2Node_InputDebugKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputDebugKeyEvent;
	static C(Other: UObject | any): K2Node_InputDebugKeyEvent;
}

declare class PaperSpriteSocket { 
	LocalTransform: Transform;
	SocketName: string;
	clone() : PaperSpriteSocket;
	static C(Other: UObject | any): PaperSpriteSocket;
}

declare type ESpriteCollisionMode = 'None' | 'Use2DPhysics' | 'Use3DPhysics' | 'ESpriteCollisionMode_MAX';
declare var ESpriteCollisionMode : { None:'None',Use2DPhysics:'Use2DPhysics',Use3DPhysics:'Use3DPhysics',ESpriteCollisionMode_MAX:'ESpriteCollisionMode_MAX', };
declare type ESpritePivotMode = 'Top_Left' | 'Top_Center' | 'Top_Right' | 'Center_Left' | 'Center_Center' | 'Center_Right' | 'Bottom_Left' | 'Bottom_Center' | 'Bottom_Right' | 'Custom' | 'ESpritePivotMode_MAX';
declare var ESpritePivotMode : { Top_Left:'Top_Left',Top_Center:'Top_Center',Top_Right:'Top_Right',Center_Left:'Center_Left',Center_Center:'Center_Center',Center_Right:'Center_Right',Bottom_Left:'Bottom_Left',Bottom_Center:'Bottom_Center',Bottom_Right:'Bottom_Right',Custom:'Custom',ESpritePivotMode_MAX:'ESpritePivotMode_MAX', };
declare type ESpriteShapeType = 'Box' | 'Circle' | 'Polygon' | 'ESpriteShapeType_MAX';
declare var ESpriteShapeType : { Box:'Box',Circle:'Circle',Polygon:'Polygon',ESpriteShapeType_MAX:'ESpriteShapeType_MAX', };
declare class SpriteGeometryShape { 
	ShapeType: ESpriteShapeType;
	Vertices: Vector2D[];
	BoxSize: Vector2D;
	BoxPosition: Vector2D;
	Rotation: number;
	bNegativeWinding: boolean;
	clone() : SpriteGeometryShape;
	static C(Other: UObject | any): SpriteGeometryShape;
}

declare type ESpritePolygonMode = 'SourceBoundingBox' | 'TightBoundingBox' | 'ShrinkWrapped' | 'FullyCustom' | 'Diced' | 'ESpritePolygonMode_MAX';
declare var ESpritePolygonMode : { SourceBoundingBox:'SourceBoundingBox',TightBoundingBox:'TightBoundingBox',ShrinkWrapped:'ShrinkWrapped',FullyCustom:'FullyCustom',Diced:'Diced',ESpritePolygonMode_MAX:'ESpritePolygonMode_MAX', };
declare class SpriteGeometryCollection { 
	Shapes: SpriteGeometryShape[];
	GeometryType: ESpritePolygonMode;
	PixelsPerSubdivisionX: number;
	PixelsPerSubdivisionY: number;
	bAvoidVertexMerging: boolean;
	AlphaThreshold: number;
	DetailAmount: number;
	SimplifyEpsilon: number;
	clone() : SpriteGeometryCollection;
	static C(Other: UObject | any): SpriteGeometryCollection;
}

declare type EPaperSpriteAtlasPadding = 'DilateBorder' | 'PadWithZero' | 'EPaperSpriteAtlasPadding_MAX';
declare var EPaperSpriteAtlasPadding : { DilateBorder:'DilateBorder',PadWithZero:'PadWithZero',EPaperSpriteAtlasPadding_MAX:'EPaperSpriteAtlasPadding_MAX', };
declare class PaperSpriteAtlasSlot { 
	SpriteRef: PaperSprite;
	AtlasIndex: number;
	X: number;
	Y: number;
	Width: number;
	Height: number;
	clone() : PaperSpriteAtlasSlot;
	static C(Other: UObject | any): PaperSpriteAtlasSlot;
}

declare class PaperSpriteAtlas extends UObject { 
	AtlasDescription: string;
	MaxWidth: number;
	MaxHeight: number;
	MipCount: number;
	PaddingType: EPaperSpriteAtlasPadding;
	Padding: number;
	CompressionSettings: TextureCompressionSettings;
	Filter: TextureFilter;
	GeneratedTextures: Texture[];
	AtlasGUID: Guid;
	bRebuildAtlas: boolean;
	AtlasSlots: PaperSpriteAtlasSlot[];
	NumIncrementalBuilds: number;
	BuiltWidth: number;
	BuiltHeight: number;
	BuiltPadding: number;
	static Load(ResourceName: string): PaperSpriteAtlas;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteAtlas;
	static GetDefaultObject(): PaperSpriteAtlas;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteAtlas;
	static C(Other: UObject | any): PaperSpriteAtlas;
}

declare class PaperSprite extends UObject { 
	OriginInSourceImageBeforeTrimming: Vector2D;
	SourceImageDimensionBeforeTrimming: Vector2D;
	bTrimmedInSourceImage: boolean;
	bRotatedInSourceImage: boolean;
	SourceTextureDimension: Vector2D;
	SourceUV: Vector2D;
	SourceDimension: Vector2D;
	SourceTexture: Texture2D;
	SourceTextureCacheNeverSerialized: Texture2D;
	AdditionalSourceTextures: Texture[];
	BakedSourceUV: Vector2D;
	BakedSourceDimension: Vector2D;
	BakedSourceTexture: Texture2D;
	DefaultMaterial: MaterialInterface;
	AlternateMaterial: MaterialInterface;
	Sockets: PaperSpriteSocket[];
	SpriteCollisionDomain: ESpriteCollisionMode;
	PixelsPerUnrealUnit: number;
	BodySetup: BodySetup;
	PivotMode: ESpritePivotMode;
	CustomPivotPoint: Vector2D;
	bSnapPivotToPixelGrid: boolean;
	CollisionGeometry: SpriteGeometryCollection;
	CollisionThickness: number;
	RenderGeometry: SpriteGeometryCollection;
	AtlasGroup: PaperSpriteAtlas;
	AlternateMaterialSplitIndex: number;
	BakedRenderData: Vector4[];
	static Load(ResourceName: string): PaperSprite;
	static Find(Outer: UObject, ResourceName: string): PaperSprite;
	static GetDefaultObject(): PaperSprite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSprite;
	static C(Other: UObject | any): PaperSprite;
	MakeBrushFromSprite(Width: number,Height: number): SlateBrush;
	static MakeBrushFromSprite(Sprite: PaperSprite,Width: number,Height: number): SlateBrush;
}

declare class PaperFlipbookKeyFrame { 
	Sprite: PaperSprite;
	FrameRun: number;
	clone() : PaperFlipbookKeyFrame;
	static C(Other: UObject | any): PaperFlipbookKeyFrame;
}

declare type EFlipbookCollisionMode = 'NoCollision' | 'FirstFrameCollision' | 'EachFrameCollision' | 'EFlipbookCollisionMode_MAX';
declare var EFlipbookCollisionMode : { NoCollision:'NoCollision',FirstFrameCollision:'FirstFrameCollision',EachFrameCollision:'EachFrameCollision',EFlipbookCollisionMode_MAX:'EFlipbookCollisionMode_MAX', };
declare class PaperFlipbook extends UObject { 
	FramesPerSecond: number;
	KeyFrames: PaperFlipbookKeyFrame[];
	DefaultMaterial: MaterialInterface;
	CollisionSource: EFlipbookCollisionMode;
	static Load(ResourceName: string): PaperFlipbook;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbook;
	static GetDefaultObject(): PaperFlipbook;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbook;
	IsValidKeyFrameIndex(Index: number): boolean;
	GetTotalDuration(): number;
	GetSpriteAtTime(Time: number,bClampToEnds: boolean): PaperSprite;
	GetSpriteAtFrame(FrameIndex: number): PaperSprite;
	GetNumKeyFrames(): number;
	GetNumFrames(): number;
	GetKeyFrameIndexAtTime(Time: number,bClampToEnds: boolean): number;
	static C(Other: UObject | any): PaperFlipbook;
}

declare class PaperFlipbookComponent extends MeshComponent { 
	SourceFlipbook: PaperFlipbook;
	Material: MaterialInterface;
	PlayRate: number;
	bLooping: boolean;
	bReversePlayback: boolean;
	bPlaying: boolean;
	AccumulatedTime: number;
	CachedFrameIndex: number;
	SpriteColor: LinearColor;
	CachedBodySetup: BodySetup;
	OnFinishedPlaying: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): PaperFlipbookComponent;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbookComponent;
	static GetDefaultObject(): PaperFlipbookComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookComponent;
	Stop(): void;
	SetSpriteColor(NewColor: LinearColor): void;
	SetPlayRate(NewRate: number): void;
	SetPlaybackPositionInFrames(NewFramePosition: number,bFireEvents: boolean): void;
	SetPlaybackPosition(NewPosition: number,bFireEvents: boolean): void;
	SetNewTime(NewTime: number): void;
	SetLooping(bNewLooping: boolean): void;
	SetFlipbook(NewFlipbook: PaperFlipbook): boolean;
	ReverseFromEnd(): void;
	Reverse(): void;
	PlayFromStart(): void;
	Play(): void;
	OnRep_SourceFlipbook(OldFlipbook: PaperFlipbook): void;
	IsReversing(): boolean;
	IsPlaying(): boolean;
	IsLooping(): boolean;
	GetSpriteColor(): LinearColor;
	GetPlayRate(): number;
	GetPlaybackPositionInFrames(): number;
	GetPlaybackPosition(): number;
	GetFlipbookLengthInFrames(): number;
	GetFlipbookLength(): number;
	GetFlipbookFramerate(): number;
	GetFlipbook(): PaperFlipbook;
	static C(Other: UObject | any): PaperFlipbookComponent;
}

declare class PaperCharacter extends Character { 
	Sprite: PaperFlipbookComponent;
	static GetDefaultObject(): PaperCharacter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperCharacter;
	static C(Other: UObject | any): PaperCharacter;
}

declare class PaperFlipbookActor extends Actor { 
	RenderComponent: PaperFlipbookComponent;
	static GetDefaultObject(): PaperFlipbookActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookActor;
	static C(Other: UObject | any): PaperFlipbookActor;
}

declare class SpriteInstanceData { 
	Transform: Matrix;
	SourceSprite: PaperSprite;
	VertexColor: Color;
	MaterialIndex: number;
	clone() : SpriteInstanceData;
	static C(Other: UObject | any): SpriteInstanceData;
}

declare class PaperGroupedSpriteComponent extends MeshComponent { 
	InstanceMaterials: MaterialInterface[];
	PerInstanceSpriteData: SpriteInstanceData[];
	static Load(ResourceName: string): PaperGroupedSpriteComponent;
	static Find(Outer: UObject, ResourceName: string): PaperGroupedSpriteComponent;
	static GetDefaultObject(): PaperGroupedSpriteComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperGroupedSpriteComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	UpdateInstanceColor(InstanceIndex: number,NewInstanceColor: LinearColor,bMarkRenderStateDirty: boolean): boolean;
	SortInstancesAlongAxis(WorldSpaceSortAxis: Vector): void;
	RemoveInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstanceCount(): number;
	ClearInstances(): void;
	AddInstance(Transform: Transform,Sprite: PaperSprite,bWorldSpace: boolean,Color: LinearColor): number;
	static C(Other: UObject | any): PaperGroupedSpriteComponent;
}

declare class PaperGroupedSpriteActor extends Actor { 
	RenderComponent: PaperGroupedSpriteComponent;
	static GetDefaultObject(): PaperGroupedSpriteActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperGroupedSpriteActor;
	static C(Other: UObject | any): PaperGroupedSpriteActor;
}

declare class PaperRuntimeSettings extends UObject { 
	bEnableSpriteAtlasGroups: boolean;
	bEnableTerrainSplineEditing: boolean;
	bResizeSpriteDataToMatchTextures: boolean;
	static Load(ResourceName: string): PaperRuntimeSettings;
	static Find(Outer: UObject, ResourceName: string): PaperRuntimeSettings;
	static GetDefaultObject(): PaperRuntimeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperRuntimeSettings;
	static C(Other: UObject | any): PaperRuntimeSettings;
}

declare class PaperSpriteComponent extends MeshComponent { 
	SourceSprite: PaperSprite;
	MaterialOverride: MaterialInterface;
	SpriteColor: LinearColor;
	static Load(ResourceName: string): PaperSpriteComponent;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteComponent;
	static GetDefaultObject(): PaperSpriteComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteComponent;
	SetSpriteColor(NewColor: LinearColor): void;
	SetSprite(NewSprite: PaperSprite): boolean;
	GetSprite(): PaperSprite;
	static C(Other: UObject | any): PaperSpriteComponent;
}

declare class PaperSpriteActor extends Actor { 
	RenderComponent: PaperSpriteComponent;
	static GetDefaultObject(): PaperSpriteActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteActor;
	static C(Other: UObject | any): PaperSpriteActor;
}

declare class PaperSpriteBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): PaperSpriteBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteBlueprintLibrary;
	static GetDefaultObject(): PaperSpriteBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteBlueprintLibrary;
	static MakeBrushFromSprite(Sprite: PaperSprite,Width: number,Height: number): SlateBrush;
	static C(Other: UObject | any): PaperSpriteBlueprintLibrary;
}

declare class IntMargin { 
	Left: number;
	Top: number;
	Right: number;
	Bottom: number;
	clone() : IntMargin;
	static C(Other: UObject | any): IntMargin;
}

declare class PaperTileMetadata { 
	UserDataName: string;
	CollisionData: SpriteGeometryCollection;
	TerrainMembership: number;
	clone() : PaperTileMetadata;
	static C(Other: UObject | any): PaperTileMetadata;
}

declare class PaperTileSetTerrain { 
	TerrainName: string;
	CenterTileIndex: number;
	clone() : PaperTileSetTerrain;
	static C(Other: UObject | any): PaperTileSetTerrain;
}

declare class PaperTileSet extends UObject { 
	TileSize: IntPoint;
	TileSheet: Texture2D;
	AdditionalSourceTextures: Texture[];
	BorderMargin: IntMargin;
	PerTileSpacing: IntPoint;
	DrawingOffset: IntPoint;
	BackgroundColor: LinearColor;
	WidthInTiles: number;
	HeightInTiles: number;
	AllocatedWidth: number;
	AllocatedHeight: number;
	PerTileData: PaperTileMetadata[];
	Terrains: PaperTileSetTerrain[];
	TileWidth: number;
	TileHeight: number;
	Margin: number;
	Spacing: number;
	static Load(ResourceName: string): PaperTileSet;
	static Find(Outer: UObject, ResourceName: string): PaperTileSet;
	static GetDefaultObject(): PaperTileSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileSet;
	static C(Other: UObject | any): PaperTileSet;
}

declare class PaperTileInfo { 
	TileSet: PaperTileSet;
	PackedTileIndex: number;
	clone() : PaperTileInfo;
	static C(Other: UObject | any): PaperTileInfo;
	BreakTile(TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	GetTileTransform(): Transform;
	GetTileUserData(): string;
	static BreakTile(Tile: PaperTileInfo,TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	static GetTileTransform(Tile: PaperTileInfo): Transform;
	static GetTileUserData(Tile: PaperTileInfo): string;
	static MakeTile(TileIndex: number,TileSet: PaperTileSet,bFlipH: boolean,bFlipV: boolean,bFlipD: boolean): PaperTileInfo;
}

declare class PaperTileLayer extends UObject { 
	LayerName: string;
	LayerWidth: number;
	LayerHeight: number;
	bHiddenInEditor: boolean;
	bHiddenInGame: boolean;
	bLayerCollides: boolean;
	bOverrideCollisionThickness: boolean;
	bOverrideCollisionOffset: boolean;
	CollisionThicknessOverride: number;
	CollisionOffsetOverride: number;
	LayerColor: LinearColor;
	AllocatedWidth: number;
	AllocatedHeight: number;
	AllocatedCells: PaperTileInfo[];
	TileSet: PaperTileSet;
	AllocatedGrid: number[];
	static Load(ResourceName: string): PaperTileLayer;
	static Find(Outer: UObject, ResourceName: string): PaperTileLayer;
	static GetDefaultObject(): PaperTileLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileLayer;
	static C(Other: UObject | any): PaperTileLayer;
}

declare type ETileMapProjectionMode = 'Orthogonal' | 'IsometricDiamond' | 'IsometricStaggered' | 'HexagonalStaggered' | 'ETileMapProjectionMode_MAX';
declare var ETileMapProjectionMode : { Orthogonal:'Orthogonal',IsometricDiamond:'IsometricDiamond',IsometricStaggered:'IsometricStaggered',HexagonalStaggered:'HexagonalStaggered',ETileMapProjectionMode_MAX:'ETileMapProjectionMode_MAX', };
declare class PaperTileMap extends UObject { 
	MapWidth: number;
	MapHeight: number;
	TileWidth: number;
	TileHeight: number;
	PixelsPerUnrealUnit: number;
	SeparationPerTileX: number;
	SeparationPerTileY: number;
	SeparationPerLayer: number;
	SelectedTileSet: PaperTileSet;
	Material: MaterialInterface;
	TileLayers: PaperTileLayer[];
	CollisionThickness: number;
	SpriteCollisionDomain: ESpriteCollisionMode;
	ProjectionMode: ETileMapProjectionMode;
	HexSideLength: number;
	BodySetup: BodySetup;
	AssetImportData: AssetImportData;
	SelectedLayerIndex: number;
	BackgroundColor: LinearColor;
	TileGridColor: LinearColor;
	MultiTileGridColor: LinearColor;
	MultiTileGridWidth: number;
	MultiTileGridHeight: number;
	MultiTileGridOffsetX: number;
	MultiTileGridOffsetY: number;
	LayerGridColor: LinearColor;
	LayerNameIndex: number;
	static Load(ResourceName: string): PaperTileMap;
	static Find(Outer: UObject, ResourceName: string): PaperTileMap;
	static GetDefaultObject(): PaperTileMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMap;
	static C(Other: UObject | any): PaperTileMap;
}

declare class PaperTileMapComponent extends MeshComponent { 
	MapWidth: number;
	MapHeight: number;
	TileWidth: number;
	TileHeight: number;
	DefaultLayerTileSet: PaperTileSet;
	Material: MaterialInterface;
	TileLayers: PaperTileLayer[];
	TileMapColor: LinearColor;
	UseSingleLayerIndex: number;
	bUseSingleLayer: boolean;
	TileMap: PaperTileMap;
	bShowPerTileGridWhenSelected: boolean;
	bShowPerLayerGridWhenSelected: boolean;
	bShowOutlineWhenUnselected: boolean;
	bShowPerTileGridWhenUnselected: boolean;
	bShowPerLayerGridWhenUnselected: boolean;
	static Load(ResourceName: string): PaperTileMapComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTileMapComponent;
	static GetDefaultObject(): PaperTileMapComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapComponent;
	SetTileMapColor(NewColor: LinearColor): void;
	SetTileMap(NewTileMap: PaperTileMap): boolean;
	SetTile(X: number,Y: number,Layer: number,NewValue: PaperTileInfo): void;
	SetLayerColor(NewColor: LinearColor,Layer: number): void;
	SetLayerCollision(Layer: number,bHasCollision: boolean,bOverrideThickness: boolean,CustomThickness: number,bOverrideOffset: boolean,CustomOffset: number,bRebuildCollision: boolean): void;
	SetDefaultCollisionThickness(Thickness: number,bRebuildCollision: boolean): void;
	ResizeMap(NewWidthInTiles: number,NewHeightInTiles: number): void;
	RebuildCollision(): void;
	OwnsTileMap(): boolean;
	MakeTileMapEditable(): void;
	GetTilePolygon(TileX: number,TileY: number,Points?: Vector[],LayerIndex?: number,bWorldSpace?: boolean): {Points: Vector[]};
	GetTileMapColor(): LinearColor;
	GetTileCornerPosition(TileX: number,TileY: number,LayerIndex: number,bWorldSpace: boolean): Vector;
	GetTileCenterPosition(TileX: number,TileY: number,LayerIndex: number,bWorldSpace: boolean): Vector;
	GetTile(X: number,Y: number,Layer: number): PaperTileInfo;
	GetMapSize(MapWidth?: number,MapHeight?: number,NumLayers?: number): {MapWidth: number, MapHeight: number, NumLayers: number};
	GetLayerColor(Layer: number): LinearColor;
	CreateNewTileMap(MapWidth: number,MapHeight: number,TileWidth: number,TileHeight: number,PixelsPerUnrealUnit: number,bCreateLayer: boolean): void;
	AddNewLayer(): PaperTileLayer;
	static C(Other: UObject | any): PaperTileMapComponent;
}

declare class PaperTileMapActor extends Actor { 
	RenderComponent: PaperTileMapComponent;
	static GetDefaultObject(): PaperTileMapActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapActor;
	static C(Other: UObject | any): PaperTileMapActor;
}

declare class MaterialExpressionSpriteTextureSampler extends MaterialExpressionTextureSampleParameter2D { 
	bSampleAdditionalTextures: boolean;
	AdditionalSlotIndex: number;
	SlotDisplayName: string;
	static Load(ResourceName: string): MaterialExpressionSpriteTextureSampler;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSpriteTextureSampler;
	static GetDefaultObject(): MaterialExpressionSpriteTextureSampler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSpriteTextureSampler;
	static C(Other: UObject | any): MaterialExpressionSpriteTextureSampler;
}

declare class PaperTerrainSplineComponent extends SplineComponent { 
	static Load(ResourceName: string): PaperTerrainSplineComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainSplineComponent;
	static GetDefaultObject(): PaperTerrainSplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainSplineComponent;
	static C(Other: UObject | any): PaperTerrainSplineComponent;
}

declare class PaperTerrainMaterialRule { 
	StartCap: PaperSprite;
	Body: PaperSprite[];
	EndCap: PaperSprite;
	MinimumAngle: number;
	MaximumAngle: number;
	bEnableCollision: boolean;
	CollisionOffset: number;
	DrawOrder: number;
	Description: string;
	clone() : PaperTerrainMaterialRule;
	static C(Other: UObject | any): PaperTerrainMaterialRule;
}

declare class PaperTerrainMaterial extends DataAsset { 
	Rules: PaperTerrainMaterialRule[];
	InteriorFill: PaperSprite;
	static Load(ResourceName: string): PaperTerrainMaterial;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainMaterial;
	static GetDefaultObject(): PaperTerrainMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainMaterial;
	static C(Other: UObject | any): PaperTerrainMaterial;
}

declare class PaperTerrainComponent extends PrimitiveComponent { 
	TerrainMaterial: PaperTerrainMaterial;
	bClosedSpline: boolean;
	bFilledSpline: boolean;
	AssociatedSpline: PaperTerrainSplineComponent;
	RandomSeed: number;
	SegmentOverlapAmount: number;
	TerrainColor: LinearColor;
	ReparamStepsPerSegment: number;
	SpriteCollisionDomain: ESpriteCollisionMode;
	CollisionThickness: number;
	CachedBodySetup: BodySetup;
	static Load(ResourceName: string): PaperTerrainComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainComponent;
	static GetDefaultObject(): PaperTerrainComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainComponent;
	SetTerrainColor(NewColor: LinearColor): void;
	static C(Other: UObject | any): PaperTerrainComponent;
}

declare class PaperTerrainActor extends Actor { 
	DummyRoot: SceneComponent;
	SplineComponent: PaperTerrainSplineComponent;
	RenderComponent: PaperTerrainComponent;
	static GetDefaultObject(): PaperTerrainActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainActor;
	static C(Other: UObject | any): PaperTerrainActor;
}

declare class TileMapBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): TileMapBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TileMapBlueprintLibrary;
	static GetDefaultObject(): TileMapBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileMapBlueprintLibrary;
	static MakeTile(TileIndex: number,TileSet: PaperTileSet,bFlipH: boolean,bFlipV: boolean,bFlipD: boolean): PaperTileInfo;
	static GetTileUserData(Tile: PaperTileInfo): string;
	static GetTileTransform(Tile: PaperTileInfo): Transform;
	static BreakTile(Tile: PaperTileInfo,TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	static C(Other: UObject | any): TileMapBlueprintLibrary;
}

declare class ActorFactoryEnvironmentQuery extends ActorFactory { 
	static Load(ResourceName: string): ActorFactoryEnvironmentQuery;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryEnvironmentQuery;
	static GetDefaultObject(): ActorFactoryEnvironmentQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryEnvironmentQuery;
	static C(Other: UObject | any): ActorFactoryEnvironmentQuery;
}

declare class EdGraphSchema_EnvironmentQuery extends AIGraphSchema { 
	static Load(ResourceName: string): EdGraphSchema_EnvironmentQuery;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_EnvironmentQuery;
	static GetDefaultObject(): EdGraphSchema_EnvironmentQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_EnvironmentQuery;
	static C(Other: UObject | any): EdGraphSchema_EnvironmentQuery;
}

declare class EnvironmentQueryFactory extends Factory { 
	static Load(ResourceName: string): EnvironmentQueryFactory;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryFactory;
	static GetDefaultObject(): EnvironmentQueryFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryFactory;
	static C(Other: UObject | any): EnvironmentQueryFactory;
}

declare class EnvironmentQueryGraph extends AIGraph { 
	static Load(ResourceName: string): EnvironmentQueryGraph;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraph;
	static GetDefaultObject(): EnvironmentQueryGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraph;
	static C(Other: UObject | any): EnvironmentQueryGraph;
}

declare class EnvironmentQueryGraphNode extends AIGraphNode { 
	static Load(ResourceName: string): EnvironmentQueryGraphNode;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode;
	static GetDefaultObject(): EnvironmentQueryGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode;
	static C(Other: UObject | any): EnvironmentQueryGraphNode;
}

declare class EnvironmentQueryGraphNode_Option extends EnvironmentQueryGraphNode { 
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Option;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Option;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Option;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Option;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Option;
}

declare class EnvironmentQueryGraphNode_Root extends EnvironmentQueryGraphNode { 
	DebugMessages: string[];
	bHasDebugError: boolean;
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Root;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Root;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Root;
}

declare class EnvironmentQueryGraphNode_Test extends EnvironmentQueryGraphNode { 
	TestWeightPct: number;
	bHasNamedWeight: boolean;
	bTestEnabled: boolean;
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Test;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Test;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Test;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Test;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Test;
}

declare class RigVMMemoryStorageGeneratorClass extends Class { 
	static Load(ResourceName: string): RigVMMemoryStorageGeneratorClass;
	static Find(Outer: UObject, ResourceName: string): RigVMMemoryStorageGeneratorClass;
	static GetDefaultObject(): RigVMMemoryStorageGeneratorClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMMemoryStorageGeneratorClass;
	static C(Other: UObject | any): RigVMMemoryStorageGeneratorClass;
}

declare class RigVMNativized extends RigVM { 
	static Load(ResourceName: string): RigVMNativized;
	static Find(Outer: UObject, ResourceName: string): RigVMNativized;
	static GetDefaultObject(): RigVMNativized;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMNativized;
	static C(Other: UObject | any): RigVMNativized;
}

declare class RigVMCompiler extends UObject { 
	Settings: RigVMCompileSettings;
	static Load(ResourceName: string): RigVMCompiler;
	static Find(Outer: UObject, ResourceName: string): RigVMCompiler;
	static GetDefaultObject(): RigVMCompiler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCompiler;
	Compile(InGraphs: RigVMGraph[],InController: RigVMController,OutVM: RigVM): boolean;
	static C(Other: UObject | any): RigVMCompiler;
}

declare class RigVMAggregateNode extends RigVMCollapseNode { 
	static Load(ResourceName: string): RigVMAggregateNode;
	static Find(Outer: UObject, ResourceName: string): RigVMAggregateNode;
	static GetDefaultObject(): RigVMAggregateNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMAggregateNode;
	static C(Other: UObject | any): RigVMAggregateNode;
}

declare class RigVMDispatchNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMDispatchNode;
	static Find(Outer: UObject, ResourceName: string): RigVMDispatchNode;
	static GetDefaultObject(): RigVMDispatchNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMDispatchNode;
	static C(Other: UObject | any): RigVMDispatchNode;
}

declare class RigVMClientHost extends Interface { 
	static Load(ResourceName: string): RigVMClientHost;
	static Find(Outer: UObject, ResourceName: string): RigVMClientHost;
	static GetDefaultObject(): RigVMClientHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMClientHost;
	static C(Other: UObject | any): RigVMClientHost;
}

declare class RigVMEditorSideObject extends Interface { 
	static Load(ResourceName: string): RigVMEditorSideObject;
	static Find(Outer: UObject, ResourceName: string): RigVMEditorSideObject;
	static GetDefaultObject(): RigVMEditorSideObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMEditorSideObject;
	static C(Other: UObject | any): RigVMEditorSideObject;
}

declare class RigVMController_CommonTypePerTemplate { 
	Counts: Map<string, number>;
	clone() : RigVMController_CommonTypePerTemplate;
	static C(Other: UObject | any): RigVMController_CommonTypePerTemplate;
}

declare class RigVMControllerSettings extends UObject { 
	bAutoResolveTemplateNodesWhenLinkingExecute: boolean;
	TemplateDefaultTypes: Map<string, RigVMController_CommonTypePerTemplate>;
	static Load(ResourceName: string): RigVMControllerSettings;
	static Find(Outer: UObject, ResourceName: string): RigVMControllerSettings;
	static GetDefaultObject(): RigVMControllerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMControllerSettings;
	static C(Other: UObject | any): RigVMControllerSettings;
}

declare class RigVMUserWorkflowRegistry extends UObject { 
	static Load(ResourceName: string): RigVMUserWorkflowRegistry;
	static Find(Outer: UObject, ResourceName: string): RigVMUserWorkflowRegistry;
	static GetDefaultObject(): RigVMUserWorkflowRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUserWorkflowRegistry;
	UnregisterProvider(InHandle: number): void;
	GetWorkflows(InType: ERigVMUserWorkflowType,InStruct: ScriptStruct,InSubject: UObject): RigVMUserWorkflow[];
	static Get(): RigVMUserWorkflowRegistry;
	static C(Other: UObject | any): RigVMUserWorkflowRegistry;
}

declare class ControlRigAnimInstance extends AnimInstance { 
	static Load(ResourceName: string): ControlRigAnimInstance;
	static Find(Outer: UObject, ResourceName: string): ControlRigAnimInstance;
	static GetDefaultObject(): ControlRigAnimInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigAnimInstance;
	static C(Other: UObject | any): ControlRigAnimInstance;
}

declare class ControlRigBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	static Load(ResourceName: string): ControlRigBlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): ControlRigBlueprintGeneratedClass;
	static GetDefaultObject(): ControlRigBlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigBlueprintGeneratedClass;
	static C(Other: UObject | any): ControlRigBlueprintGeneratedClass;
}

declare type EControlRigComponentMapDirection = 'Input' | 'Output' | 'EControlRigComponentMapDirection_MAX';
declare var EControlRigComponentMapDirection : { Input:'Input',Output:'Output',EControlRigComponentMapDirection_MAX:'EControlRigComponentMapDirection_MAX', };
declare type EControlRigComponentSpace = 'WorldSpace' | 'ActorSpace' | 'ComponentSpace' | 'RigSpace' | 'LocalSpace' | 'Max' | 'EControlRigComponentSpace_MAX';
declare var EControlRigComponentSpace : { WorldSpace:'WorldSpace',ActorSpace:'ActorSpace',ComponentSpace:'ComponentSpace',RigSpace:'RigSpace',LocalSpace:'LocalSpace',Max:'Max',EControlRigComponentSpace_MAX:'EControlRigComponentSpace_MAX', };
declare class ControlRigComponentMappedElement { 
	ComponentReference: ComponentReference;
	TransformIndex: number;
	TransformName: string;
	ElementType: ERigElementType;
	ElementName: string;
	Direction: EControlRigComponentMapDirection;
	Offset: Transform;
	Weight: number;
	Space: EControlRigComponentSpace;
	SceneComponent: SceneComponent;
	ElementIndex: number;
	SubIndex: number;
	clone() : ControlRigComponentMappedElement;
	static C(Other: UObject | any): ControlRigComponentMappedElement;
}

declare class ControlRigComponentMappedBone { 
	Source: string;
	Target: string;
	clone() : ControlRigComponentMappedBone;
	static C(Other: UObject | any): ControlRigComponentMappedBone;
}

declare class ControlRigComponentMappedCurve { 
	Source: string;
	Target: string;
	clone() : ControlRigComponentMappedCurve;
	static C(Other: UObject | any): ControlRigComponentMappedCurve;
}

declare class ControlRigComponentMappedComponent { 
	Component: SceneComponent;
	ElementName: string;
	ElementType: ERigElementType;
	Direction: EControlRigComponentMapDirection;
	clone() : ControlRigComponentMappedComponent;
	static C(Other: UObject | any): ControlRigComponentMappedComponent;
}

declare class ControlRigComponent extends PrimitiveComponent { 
	ControlRigClass: UnrealEngineClass;
	OnPreInitializeDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	OnPostInitializeDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	OnPreConstructionDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	OnPostConstructionDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	OnPreForwardsSolveDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	OnPostForwardsSolveDelegate: UnrealEngineMulticastDelegate<(Component: ControlRigComponent) => void>;
	UserDefinedElements: ControlRigComponentMappedElement[];
	MappedElements: ControlRigComponentMappedElement[];
	bEnableLazyEvaluation: boolean;
	LazyEvaluationPositionThreshold: number;
	LazyEvaluationRotationThreshold: number;
	LazyEvaluationScaleThreshold: number;
	bResetTransformBeforeTick: boolean;
	bResetInitialsBeforeConstruction: boolean;
	bUpdateRigOnTick: boolean;
	bUpdateInEditor: boolean;
	bDrawBones: boolean;
	bShowDebugDrawing: boolean;
	ControlRig: ControlRig;
	static Load(ResourceName: string): ControlRigComponent;
	static Find(Outer: UObject, ResourceName: string): ControlRigComponent;
	static GetDefaultObject(): ControlRigComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigComponent;
	Update(DeltaTime: number): void;
	SetObjectBinding(InObjectToBind: UObject): void;
	SetMappedElements(NewMappedElements: ControlRigComponentMappedElement[]): void;
	SetInitialSpaceTransform(SpaceName: string,InitialTransform: Transform,Space: EControlRigComponentSpace): void;
	SetInitialBoneTransform(BoneName: string,InitialTransform: Transform,Space: EControlRigComponentSpace,bPropagateToChildren: boolean): void;
	SetControlVector2D(ControlName: string,Value: Vector2D): void;
	SetControlTransform(ControlName: string,Value: Transform,Space: EControlRigComponentSpace): void;
	SetControlScale(ControlName: string,Value: Vector,Space: EControlRigComponentSpace): void;
	SetControlRotator(ControlName: string,Value: Rotator,Space: EControlRigComponentSpace): void;
	SetControlRigClass(InControlRigClass: UnrealEngineClass): void;
	SetControlPosition(ControlName: string,Value: Vector,Space: EControlRigComponentSpace): void;
	SetControlOffset(ControlName: string,OffsetTransform: Transform,Space: EControlRigComponentSpace): void;
	SetControlInt(ControlName: string,Value: number): void;
	SetControlFloat(ControlName: string,Value: number): void;
	SetControlBool(ControlName: string,Value: boolean): void;
	SetBoneTransform(BoneName: string,Transform: Transform,Space: EControlRigComponentSpace,Weight: number,bPropagateToChildren: boolean): void;
	SetBoneInitialTransformsFromSkeletalMesh(InSkeletalMesh: SkeletalMesh): void;
	OnPreInitialize(Component: ControlRigComponent): void;
	OnPreForwardsSolve(Component: ControlRigComponent): void;
	OnPreConstruction(Component: ControlRigComponent): void;
	OnPostInitialize(Component: ControlRigComponent): void;
	OnPostForwardsSolve(Component: ControlRigComponent): void;
	OnPostConstruction(Component: ControlRigComponent): void;
	Initialize(): void;
	GetSpaceTransform(SpaceName: string,Space: EControlRigComponentSpace): Transform;
	GetInitialSpaceTransform(SpaceName: string,Space: EControlRigComponentSpace): Transform;
	GetInitialBoneTransform(BoneName: string,Space: EControlRigComponentSpace): Transform;
	GetElementNames(ElementType: ERigElementType): string[];
	GetControlVector2D(ControlName: string): Vector2D;
	GetControlTransform(ControlName: string,Space: EControlRigComponentSpace): Transform;
	GetControlScale(ControlName: string,Space: EControlRigComponentSpace): Vector;
	GetControlRotator(ControlName: string,Space: EControlRigComponentSpace): Rotator;
	GetControlRig(): ControlRig;
	GetControlPosition(ControlName: string,Space: EControlRigComponentSpace): Vector;
	GetControlOffset(ControlName: string,Space: EControlRigComponentSpace): Transform;
	GetControlInt(ControlName: string): number;
	GetControlFloat(ControlName: string): number;
	GetControlBool(ControlName: string): boolean;
	GetBoneTransform(BoneName: string,Space: EControlRigComponentSpace): Transform;
	GetAbsoluteTime(): number;
	DoesElementExist(Name: string,ElementType: ERigElementType): boolean;
	ClearMappedElements(): void;
	CanExecute(): boolean;
	AddMappedSkeletalMesh(SkeletalMeshComponent: SkeletalMeshComponent,Bones: ControlRigComponentMappedBone[],Curves: ControlRigComponentMappedCurve[]): void;
	AddMappedElements(NewMappedElements: ControlRigComponentMappedElement[]): void;
	AddMappedComponents(Components: ControlRigComponentMappedComponent[]): void;
	AddMappedCompleteSkeletalMesh(SkeletalMeshComponent: SkeletalMeshComponent): void;
	static C(Other: UObject | any): ControlRigComponent;
}

declare class ControlRigControlActor extends Actor { 
	ActorToTrack: Actor;
	ControlRigClass: UnrealEngineClass;
	bRefreshOnTick: boolean;
	bIsSelectable: boolean;
	MaterialOverride: MaterialInterface;
	ColorParameter: string;
	bCastShadows: boolean;
	ActorRootComponent: SceneComponent;
	ControlRig: ControlRig;
	ControlNames: string[];
	ShapeTransforms: Transform[];
	Components: StaticMeshComponent[];
	Materials: MaterialInstanceDynamic[];
	ColorParameterName: string;
	static GetDefaultObject(): ControlRigControlActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigControlActor;
	ResetControlActor(): void;
	Refresh(): void;
	Clear(): void;
	static C(Other: UObject | any): ControlRigControlActor;
}

declare class ControlRigShapeActor extends Actor { 
	ActorRootComponent: SceneComponent;
	StaticMeshComponent: StaticMeshComponent;
	ControlRigIndex: number;
	ControlRig: ControlRig;
	ControlName: string;
	ShapeName: string;
	ColorParameterName: string;
	bSelected: boolean;
	bHovered: boolean;
	static GetDefaultObject(): ControlRigShapeActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigShapeActor;
	SetSelected(bInSelected: boolean): void;
	SetSelectable(bInSelectable: boolean): void;
	SetHovered(bInHovered: boolean): void;
	SetGlobalTransform(InTransform: Transform): void;
	SetEnabled(bInEnabled: boolean): void;
	OnTransformChanged(NewTransform: Transform): void;
	OnSelectionChanged(bIsSelected: boolean): void;
	OnManipulatingChanged(bIsManipulating: boolean): void;
	OnHoveredChanged(bIsSelected: boolean): void;
	OnEnabledChanged(bIsEnabled: boolean): void;
	IsSelectedInEditor(): boolean;
	IsHovered(): boolean;
	IsEnabled(): boolean;
	GetGlobalTransform(): Transform;
	static C(Other: UObject | any): ControlRigShapeActor;
}

declare class AdditiveControlRig extends ControlRig { 
	static Load(ResourceName: string): AdditiveControlRig;
	static Find(Outer: UObject, ResourceName: string): AdditiveControlRig;
	static GetDefaultObject(): AdditiveControlRig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AdditiveControlRig;
	static C(Other: UObject | any): AdditiveControlRig;
}

declare type EControlRigFKRigExecuteMode = 'Replace' | 'Additive' | 'Direct' | 'Max' | 'EControlRigFKRigExecuteMode_MAX';
declare var EControlRigFKRigExecuteMode : { Replace:'Replace',Additive:'Additive',Direct:'Direct',Max:'Max',EControlRigFKRigExecuteMode_MAX:'EControlRigFKRigExecuteMode_MAX', };
declare class FKControlRig extends ControlRig { 
	IsControlActive: boolean[];
	ApplyMode: EControlRigFKRigExecuteMode;
	static Load(ResourceName: string): FKControlRig;
	static Find(Outer: UObject, ResourceName: string): FKControlRig;
	static GetDefaultObject(): FKControlRig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FKControlRig;
	static C(Other: UObject | any): FKControlRig;
}

declare class ControlRigLayerInstance extends AnimInstance { 
	static Load(ResourceName: string): ControlRigLayerInstance;
	static Find(Outer: UObject, ResourceName: string): ControlRigLayerInstance;
	static GetDefaultObject(): ControlRigLayerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigLayerInstance;
	static C(Other: UObject | any): ControlRigLayerInstance;
}

declare class ControlRigObjectHolder extends UObject { 
	Objects: UObject[];
	static Load(ResourceName: string): ControlRigObjectHolder;
	static Find(Outer: UObject, ResourceName: string): ControlRigObjectHolder;
	static GetDefaultObject(): ControlRigObjectHolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigObjectHolder;
	static C(Other: UObject | any): ControlRigObjectHolder;
}

declare class ControlRigSequence extends LevelSequence { 
	LastExportedToAnimationSequence: AnimSequence;
	LastExportedUsingSkeletalMesh: SkeletalMesh;
	LastExportedFrameRate: number;
	static Load(ResourceName: string): ControlRigSequence;
	static Find(Outer: UObject, ResourceName: string): ControlRigSequence;
	static GetDefaultObject(): ControlRigSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigSequence;
	static C(Other: UObject | any): ControlRigSequence;
}

declare class ControlRigSettings extends DeveloperSettings { 
	DefaultShapeLibrary: ControlRigShapeLibrary;
	static Load(ResourceName: string): ControlRigSettings;
	static Find(Outer: UObject, ResourceName: string): ControlRigSettings;
	static GetDefaultObject(): ControlRigSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigSettings;
	static C(Other: UObject | any): ControlRigSettings;
}

declare class ControlRigSettingsPerPinBool { 
	Values: Map<string, boolean>;
	clone() : ControlRigSettingsPerPinBool;
	static C(Other: UObject | any): ControlRigSettingsPerPinBool;
}

declare class ControlRigEditorSettings extends DeveloperSettings { 
	bAutoLinkMutableNodes: boolean;
	bResetControlsOnCompile: boolean;
	bResetControlsOnPinValueInteraction: boolean;
	bEnableUndoForPoseInteraction: boolean;
	bResetControlTransformsOnCompile: boolean;
	RigUnitPinExpansion: Map<string, ControlRigSettingsPerPinBool>;
	ConstructionEventBorderColor: LinearColor;
	BackwardsSolveBorderColor: LinearColor;
	BackwardsAndForwardsBorderColor: LinearColor;
	bShowStackedHierarchy: boolean;
	MaxStackSize: number;
	NodeSnippet_1: string;
	NodeSnippet_2: string;
	NodeSnippet_3: string;
	NodeSnippet_4: string;
	NodeSnippet_5: string;
	NodeSnippet_6: string;
	NodeSnippet_7: string;
	NodeSnippet_8: string;
	NodeSnippet_9: string;
	NodeSnippet_0: string;
	static Load(ResourceName: string): ControlRigEditorSettings;
	static Find(Outer: UObject, ResourceName: string): ControlRigEditorSettings;
	static GetDefaultObject(): ControlRigEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigEditorSettings;
	static C(Other: UObject | any): ControlRigEditorSettings;
}

declare class RigControlCopy { 
	Name: string;
	ControlType: ERigControlType;
	Value: RigControlValue;
	ParentKey: RigElementKey;
	OffsetTransform: Transform;
	ParentTransform: Transform;
	LocalTransform: Transform;
	GlobalTransform: Transform;
	clone() : RigControlCopy;
	static C(Other: UObject | any): RigControlCopy;
}

declare class ControlRigControlPose { 
	CopyOfControls: RigControlCopy[];
	clone() : ControlRigControlPose;
	static C(Other: UObject | any): ControlRigControlPose;
}

declare class ControlRigPoseAsset extends UObject { 
	Pose: ControlRigControlPose;
	static Load(ResourceName: string): ControlRigPoseAsset;
	static Find(Outer: UObject, ResourceName: string): ControlRigPoseAsset;
	static GetDefaultObject(): ControlRigPoseAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigPoseAsset;
	SelectControls(InControlRig: ControlRig,bDoMirror: boolean): void;
	SavePose(InControlRig: ControlRig,bUseAll: boolean): void;
	ReplaceControlName(CurrentName: string,NewName: string): void;
	PastePose(InControlRig: ControlRig,bDoKey: boolean,bDoMirror: boolean): void;
	GetCurrentPose(InControlRig: ControlRig,OutPose?: ControlRigControlPose): {OutPose: ControlRigControlPose};
	GetControlNames(): string[];
	DoesMirrorMatch(ControlRig: ControlRig,ControlName: string): boolean;
	static C(Other: UObject | any): ControlRigPoseAsset;
}

declare class ControlRigPoseMirrorSettings extends UObject { 
	RightSide: string;
	LeftSide: string;
	MirrorAxis: EAxis;
	AxisToFlip: EAxis;
	static Load(ResourceName: string): ControlRigPoseMirrorSettings;
	static Find(Outer: UObject, ResourceName: string): ControlRigPoseMirrorSettings;
	static GetDefaultObject(): ControlRigPoseMirrorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigPoseMirrorSettings;
	static C(Other: UObject | any): ControlRigPoseMirrorSettings;
}

declare class ControlRigPoseProjectSettings extends UObject { 
	RootSaveDirs: DirectoryPath[];
	static Load(ResourceName: string): ControlRigPoseProjectSettings;
	static Find(Outer: UObject, ResourceName: string): ControlRigPoseProjectSettings;
	static GetDefaultObject(): ControlRigPoseProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigPoseProjectSettings;
	static C(Other: UObject | any): ControlRigPoseProjectSettings;
}

declare class ControlRigWorkflowOptions extends RigVMUserWorkflowOptions { 
	Hierarchy: RigHierarchy;
	USelection: RigElementKey[];
	static Load(ResourceName: string): ControlRigWorkflowOptions;
	static Find(Outer: UObject, ResourceName: string): ControlRigWorkflowOptions;
	static GetDefaultObject(): ControlRigWorkflowOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigWorkflowOptions;
	EnsureAtLeastOneRigElementSelected(): boolean;
	static C(Other: UObject | any): ControlRigWorkflowOptions;
}

declare type ERigTransformType = 'InitialLocal' | 'CurrentLocal' | 'InitialGlobal' | 'CurrentGlobal' | 'NumTransformTypes' | 'ERigTransformType_MAX';
declare var ERigTransformType : { InitialLocal:'InitialLocal',CurrentLocal:'CurrentLocal',InitialGlobal:'InitialGlobal',CurrentGlobal:'CurrentGlobal',NumTransformTypes:'NumTransformTypes',ERigTransformType_MAX:'ERigTransformType_MAX', };
declare class ControlRigTransformWorkflowOptions extends ControlRigWorkflowOptions { 
	TransformType: ERigTransformType;
	static Load(ResourceName: string): ControlRigTransformWorkflowOptions;
	static Find(Outer: UObject, ResourceName: string): ControlRigTransformWorkflowOptions;
	static GetDefaultObject(): ControlRigTransformWorkflowOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigTransformWorkflowOptions;
	ProvideWorkflows(InSubject: UObject): RigVMUserWorkflow[];
	static C(Other: UObject | any): ControlRigTransformWorkflowOptions;
}

declare class ControlRigNumericalValidationPass extends ControlRigValidationPass { 
	bCheckControls: boolean;
	bCheckBones: boolean;
	bCheckCurves: boolean;
	TranslationPrecision: number;
	RotationPrecision: number;
	ScalePrecision: number;
	CurvePrecision: number;
	EventNameA: string;
	EventNameB: string;
	Pose: RigPose;
	static Load(ResourceName: string): ControlRigNumericalValidationPass;
	static Find(Outer: UObject, ResourceName: string): ControlRigNumericalValidationPass;
	static GetDefaultObject(): ControlRigNumericalValidationPass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigNumericalValidationPass;
	static C(Other: UObject | any): ControlRigNumericalValidationPass;
}

declare class ControlRigIOSettings { 
	bUpdatePose: boolean;
	bUpdateCurves: boolean;
	clone() : ControlRigIOSettings;
	static C(Other: UObject | any): ControlRigIOSettings;
}

declare class ControlRigAnimNodeEventName { 
	EventName: string;
	clone() : ControlRigAnimNodeEventName;
	static C(Other: UObject | any): ControlRigAnimNodeEventName;
}

declare class AnimNode_ControlRigBase extends AnimNode_CustomProperty { 
	Source: PoseLink;
	bResetInputPoseToInitial: boolean;
	bTransferInputPose: boolean;
	bTransferInputCurves: boolean;
	bTransferPoseInGlobalSpace: boolean;
	InputBonesToTransfer: BoneReference[];
	NodeMappingContainer: NodeMappingContainer;
	InputSettings: ControlRigIOSettings;
	OutputSettings: ControlRigIOSettings;
	bExecute: boolean;
	EventQueue: ControlRigAnimNodeEventName[];
	clone() : AnimNode_ControlRigBase;
	static C(Other: UObject | any): AnimNode_ControlRigBase;
}

declare class AnimNode_ControlRig extends AnimNode_ControlRigBase { 
	ControlRigClass: UnrealEngineClass;
	ControlRig: ControlRig;
	Alpha: number;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	bSetRefPoseFromSkeleton: boolean;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	InputMapping: Map<string, string>;
	OutputMapping: Map<string, string>;
	LODThreshold: number;
	clone() : AnimNode_ControlRig;
	static C(Other: UObject | any): AnimNode_ControlRig;
}

declare class AnimGraphNode_ControlRig extends AnimGraphNode_CustomProperty { 
	UNode: AnimNode_ControlRig;
	static Load(ResourceName: string): AnimGraphNode_ControlRig;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ControlRig;
	static GetDefaultObject(): AnimGraphNode_ControlRig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ControlRig;
	static C(Other: UObject | any): AnimGraphNode_ControlRig;
}

declare class ControlRigGraphNode extends EdGraphNode { 
	ModelNodePath: string;
	CachedModelNode: RigVMNode;
	CachedModelPins: Map<string, RigVMPin>;
	PropertyName: string;
	StructPath: string;
	PinType: EdGraphPinType;
	ParameterType: number;
	ExpandedPins: string[];
	static Load(ResourceName: string): ControlRigGraphNode;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraphNode;
	static GetDefaultObject(): ControlRigGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraphNode;
	static C(Other: UObject | any): ControlRigGraphNode;
}

declare class ControlRigGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): ControlRigGraphSchema;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraphSchema;
	static GetDefaultObject(): ControlRigGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraphSchema;
	static C(Other: UObject | any): ControlRigGraphSchema;
}

declare type EIKRigGoalTransformSource = 'Manual' | 'Bone' | 'ActorComponent' | 'EIKRigGoalTransformSource_MAX';
declare var EIKRigGoalTransformSource : { Manual:'Manual',Bone:'Bone',ActorComponent:'ActorComponent',EIKRigGoalTransformSource_MAX:'EIKRigGoalTransformSource_MAX', };
declare type EIKRigGoalSpace = 'Component' | 'Additive' | 'World' | 'EIKRigGoalSpace_MAX';
declare var EIKRigGoalSpace : { Component:'Component',Additive:'Additive',World:'World',EIKRigGoalSpace_MAX:'EIKRigGoalSpace_MAX', };
declare class IKRigGoal { 
	Name: string;
	TransformSource: EIKRigGoalTransformSource;
	SourceBone: BoneReference;
	Position: Vector;
	Rotation: Rotator;
	PositionAlpha: number;
	RotationAlpha: number;
	PositionSpace: EIKRigGoalSpace;
	RotationSpace: EIKRigGoalSpace;
	FinalBlendedPosition: Vector;
	FinalBlendedRotation: Quat;
	clone() : IKRigGoal;
	static C(Other: UObject | any): IKRigGoal;
}

declare class IKGoalCreatorInterface extends Interface { 
	static Load(ResourceName: string): IKGoalCreatorInterface;
	static Find(Outer: UObject, ResourceName: string): IKGoalCreatorInterface;
	static GetDefaultObject(): IKGoalCreatorInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKGoalCreatorInterface;
	AddIKGoals(OutGoals?: Map<string, IKRigGoal>): {OutGoals: Map<string, IKRigGoal>};
	static C(Other: UObject | any): IKGoalCreatorInterface;
}

declare class IKRigComponent extends ActorComponent { 
	static Load(ResourceName: string): IKRigComponent;
	static Find(Outer: UObject, ResourceName: string): IKRigComponent;
	static GetDefaultObject(): IKRigComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigComponent;
	SetIKRigGoalTransform(GoalName: string,Transform: Transform,PositionAlpha: number,RotationAlpha: number): void;
	SetIKRigGoalPositionAndRotation(GoalName: string,Position: Vector,Rotation: Quat,PositionAlpha: number,RotationAlpha: number): void;
	SetIKRigGoal(Goal: IKRigGoal): void;
	ClearAllGoals(): void;
	static C(Other: UObject | any): IKRigComponent;
}

declare type EIKRigGoalPreviewMode = 'Additive' | 'Absolute' | 'EIKRigGoalPreviewMode_MAX';
declare var EIKRigGoalPreviewMode : { Additive:'Additive',Absolute:'Absolute',EIKRigGoalPreviewMode_MAX:'EIKRigGoalPreviewMode_MAX', };
declare class IKRigEffectorGoal extends UObject { 
	GoalName: string;
	BoneName: string;
	PositionAlpha: number;
	RotationAlpha: number;
	CurrentTransform: Transform;
	InitialTransform: Transform;
	PreviewMode: EIKRigGoalPreviewMode;
	SizeMultiplier: number;
	ThicknessMultiplier: number;
	bExposePosition: boolean;
	bExposeRotation: boolean;
	static Load(ResourceName: string): IKRigEffectorGoal;
	static Find(Outer: UObject, ResourceName: string): IKRigEffectorGoal;
	static GetDefaultObject(): IKRigEffectorGoal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigEffectorGoal;
	static C(Other: UObject | any): IKRigEffectorGoal;
}

declare class IKRigSkeleton { 
	BoneNames: string[];
	ParentIndices: number[];
	ExcludedBones: string[];
	CurrentPoseGlobal: Transform[];
	CurrentPoseLocal: Transform[];
	RefPoseGlobal: Transform[];
	clone() : IKRigSkeleton;
	static C(Other: UObject | any): IKRigSkeleton;
}

declare class IKRigSolver extends UObject { 
	bIsEnabled: boolean;
	static Load(ResourceName: string): IKRigSolver;
	static Find(Outer: UObject, ResourceName: string): IKRigSolver;
	static GetDefaultObject(): IKRigSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigSolver;
	static C(Other: UObject | any): IKRigSolver;
}

declare class BoneChain { 
	ChainName: string;
	StartBone: BoneReference;
	EndBone: BoneReference;
	IKGoalName: string;
	clone() : BoneChain;
	static C(Other: UObject | any): BoneChain;
}

declare class RetargetDefinition { 
	RootBone: string;
	BoneChains: BoneChain[];
	clone() : RetargetDefinition;
	static C(Other: UObject | any): RetargetDefinition;
}

declare class IKRigDefinition extends UObject { 
	PreviewSkeletalMesh: SkeletalMesh;
	BoneSize: number;
	DrawGoals: boolean;
	GoalSize: number;
	GoalThickness: number;
	Controller: UObject;
	Skeleton: IKRigSkeleton;
	Goals: IKRigEffectorGoal[];
	Solvers: IKRigSolver[];
	RetargetDefinition: RetargetDefinition;
	static Load(ResourceName: string): IKRigDefinition;
	static Find(Outer: UObject, ResourceName: string): IKRigDefinition;
	static GetDefaultObject(): IKRigDefinition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigDefinition;
	static C(Other: UObject | any): IKRigDefinition;
}

declare class IKRigProcessor extends UObject { 
	Solvers: IKRigSolver[];
	static Load(ResourceName: string): IKRigProcessor;
	static Find(Outer: UObject, ResourceName: string): IKRigProcessor;
	static GetDefaultObject(): IKRigProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigProcessor;
	static C(Other: UObject | any): IKRigProcessor;
}

declare type ERetargetRotationMode = 'Interpolated' | 'OneToOne' | 'OneToOneReversed' | 'None' | 'ERetargetRotationMode_MAX';
declare var ERetargetRotationMode : { Interpolated:'Interpolated',OneToOne:'OneToOne',OneToOneReversed:'OneToOneReversed',None:'None',ERetargetRotationMode_MAX:'ERetargetRotationMode_MAX', };
declare type ERetargetTranslationMode = 'None' | 'GloballyScaled' | 'Absolute' | 'ERetargetTranslationMode_MAX';
declare var ERetargetTranslationMode : { None:'None',GloballyScaled:'GloballyScaled',Absolute:'Absolute',ERetargetTranslationMode_MAX:'ERetargetTranslationMode_MAX', };
declare class TargetChainFKSettings { 
	EnableFK: boolean;
	RotationMode: ERetargetRotationMode;
	RotationAlpha: number;
	TranslationMode: ERetargetTranslationMode;
	TranslationAlpha: number;
	PoleVectorMatching: number;
	PoleVectorOffset: number;
	clone() : TargetChainFKSettings;
	static C(Other: UObject | any): TargetChainFKSettings;
}

declare class TargetChainIKSettings { 
	EnableIK: boolean;
	BlendToSource: number;
	BlendToSourceWeights: Vector;
	StaticOffset: Vector;
	StaticLocalOffset: Vector;
	StaticRotationOffset: Rotator;
	Extension: number;
	bAffectedByIKWarping: boolean;
	clone() : TargetChainIKSettings;
	static C(Other: UObject | any): TargetChainIKSettings;
}

declare class TargetChainSpeedPlantSettings { 
	EnableSpeedPlanting: boolean;
	SpeedCurveName: string;
	SpeedThreshold: number;
	UnplantStiffness: number;
	UnplantCriticalDamping: number;
	clone() : TargetChainSpeedPlantSettings;
	static C(Other: UObject | any): TargetChainSpeedPlantSettings;
}

declare class TargetChainSettings { 
	FK: TargetChainFKSettings;
	IK: TargetChainIKSettings;
	SpeedPlanting: TargetChainSpeedPlantSettings;
	clone() : TargetChainSettings;
	static C(Other: UObject | any): TargetChainSettings;
}

declare class RetargetChainSettings extends UObject { 
	SourceChain: string;
	TargetChain: string;
	Settings: TargetChainSettings;
	CopyPoseUsingFK: boolean;
	RotationMode: ERetargetRotationMode;
	RotationAlpha: number;
	TranslationMode: ERetargetTranslationMode;
	TranslationAlpha: number;
	DriveIKGoal: boolean;
	BlendToSource: number;
	BlendToSourceWeights: Vector;
	StaticOffset: Vector;
	StaticLocalOffset: Vector;
	StaticRotationOffset: Rotator;
	Extension: number;
	UseSpeedCurveToPlantIK: boolean;
	SpeedCurveName: string;
	VelocityThreshold: number;
	UnplantStiffness: number;
	UnplantCriticalDamping: number;
	static Load(ResourceName: string): RetargetChainSettings;
	static Find(Outer: UObject, ResourceName: string): RetargetChainSettings;
	static GetDefaultObject(): RetargetChainSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RetargetChainSettings;
	static C(Other: UObject | any): RetargetChainSettings;
}

declare class TargetRootSettings { 
	RotationAlpha: number;
	TranslationAlpha: number;
	BlendToSource: number;
	BlendToSourceWeights: Vector;
	ScaleHorizontal: number;
	ScaleVertical: number;
	TranslationOffset: Vector;
	RotationOffset: Rotator;
	AffectIKHorizontal: number;
	AffectIKVertical: number;
	clone() : TargetRootSettings;
	static C(Other: UObject | any): TargetRootSettings;
}

declare class RetargetRootSettings extends UObject { 
	Settings: TargetRootSettings;
	RetargetRootTranslation: boolean;
	GlobalScaleHorizontal: number;
	GlobalScaleVertical: number;
	BlendToSource: Vector;
	StaticOffset: Vector;
	StaticRotationOffset: Rotator;
	static Load(ResourceName: string): RetargetRootSettings;
	static Find(Outer: UObject, ResourceName: string): RetargetRootSettings;
	static GetDefaultObject(): RetargetRootSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RetargetRootSettings;
	static C(Other: UObject | any): RetargetRootSettings;
}

declare type EWarpingDirectionSource = 'Goals' | 'Chain' | 'EWarpingDirectionSource_MAX';
declare var EWarpingDirectionSource : { Goals:'Goals',Chain:'Chain',EWarpingDirectionSource_MAX:'EWarpingDirectionSource_MAX', };
declare type EBasicAxis = 'X' | 'Y' | 'Z' | 'NegX' | 'NegY' | 'NegZ' | 'EBasicAxis_MAX';
declare var EBasicAxis : { X:'X',Y:'Y',Z:'Z',NegX:'NegX',NegY:'NegY',NegZ:'NegZ',EBasicAxis_MAX:'EBasicAxis_MAX', };
declare class RetargetGlobalSettings { 
	bEnableRoot: boolean;
	bEnableFK: boolean;
	bEnableIK: boolean;
	bWarping: boolean;
	DirectionSource: EWarpingDirectionSource;
	ForwardDirection: EBasicAxis;
	DirectionChain: string;
	WarpForwards: number;
	SidewaysOffset: number;
	WarpSplay: number;
	clone() : RetargetGlobalSettings;
	static C(Other: UObject | any): RetargetGlobalSettings;
}

declare class IKRetargetGlobalSettings extends UObject { 
	Settings: RetargetGlobalSettings;
	static Load(ResourceName: string): IKRetargetGlobalSettings;
	static Find(Outer: UObject, ResourceName: string): IKRetargetGlobalSettings;
	static GetDefaultObject(): IKRetargetGlobalSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRetargetGlobalSettings;
	static C(Other: UObject | any): IKRetargetGlobalSettings;
}

declare class RetargetChainMap { 
	SourceChain: string;
	TargetChain: string;
	clone() : RetargetChainMap;
	static C(Other: UObject | any): RetargetChainMap;
}

declare class RetargetProfile { 
	bApplyTargetRetargetPose: boolean;
	TargetRetargetPoseName: string;
	bApplySourceRetargetPose: boolean;
	SourceRetargetPoseName: string;
	bApplyChainSettings: boolean;
	ChainSettings: Map<string, TargetChainSettings>;
	bApplyRootSettings: boolean;
	RootSettings: TargetRootSettings;
	bApplyGlobalSettings: boolean;
	GlobalSettings: RetargetGlobalSettings;
	clone() : RetargetProfile;
	static C(Other: UObject | any): RetargetProfile;
}

declare class IKRetargetPose { 
	RootTranslationOffset: Vector;
	BoneRotationOffsets: Map<string, Quat>;
	clone() : IKRetargetPose;
	static C(Other: UObject | any): IKRetargetPose;
}

declare class IKRetargeter extends UObject { 
	SourceIKRigAsset: IKRigDefinition;
	SourcePreviewMesh: SkeletalMesh;
	TargetIKRigAsset: IKRigDefinition;
	TargetPreviewMesh: SkeletalMesh;
	bRetargetRoot: boolean;
	bRetargetFK: boolean;
	bRetargetIK: boolean;
	TargetActorOffset: number;
	TargetActorScale: number;
	TargetMeshOffset: Vector;
	TargetMeshScale: number;
	SourceMeshOffset: Vector;
	bDebugDraw: boolean;
	bDrawFinalGoals: boolean;
	bDrawSourceLocations: boolean;
	ChainDrawSize: number;
	ChainDrawThickness: number;
	BoneDrawSize: number;
	Controller: UObject;
	MeshesAskedToFixRootHeightFor: Set<SkeletalMesh>;
	ChainMapping: RetargetChainMap[];
	ChainSettings: RetargetChainSettings[];
	RootSettings: RetargetRootSettings;
	GlobalSettings: IKRetargetGlobalSettings;
	Profiles: Map<string, RetargetProfile>;
	CurrentProfile: string;
	SourceRetargetPoses: Map<string, IKRetargetPose>;
	TargetRetargetPoses: Map<string, IKRetargetPose>;
	CurrentSourceRetargetPose: string;
	CurrentTargetRetargetPose: string;
	RetargetPoses: Map<string, IKRetargetPose>;
	CurrentRetargetPose: string;
	static Load(ResourceName: string): IKRetargeter;
	static Find(Outer: UObject, ResourceName: string): IKRetargeter;
	static GetDefaultObject(): IKRetargeter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRetargeter;
	static SetRootSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,RootSettings?: TargetRootSettings): {RetargetProfile: RetargetProfile};
	static SetGlobalSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,GlobalSettings?: RetargetGlobalSettings): {RetargetProfile: RetargetProfile};
	static SetChainSpeedPlantSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,SpeedPlantSettings?: TargetChainSpeedPlantSettings,TargetChainName?: string): {RetargetProfile: RetargetProfile};
	static SetChainSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,ChainSettings?: TargetChainSettings,TargetChainName?: string): {RetargetProfile: RetargetProfile};
	static SetChainIKSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,IKSettings?: TargetChainIKSettings,TargetChainName?: string): {RetargetProfile: RetargetProfile};
	static SetChainFKSettingsInRetargetProfile(RetargetProfile?: RetargetProfile,FKSettings?: TargetChainFKSettings,TargetChainName?: string): {RetargetProfile: RetargetProfile};
	static GetRootSettingsFromRetargetProfile(RetargetProfile?: RetargetProfile): {RetargetProfile: RetargetProfile, $: TargetRootSettings};
	static GetRootSettingsFromRetargetAsset(RetargetAsset: IKRetargeter,OptionalProfileName: string,OutSettings?: TargetRootSettings): {OutSettings: TargetRootSettings};
	static GetGlobalSettingsFromRetargetProfile(RetargetProfile?: RetargetProfile): {RetargetProfile: RetargetProfile, $: RetargetGlobalSettings};
	static GetGlobalSettingsFromRetargetAsset(RetargetAsset: IKRetargeter,OptionalProfileName: string,OutSettings?: RetargetGlobalSettings): {OutSettings: RetargetGlobalSettings};
	static GetChainUsingGoalFromRetargetAsset(RetargetAsset: IKRetargeter,IKGoalName: string): TargetChainSettings;
	static GetChainSettingsFromRetargetProfile(RetargetProfile?: RetargetProfile,TargetChainName?: string): {RetargetProfile: RetargetProfile, $: TargetChainSettings};
	static GetChainSettingsFromRetargetAsset(RetargetAsset: IKRetargeter,TargetChainName: string,OptionalProfileName: string): TargetChainSettings;
	static C(Other: UObject | any): IKRetargeter;
}

declare class IKRetargetProcessor extends UObject { 
	IKRigProcessor: IKRigProcessor;
	static Load(ResourceName: string): IKRetargetProcessor;
	static Find(Outer: UObject, ResourceName: string): IKRetargetProcessor;
	static GetDefaultObject(): IKRetargetProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRetargetProcessor;
	static C(Other: UObject | any): IKRetargetProcessor;
}

declare class IKRig_BodyMoverEffector extends UObject { 
	GoalName: string;
	BoneName: string;
	InfluenceMultiplier: number;
	static Load(ResourceName: string): IKRig_BodyMoverEffector;
	static Find(Outer: UObject, ResourceName: string): IKRig_BodyMoverEffector;
	static GetDefaultObject(): IKRig_BodyMoverEffector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_BodyMoverEffector;
	static C(Other: UObject | any): IKRig_BodyMoverEffector;
}

declare class IKRig_BodyMover extends IKRigSolver { 
	RootBone: string;
	PositionAlpha: number;
	PositionPositiveX: number;
	PositionNegativeX: number;
	PositionPositiveY: number;
	PositionNegativeY: number;
	PositionPositiveZ: number;
	PositionNegativeZ: number;
	RotationAlpha: number;
	RotateXAlpha: number;
	RotateYAlpha: number;
	RotateZAlpha: number;
	Effectors: IKRig_BodyMoverEffector[];
	static Load(ResourceName: string): IKRig_BodyMover;
	static Find(Outer: UObject, ResourceName: string): IKRig_BodyMover;
	static GetDefaultObject(): IKRig_BodyMover;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_BodyMover;
	static C(Other: UObject | any): IKRig_BodyMover;
}

declare class IKRig_LimbEffector extends UObject { 
	GoalName: string;
	BoneName: string;
	static Load(ResourceName: string): IKRig_LimbEffector;
	static Find(Outer: UObject, ResourceName: string): IKRig_LimbEffector;
	static GetDefaultObject(): IKRig_LimbEffector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_LimbEffector;
	static C(Other: UObject | any): IKRig_LimbEffector;
}

declare class IKRig_LimbSolver extends IKRigSolver { 
	RootName: string;
	ReachPrecision: number;
	HingeRotationAxis: EAxis;
	MaxIterations: number;
	bEnableLimit: boolean;
	MinRotationAngle: number;
	bAveragePull: boolean;
	PullDistribution: number;
	ReachStepAlpha: number;
	bEnableTwistCorrection: boolean;
	EndBoneForwardAxis: EAxis;
	Effector: IKRig_LimbEffector;
	static Load(ResourceName: string): IKRig_LimbSolver;
	static Find(Outer: UObject, ResourceName: string): IKRig_LimbSolver;
	static GetDefaultObject(): IKRig_LimbSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_LimbSolver;
	static C(Other: UObject | any): IKRig_LimbSolver;
}

declare class IKRig_FBIKEffector extends UObject { 
	GoalName: string;
	BoneName: string;
	StrengthAlpha: number;
	PullChainAlpha: number;
	PinRotation: number;
	IndexInSolver: number;
	static Load(ResourceName: string): IKRig_FBIKEffector;
	static Find(Outer: UObject, ResourceName: string): IKRig_FBIKEffector;
	static GetDefaultObject(): IKRig_FBIKEffector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_FBIKEffector;
	static C(Other: UObject | any): IKRig_FBIKEffector;
}

declare type EPBIKLimitType = 'Free' | 'Limited' | 'Locked' | 'EPBIKLimitType_MAX';
declare var EPBIKLimitType : { Free:'Free',Limited:'Limited',Locked:'Locked',EPBIKLimitType_MAX:'EPBIKLimitType_MAX', };
declare class IKRig_PBIKBoneSettings extends UObject { 
	bone: string;
	RotationStiffness: number;
	PositionStiffness: number;
	X: EPBIKLimitType;
	MinX: number;
	MaxX: number;
	Y: EPBIKLimitType;
	MinY: number;
	MaxY: number;
	Z: EPBIKLimitType;
	MinZ: number;
	MaxZ: number;
	bUsePreferredAngles: boolean;
	PreferredAngles: Vector;
	static Load(ResourceName: string): IKRig_PBIKBoneSettings;
	static Find(Outer: UObject, ResourceName: string): IKRig_PBIKBoneSettings;
	static GetDefaultObject(): IKRig_PBIKBoneSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_PBIKBoneSettings;
	static C(Other: UObject | any): IKRig_PBIKBoneSettings;
}

declare type EPBIKRootBehavior = 'PrePull' | 'PinToInput' | 'Free' | 'EPBIKRootBehavior_MAX';
declare var EPBIKRootBehavior : { PrePull:'PrePull',PinToInput:'PinToInput',Free:'Free',EPBIKRootBehavior_MAX:'EPBIKRootBehavior_MAX', };
declare class IKRigPBIKSolver extends IKRigSolver { 
	RootBone: string;
	Iterations: number;
	MassMultiplier: number;
	MinMassMultiplier: number;
	bAllowStretch: boolean;
	RootBehavior: EPBIKRootBehavior;
	bStartSolveFromInputPose: boolean;
	Effectors: IKRig_FBIKEffector[];
	BoneSettings: IKRig_PBIKBoneSettings[];
	static Load(ResourceName: string): IKRigPBIKSolver;
	static Find(Outer: UObject, ResourceName: string): IKRigPBIKSolver;
	static GetDefaultObject(): IKRigPBIKSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRigPBIKSolver;
	static C(Other: UObject | any): IKRigPBIKSolver;
}

declare class IKRig_PoleSolverEffector extends UObject { 
	GoalName: string;
	BoneName: string;
	Alpha: number;
	static Load(ResourceName: string): IKRig_PoleSolverEffector;
	static Find(Outer: UObject, ResourceName: string): IKRig_PoleSolverEffector;
	static GetDefaultObject(): IKRig_PoleSolverEffector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_PoleSolverEffector;
	static C(Other: UObject | any): IKRig_PoleSolverEffector;
}

declare class IKRig_PoleSolver extends IKRigSolver { 
	RootName: string;
	EndName: string;
	Effector: IKRig_PoleSolverEffector;
	static Load(ResourceName: string): IKRig_PoleSolver;
	static Find(Outer: UObject, ResourceName: string): IKRig_PoleSolver;
	static GetDefaultObject(): IKRig_PoleSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_PoleSolver;
	static C(Other: UObject | any): IKRig_PoleSolver;
}

declare class IKRig_SetTransformEffector extends UObject { 
	bEnablePosition: boolean;
	bEnableRotation: boolean;
	Alpha: number;
	static Load(ResourceName: string): IKRig_SetTransformEffector;
	static Find(Outer: UObject, ResourceName: string): IKRig_SetTransformEffector;
	static GetDefaultObject(): IKRig_SetTransformEffector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_SetTransformEffector;
	static C(Other: UObject | any): IKRig_SetTransformEffector;
}

declare class IKRig_SetTransform extends IKRigSolver { 
	Goal: string;
	RootBone: string;
	Effector: IKRig_SetTransformEffector;
	static Load(ResourceName: string): IKRig_SetTransform;
	static Find(Outer: UObject, ResourceName: string): IKRig_SetTransform;
	static GetDefaultObject(): IKRig_SetTransform;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IKRig_SetTransform;
	static C(Other: UObject | any): IKRig_SetTransform;
}

declare class AnimNode_IKRig extends AnimNode_CustomProperty { 
	Source: PoseLink;
	RigDefinitionAsset: IKRigDefinition;
	Goals: IKRigGoal[];
	bStartFromRefPose: boolean;
	bEnableDebugDraw: boolean;
	DebugScale: number;
	AlphaInputType: EAnimAlphaInputType;
	bAlphaBoolEnabled: boolean;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	AlphaBoolBlend: InputAlphaBoolBlend;
	AlphaCurveName: string;
	AlphaScaleBiasClamp: InputScaleBiasClamp;
	IKRigProcessor: IKRigProcessor;
	ActualAlpha: number;
	clone() : AnimNode_IKRig;
	static C(Other: UObject | any): AnimNode_IKRig;
}

declare class AnimGraphNode_IKRig extends AnimGraphNode_CustomProperty { 
	UNode: AnimNode_IKRig;
	static Load(ResourceName: string): AnimGraphNode_IKRig;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_IKRig;
	static GetDefaultObject(): AnimGraphNode_IKRig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_IKRig;
	static C(Other: UObject | any): AnimGraphNode_IKRig;
}

declare class AnimNode_RetargetPoseFromMesh extends AnimNode_Base { 
	SourceMeshComponent: SkeletalMeshComponent;
	bUseAttachedParent: boolean;
	IKRetargeterAsset: IKRetargeter;
	CustomRetargetProfile: RetargetProfile;
	bSuppressWarnings: boolean;
	bCopyCurves: boolean;
	Processor: IKRetargetProcessor;
	clone() : AnimNode_RetargetPoseFromMesh;
	static C(Other: UObject | any): AnimNode_RetargetPoseFromMesh;
}

declare class AnimGraphNode_RetargetPoseFromMesh extends AnimGraphNode_Base { 
	UNode: AnimNode_RetargetPoseFromMesh;
	static Load(ResourceName: string): AnimGraphNode_RetargetPoseFromMesh;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RetargetPoseFromMesh;
	static GetDefaultObject(): AnimGraphNode_RetargetPoseFromMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RetargetPoseFromMesh;
	static C(Other: UObject | any): AnimGraphNode_RetargetPoseFromMesh;
}

declare class AudioAnalyzerAssetBase extends UObject { 
	static Load(ResourceName: string): AudioAnalyzerAssetBase;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzerAssetBase;
	static GetDefaultObject(): AudioAnalyzerAssetBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzerAssetBase;
	static C(Other: UObject | any): AudioAnalyzerAssetBase;
}

declare class AudioAnalyzerSettings extends AudioAnalyzerAssetBase { 
	static Load(ResourceName: string): AudioAnalyzerSettings;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzerSettings;
	static GetDefaultObject(): AudioAnalyzerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzerSettings;
	static C(Other: UObject | any): AudioAnalyzerSettings;
}

declare class AudioAnalyzerSubsystem extends EngineSubsystem { 
	AudioAnalyzers: AudioAnalyzer[];
	static Load(ResourceName: string): AudioAnalyzerSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzerSubsystem;
	static GetDefaultObject(): AudioAnalyzerSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzerSubsystem;
	static C(Other: UObject | any): AudioAnalyzerSubsystem;
}

declare class AudioAnalyzer extends UObject { 
	AudioBus: AudioBus;
	AudioAnalyzerSubsystem: AudioAnalyzerSubsystem;
	static Load(ResourceName: string): AudioAnalyzer;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzer;
	static GetDefaultObject(): AudioAnalyzer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzer;
	StopAnalyzing(WorldContextObject: UObject): void;
	StartAnalyzing(WorldContextObject: UObject,AudioBusToAnalyze: AudioBus): void;
	static C(Other: UObject | any): AudioAnalyzer;
}

declare class AudioAnalyzerNRTSettings extends AudioAnalyzerAssetBase { 
	static Load(ResourceName: string): AudioAnalyzerNRTSettings;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzerNRTSettings;
	static GetDefaultObject(): AudioAnalyzerNRTSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzerNRTSettings;
	static C(Other: UObject | any): AudioAnalyzerNRTSettings;
}

declare class AudioAnalyzerNRT extends AudioAnalyzerAssetBase { 
	Sound: SoundWave;
	DurationInSeconds: number;
	static Load(ResourceName: string): AudioAnalyzerNRT;
	static Find(Outer: UObject, ResourceName: string): AudioAnalyzerNRT;
	static GetDefaultObject(): AudioAnalyzerNRT;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioAnalyzerNRT;
	AnalyzeAudio(): void;
	static C(Other: UObject | any): AudioAnalyzerNRT;
}

declare class AudioSynesthesiaSettings extends AudioAnalyzerSettings { 
	static Load(ResourceName: string): AudioSynesthesiaSettings;
	static Find(Outer: UObject, ResourceName: string): AudioSynesthesiaSettings;
	static GetDefaultObject(): AudioSynesthesiaSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSynesthesiaSettings;
	static C(Other: UObject | any): AudioSynesthesiaSettings;
}

declare class SynesthesiaSpectrumAnalysisSettings extends AudioSynesthesiaSettings { 
	AnalysisPeriod: number;
	FFTSize: EFFTSize;
	SpectrumType: EAudioSpectrumType;
	WindowType: EFFTWindowType;
	bDownmixToMono: boolean;
	static Load(ResourceName: string): SynesthesiaSpectrumAnalysisSettings;
	static Find(Outer: UObject, ResourceName: string): SynesthesiaSpectrumAnalysisSettings;
	static GetDefaultObject(): SynesthesiaSpectrumAnalysisSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynesthesiaSpectrumAnalysisSettings;
	static C(Other: UObject | any): SynesthesiaSpectrumAnalysisSettings;
}

declare class SynesthesiaSpectrumResults { 
	TimeSeconds: number;
	SpectrumValues: number[];
	clone() : SynesthesiaSpectrumResults;
	static C(Other: UObject | any): SynesthesiaSpectrumResults;
}

declare class SynesthesiaSpectrumAnalyzer extends AudioAnalyzer { 
	Settings: SynesthesiaSpectrumAnalysisSettings;
	OnSpectrumResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, SpectrumResults: SynesthesiaSpectrumResults[]) => void>;
	OnLatestSpectrumResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, LatestSpectrumResults: SynesthesiaSpectrumResults) => void>;
	static Load(ResourceName: string): SynesthesiaSpectrumAnalyzer;
	static Find(Outer: UObject, ResourceName: string): SynesthesiaSpectrumAnalyzer;
	static GetDefaultObject(): SynesthesiaSpectrumAnalyzer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynesthesiaSpectrumAnalyzer;
	GetNumCenterFrequencies(): number;
	GetCenterFrequencies(InSampleRate: number,OutCenterFrequencies?: number[]): {OutCenterFrequencies: number[]};
	static C(Other: UObject | any): SynesthesiaSpectrumAnalyzer;
}

declare class AudioSynesthesiaNRTSettings extends AudioAnalyzerNRTSettings { 
	static Load(ResourceName: string): AudioSynesthesiaNRTSettings;
	static Find(Outer: UObject, ResourceName: string): AudioSynesthesiaNRTSettings;
	static GetDefaultObject(): AudioSynesthesiaNRTSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSynesthesiaNRTSettings;
	static C(Other: UObject | any): AudioSynesthesiaNRTSettings;
}

declare class AudioSynesthesiaNRT extends AudioAnalyzerNRT { 
	static Load(ResourceName: string): AudioSynesthesiaNRT;
	static Find(Outer: UObject, ResourceName: string): AudioSynesthesiaNRT;
	static GetDefaultObject(): AudioSynesthesiaNRT;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSynesthesiaNRT;
	static C(Other: UObject | any): AudioSynesthesiaNRT;
}

declare type EConstantQFFTSizeEnum = 'Min' | 'XXSmall' | 'XSmall' | 'Small' | 'Medium' | 'Large' | 'XLarge' | 'XXLarge' | 'Max' | 'EConstantQFFTSizeEnum_MAX';
declare var EConstantQFFTSizeEnum : { Min:'Min',XXSmall:'XXSmall',XSmall:'XSmall',Small:'Small',Medium:'Medium',Large:'Large',XLarge:'XLarge',XXLarge:'XXLarge',Max:'Max',EConstantQFFTSizeEnum_MAX:'EConstantQFFTSizeEnum_MAX', };
declare type EConstantQNormalizationEnum = 'EqualEuclideanNorm' | 'EqualEnergy' | 'EqualAmplitude' | 'EConstantQNormalizationEnum_MAX';
declare var EConstantQNormalizationEnum : { EqualEuclideanNorm:'EqualEuclideanNorm',EqualEnergy:'EqualEnergy',EqualAmplitude:'EqualAmplitude',EConstantQNormalizationEnum_MAX:'EConstantQNormalizationEnum_MAX', };
declare class ConstantQNRTSettings extends AudioSynesthesiaNRTSettings { 
	StartingFrequency: number;
	NumBands: number;
	NumBandsPerOctave: number;
	AnalysisPeriod: number;
	bDownmixToMono: boolean;
	FFTSize: EConstantQFFTSizeEnum;
	WindowType: EFFTWindowType;
	SpectrumType: EAudioSpectrumType;
	BandWidthStretch: number;
	CQTNormalization: EConstantQNormalizationEnum;
	NoiseFloorDb: number;
	static Load(ResourceName: string): ConstantQNRTSettings;
	static Find(Outer: UObject, ResourceName: string): ConstantQNRTSettings;
	static GetDefaultObject(): ConstantQNRTSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstantQNRTSettings;
	static C(Other: UObject | any): ConstantQNRTSettings;
}

declare class ConstantQNRT extends AudioSynesthesiaNRT { 
	Settings: ConstantQNRTSettings;
	static Load(ResourceName: string): ConstantQNRT;
	static Find(Outer: UObject, ResourceName: string): ConstantQNRT;
	static GetDefaultObject(): ConstantQNRT;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstantQNRT;
	GetNormalizedChannelConstantQAtTime(InSeconds: number,InChannel: number,OutConstantQ?: number[]): {OutConstantQ: number[]};
	GetChannelConstantQAtTime(InSeconds: number,InChannel: number,OutConstantQ?: number[]): {OutConstantQ: number[]};
	static C(Other: UObject | any): ConstantQNRT;
}

declare type ELoudnessCurveTypeEnum = 'A' | 'B' | 'C' | 'D' | 'None' | 'ELoudnessCurveTypeEnum_MAX';
declare var ELoudnessCurveTypeEnum : { A:'A',B:'B',C:'C',D:'D',None:'None',ELoudnessCurveTypeEnum_MAX:'ELoudnessCurveTypeEnum_MAX', };
declare class LoudnessSettings extends AudioSynesthesiaSettings { 
	AnalysisPeriod: number;
	MinimumFrequency: number;
	MaximumFrequency: number;
	CurveType: ELoudnessCurveTypeEnum;
	NoiseFloorDb: number;
	ExpectedMaxLoudness: number;
	static Load(ResourceName: string): LoudnessSettings;
	static Find(Outer: UObject, ResourceName: string): LoudnessSettings;
	static GetDefaultObject(): LoudnessSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LoudnessSettings;
	static C(Other: UObject | any): LoudnessSettings;
}

declare class LoudnessResults { 
	Loudness: number;
	NormalizedLoudness: number;
	PerceptualEnergy: number;
	TimeSeconds: number;
	clone() : LoudnessResults;
	static C(Other: UObject | any): LoudnessResults;
}

declare class LoudnessAnalyzer extends AudioAnalyzer { 
	Settings: LoudnessSettings;
	OnOverallLoudnessResults: UnrealEngineMulticastDelegate<(OverallLoudnessResults: LoudnessResults[]) => void>;
	OnPerChannelLoudnessResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, LoudnessResults: LoudnessResults[]) => void>;
	OnLatestOverallLoudnessResults: UnrealEngineMulticastDelegate<(LatestOverallLoudnessResults: LoudnessResults) => void>;
	OnLatestPerChannelLoudnessResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, LatestLoudnessResults: LoudnessResults) => void>;
	static Load(ResourceName: string): LoudnessAnalyzer;
	static Find(Outer: UObject, ResourceName: string): LoudnessAnalyzer;
	static GetDefaultObject(): LoudnessAnalyzer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LoudnessAnalyzer;
	static C(Other: UObject | any): LoudnessAnalyzer;
}

declare type ELoudnessNRTCurveTypeEnum = 'A' | 'B' | 'C' | 'D' | 'None' | 'ELoudnessNRTCurveTypeEnum_MAX';
declare var ELoudnessNRTCurveTypeEnum : { A:'A',B:'B',C:'C',D:'D',None:'None',ELoudnessNRTCurveTypeEnum_MAX:'ELoudnessNRTCurveTypeEnum_MAX', };
declare class LoudnessNRTSettings extends AudioSynesthesiaNRTSettings { 
	AnalysisPeriod: number;
	MinimumFrequency: number;
	MaximumFrequency: number;
	CurveType: ELoudnessNRTCurveTypeEnum;
	NoiseFloorDb: number;
	static Load(ResourceName: string): LoudnessNRTSettings;
	static Find(Outer: UObject, ResourceName: string): LoudnessNRTSettings;
	static GetDefaultObject(): LoudnessNRTSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LoudnessNRTSettings;
	static C(Other: UObject | any): LoudnessNRTSettings;
}

declare class LoudnessNRT extends AudioSynesthesiaNRT { 
	Settings: LoudnessNRTSettings;
	static Load(ResourceName: string): LoudnessNRT;
	static Find(Outer: UObject, ResourceName: string): LoudnessNRT;
	static GetDefaultObject(): LoudnessNRT;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LoudnessNRT;
	GetNormalizedLoudnessAtTime(InSeconds: number,OutLoudness?: number): {OutLoudness: number};
	GetNormalizedChannelLoudnessAtTime(InSeconds: number,InChannel: number,OutLoudness?: number): {OutLoudness: number};
	GetLoudnessAtTime(InSeconds: number,OutLoudness?: number): {OutLoudness: number};
	GetChannelLoudnessAtTime(InSeconds: number,InChannel: number,OutLoudness?: number): {OutLoudness: number};
	static C(Other: UObject | any): LoudnessNRT;
}

declare type EMeterPeakType = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count' | 'EMeterPeakType_MAX';
declare var EMeterPeakType : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count',EMeterPeakType_MAX:'EMeterPeakType_MAX', };
declare class MeterSettings extends AudioSynesthesiaSettings { 
	AnalysisPeriod: number;
	PeakMode: EMeterPeakType;
	MeterAttackTime: number;
	MeterReleaseTime: number;
	PeakHoldTime: number;
	ClippingThreshold: number;
	static Load(ResourceName: string): MeterSettings;
	static Find(Outer: UObject, ResourceName: string): MeterSettings;
	static GetDefaultObject(): MeterSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeterSettings;
	static C(Other: UObject | any): MeterSettings;
}

declare class MeterResults { 
	TimeSeconds: number;
	MeterValue: number;
	PeakValue: number;
	NumSamplesClipping: number;
	ClippingValue: number;
	clone() : MeterResults;
	static C(Other: UObject | any): MeterResults;
}

declare class MeterAnalyzer extends AudioAnalyzer { 
	Settings: MeterSettings;
	OnOverallMeterResults: UnrealEngineMulticastDelegate<(MeterResults: MeterResults[]) => void>;
	OnPerChannelMeterResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, MeterResults: MeterResults[]) => void>;
	OnLatestOverallMeterResults: UnrealEngineMulticastDelegate<(LatestOverallMeterResults: MeterResults) => void>;
	OnLatestPerChannelMeterResults: UnrealEngineMulticastDelegate<(ChannelIndex: number, LatestMeterResults: MeterResults) => void>;
	static Load(ResourceName: string): MeterAnalyzer;
	static Find(Outer: UObject, ResourceName: string): MeterAnalyzer;
	static GetDefaultObject(): MeterAnalyzer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeterAnalyzer;
	static C(Other: UObject | any): MeterAnalyzer;
}

declare class OnsetNRTSettings extends AudioSynesthesiaNRTSettings { 
	bDownmixToMono: boolean;
	GranularityInSeconds: number;
	Sensitivity: number;
	MinimumFrequency: number;
	MaximumFrequency: number;
	static Load(ResourceName: string): OnsetNRTSettings;
	static Find(Outer: UObject, ResourceName: string): OnsetNRTSettings;
	static GetDefaultObject(): OnsetNRTSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnsetNRTSettings;
	static C(Other: UObject | any): OnsetNRTSettings;
}

declare class OnsetNRT extends AudioSynesthesiaNRT { 
	Settings: OnsetNRTSettings;
	static Load(ResourceName: string): OnsetNRT;
	static Find(Outer: UObject, ResourceName: string): OnsetNRT;
	static GetDefaultObject(): OnsetNRT;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnsetNRT;
	GetNormalizedChannelOnsetsBetweenTimes(InStartSeconds: number,InEndSeconds: number,InChannel: number,OutOnsetTimestamps?: number[],OutOnsetStrengths?: number[]): {OutOnsetTimestamps: number[], OutOnsetStrengths: number[]};
	GetChannelOnsetsBetweenTimes(InStartSeconds: number,InEndSeconds: number,InChannel: number,OutOnsetTimestamps?: number[],OutOnsetStrengths?: number[]): {OutOnsetTimestamps: number[], OutOnsetStrengths: number[]};
	static C(Other: UObject | any): OnsetNRT;
}

declare class CableComponent extends MeshComponent { 
	bAttachStart: boolean;
	bAttachEnd: boolean;
	AttachEndTo: ComponentReference;
	AttachEndToSocketName: string;
	EndLocation: Vector;
	CableLength: number;
	NumSegments: number;
	SubstepTime: number;
	SolverIterations: number;
	bEnableStiffness: boolean;
	bUseSubstepping: boolean;
	bSkipCableUpdateWhenNotVisible: boolean;
	bSkipCableUpdateWhenNotOwnerRecentlyRendered: boolean;
	bEnableCollision: boolean;
	CollisionFriction: number;
	CableForce: Vector;
	CableGravityScale: number;
	CableWidth: number;
	NumSides: number;
	TileMaterial: number;
	static Load(ResourceName: string): CableComponent;
	static Find(Outer: UObject, ResourceName: string): CableComponent;
	static GetDefaultObject(): CableComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CableComponent;
	SetAttachEndToComponent(Component: SceneComponent,SocketName: string): void;
	SetAttachEndTo(Actor: Actor,ComponentProperty: string,SocketName: string): void;
	GetCableParticleLocations(Locations?: Vector[]): {Locations: Vector[]};
	GetAttachedComponent(): SceneComponent;
	GetAttachedActor(): Actor;
	static C(Other: UObject | any): CableComponent;
}

declare class CableActor extends Actor { 
	CableComponent: CableComponent;
	static GetDefaultObject(): CableActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CableActor;
	static C(Other: UObject | any): CableActor;
}

declare class CustomMeshTriangle { 
	Vertex0: Vector;
	Vertex1: Vector;
	Vertex2: Vector;
	clone() : CustomMeshTriangle;
	static C(Other: UObject | any): CustomMeshTriangle;
}

declare class CustomMeshComponent extends MeshComponent { 
	static Load(ResourceName: string): CustomMeshComponent;
	static Find(Outer: UObject, ResourceName: string): CustomMeshComponent;
	static GetDefaultObject(): CustomMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CustomMeshComponent;
	SetCustomMeshTriangles(Triangles: CustomMeshTriangle[]): boolean;
	ClearCustomMeshTriangles(): void;
	AddCustomMeshTriangles(Triangles: CustomMeshTriangle[]): void;
	static C(Other: UObject | any): CustomMeshComponent;
}

declare type ELocationAccuracy = 'LA_ThreeKilometers' | 'LA_OneKilometer' | 'LA_HundredMeters' | 'LA_TenMeters' | 'LA_Best' | 'LA_Navigation' | 'LA_MAX';
declare var ELocationAccuracy : { LA_ThreeKilometers:'LA_ThreeKilometers',LA_OneKilometer:'LA_OneKilometer',LA_HundredMeters:'LA_HundredMeters',LA_TenMeters:'LA_TenMeters',LA_Best:'LA_Best',LA_Navigation:'LA_Navigation',LA_MAX:'LA_MAX', };
declare class LocationServicesData { 
	Timestamp: number;
	Longitude: number;
	Latitude: number;
	HorizontalAccuracy: number;
	VerticalAccuracy: number;
	Altitude: number;
	clone() : LocationServicesData;
	static C(Other: UObject | any): LocationServicesData;
	static GetLastKnownLocation(): LocationServicesData;
}

declare class LocationServicesImpl extends UObject { 
	OnLocationChanged: UnrealEngineMulticastDelegate<(LocationData: LocationServicesData) => void>;
	static Load(ResourceName: string): LocationServicesImpl;
	static Find(Outer: UObject, ResourceName: string): LocationServicesImpl;
	static GetDefaultObject(): LocationServicesImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocationServicesImpl;
	static C(Other: UObject | any): LocationServicesImpl;
}

declare class LocationServices extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LocationServices;
	static Find(Outer: UObject, ResourceName: string): LocationServices;
	static GetDefaultObject(): LocationServices;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocationServices;
	static StopLocationServices(): boolean;
	static StartLocationServices(): boolean;
	static IsLocationAccuracyAvailable(Accuracy: ELocationAccuracy): boolean;
	static InitLocationServices(Accuracy: ELocationAccuracy,UpdateFrequency: number,MinDistanceFilter: number): boolean;
	static GetLocationServicesImpl(): LocationServicesImpl;
	static GetLastKnownLocation(): LocationServicesData;
	static AreLocationServicesEnabled(): boolean;
	static C(Other: UObject | any): LocationServices;
}

declare type EWaveTableResolution = 'None' | 'Res_8' | 'Res_16' | 'Res_32' | 'Res_64' | 'Res_128' | 'Res_256' | 'Res_512' | 'Res_1024' | 'Res_2048' | 'Res_4096' | 'Res_Max' | 'Maximum' | 'EWaveTableResolution_MAX';
declare var EWaveTableResolution : { None:'None',Res_8:'Res_8',Res_16:'Res_16',Res_32:'Res_32',Res_64:'Res_64',Res_128:'Res_128',Res_256:'Res_256',Res_512:'Res_512',Res_1024:'Res_1024',Res_2048:'Res_2048',Res_4096:'Res_4096',Res_Max:'Res_Max',Maximum:'Maximum',EWaveTableResolution_MAX:'EWaveTableResolution_MAX', };
declare type EWaveTableCurve = 'Linear' | 'Linear_Inv' | 'Exp' | 'Exp_Inverse' | 'Log' | 'Sin' | 'Sin_Full' | 'SCurve' | 'Shared' | 'Custom' | 'File' | 'Count' | 'EWaveTableCurve_MAX';
declare var EWaveTableCurve : { Linear:'Linear',Linear_Inv:'Linear_Inv',Exp:'Exp',Exp_Inverse:'Exp_Inverse',Log:'Log',Sin:'Sin',Sin_Full:'Sin_Full',SCurve:'SCurve',Shared:'Shared',Custom:'Custom',File:'File',Count:'Count',EWaveTableCurve_MAX:'EWaveTableCurve_MAX', };
declare class WaveTableSettings { 
	FilePath: FilePath;
	ChannelIndex: number;
	Phase: number;
	Top: number;
	Tail: number;
	FadeIn: number;
	FadeOut: number;
	bNormalize: boolean;
	bRemoveOffset: boolean;
	SourcePCMData: number[];
	clone() : WaveTableSettings;
	static C(Other: UObject | any): WaveTableSettings;
}

declare class WaveTableTransform { 
	Curve: EWaveTableCurve;
	Scalar: number;
	CurveCustom: RichCurve;
	CurveShared: CurveFloat;
	WaveTable: number[];
	WaveTableSettings: WaveTableSettings;
	clone() : WaveTableTransform;
	static C(Other: UObject | any): WaveTableTransform;
}

declare class WaveTableBankEntry { 
	Transform: WaveTableTransform;
	clone() : WaveTableBankEntry;
	static C(Other: UObject | any): WaveTableBankEntry;
}

declare class WaveTableBank extends UObject { 
	Resolution: EWaveTableResolution;
	bBipolar: boolean;
	WaveTableSizeMB: number;
	WaveTableLengthSec: number;
	Entries: WaveTableBankEntry[];
	static Load(ResourceName: string): WaveTableBank;
	static Find(Outer: UObject, ResourceName: string): WaveTableBank;
	static GetDefaultObject(): WaveTableBank;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveTableBank;
	static C(Other: UObject | any): WaveTableBank;
}

declare class MetasoundFrontendClassName { 
	Namespace: string;
	Name: string;
	Variant: string;
	clone() : MetasoundFrontendClassName;
	static C(Other: UObject | any): MetasoundFrontendClassName;
}

declare class DefaultMetaSoundAssetAutoUpdateSettings { 
	Metasound: SoftObjectPath;
	clone() : DefaultMetaSoundAssetAutoUpdateSettings;
	static C(Other: UObject | any): DefaultMetaSoundAssetAutoUpdateSettings;
}

declare class MetaSoundSettings extends DeveloperSettings { 
	bAutoUpdateEnabled: boolean;
	AutoUpdateDenylist: MetasoundFrontendClassName[];
	AutoUpdateAssetDenylist: DefaultMetaSoundAssetAutoUpdateSettings[];
	bAutoUpdateLogWarningOnDroppedConnection: boolean;
	DirectoriesToRegister: DirectoryPath[];
	DenyListCacheChangeID: number;
	static Load(ResourceName: string): MetaSoundSettings;
	static Find(Outer: UObject, ResourceName: string): MetaSoundSettings;
	static GetDefaultObject(): MetaSoundSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundSettings;
	static C(Other: UObject | any): MetaSoundSettings;
}

declare class MetasoundEditorGraphBase extends EdGraph { 
	static Load(ResourceName: string): MetasoundEditorGraphBase;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphBase;
	static GetDefaultObject(): MetasoundEditorGraphBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphBase;
	static C(Other: UObject | any): MetasoundEditorGraphBase;
}

declare class MetasoundFrontendVersionNumber { 
	Major: number;
	Minor: number;
	clone() : MetasoundFrontendVersionNumber;
	static C(Other: UObject | any): MetasoundFrontendVersionNumber;
}

declare class MetasoundFrontendVersion { 
	Name: string;
	Number: MetasoundFrontendVersionNumber;
	clone() : MetasoundFrontendVersion;
	static C(Other: UObject | any): MetasoundFrontendVersion;
}

declare class MetasoundFrontendDocumentMetadata { 
	Version: MetasoundFrontendVersion;
	clone() : MetasoundFrontendDocumentMetadata;
	static C(Other: UObject | any): MetasoundFrontendDocumentMetadata;
}

declare type EMetasoundFrontendClassType = 'External' | 'Graph' | 'Input' | 'Output' | 'Literal' | 'Variable' | 'VariableDeferredAccessor' | 'VariableAccessor' | 'VariableMutator' | 'Template' | 'Invalid' | 'EMetasoundFrontendClassType_MAX';
declare var EMetasoundFrontendClassType : { External:'External',Graph:'Graph',Input:'Input',Output:'Output',Literal:'Literal',Variable:'Variable',VariableDeferredAccessor:'VariableDeferredAccessor',VariableAccessor:'VariableAccessor',VariableMutator:'VariableMutator',Template:'Template',Invalid:'Invalid',EMetasoundFrontendClassType_MAX:'EMetasoundFrontendClassType_MAX', };
declare class MetasoundFrontendClassMetadata { 
	ClassName: MetasoundFrontendClassName;
	Version: MetasoundFrontendVersionNumber;
	Type: EMetasoundFrontendClassType;
	DisplayName: string;
	DisplayNameTransient: string;
	Description: string;
	DescriptionTransient: string;
	PromptIfMissingTransient: string;
	Author: string;
	Keywords: string[];
	KeywordsTransient: string[];
	CategoryHierarchy: string[];
	CategoryHierarchyTransient: string[];
	bIsDeprecated: boolean;
	bAutoUpdateManagesInterface: boolean;
	bSerializeText: boolean;
	ChangeID: Guid;
	clone() : MetasoundFrontendClassMetadata;
	static C(Other: UObject | any): MetasoundFrontendClassMetadata;
}

declare class MetasoundFrontendInterfaceStyle { 
	DefaultSortOrder: number[];
	RequiredMembers: Map<string, string>;
	clone() : MetasoundFrontendInterfaceStyle;
	static C(Other: UObject | any): MetasoundFrontendInterfaceStyle;
}

declare class MetasoundFrontendVertex { 
	Name: string;
	TypeName: string;
	VertexID: Guid;
	clone() : MetasoundFrontendVertex;
	static C(Other: UObject | any): MetasoundFrontendVertex;
}

declare class MetasoundFrontendVertexMetadata { 
	DisplayName: string;
	DisplayNameTransient: string;
	Description: string;
	DescriptionTransient: string;
	SortOrderIndex: number;
	bIsAdvancedDisplay: boolean;
	bSerializeText: boolean;
	clone() : MetasoundFrontendVertexMetadata;
	static C(Other: UObject | any): MetasoundFrontendVertexMetadata;
}

declare type EMetasoundFrontendVertexAccessType = 'Reference' | 'Value' | 'Unset' | 'EMetasoundFrontendVertexAccessType_MAX';
declare var EMetasoundFrontendVertexAccessType : { Reference:'Reference',Value:'Value',Unset:'Unset',EMetasoundFrontendVertexAccessType_MAX:'EMetasoundFrontendVertexAccessType_MAX', };
declare class MetasoundFrontendClassVertex extends MetasoundFrontendVertex { 
	NodeID: Guid;
	MetaData: MetasoundFrontendVertexMetadata;
	AccessType: EMetasoundFrontendVertexAccessType;
	clone() : MetasoundFrontendClassVertex;
	static C(Other: UObject | any): MetasoundFrontendClassVertex;
}

declare type EMetasoundFrontendLiteralType = 'None' | 'Boolean' | 'Integer' | 'Float' | 'String' | 'UObject' | 'NoneArray' | 'BooleanArray' | 'IntegerArray' | 'FloatArray' | 'StringArray' | 'UObjectArray' | 'Invalid' | 'EMetasoundFrontendLiteralType_MAX';
declare var EMetasoundFrontendLiteralType : { None:'None',Boolean:'Boolean',Integer:'Integer',Float:'Float',String:'String',UObject:'UObject',NoneArray:'NoneArray',BooleanArray:'BooleanArray',IntegerArray:'IntegerArray',FloatArray:'FloatArray',StringArray:'StringArray',UObjectArray:'UObjectArray',Invalid:'Invalid',EMetasoundFrontendLiteralType_MAX:'EMetasoundFrontendLiteralType_MAX', };
declare class MetasoundFrontendLiteral { 
	Type: EMetasoundFrontendLiteralType;
	AsNumDefault: number;
	AsBoolean: boolean[];
	AsInteger: number[];
	AsFloat: number[];
	AsString: string[];
	AsUObject: UObject[];
	clone() : MetasoundFrontendLiteral;
	static C(Other: UObject | any): MetasoundFrontendLiteral;
}

declare class MetasoundFrontendClassInput extends MetasoundFrontendClassVertex { 
	DefaultLiteral: MetasoundFrontendLiteral;
	clone() : MetasoundFrontendClassInput;
	static C(Other: UObject | any): MetasoundFrontendClassInput;
}

declare class MetasoundFrontendClassOutput extends MetasoundFrontendClassVertex { 
	clone() : MetasoundFrontendClassOutput;
	static C(Other: UObject | any): MetasoundFrontendClassOutput;
}

declare class MetasoundFrontendClassEnvironmentVariable { 
	Name: string;
	TypeName: string;
	bIsRequired: boolean;
	clone() : MetasoundFrontendClassEnvironmentVariable;
	static C(Other: UObject | any): MetasoundFrontendClassEnvironmentVariable;
}

declare class MetasoundFrontendClassInterface { 
	InputStyle: MetasoundFrontendInterfaceStyle;
	OutputStyle: MetasoundFrontendInterfaceStyle;
	Inputs: MetasoundFrontendClassInput[];
	Outputs: MetasoundFrontendClassOutput[];
	Environment: MetasoundFrontendClassEnvironmentVariable[];
	ChangeID: Guid;
	clone() : MetasoundFrontendClassInterface;
	static C(Other: UObject | any): MetasoundFrontendClassInterface;
}

declare class MetasoundFrontendClassStyleDisplay { 
	ImageName: string;
	bShowName: boolean;
	bShowInputNames: boolean;
	bShowOutputNames: boolean;
	bShowLiterals: boolean;
	clone() : MetasoundFrontendClassStyleDisplay;
	static C(Other: UObject | any): MetasoundFrontendClassStyleDisplay;
}

declare class MetasoundFrontendClassStyle { 
	Display: MetasoundFrontendClassStyleDisplay;
	ChangeID: Guid;
	clone() : MetasoundFrontendClassStyle;
	static C(Other: UObject | any): MetasoundFrontendClassStyle;
}

declare class MetasoundFrontendClass { 
	ID: Guid;
	MetaData: MetasoundFrontendClassMetadata;
	Interface: MetasoundFrontendClassInterface;
	Style: MetasoundFrontendClassStyle;
	clone() : MetasoundFrontendClass;
	static C(Other: UObject | any): MetasoundFrontendClass;
}

declare class MetasoundFrontendNodeInterface { 
	Inputs: MetasoundFrontendVertex[];
	Outputs: MetasoundFrontendVertex[];
	Environment: MetasoundFrontendVertex[];
	clone() : MetasoundFrontendNodeInterface;
	static C(Other: UObject | any): MetasoundFrontendNodeInterface;
}

declare class MetasoundFrontendVertexLiteral { 
	VertexID: Guid;
	Value: MetasoundFrontendLiteral;
	clone() : MetasoundFrontendVertexLiteral;
	static C(Other: UObject | any): MetasoundFrontendVertexLiteral;
}

declare type EMetasoundFrontendNodeStyleDisplayVisibility = 'Visible' | 'Hidden' | 'EMetasoundFrontendNodeStyleDisplayVisibility_MAX';
declare var EMetasoundFrontendNodeStyleDisplayVisibility : { Visible:'Visible',Hidden:'Hidden',EMetasoundFrontendNodeStyleDisplayVisibility_MAX:'EMetasoundFrontendNodeStyleDisplayVisibility_MAX', };
declare class MetasoundFrontendNodeStyleDisplay { 
	Visibility: EMetasoundFrontendNodeStyleDisplayVisibility;
	Locations: Map<Guid, Vector2D>;
	clone() : MetasoundFrontendNodeStyleDisplay;
	static C(Other: UObject | any): MetasoundFrontendNodeStyleDisplay;
}

declare class MetasoundFrontendNodeStyle { 
	Display: MetasoundFrontendNodeStyleDisplay;
	bMessageNodeUpdated: boolean;
	bIsPrivate: boolean;
	clone() : MetasoundFrontendNodeStyle;
	static C(Other: UObject | any): MetasoundFrontendNodeStyle;
}

declare class MetasoundFrontendNode { 
	ID: Guid;
	ClassID: Guid;
	Name: string;
	Interface: MetasoundFrontendNodeInterface;
	InputLiterals: MetasoundFrontendVertexLiteral[];
	Style: MetasoundFrontendNodeStyle;
	clone() : MetasoundFrontendNode;
	static C(Other: UObject | any): MetasoundFrontendNode;
}

declare class MetasoundFrontendEdge { 
	FromNodeID: Guid;
	FromVertexID: Guid;
	ToNodeID: Guid;
	ToVertexID: Guid;
	clone() : MetasoundFrontendEdge;
	static C(Other: UObject | any): MetasoundFrontendEdge;
}

declare class MetasoundFrontendVariable { 
	Name: string;
	DisplayName: string;
	Description: string;
	TypeName: string;
	Literal: MetasoundFrontendLiteral;
	ID: Guid;
	VariableNodeID: Guid;
	MutatorNodeID: Guid;
	AccessorNodeIDs: Guid[];
	DeferredAccessorNodeIDs: Guid[];
	clone() : MetasoundFrontendVariable;
	static C(Other: UObject | any): MetasoundFrontendVariable;
}

declare class MetasoundFrontendEdgeStyleLiteralColorPair { 
	Value: MetasoundFrontendLiteral;
	Color: LinearColor;
	clone() : MetasoundFrontendEdgeStyleLiteralColorPair;
	static C(Other: UObject | any): MetasoundFrontendEdgeStyleLiteralColorPair;
}

declare class MetasoundFrontendEdgeStyle { 
	NodeID: Guid;
	OutputName: string;
	LiteralColorPairs: MetasoundFrontendEdgeStyleLiteralColorPair[];
	clone() : MetasoundFrontendEdgeStyle;
	static C(Other: UObject | any): MetasoundFrontendEdgeStyle;
}

declare class MetasoundFrontendGraphStyle { 
	bIsGraphEditable: boolean;
	EdgeStyles: MetasoundFrontendEdgeStyle[];
	clone() : MetasoundFrontendGraphStyle;
	static C(Other: UObject | any): MetasoundFrontendGraphStyle;
}

declare class MetasoundFrontendGraph { 
	Nodes: MetasoundFrontendNode[];
	Edges: MetasoundFrontendEdge[];
	Variables: MetasoundFrontendVariable[];
	Style: MetasoundFrontendGraphStyle;
	clone() : MetasoundFrontendGraph;
	static C(Other: UObject | any): MetasoundFrontendGraph;
}

declare class MetasoundFrontendGraphClassPresetOptions { 
	bIsPreset: boolean;
	InputsInheritingDefault: Set<string>;
	clone() : MetasoundFrontendGraphClassPresetOptions;
	static C(Other: UObject | any): MetasoundFrontendGraphClassPresetOptions;
}

declare class MetasoundFrontendGraphClass extends MetasoundFrontendClass { 
	Graph: MetasoundFrontendGraph;
	PresetOptions: MetasoundFrontendGraphClassPresetOptions;
	clone() : MetasoundFrontendGraphClass;
	static C(Other: UObject | any): MetasoundFrontendGraphClass;
}

declare class MetasoundFrontendDocument { 
	MetaData: MetasoundFrontendDocumentMetadata;
	Interfaces: Set<MetasoundFrontendVersion>;
	RootGraph: MetasoundFrontendGraphClass;
	SubGraphs: MetasoundFrontendGraphClass[];
	Dependencies: MetasoundFrontendClass[];
	ArchetypeVersion: MetasoundFrontendVersion;
	InterfaceVersions: MetasoundFrontendVersion[];
	clone() : MetasoundFrontendDocument;
	static C(Other: UObject | any): MetasoundFrontendDocument;
}

declare class MetaSoundPatch extends UObject { 
	RootMetaSoundDocument: MetasoundFrontendDocument;
	ReferencedAssetClassKeys: Set<string>;
	ReferencedAssetClassObjects: Set<UObject>;
	ReferenceAssetClassCache: Set<SoftObjectPath>;
	Graph: MetasoundEditorGraphBase;
	AssetClassID: Guid;
	RegistryInputTypes: string;
	RegistryOutputTypes: string;
	RegistryVersionMajor: number;
	RegistryVersionMinor: number;
	bIsPreset: boolean;
	static Load(ResourceName: string): MetaSoundPatch;
	static Find(Outer: UObject, ResourceName: string): MetaSoundPatch;
	static GetDefaultObject(): MetaSoundPatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundPatch;
	static C(Other: UObject | any): MetaSoundPatch;
}

declare class MetaSoundAsyncAssetDependencies { 
	Metasound: UObject;
	clone() : MetaSoundAsyncAssetDependencies;
	static C(Other: UObject | any): MetaSoundAsyncAssetDependencies;
}

declare class MetaSoundAssetDirectory { 
	Directory: DirectoryPath;
	clone() : MetaSoundAssetDirectory;
	static C(Other: UObject | any): MetaSoundAssetDirectory;
}

declare class MetaSoundAssetSubsystem extends EngineSubsystem { 
	LoadingDependencies: MetaSoundAsyncAssetDependencies[];
	static Load(ResourceName: string): MetaSoundAssetSubsystem;
	static Find(Outer: UObject, ResourceName: string): MetaSoundAssetSubsystem;
	static GetDefaultObject(): MetaSoundAssetSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundAssetSubsystem;
	UnregisterAssetClassesInDirectories(Directories: MetaSoundAssetDirectory[]): void;
	RegisterAssetClassesInDirectories(Directories: MetaSoundAssetDirectory[]): void;
	static C(Other: UObject | any): MetaSoundAssetSubsystem;
}

declare type EMetasoundSourceAudioFormat = 'Mono' | 'Stereo' | 'Quad' | 'FiveDotOne' | 'SevenDotOne' | 'COUNT' | 'EMetasoundSourceAudioFormat_MAX';
declare var EMetasoundSourceAudioFormat : { Mono:'Mono',Stereo:'Stereo',Quad:'Quad',FiveDotOne:'FiveDotOne',SevenDotOne:'SevenDotOne',COUNT:'COUNT',EMetasoundSourceAudioFormat_MAX:'EMetasoundSourceAudioFormat_MAX', };
declare class MetaSoundSource extends SoundWaveProcedural { 
	RootMetaSoundDocument: MetasoundFrontendDocument;
	ReferencedAssetClassKeys: Set<string>;
	ReferencedAssetClassObjects: Set<UObject>;
	ReferenceAssetClassCache: Set<SoftObjectPath>;
	Graph: MetasoundEditorGraphBase;
	OutputFormat: EMetasoundSourceAudioFormat;
	AssetClassID: Guid;
	RegistryInputTypes: string;
	RegistryOutputTypes: string;
	RegistryVersionMajor: number;
	RegistryVersionMinor: number;
	bIsPreset: boolean;
	static Load(ResourceName: string): MetaSoundSource;
	static Find(Outer: UObject, ResourceName: string): MetaSoundSource;
	static GetDefaultObject(): MetaSoundSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundSource;
	static C(Other: UObject | any): MetaSoundSource;
}

declare class RadialSlider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	bUseCustomDefaultValue: boolean;
	CustomDefaultValue: number;
	SliderRange: RuntimeFloatCurve;
	ValueTags: number[];
	SliderHandleStartAngle: number;
	SliderHandleEndAngle: number;
	AngularOffset: number;
	HandStartEndRatio: Vector2D;
	WidgetStyle: SliderStyle;
	SliderBarColor: LinearColor;
	SliderProgressColor: LinearColor;
	SliderHandleColor: LinearColor;
	CenterBackgroundColor: LinearColor;
	Locked: boolean;
	MouseUsesStep: boolean;
	RequiresControllerLock: boolean;
	StepSize: number;
	IsFocusable: boolean;
	UseVerticalDrag: boolean;
	ShowSliderHandle: boolean;
	ShowSliderHand: boolean;
	OnMouseCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnMouseCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): RadialSlider;
	static Find(Outer: UObject, ResourceName: string): RadialSlider;
	static GetDefaultObject(): RadialSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialSlider;
	SetValueTags(InValueTags: number[]): void;
	SetValue(InValue: number): void;
	SetUseVerticalDrag(InUseVerticalDrag: boolean): void;
	SetStepSize(InValue: number): void;
	SetSliderRange(InSliderRange: RuntimeFloatCurve): void;
	SetSliderProgressColor(InValue: LinearColor): void;
	SetSliderHandleStartAngle(InValue: number): void;
	SetSliderHandleEndAngle(InValue: number): void;
	SetSliderHandleColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetShowSliderHandle(InShowSliderHandle: boolean): void;
	SetShowSliderHand(InShowSliderHand: boolean): void;
	SetLocked(InValue: boolean): void;
	SetHandStartEndRatio(InValue: Vector2D): void;
	SetCustomDefaultValue(InValue: number): void;
	SetCenterBackgroundColor(InValue: LinearColor): void;
	SetAngularOffset(InValue: number): void;
	GetValue(): number;
	GetNormalizedSliderHandlePosition(): number;
	GetCustomDefaultValue(): number;
	static C(Other: UObject | any): RadialSlider;
}

declare class MeterChannelInfo { 
	MeterValue: number;
	PeakValue: number;
	ClippingValue: number;
	clone() : MeterChannelInfo;
	static C(Other: UObject | any): MeterChannelInfo;
}

declare class AudioMeterStyle extends SlateWidgetStyle { 
	MeterValueImage: SlateBrush;
	BackgroundImage: SlateBrush;
	MeterBackgroundImage: SlateBrush;
	MeterValueBackgroundImage: SlateBrush;
	MeterPeakImage: SlateBrush;
	MeterSize: Vector2D;
	MeterPadding: Vector2D;
	MeterValuePadding: number;
	PeakValueWidth: number;
	ValueRangeDb: Vector2D;
	bShowScale: boolean;
	bScaleSide: boolean;
	ScaleHashOffset: number;
	ScaleHashWidth: number;
	ScaleHashHeight: number;
	DecibelsPerHash: number;
	Font: SlateFontInfo;
	clone() : AudioMeterStyle;
	static C(Other: UObject | any): AudioMeterStyle;
}

declare class AudioMeter extends Widget { 
	MeterChannelInfo: MeterChannelInfo[];
	MeterChannelInfoDelegate: UnrealEngineDelegate<() => MeterChannelInfo[]>;
	WidgetStyle: AudioMeterStyle;
	Orientation: EOrientation;
	BackgroundColor: LinearColor;
	MeterBackgroundColor: LinearColor;
	MeterValueColor: LinearColor;
	MeterPeakColor: LinearColor;
	MeterClippingColor: LinearColor;
	MeterScaleColor: LinearColor;
	MeterScaleLabelColor: LinearColor;
	static Load(ResourceName: string): AudioMeter;
	static Find(Outer: UObject, ResourceName: string): AudioMeter;
	static GetDefaultObject(): AudioMeter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioMeter;
	SetMeterValueColor(InValue: LinearColor): void;
	SetMeterScaleLabelColor(InValue: LinearColor): void;
	SetMeterScaleColor(InValue: LinearColor): void;
	SetMeterPeakColor(InValue: LinearColor): void;
	SetMeterClippingColor(InValue: LinearColor): void;
	SetMeterChannelInfo(InMeterChannelInfo: MeterChannelInfo[]): void;
	SetMeterBackgroundColor(InValue: LinearColor): void;
	SetBackgroundColor(InValue: LinearColor): void;
	GetMeterChannelInfo(): MeterChannelInfo[];
	static C(Other: UObject | any): AudioMeter;
}

declare type EAudioRadialSliderLayout = 'Layout_LabelTop' | 'Layout_LabelCenter' | 'Layout_LabelBottom' | 'Layout_MAX';
declare var EAudioRadialSliderLayout : { Layout_LabelTop:'Layout_LabelTop',Layout_LabelCenter:'Layout_LabelCenter',Layout_LabelBottom:'Layout_LabelBottom',Layout_MAX:'Layout_MAX', };
declare class AudioRadialSlider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetLayout: EAudioRadialSliderLayout;
	CenterBackgroundColor: LinearColor;
	SliderProgressColor: LinearColor;
	SliderBarColor: LinearColor;
	HandStartEndRatio: Vector2D;
	UnitsText: string;
	TextLabelBackgroundColor: LinearColor;
	ShowLabelOnlyOnHover: boolean;
	ShowUnitsText: boolean;
	IsUnitsTextReadOnly: boolean;
	IsValueTextReadOnly: boolean;
	SliderThickness: number;
	OutputRange: Vector2D;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): AudioRadialSlider;
	static Find(Outer: UObject, ResourceName: string): AudioRadialSlider;
	static GetDefaultObject(): AudioRadialSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioRadialSlider;
	SetWidgetLayout(InLayout: EAudioRadialSliderLayout): void;
	SetValueTextReadOnly(bIsReadOnly: boolean): void;
	SetUnitsTextReadOnly(bIsReadOnly: boolean): void;
	SetUnitsText(Units: string): void;
	SetTextLabelBackgroundColor(InColor: SlateColor): void;
	SetSliderThickness(InThickness: number): void;
	SetSliderProgressColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetShowUnitsText(bShowUnitsText: boolean): void;
	SetShowLabelOnlyOnHover(bShowLabelOnlyOnHover: boolean): void;
	SetOutputRange(InOutputRange: Vector2D): void;
	SetHandStartEndRatio(InHandStartEndRatio: Vector2D): void;
	SetCenterBackgroundColor(InValue: LinearColor): void;
	GetSliderValue(OutputValue: number): number;
	GetOutputValue(InSliderValue: number): number;
	static C(Other: UObject | any): AudioRadialSlider;
}

declare class AudioVolumeRadialSlider extends AudioRadialSlider { 
	static Load(ResourceName: string): AudioVolumeRadialSlider;
	static Find(Outer: UObject, ResourceName: string): AudioVolumeRadialSlider;
	static GetDefaultObject(): AudioVolumeRadialSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioVolumeRadialSlider;
	static C(Other: UObject | any): AudioVolumeRadialSlider;
}

declare class AudioFrequencyRadialSlider extends AudioRadialSlider { 
	static Load(ResourceName: string): AudioFrequencyRadialSlider;
	static Find(Outer: UObject, ResourceName: string): AudioFrequencyRadialSlider;
	static GetDefaultObject(): AudioFrequencyRadialSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioFrequencyRadialSlider;
	static C(Other: UObject | any): AudioFrequencyRadialSlider;
}

declare class AudioSliderBase extends Widget { 
	Value: number;
	UnitsText: string;
	TextLabelBackgroundColor: LinearColor;
	TextLabelBackgroundColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	ShowLabelOnlyOnHover: boolean;
	ShowUnitsText: boolean;
	IsUnitsTextReadOnly: boolean;
	IsValueTextReadOnly: boolean;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	SliderBackgroundColor: LinearColor;
	SliderBackgroundColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	SliderBarColor: LinearColor;
	SliderBarColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	SliderThumbColor: LinearColor;
	SliderThumbColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	WidgetBackgroundColor: LinearColor;
	WidgetBackgroundColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	Orientation: EOrientation;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): AudioSliderBase;
	static Find(Outer: UObject, ResourceName: string): AudioSliderBase;
	static GetDefaultObject(): AudioSliderBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSliderBase;
	SetWidgetBackgroundColor(InValue: LinearColor): void;
	SetValueTextReadOnly(bIsReadOnly: boolean): void;
	SetUnitsTextReadOnly(bIsReadOnly: boolean): void;
	SetUnitsText(Units: string): void;
	SetTextLabelBackgroundColor(InColor: SlateColor): void;
	SetSliderThumbColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetSliderBackgroundColor(InValue: LinearColor): void;
	SetShowUnitsText(bShowUnitsText: boolean): void;
	SetShowLabelOnlyOnHover(bShowLabelOnlyOnHover: boolean): void;
	GetSliderValue(OutputValue: number): number;
	GetOutputValue(InSliderValue: number): number;
	GetLinValue(OutputValue: number): number;
	static C(Other: UObject | any): AudioSliderBase;
}

declare class AudioSlider extends AudioSliderBase { 
	LinToOutputCurve: CurveFloat;
	OutputToLinCurve: CurveFloat;
	static Load(ResourceName: string): AudioSlider;
	static Find(Outer: UObject, ResourceName: string): AudioSlider;
	static GetDefaultObject(): AudioSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSlider;
	static C(Other: UObject | any): AudioSlider;
}

declare class AudioVolumeSlider extends AudioSlider { 
	static Load(ResourceName: string): AudioVolumeSlider;
	static Find(Outer: UObject, ResourceName: string): AudioVolumeSlider;
	static GetDefaultObject(): AudioVolumeSlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioVolumeSlider;
	static C(Other: UObject | any): AudioVolumeSlider;
}

declare class AudioFrequencySlider extends AudioSliderBase { 
	OutputRange: Vector2D;
	static Load(ResourceName: string): AudioFrequencySlider;
	static Find(Outer: UObject, ResourceName: string): AudioFrequencySlider;
	static GetDefaultObject(): AudioFrequencySlider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioFrequencySlider;
	static C(Other: UObject | any): AudioFrequencySlider;
}

declare class MetasoundInterfacesView extends UObject { 
	static Load(ResourceName: string): MetasoundInterfacesView;
	static Find(Outer: UObject, ResourceName: string): MetasoundInterfacesView;
	static GetDefaultObject(): MetasoundInterfacesView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundInterfacesView;
	static C(Other: UObject | any): MetasoundInterfacesView;
}

declare class MetasoundEditorGraphMemberDefaultLiteral extends UObject { 
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultLiteral;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultLiteral;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultLiteral;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultLiteral;
}

declare class MetasoundEditorGraphMember extends UObject { 
	Literal: MetasoundEditorGraphMemberDefaultLiteral;
	TypeName: string;
	static Load(ResourceName: string): MetasoundEditorGraphMember;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMember;
	static GetDefaultObject(): MetasoundEditorGraphMember;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMember;
	static C(Other: UObject | any): MetasoundEditorGraphMember;
}

declare class MetasoundEditorGraphVertex extends MetasoundEditorGraphMember { 
	NodeID: Guid;
	ClassName: MetasoundFrontendClassName;
	static Load(ResourceName: string): MetasoundEditorGraphVertex;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphVertex;
	static GetDefaultObject(): MetasoundEditorGraphVertex;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphVertex;
	static C(Other: UObject | any): MetasoundEditorGraphVertex;
}

declare class MetasoundEditorGraphInput extends MetasoundEditorGraphVertex { 
	static Load(ResourceName: string): MetasoundEditorGraphInput;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphInput;
	static GetDefaultObject(): MetasoundEditorGraphInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphInput;
	static C(Other: UObject | any): MetasoundEditorGraphInput;
}

declare class MetasoundEditorGraphOutput extends MetasoundEditorGraphVertex { 
	static Load(ResourceName: string): MetasoundEditorGraphOutput;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphOutput;
	static GetDefaultObject(): MetasoundEditorGraphOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphOutput;
	static C(Other: UObject | any): MetasoundEditorGraphOutput;
}

declare class MetasoundEditorGraphVariable extends MetasoundEditorGraphMember { 
	VariableID: Guid;
	static Load(ResourceName: string): MetasoundEditorGraphVariable;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphVariable;
	static GetDefaultObject(): MetasoundEditorGraphVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphVariable;
	static C(Other: UObject | any): MetasoundEditorGraphVariable;
}

declare class MetasoundEditorGraph extends MetasoundEditorGraphBase { 
	Inputs: MetasoundEditorGraphInput[];
	Outputs: MetasoundEditorGraphOutput[];
	Variables: MetasoundEditorGraphVariable[];
	static Load(ResourceName: string): MetasoundEditorGraph;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraph;
	static GetDefaultObject(): MetasoundEditorGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraph;
	static C(Other: UObject | any): MetasoundEditorGraph;
}

declare class MetasoundEditorGraphNode extends EdGraphNode { 
	static Load(ResourceName: string): MetasoundEditorGraphNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphNode;
	static GetDefaultObject(): MetasoundEditorGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphNode;
	static C(Other: UObject | any): MetasoundEditorGraphNode;
}

declare class MetasoundEditorGraphMemberNode extends MetasoundEditorGraphNode { 
	static Load(ResourceName: string): MetasoundEditorGraphMemberNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberNode;
	static GetDefaultObject(): MetasoundEditorGraphMemberNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberNode;
	static C(Other: UObject | any): MetasoundEditorGraphMemberNode;
}

declare class MetasoundEditorGraphInputNode extends MetasoundEditorGraphMemberNode { 
	Input: MetasoundEditorGraphInput;
	static Load(ResourceName: string): MetasoundEditorGraphInputNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphInputNode;
	static GetDefaultObject(): MetasoundEditorGraphInputNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphInputNode;
	static C(Other: UObject | any): MetasoundEditorGraphInputNode;
}

declare class MetasoundEditorGraphMemberDefaultBoolRef { 
	Value: boolean;
	clone() : MetasoundEditorGraphMemberDefaultBoolRef;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultBoolRef;
}

declare class MetasoundEditorGraphMemberDefaultBool extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultBoolRef;
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultBool;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultBool;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultBool;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultBool;
}

declare class MetasoundEditorGraphMemberDefaultBoolArray extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultBoolRef[];
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultBoolArray;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultBoolArray;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultBoolArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultBoolArray;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultBoolArray;
}

declare class MetasoundEditorGraphMemberDefaultIntRef { 
	Value: number;
	clone() : MetasoundEditorGraphMemberDefaultIntRef;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultIntRef;
}

declare class MetasoundEditorGraphMemberDefaultInt extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultIntRef;
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultInt;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultInt;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultInt;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultInt;
}

declare class MetasoundEditorGraphMemberDefaultIntArray extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultIntRef[];
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultIntArray;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultIntArray;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultIntArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultIntArray;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultIntArray;
}

declare type EMetasoundMemberDefaultWidget = 'None' | 'Slider' | 'RadialSlider' | 'EMetasoundMemberDefaultWidget_MAX';
declare var EMetasoundMemberDefaultWidget : { None:'None',Slider:'Slider',RadialSlider:'RadialSlider',EMetasoundMemberDefaultWidget_MAX:'EMetasoundMemberDefaultWidget_MAX', };
declare type EMetasoundMemberDefaultWidgetValueType = 'Linear' | 'Frequency' | 'Volume' | 'EMetasoundMemberDefaultWidgetValueType_MAX';
declare var EMetasoundMemberDefaultWidgetValueType : { Linear:'Linear',Frequency:'Frequency',Volume:'Volume',EMetasoundMemberDefaultWidgetValueType_MAX:'EMetasoundMemberDefaultWidgetValueType_MAX', };
declare class MetasoundEditorGraphMemberDefaultFloat extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: number;
	ClampDefault: boolean;
	Range: Vector2D;
	WidgetType: EMetasoundMemberDefaultWidget;
	WidgetOrientation: EOrientation;
	WidgetValueType: EMetasoundMemberDefaultWidgetValueType;
	VolumeWidgetUseLinearOutput: boolean;
	VolumeWidgetDecibelRange: Vector2D;
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultFloat;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultFloat;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultFloat;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultFloat;
}

declare class MetasoundEditorGraphMemberDefaultFloatArray extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: number[];
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultFloatArray;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultFloatArray;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultFloatArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultFloatArray;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultFloatArray;
}

declare class MetasoundEditorGraphMemberDefaultString extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: string;
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultString;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultString;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultString;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultString;
}

declare class MetasoundEditorGraphMemberDefaultStringArray extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: string[];
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultStringArray;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultStringArray;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultStringArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultStringArray;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultStringArray;
}

declare class MetasoundEditorGraphMemberDefaultObjectRef { 
	UObject: UObject;
	clone() : MetasoundEditorGraphMemberDefaultObjectRef;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultObjectRef;
}

declare class MetasoundEditorGraphMemberDefaultObject extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultObjectRef;
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultObject;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultObject;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultObject;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultObject;
}

declare class MetasoundEditorGraphMemberDefaultObjectArray extends MetasoundEditorGraphMemberDefaultLiteral { 
	Default: MetasoundEditorGraphMemberDefaultObjectRef[];
	static Load(ResourceName: string): MetasoundEditorGraphMemberDefaultObjectArray;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphMemberDefaultObjectArray;
	static GetDefaultObject(): MetasoundEditorGraphMemberDefaultObjectArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphMemberDefaultObjectArray;
	static C(Other: UObject | any): MetasoundEditorGraphMemberDefaultObjectArray;
}

declare class MetasoundEditorGraphOutputNode extends MetasoundEditorGraphMemberNode { 
	Output: MetasoundEditorGraphOutput;
	static Load(ResourceName: string): MetasoundEditorGraphOutputNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphOutputNode;
	static GetDefaultObject(): MetasoundEditorGraphOutputNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphOutputNode;
	static C(Other: UObject | any): MetasoundEditorGraphOutputNode;
}

declare class MetasoundEditorGraphExternalNode extends MetasoundEditorGraphNode { 
	ClassName: MetasoundFrontendClassName;
	NodeID: Guid;
	bIsClassNative: boolean;
	static Load(ResourceName: string): MetasoundEditorGraphExternalNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphExternalNode;
	static GetDefaultObject(): MetasoundEditorGraphExternalNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphExternalNode;
	static C(Other: UObject | any): MetasoundEditorGraphExternalNode;
}

declare class MetasoundEditorGraphVariableNode extends MetasoundEditorGraphMemberNode { 
	ClassType: EMetasoundFrontendClassType;
	ClassName: MetasoundFrontendClassName;
	NodeID: Guid;
	Variable: MetasoundEditorGraphVariable;
	static Load(ResourceName: string): MetasoundEditorGraphVariableNode;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphVariableNode;
	static GetDefaultObject(): MetasoundEditorGraphVariableNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphVariableNode;
	static C(Other: UObject | any): MetasoundEditorGraphVariableNode;
}

declare class MetasoundEditorGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): MetasoundEditorGraphSchema;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorGraphSchema;
	static GetDefaultObject(): MetasoundEditorGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorGraphSchema;
	static C(Other: UObject | any): MetasoundEditorGraphSchema;
}

declare type EMetasoundActiveAnalyzerEnvelopeDirection = 'FromSourceOutput' | 'FromDestinationInput' | 'EMetasoundActiveAnalyzerEnvelopeDirection_MAX';
declare var EMetasoundActiveAnalyzerEnvelopeDirection : { FromSourceOutput:'FromSourceOutput',FromDestinationInput:'FromDestinationInput',EMetasoundActiveAnalyzerEnvelopeDirection_MAX:'EMetasoundActiveAnalyzerEnvelopeDirection_MAX', };
declare class MetasoundAnalyzerAnimationSettings { 
	bAnimateConnections: boolean;
	EnvelopeWireThickness: number;
	EnvelopeSpeed: number;
	EnvelopeDirection: EMetasoundActiveAnalyzerEnvelopeDirection;
	NumericWireThickness: number;
	WireScalarMin: number;
	WireScalarMax: number;
	clone() : MetasoundAnalyzerAnimationSettings;
	static C(Other: UObject | any): MetasoundAnalyzerAnimationSettings;
}

declare type EMetasoundActiveDetailView = 'Metasound' | 'General' | 'EMetasoundActiveDetailView_MAX';
declare var EMetasoundActiveDetailView : { Metasound:'Metasound',General:'General',EMetasoundActiveDetailView_MAX:'EMetasoundActiveDetailView_MAX', };
declare class MetasoundEditorSettings extends UObject { 
	bPinMetaSoundPatchInAssetMenu: boolean;
	bPinMetaSoundSourceInAssetMenu: boolean;
	DefaultAuthor: string;
	DefaultPinTypeColor: LinearColor;
	AudioPinTypeColor: LinearColor;
	BooleanPinTypeColor: LinearColor;
	FloatPinTypeColor: LinearColor;
	IntPinTypeColor: LinearColor;
	ObjectPinTypeColor: LinearColor;
	StringPinTypeColor: LinearColor;
	TimePinTypeColor: LinearColor;
	TriggerPinTypeColor: LinearColor;
	WaveTablePinTypeColor: LinearColor;
	NativeNodeTitleColor: LinearColor;
	AssetReferenceNodeTitleColor: LinearColor;
	InputNodeTitleColor: LinearColor;
	OutputNodeTitleColor: LinearColor;
	VariableNodeTitleColor: LinearColor;
	DefaultInputWidgetType: EMetasoundMemberDefaultWidget;
	AnalyzerAnimationSettings: MetasoundAnalyzerAnimationSettings;
	DetailView: EMetasoundActiveDetailView;
	static Load(ResourceName: string): MetasoundEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MetasoundEditorSettings;
	static GetDefaultObject(): MetasoundEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetasoundEditorSettings;
	static C(Other: UObject | any): MetasoundEditorSettings;
}

declare class MetaSoundBaseFactory extends Factory { 
	ReferencedMetaSoundObject: UObject;
	static Load(ResourceName: string): MetaSoundBaseFactory;
	static Find(Outer: UObject, ResourceName: string): MetaSoundBaseFactory;
	static GetDefaultObject(): MetaSoundBaseFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundBaseFactory;
	static C(Other: UObject | any): MetaSoundBaseFactory;
}

declare class MetaSoundFactory extends MetaSoundBaseFactory { 
	static Load(ResourceName: string): MetaSoundFactory;
	static Find(Outer: UObject, ResourceName: string): MetaSoundFactory;
	static GetDefaultObject(): MetaSoundFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundFactory;
	static C(Other: UObject | any): MetaSoundFactory;
}

declare class MetaSoundSourceFactory extends MetaSoundBaseFactory { 
	static Load(ResourceName: string): MetaSoundSourceFactory;
	static Find(Outer: UObject, ResourceName: string): MetaSoundSourceFactory;
	static GetDefaultObject(): MetaSoundSourceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaSoundSourceFactory;
	static C(Other: UObject | any): MetaSoundSourceFactory;
}

declare class KismetProceduralMeshLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetProceduralMeshLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetProceduralMeshLibrary;
	static GetDefaultObject(): KismetProceduralMeshLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetProceduralMeshLibrary;
	static SliceProceduralMesh(InProcMesh: ProceduralMeshComponent,PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: EProcMeshSliceCapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
	static GetSectionFromStaticMesh(InMesh: StaticMesh,LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static GetSectionFromProceduralMesh(InProcMesh: ProceduralMeshComponent,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static CreateGridMeshWelded(NumX: number,NumY: number,Triangles?: number[],Vertices?: Vector[],UVs?: Vector2D[],GridSpacing?: number): {Triangles: number[], Vertices: Vector[], UVs: Vector2D[]};
	static CreateGridMeshTriangles(NumX: number,NumY: number,bWinding: boolean,Triangles?: number[]): {Triangles: number[]};
	static CreateGridMeshSplit(NumX: number,NumY: number,Triangles?: number[],Vertices?: Vector[],UVs?: Vector2D[],UV1s?: Vector2D[],GridSpacing?: number): {Triangles: number[], Vertices: Vector[], UVs: Vector2D[], UV1s: Vector2D[]};
	static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: StaticMeshComponent,LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	static ConvertQuadToTriangles(Triangles?: number[],Vert0?: number,Vert1?: number,Vert2?: number,Vert3?: number): {Triangles: number[]};
	static CalculateTangentsForMesh(Vertices: Vector[],Triangles: number[],UVs: Vector2D[],Normals?: Vector[],Tangents?: ProcMeshTangent[]): {Normals: Vector[], Tangents: ProcMeshTangent[]};
	static C(Other: UObject | any): KismetProceduralMeshLibrary;
}

declare class SignificanceManager extends UObject { 
	SignificanceManagerClassName: SoftClassPath;
	static Load(ResourceName: string): SignificanceManager;
	static Find(Outer: UObject, ResourceName: string): SignificanceManager;
	static GetDefaultObject(): SignificanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SignificanceManager;
	static C(Other: UObject | any): SignificanceManager;
}

declare class AmbisonicsEncodingSettings extends SoundfieldEncodingSettingsBase { 
	AmbisonicsOrder: number;
	static Load(ResourceName: string): AmbisonicsEncodingSettings;
	static Find(Outer: UObject, ResourceName: string): AmbisonicsEncodingSettings;
	static GetDefaultObject(): AmbisonicsEncodingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AmbisonicsEncodingSettings;
	static C(Other: UObject | any): AmbisonicsEncodingSettings;
}

declare class AudioImpulseResponse extends UObject { 
	ImpulseResponse: number[];
	NumChannels: number;
	SampleRate: number;
	NormalizationVolumeDb: number;
	bTrueStereo: boolean;
	IRData: number[];
	static Load(ResourceName: string): AudioImpulseResponse;
	static Find(Outer: UObject, ResourceName: string): AudioImpulseResponse;
	static GetDefaultObject(): AudioImpulseResponse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioImpulseResponse;
	static C(Other: UObject | any): AudioImpulseResponse;
}

declare type ESynth1OscType = 'Sine' | 'Saw' | 'Triangle' | 'Square' | 'Noise' | 'Count' | 'ESynth1OscType_MAX';
declare var ESynth1OscType : { Sine:'Sine',Saw:'Saw',Triangle:'Triangle',Square:'Square',Noise:'Noise',Count:'Count',ESynth1OscType_MAX:'ESynth1OscType_MAX', };
declare type ESynthLFOType = 'Sine' | 'UpSaw' | 'DownSaw' | 'Square' | 'Triangle' | 'Exponential' | 'RandomSampleHold' | 'Count' | 'ESynthLFOType_MAX';
declare var ESynthLFOType : { Sine:'Sine',UpSaw:'UpSaw',DownSaw:'DownSaw',Square:'Square',Triangle:'Triangle',Exponential:'Exponential',RandomSampleHold:'RandomSampleHold',Count:'Count',ESynthLFOType_MAX:'ESynthLFOType_MAX', };
declare type ESynthLFOMode = 'Sync' | 'OneShot' | 'Free' | 'Count' | 'ESynthLFOMode_MAX';
declare var ESynthLFOMode : { Sync:'Sync',OneShot:'OneShot',Free:'Free',Count:'Count',ESynthLFOMode_MAX:'ESynthLFOMode_MAX', };
declare type ESynthLFOPatchType = 'PatchToNone' | 'PatchToGain' | 'PatchToOscFreq' | 'PatchToFilterFreq' | 'PatchToFilterQ' | 'PatchToOscPulseWidth' | 'PatchToOscPan' | 'PatchLFO1ToLFO2Frequency' | 'PatchLFO1ToLFO2Gain' | 'Count' | 'ESynthLFOPatchType_MAX';
declare var ESynthLFOPatchType : { PatchToNone:'PatchToNone',PatchToGain:'PatchToGain',PatchToOscFreq:'PatchToOscFreq',PatchToFilterFreq:'PatchToFilterFreq',PatchToFilterQ:'PatchToFilterQ',PatchToOscPulseWidth:'PatchToOscPulseWidth',PatchToOscPan:'PatchToOscPan',PatchLFO1ToLFO2Frequency:'PatchLFO1ToLFO2Frequency',PatchLFO1ToLFO2Gain:'PatchLFO1ToLFO2Gain',Count:'Count',ESynthLFOPatchType_MAX:'ESynthLFOPatchType_MAX', };
declare type ESynthModEnvPatch = 'PatchToNone' | 'PatchToOscFreq' | 'PatchToFilterFreq' | 'PatchToFilterQ' | 'PatchToLFO1Gain' | 'PatchToLFO2Gain' | 'PatchToLFO1Freq' | 'PatchToLFO2Freq' | 'Count' | 'ESynthModEnvPatch_MAX';
declare var ESynthModEnvPatch : { PatchToNone:'PatchToNone',PatchToOscFreq:'PatchToOscFreq',PatchToFilterFreq:'PatchToFilterFreq',PatchToFilterQ:'PatchToFilterQ',PatchToLFO1Gain:'PatchToLFO1Gain',PatchToLFO2Gain:'PatchToLFO2Gain',PatchToLFO1Freq:'PatchToLFO1Freq',PatchToLFO2Freq:'PatchToLFO2Freq',Count:'Count',ESynthModEnvPatch_MAX:'ESynthModEnvPatch_MAX', };
declare type ESynthModEnvBiasPatch = 'PatchToNone' | 'PatchToOscFreq' | 'PatchToFilterFreq' | 'PatchToFilterQ' | 'PatchToLFO1Gain' | 'PatchToLFO2Gain' | 'PatchToLFO1Freq' | 'PatchToLFO2Freq' | 'Count' | 'ESynthModEnvBiasPatch_MAX';
declare var ESynthModEnvBiasPatch : { PatchToNone:'PatchToNone',PatchToOscFreq:'PatchToOscFreq',PatchToFilterFreq:'PatchToFilterFreq',PatchToFilterQ:'PatchToFilterQ',PatchToLFO1Gain:'PatchToLFO1Gain',PatchToLFO2Gain:'PatchToLFO2Gain',PatchToLFO1Freq:'PatchToLFO1Freq',PatchToLFO2Freq:'PatchToLFO2Freq',Count:'Count',ESynthModEnvBiasPatch_MAX:'ESynthModEnvBiasPatch_MAX', };
declare type ESynthFilterType = 'LowPass' | 'HighPass' | 'BandPass' | 'BandStop' | 'Count' | 'ESynthFilterType_MAX';
declare var ESynthFilterType : { LowPass:'LowPass',HighPass:'HighPass',BandPass:'BandPass',BandStop:'BandStop',Count:'Count',ESynthFilterType_MAX:'ESynthFilterType_MAX', };
declare type ESynthFilterAlgorithm = 'OnePole' | 'StateVariable' | 'Ladder' | 'Count' | 'ESynthFilterAlgorithm_MAX';
declare var ESynthFilterAlgorithm : { OnePole:'OnePole',StateVariable:'StateVariable',Ladder:'Ladder',Count:'Count',ESynthFilterAlgorithm_MAX:'ESynthFilterAlgorithm_MAX', };
declare type ESynthStereoDelayMode = 'Normal' | 'Cross' | 'PingPong' | 'Count' | 'ESynthStereoDelayMode_MAX';
declare var ESynthStereoDelayMode : { Normal:'Normal',Cross:'Cross',PingPong:'PingPong',Count:'Count',ESynthStereoDelayMode_MAX:'ESynthStereoDelayMode_MAX', };
declare type ESynth1PatchSource = 'LFO1' | 'LFO2' | 'Envelope' | 'BiasEnvelope' | 'Count' | 'ESynth1PatchSource_MAX';
declare var ESynth1PatchSource : { LFO1:'LFO1',LFO2:'LFO2',Envelope:'Envelope',BiasEnvelope:'BiasEnvelope',Count:'Count',ESynth1PatchSource_MAX:'ESynth1PatchSource_MAX', };
declare type ESynth1PatchDestination = 'Osc1Gain' | 'Osc1Frequency' | 'Osc1Pulsewidth' | 'Osc2Gain' | 'Osc2Frequency' | 'Osc2Pulsewidth' | 'FilterFrequency' | 'FilterQ' | 'Gain' | 'Pan' | 'LFO1Frequency' | 'LFO1Gain' | 'LFO2Frequency' | 'LFO2Gain' | 'Count' | 'ESynth1PatchDestination_MAX';
declare var ESynth1PatchDestination : { Osc1Gain:'Osc1Gain',Osc1Frequency:'Osc1Frequency',Osc1Pulsewidth:'Osc1Pulsewidth',Osc2Gain:'Osc2Gain',Osc2Frequency:'Osc2Frequency',Osc2Pulsewidth:'Osc2Pulsewidth',FilterFrequency:'FilterFrequency',FilterQ:'FilterQ',Gain:'Gain',Pan:'Pan',LFO1Frequency:'LFO1Frequency',LFO1Gain:'LFO1Gain',LFO2Frequency:'LFO2Frequency',LFO2Gain:'LFO2Gain',Count:'Count',ESynth1PatchDestination_MAX:'ESynth1PatchDestination_MAX', };
declare class Synth1PatchCable { 
	Depth: number;
	Destination: ESynth1PatchDestination;
	clone() : Synth1PatchCable;
	static C(Other: UObject | any): Synth1PatchCable;
}

declare class EpicSynth1Patch { 
	PatchSource: ESynth1PatchSource;
	PatchCables: Synth1PatchCable[];
	clone() : EpicSynth1Patch;
	static C(Other: UObject | any): EpicSynth1Patch;
}

declare class ModularSynthPreset extends TableRowBase { 
	bEnablePolyphony: boolean;
	Osc1Type: ESynth1OscType;
	Osc1Gain: number;
	Osc1Octave: number;
	Osc1Semitones: number;
	Osc1Cents: number;
	Osc1PulseWidth: number;
	Osc2Type: ESynth1OscType;
	Osc2Gain: number;
	Osc2Octave: number;
	Osc2Semitones: number;
	Osc2Cents: number;
	Osc2PulseWidth: number;
	Portamento: number;
	bEnableUnison: boolean;
	bEnableOscillatorSync: boolean;
	Spread: number;
	Pan: number;
	LFO1Frequency: number;
	LFO1Gain: number;
	LFO1Type: ESynthLFOType;
	LFO1Mode: ESynthLFOMode;
	LFO1PatchType: ESynthLFOPatchType;
	LFO2Frequency: number;
	LFO2Gain: number;
	LFO2Type: ESynthLFOType;
	LFO2Mode: ESynthLFOMode;
	LFO2PatchType: ESynthLFOPatchType;
	GainDb: number;
	AttackTime: number;
	DecayTime: number;
	SustainGain: number;
	ReleaseTime: number;
	ModEnvPatchType: ESynthModEnvPatch;
	ModEnvBiasPatchType: ESynthModEnvBiasPatch;
	bInvertModulationEnvelope: boolean;
	bInvertModulationEnvelopeBias: boolean;
	ModulationEnvelopeDepth: number;
	ModulationEnvelopeAttackTime: number;
	ModulationEnvelopeDecayTime: number;
	ModulationEnvelopeSustainGain: number;
	ModulationEnvelopeReleaseTime: number;
	bLegato: boolean;
	bRetrigger: boolean;
	FilterFrequency: number;
	FilterQ: number;
	FilterType: ESynthFilterType;
	FilterAlgorithm: ESynthFilterAlgorithm;
	bStereoDelayEnabled: boolean;
	StereoDelayMode: ESynthStereoDelayMode;
	StereoDelayTime: number;
	StereoDelayFeedback: number;
	StereoDelayWetlevel: number;
	StereoDelayRatio: number;
	bChorusEnabled: boolean;
	ChorusDepth: number;
	ChorusFeedback: number;
	ChorusFrequency: number;
	Patches: EpicSynth1Patch[];
	clone() : ModularSynthPreset;
	static C(Other: UObject | any): ModularSynthPreset;
}

declare class ModularSynthPresetBankEntry { 
	PresetName: string;
	Preset: ModularSynthPreset;
	clone() : ModularSynthPresetBankEntry;
	static C(Other: UObject | any): ModularSynthPresetBankEntry;
}

declare class ModularSynthPresetBank extends UObject { 
	Presets: ModularSynthPresetBankEntry[];
	static Load(ResourceName: string): ModularSynthPresetBank;
	static Find(Outer: UObject, ResourceName: string): ModularSynthPresetBank;
	static GetDefaultObject(): ModularSynthPresetBank;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModularSynthPresetBank;
	static C(Other: UObject | any): ModularSynthPresetBank;
	AddModularSynthPresetToBankAsset(Preset: ModularSynthPreset,PresetName: string): void;
	static AddModularSynthPresetToBankAsset(InBank: ModularSynthPresetBank,Preset: ModularSynthPreset,PresetName: string): void;
}

declare class ModularSynthLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ModularSynthLibrary;
	static Find(Outer: UObject, ResourceName: string): ModularSynthLibrary;
	static GetDefaultObject(): ModularSynthLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModularSynthLibrary;
	static AddModularSynthPresetToBankAsset(InBank: ModularSynthPresetBank,Preset: ModularSynthPreset,PresetName: string): void;
	static C(Other: UObject | any): ModularSynthLibrary;
}

declare class PatchId { 
	ID: number;
	clone() : PatchId;
	static C(Other: UObject | any): PatchId;
}

declare class ModularSynthComponent extends SynthComponent { 
	VoiceCount: number;
	static Load(ResourceName: string): ModularSynthComponent;
	static Find(Outer: UObject, ResourceName: string): ModularSynthComponent;
	static GetDefaultObject(): ModularSynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModularSynthComponent;
	SetSynthPreset(SynthPreset: ModularSynthPreset): void;
	SetSustainGain(SustainGain: number): void;
	SetStereoDelayWetlevel(DelayWetlevel: number): void;
	SetStereoDelayTime(DelayTimeMsec: number): void;
	SetStereoDelayRatio(DelayRatio: number): void;
	SetStereoDelayMode(StereoDelayMode: ESynthStereoDelayMode): void;
	SetStereoDelayIsEnabled(StereoDelayEnabled: boolean): void;
	SetStereoDelayFeedback(DelayFeedback: number): void;
	SetSpread(Spread: number): void;
	SetReleaseTime(ReleaseTimeMsec: number): void;
	SetPortamento(Portamento: number): void;
	SetPitchBend(PitchBend: number): void;
	SetPan(Pan: number): void;
	SetOscType(OscIndex: number,OscType: ESynth1OscType): void;
	SetOscSync(bIsSynced: boolean): void;
	SetOscSemitones(OscIndex: number,Semitones: number): void;
	SetOscPulsewidth(OscIndex: number,Pulsewidth: number): void;
	SetOscOctave(OscIndex: number,Octave: number): void;
	SetOscGainMod(OscIndex: number,OscGainMod: number): void;
	SetOscGain(OscIndex: number,OscGain: number): void;
	SetOscFrequencyMod(OscIndex: number,OscFreqMod: number): void;
	SetOscCents(OscIndex: number,Cents: number): void;
	SetModEnvSustainGain(SustainGain: number): void;
	SetModEnvReleaseTime(Release: number): void;
	SetModEnvPatch(InPatchType: ESynthModEnvPatch): void;
	SetModEnvInvert(bInvert: boolean): void;
	SetModEnvDepth(Depth: number): void;
	SetModEnvDecayTime(DecayTimeMsec: number): void;
	SetModEnvBiasPatch(InPatchType: ESynthModEnvBiasPatch): void;
	SetModEnvBiasInvert(bInvert: boolean): void;
	SetModEnvAttackTime(AttackTimeMsec: number): void;
	SetLFOType(LFOIndex: number,LFOType: ESynthLFOType): void;
	SetLFOPatch(LFOIndex: number,LFOPatchType: ESynthLFOPatchType): void;
	SetLFOMode(LFOIndex: number,LFOMode: ESynthLFOMode): void;
	SetLFOGainMod(LFOIndex: number,GainMod: number): void;
	SetLFOGain(LFOIndex: number,Gain: number): void;
	SetLFOFrequencyMod(LFOIndex: number,FrequencyModHz: number): void;
	SetLFOFrequency(LFOIndex: number,FrequencyHz: number): void;
	SetGainDb(GainDb: number): void;
	SetFilterType(FilterType: ESynthFilterType): void;
	SetFilterQMod(FilterQ: number): void;
	SetFilterQ(FilterQ: number): void;
	SetFilterFrequencyMod(FilterFrequencyHz: number): void;
	SetFilterFrequency(FilterFrequencyHz: number): void;
	SetFilterAlgorithm(FilterAlgorithm: ESynthFilterAlgorithm): void;
	SetEnableUnison(EnableUnison: boolean): void;
	SetEnableRetrigger(RetriggerEnabled: boolean): void;
	SetEnablePolyphony(bEnablePolyphony: boolean): void;
	SetEnablePatch(PatchId: PatchId,bIsEnabled: boolean): boolean;
	SetEnableLegato(LegatoEnabled: boolean): void;
	SetDecayTime(DecayTimeMsec: number): void;
	SetChorusFrequency(Frequency: number): void;
	SetChorusFeedback(Feedback: number): void;
	SetChorusEnabled(EnableChorus: boolean): void;
	SetChorusDepth(Depth: number): void;
	SetAttackTime(AttackTimeMsec: number): void;
	NoteOn(Note: number,Velocity: number,Duration: number): void;
	NoteOff(Note: number,bAllNotesOff: boolean,bKillAllNotes: boolean): void;
	CreatePatch(PatchSource: ESynth1PatchSource,PatchCables: Synth1PatchCable[],bEnableByDefault: boolean): PatchId;
	static C(Other: UObject | any): ModularSynthComponent;
}

declare class SourceEffectBitCrusherSettings { 
	CrushedSampleRate: number;
	SampleRateModulation: SoundModulationDestinationSettings;
	CrushedBits: number;
	BitModulation: SoundModulationDestinationSettings;
	clone() : SourceEffectBitCrusherSettings;
	static C(Other: UObject | any): SourceEffectBitCrusherSettings;
}

declare class SourceEffectBitCrusherBaseSettings { 
	SampleRate: number;
	BitDepth: number;
	clone() : SourceEffectBitCrusherBaseSettings;
	static C(Other: UObject | any): SourceEffectBitCrusherBaseSettings;
}

declare class SourceEffectBitCrusherPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectBitCrusherSettings;
	static Load(ResourceName: string): SourceEffectBitCrusherPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectBitCrusherPreset;
	static GetDefaultObject(): SourceEffectBitCrusherPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectBitCrusherPreset;
	SetSettings(Settings: SourceEffectBitCrusherBaseSettings): void;
	SetSampleRateModulators(InModulators: Set<SoundModulatorBase>): void;
	SetSampleRateModulator(Modulator: SoundModulatorBase): void;
	SetSampleRate(SampleRate: number): void;
	SetModulationSettings(ModulationSettings: SourceEffectBitCrusherSettings): void;
	SetBits(Bits: number): void;
	SetBitModulators(InModulators: Set<SoundModulatorBase>): void;
	SetBitModulator(Modulator: SoundModulatorBase): void;
	static C(Other: UObject | any): SourceEffectBitCrusherPreset;
}

declare class SourceEffectChorusSettings { 
	Depth: number;
	Frequency: number;
	Feedback: number;
	WetLevel: number;
	DryLevel: number;
	Spread: number;
	DepthModulation: SoundModulationDestinationSettings;
	FrequencyModulation: SoundModulationDestinationSettings;
	FeedbackModulation: SoundModulationDestinationSettings;
	WetModulation: SoundModulationDestinationSettings;
	DryModulation: SoundModulationDestinationSettings;
	SpreadModulation: SoundModulationDestinationSettings;
	clone() : SourceEffectChorusSettings;
	static C(Other: UObject | any): SourceEffectChorusSettings;
}

declare class SourceEffectChorusBaseSettings { 
	Depth: number;
	Frequency: number;
	Feedback: number;
	WetLevel: number;
	DryLevel: number;
	Spread: number;
	clone() : SourceEffectChorusBaseSettings;
	static C(Other: UObject | any): SourceEffectChorusBaseSettings;
}

declare class SourceEffectChorusPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectChorusSettings;
	static Load(ResourceName: string): SourceEffectChorusPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectChorusPreset;
	static GetDefaultObject(): SourceEffectChorusPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectChorusPreset;
	SetWetModulators(Modulators: Set<SoundModulatorBase>): void;
	SetWetModulator(Modulator: SoundModulatorBase): void;
	SetWet(WetAmount: number): void;
	SetSpreadModulators(Modulators: Set<SoundModulatorBase>): void;
	SetSpreadModulator(Modulator: SoundModulatorBase): void;
	SetSpread(Spread: number): void;
	SetSettings(Settings: SourceEffectChorusBaseSettings): void;
	SetModulationSettings(ModulationSettings: SourceEffectChorusSettings): void;
	SetFrequencyModulators(Modulators: Set<SoundModulatorBase>): void;
	SetFrequencyModulator(Modulator: SoundModulatorBase): void;
	SetFrequency(Frequency: number): void;
	SetFeedbackModulators(Modulators: Set<SoundModulatorBase>): void;
	SetFeedbackModulator(Modulator: SoundModulatorBase): void;
	SetFeedback(Feedback: number): void;
	SetDryModulators(Modulators: Set<SoundModulatorBase>): void;
	SetDryModulator(Modulator: SoundModulatorBase): void;
	SetDry(DryAmount: number): void;
	SetDepthModulators(Modulators: Set<SoundModulatorBase>): void;
	SetDepthModulator(Modulator: SoundModulatorBase): void;
	SetDepth(Depth: number): void;
	static C(Other: UObject | any): SourceEffectChorusPreset;
}

declare class SourceEffectConvolutionReverbSettings { 
	NormalizationVolumeDb: number;
	WetVolumeDb: number;
	DryVolumeDb: number;
	bBypass: boolean;
	clone() : SourceEffectConvolutionReverbSettings;
	static C(Other: UObject | any): SourceEffectConvolutionReverbSettings;
}

declare type ESubmixEffectConvolutionReverbBlockSize = 'BlockSize256' | 'BlockSize512' | 'BlockSize1024' | 'ESubmixEffectConvolutionReverbBlockSize_MAX';
declare var ESubmixEffectConvolutionReverbBlockSize : { BlockSize256:'BlockSize256',BlockSize512:'BlockSize512',BlockSize1024:'BlockSize1024',ESubmixEffectConvolutionReverbBlockSize_MAX:'ESubmixEffectConvolutionReverbBlockSize_MAX', };
declare class SourceEffectConvolutionReverbPreset extends SoundEffectSourcePreset { 
	ImpulseResponse: AudioImpulseResponse;
	Settings: SourceEffectConvolutionReverbSettings;
	BlockSize: ESubmixEffectConvolutionReverbBlockSize;
	bEnableHardwareAcceleration: boolean;
	static Load(ResourceName: string): SourceEffectConvolutionReverbPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectConvolutionReverbPreset;
	static GetDefaultObject(): SourceEffectConvolutionReverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectConvolutionReverbPreset;
	SetSettings(InSettings: SourceEffectConvolutionReverbSettings): void;
	SetImpulseResponse(InImpulseResponse: AudioImpulseResponse): void;
	static C(Other: UObject | any): SourceEffectConvolutionReverbPreset;
}

declare type ESourceEffectDynamicsProcessorType = 'Compressor' | 'Limiter' | 'Expander' | 'Gate' | 'UpwardsCompressor' | 'Count' | 'ESourceEffectDynamicsProcessorType_MAX';
declare var ESourceEffectDynamicsProcessorType : { Compressor:'Compressor',Limiter:'Limiter',Expander:'Expander',Gate:'Gate',UpwardsCompressor:'UpwardsCompressor',Count:'Count',ESourceEffectDynamicsProcessorType_MAX:'ESourceEffectDynamicsProcessorType_MAX', };
declare type ESourceEffectDynamicsPeakMode = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count' | 'ESourceEffectDynamicsPeakMode_MAX';
declare var ESourceEffectDynamicsPeakMode : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count',ESourceEffectDynamicsPeakMode_MAX:'ESourceEffectDynamicsPeakMode_MAX', };
declare class SourceEffectDynamicsProcessorSettings { 
	DynamicsProcessorType: ESourceEffectDynamicsProcessorType;
	PeakMode: ESourceEffectDynamicsPeakMode;
	LookAheadMsec: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	ThresholdDb: number;
	Ratio: number;
	KneeBandwidthDb: number;
	InputGainDb: number;
	OutputGainDb: number;
	bStereoLinked: boolean;
	bAnalogMode: boolean;
	clone() : SourceEffectDynamicsProcessorSettings;
	static C(Other: UObject | any): SourceEffectDynamicsProcessorSettings;
}

declare class SourceEffectDynamicsProcessorPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectDynamicsProcessorSettings;
	static Load(ResourceName: string): SourceEffectDynamicsProcessorPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectDynamicsProcessorPreset;
	static GetDefaultObject(): SourceEffectDynamicsProcessorPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectDynamicsProcessorPreset;
	SetSettings(InSettings: SourceEffectDynamicsProcessorSettings): void;
	static C(Other: UObject | any): SourceEffectDynamicsProcessorPreset;
}

declare class EnvelopeFollowerListener extends ActorComponent { 
	OnEnvelopeFollowerUpdate: UnrealEngineMulticastDelegate<(EnvelopeValue: number) => void>;
	static Load(ResourceName: string): EnvelopeFollowerListener;
	static Find(Outer: UObject, ResourceName: string): EnvelopeFollowerListener;
	static GetDefaultObject(): EnvelopeFollowerListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvelopeFollowerListener;
	static C(Other: UObject | any): EnvelopeFollowerListener;
}

declare type EEnvelopeFollowerPeakMode = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count' | 'EEnvelopeFollowerPeakMode_MAX';
declare var EEnvelopeFollowerPeakMode : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count',EEnvelopeFollowerPeakMode_MAX:'EEnvelopeFollowerPeakMode_MAX', };
declare class SourceEffectEnvelopeFollowerSettings { 
	AttackTime: number;
	ReleaseTime: number;
	PeakMode: EEnvelopeFollowerPeakMode;
	bIsAnalogMode: boolean;
	clone() : SourceEffectEnvelopeFollowerSettings;
	static C(Other: UObject | any): SourceEffectEnvelopeFollowerSettings;
}

declare class SourceEffectEnvelopeFollowerPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectEnvelopeFollowerSettings;
	static Load(ResourceName: string): SourceEffectEnvelopeFollowerPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectEnvelopeFollowerPreset;
	static GetDefaultObject(): SourceEffectEnvelopeFollowerPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectEnvelopeFollowerPreset;
	UnregisterEnvelopeFollowerListener(EnvelopeFollowerListener: EnvelopeFollowerListener): void;
	SetSettings(InSettings: SourceEffectEnvelopeFollowerSettings): void;
	RegisterEnvelopeFollowerListener(EnvelopeFollowerListener: EnvelopeFollowerListener): void;
	static C(Other: UObject | any): SourceEffectEnvelopeFollowerPreset;
}

declare class SourceEffectEQBand { 
	Frequency: number;
	Bandwidth: number;
	GainDb: number;
	bEnabled: boolean;
	clone() : SourceEffectEQBand;
	static C(Other: UObject | any): SourceEffectEQBand;
}

declare class SourceEffectEQSettings { 
	EQBands: SourceEffectEQBand[];
	clone() : SourceEffectEQSettings;
	static C(Other: UObject | any): SourceEffectEQSettings;
}

declare class SourceEffectEQPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectEQSettings;
	static Load(ResourceName: string): SourceEffectEQPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectEQPreset;
	static GetDefaultObject(): SourceEffectEQPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectEQPreset;
	SetSettings(InSettings: SourceEffectEQSettings): void;
	static C(Other: UObject | any): SourceEffectEQPreset;
}

declare type ESourceEffectFilterCircuit = 'OnePole' | 'StateVariable' | 'Ladder' | 'Count' | 'ESourceEffectFilterCircuit_MAX';
declare var ESourceEffectFilterCircuit : { OnePole:'OnePole',StateVariable:'StateVariable',Ladder:'Ladder',Count:'Count',ESourceEffectFilterCircuit_MAX:'ESourceEffectFilterCircuit_MAX', };
declare type ESourceEffectFilterType = 'LowPass' | 'HighPass' | 'BandPass' | 'BandStop' | 'Count' | 'ESourceEffectFilterType_MAX';
declare var ESourceEffectFilterType : { LowPass:'LowPass',HighPass:'HighPass',BandPass:'BandPass',BandStop:'BandStop',Count:'Count',ESourceEffectFilterType_MAX:'ESourceEffectFilterType_MAX', };
declare type ESourceEffectFilterParam = 'FilterFrequency' | 'FilterResonance' | 'Count' | 'ESourceEffectFilterParam_MAX';
declare var ESourceEffectFilterParam : { FilterFrequency:'FilterFrequency',FilterResonance:'FilterResonance',Count:'Count',ESourceEffectFilterParam_MAX:'ESourceEffectFilterParam_MAX', };
declare class SourceEffectFilterAudioBusModulationSettings { 
	AudioBus: AudioBus;
	EnvelopeFollowerAttackTimeMsec: number;
	EnvelopeFollowerReleaseTimeMsec: number;
	EnvelopeGainMultiplier: number;
	FilterParam: ESourceEffectFilterParam;
	MinFrequencyModulation: number;
	MaxFrequencyModulation: number;
	MinResonanceModulation: number;
	MaxResonanceModulation: number;
	clone() : SourceEffectFilterAudioBusModulationSettings;
	static C(Other: UObject | any): SourceEffectFilterAudioBusModulationSettings;
}

declare class SourceEffectFilterSettings { 
	FilterCircuit: ESourceEffectFilterCircuit;
	FilterType: ESourceEffectFilterType;
	CutoffFrequency: number;
	FilterQ: number;
	AudioBusModulation: SourceEffectFilterAudioBusModulationSettings[];
	clone() : SourceEffectFilterSettings;
	static C(Other: UObject | any): SourceEffectFilterSettings;
}

declare class SourceEffectFilterPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectFilterSettings;
	static Load(ResourceName: string): SourceEffectFilterPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectFilterPreset;
	static GetDefaultObject(): SourceEffectFilterPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectFilterPreset;
	SetSettings(InSettings: SourceEffectFilterSettings): void;
	static C(Other: UObject | any): SourceEffectFilterPreset;
}

declare class SourceEffectFoldbackDistortionSettings { 
	InputGainDb: number;
	ThresholdDb: number;
	OutputGainDb: number;
	clone() : SourceEffectFoldbackDistortionSettings;
	static C(Other: UObject | any): SourceEffectFoldbackDistortionSettings;
}

declare class SourceEffectFoldbackDistortionPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectFoldbackDistortionSettings;
	static Load(ResourceName: string): SourceEffectFoldbackDistortionPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectFoldbackDistortionPreset;
	static GetDefaultObject(): SourceEffectFoldbackDistortionPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectFoldbackDistortionPreset;
	SetSettings(InSettings: SourceEffectFoldbackDistortionSettings): void;
	static C(Other: UObject | any): SourceEffectFoldbackDistortionPreset;
}

declare type EStereoChannelMode = 'MidSide' | 'LeftRight' | 'count' | 'EStereoChannelMode_MAX';
declare var EStereoChannelMode : { MidSide:'MidSide',LeftRight:'LeftRight',count:'count',EStereoChannelMode_MAX:'EStereoChannelMode_MAX', };
declare class SourceEffectMidSideSpreaderSettings { 
	SpreadAmount: number;
	InputMode: EStereoChannelMode;
	OutputMode: EStereoChannelMode;
	bEqualPower: boolean;
	clone() : SourceEffectMidSideSpreaderSettings;
	static C(Other: UObject | any): SourceEffectMidSideSpreaderSettings;
}

declare class SourceEffectMidSideSpreaderPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectMidSideSpreaderSettings;
	static Load(ResourceName: string): SourceEffectMidSideSpreaderPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectMidSideSpreaderPreset;
	static GetDefaultObject(): SourceEffectMidSideSpreaderPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectMidSideSpreaderPreset;
	SetSettings(InSettings: SourceEffectMidSideSpreaderSettings): void;
	static C(Other: UObject | any): SourceEffectMidSideSpreaderPreset;
}

declare type ESourceEffectMotionFilterTopology = 'SerialMode' | 'ParallelMode' | 'Count' | 'ESourceEffectMotionFilterTopology_MAX';
declare var ESourceEffectMotionFilterTopology : { SerialMode:'SerialMode',ParallelMode:'ParallelMode',Count:'Count',ESourceEffectMotionFilterTopology_MAX:'ESourceEffectMotionFilterTopology_MAX', };
declare type ESourceEffectMotionFilterCircuit = 'OnePole' | 'StateVariable' | 'Ladder' | 'Count' | 'ESourceEffectMotionFilterCircuit_MAX';
declare var ESourceEffectMotionFilterCircuit : { OnePole:'OnePole',StateVariable:'StateVariable',Ladder:'Ladder',Count:'Count',ESourceEffectMotionFilterCircuit_MAX:'ESourceEffectMotionFilterCircuit_MAX', };
declare type ESourceEffectMotionFilterType = 'LowPass' | 'HighPass' | 'BandPass' | 'BandStop' | 'Count' | 'ESourceEffectMotionFilterType_MAX';
declare var ESourceEffectMotionFilterType : { LowPass:'LowPass',HighPass:'HighPass',BandPass:'BandPass',BandStop:'BandStop',Count:'Count',ESourceEffectMotionFilterType_MAX:'ESourceEffectMotionFilterType_MAX', };
declare class SourceEffectIndividualFilterSettings { 
	FilterCircuit: ESourceEffectMotionFilterCircuit;
	FilterType: ESourceEffectMotionFilterType;
	CutoffFrequency: number;
	FilterQ: number;
	clone() : SourceEffectIndividualFilterSettings;
	static C(Other: UObject | any): SourceEffectIndividualFilterSettings;
}

declare type ESourceEffectMotionFilterModDestination = 'FilterACutoffFrequency' | 'FilterAResonance' | 'FilterAOutputVolumeDB' | 'FilterBCutoffFrequency' | 'FilterBResonance' | 'FilterBOutputVolumeDB' | 'FilterMix' | 'Count' | 'ESourceEffectMotionFilterModDestination_MAX';
declare var ESourceEffectMotionFilterModDestination : { FilterACutoffFrequency:'FilterACutoffFrequency',FilterAResonance:'FilterAResonance',FilterAOutputVolumeDB:'FilterAOutputVolumeDB',FilterBCutoffFrequency:'FilterBCutoffFrequency',FilterBResonance:'FilterBResonance',FilterBOutputVolumeDB:'FilterBOutputVolumeDB',FilterMix:'FilterMix',Count:'Count',ESourceEffectMotionFilterModDestination_MAX:'ESourceEffectMotionFilterModDestination_MAX', };
declare type ESourceEffectMotionFilterModSource = 'DistanceFromListener' | 'SpeedRelativeToListener' | 'SpeedOfSourceEmitter' | 'SpeedOfListener' | 'SpeedOfAngleDelta' | 'Count' | 'ESourceEffectMotionFilterModSource_MAX';
declare var ESourceEffectMotionFilterModSource : { DistanceFromListener:'DistanceFromListener',SpeedRelativeToListener:'SpeedRelativeToListener',SpeedOfSourceEmitter:'SpeedOfSourceEmitter',SpeedOfListener:'SpeedOfListener',SpeedOfAngleDelta:'SpeedOfAngleDelta',Count:'Count',ESourceEffectMotionFilterModSource_MAX:'ESourceEffectMotionFilterModSource_MAX', };
declare class SourceEffectMotionFilterModulationSettings { 
	ModulationSource: ESourceEffectMotionFilterModSource;
	ModulationInputRange: Vector2D;
	ModulationOutputMinimumRange: Vector2D;
	ModulationOutputMaximumRange: Vector2D;
	UpdateEaseMS: number;
	clone() : SourceEffectMotionFilterModulationSettings;
	static C(Other: UObject | any): SourceEffectMotionFilterModulationSettings;
}

declare class SourceEffectMotionFilterSettings { 
	MotionFilterTopology: ESourceEffectMotionFilterTopology;
	MotionFilterMix: number;
	FilterASettings: SourceEffectIndividualFilterSettings;
	FilterBSettings: SourceEffectIndividualFilterSettings;
	ModulationMappings: Map<ESourceEffectMotionFilterModDestination, SourceEffectMotionFilterModulationSettings>;
	DryVolumeDb: number;
	clone() : SourceEffectMotionFilterSettings;
	static C(Other: UObject | any): SourceEffectMotionFilterSettings;
}

declare class SourceEffectMotionFilterPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectMotionFilterSettings;
	static Load(ResourceName: string): SourceEffectMotionFilterPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectMotionFilterPreset;
	static GetDefaultObject(): SourceEffectMotionFilterPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectMotionFilterPreset;
	SetSettings(InSettings: SourceEffectMotionFilterSettings): void;
	static C(Other: UObject | any): SourceEffectMotionFilterPreset;
}

declare class SourceEffectPannerSettings { 
	Spread: number;
	Pan: number;
	clone() : SourceEffectPannerSettings;
	static C(Other: UObject | any): SourceEffectPannerSettings;
}

declare class SourceEffectPannerPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectPannerSettings;
	static Load(ResourceName: string): SourceEffectPannerPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectPannerPreset;
	static GetDefaultObject(): SourceEffectPannerPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectPannerPreset;
	SetSettings(InSettings: SourceEffectPannerSettings): void;
	static C(Other: UObject | any): SourceEffectPannerPreset;
}

declare type EPhaserLFOType = 'Sine' | 'UpSaw' | 'DownSaw' | 'Square' | 'Triangle' | 'Exponential' | 'RandomSampleHold' | 'Count' | 'EPhaserLFOType_MAX';
declare var EPhaserLFOType : { Sine:'Sine',UpSaw:'UpSaw',DownSaw:'DownSaw',Square:'Square',Triangle:'Triangle',Exponential:'Exponential',RandomSampleHold:'RandomSampleHold',Count:'Count',EPhaserLFOType_MAX:'EPhaserLFOType_MAX', };
declare class SourceEffectPhaserSettings { 
	WetLevel: number;
	Frequency: number;
	Feedback: number;
	LFOType: EPhaserLFOType;
	UseQuadraturePhase: boolean;
	clone() : SourceEffectPhaserSettings;
	static C(Other: UObject | any): SourceEffectPhaserSettings;
}

declare class SourceEffectPhaserPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectPhaserSettings;
	static Load(ResourceName: string): SourceEffectPhaserPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectPhaserPreset;
	static GetDefaultObject(): SourceEffectPhaserPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectPhaserPreset;
	SetSettings(InSettings: SourceEffectPhaserSettings): void;
	static C(Other: UObject | any): SourceEffectPhaserPreset;
}

declare type ERingModulatorTypeSourceEffect = 'Sine' | 'Saw' | 'Triangle' | 'Square' | 'Count' | 'ERingModulatorTypeSourceEffect_MAX';
declare var ERingModulatorTypeSourceEffect : { Sine:'Sine',Saw:'Saw',Triangle:'Triangle',Square:'Square',Count:'Count',ERingModulatorTypeSourceEffect_MAX:'ERingModulatorTypeSourceEffect_MAX', };
declare class SourceEffectRingModulationSettings { 
	ModulatorType: ERingModulatorTypeSourceEffect;
	Frequency: number;
	Depth: number;
	DryLevel: number;
	WetLevel: number;
	AudioBusModulator: AudioBus;
	clone() : SourceEffectRingModulationSettings;
	static C(Other: UObject | any): SourceEffectRingModulationSettings;
}

declare class SourceEffectRingModulationPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectRingModulationSettings;
	static Load(ResourceName: string): SourceEffectRingModulationPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectRingModulationPreset;
	static GetDefaultObject(): SourceEffectRingModulationPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectRingModulationPreset;
	SetSettings(InSettings: SourceEffectRingModulationSettings): void;
	static C(Other: UObject | any): SourceEffectRingModulationPreset;
}

declare class SourceEffectSimpleDelaySettings { 
	SpeedOfSound: number;
	DelayAmount: number;
	DryAmount: number;
	WetAmount: number;
	Feedback: number;
	bDelayBasedOnDistance: boolean;
	bUseDistanceOverride: boolean;
	clone() : SourceEffectSimpleDelaySettings;
	static C(Other: UObject | any): SourceEffectSimpleDelaySettings;
}

declare class SourceEffectSimpleDelayPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectSimpleDelaySettings;
	static Load(ResourceName: string): SourceEffectSimpleDelayPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectSimpleDelayPreset;
	static GetDefaultObject(): SourceEffectSimpleDelayPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectSimpleDelayPreset;
	SetSettings(InSettings: SourceEffectSimpleDelaySettings): void;
	static C(Other: UObject | any): SourceEffectSimpleDelayPreset;
}

declare type EStereoDelaySourceEffect = 'Normal' | 'Cross' | 'PingPong' | 'Count' | 'EStereoDelaySourceEffect_MAX';
declare var EStereoDelaySourceEffect : { Normal:'Normal',Cross:'Cross',PingPong:'PingPong',Count:'Count',EStereoDelaySourceEffect_MAX:'EStereoDelaySourceEffect_MAX', };
declare type EStereoDelayFiltertype = 'Lowpass' | 'Highpass' | 'Bandpass' | 'Notch' | 'Count' | 'EStereoDelayFiltertype_MAX';
declare var EStereoDelayFiltertype : { Lowpass:'Lowpass',Highpass:'Highpass',Bandpass:'Bandpass',Notch:'Notch',Count:'Count',EStereoDelayFiltertype_MAX:'EStereoDelayFiltertype_MAX', };
declare class SourceEffectStereoDelaySettings { 
	DelayMode: EStereoDelaySourceEffect;
	DelayTimeMsec: number;
	Feedback: number;
	DelayRatio: number;
	WetLevel: number;
	DryLevel: number;
	bFilterEnabled: boolean;
	FilterType: EStereoDelayFiltertype;
	FilterFrequency: number;
	FilterQ: number;
	clone() : SourceEffectStereoDelaySettings;
	static C(Other: UObject | any): SourceEffectStereoDelaySettings;
}

declare class SourceEffectStereoDelayPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectStereoDelaySettings;
	static Load(ResourceName: string): SourceEffectStereoDelayPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectStereoDelayPreset;
	static GetDefaultObject(): SourceEffectStereoDelayPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectStereoDelayPreset;
	SetSettings(InSettings: SourceEffectStereoDelaySettings): void;
	static C(Other: UObject | any): SourceEffectStereoDelayPreset;
}

declare class SourceEffectWaveShaperSettings { 
	Amount: number;
	OutputGainDb: number;
	clone() : SourceEffectWaveShaperSettings;
	static C(Other: UObject | any): SourceEffectWaveShaperSettings;
}

declare class SourceEffectWaveShaperPreset extends SoundEffectSourcePreset { 
	Settings: SourceEffectWaveShaperSettings;
	static Load(ResourceName: string): SourceEffectWaveShaperPreset;
	static Find(Outer: UObject, ResourceName: string): SourceEffectWaveShaperPreset;
	static GetDefaultObject(): SourceEffectWaveShaperPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceEffectWaveShaperPreset;
	SetSettings(InSettings: SourceEffectWaveShaperSettings): void;
	static C(Other: UObject | any): SourceEffectWaveShaperPreset;
}

declare class SubmixEffectConvolutionReverbSettings { 
	NormalizationVolumeDb: number;
	WetVolumeDb: number;
	DryVolumeDb: number;
	bBypass: boolean;
	bMixInputChannelFormatToImpulseResponseFormat: boolean;
	bMixReverbOutputToOutputChannelFormat: boolean;
	SurroundRearChannelBleedDb: number;
	bInvertRearChannelBleedPhase: boolean;
	bSurroundRearChannelFlip: boolean;
	SurroundRearChannelBleedAmount: number;
	ImpulseResponse: AudioImpulseResponse;
	AllowHardwareAcceleration: boolean;
	clone() : SubmixEffectConvolutionReverbSettings;
	static C(Other: UObject | any): SubmixEffectConvolutionReverbSettings;
}

declare class SubmixEffectConvolutionReverbPreset extends SoundEffectSubmixPreset { 
	ImpulseResponse: AudioImpulseResponse;
	Settings: SubmixEffectConvolutionReverbSettings;
	BlockSize: ESubmixEffectConvolutionReverbBlockSize;
	bEnableHardwareAcceleration: boolean;
	static Load(ResourceName: string): SubmixEffectConvolutionReverbPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectConvolutionReverbPreset;
	static GetDefaultObject(): SubmixEffectConvolutionReverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectConvolutionReverbPreset;
	SetSettings(InSettings: SubmixEffectConvolutionReverbSettings): void;
	SetImpulseResponse(InImpulseResponse: AudioImpulseResponse): void;
	static C(Other: UObject | any): SubmixEffectConvolutionReverbPreset;
}

declare class SubmixEffectDelaySettings { 
	MaximumDelayLength: number;
	InterpolationTime: number;
	DelayLength: number;
	clone() : SubmixEffectDelaySettings;
	static C(Other: UObject | any): SubmixEffectDelaySettings;
	SetDelayLength(DelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	SetInterpolationTime(InterpolationTime?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	SetMaximumDelayLength(MaximumDelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static SetDelayLength(DelaySettings?: SubmixEffectDelaySettings,DelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static SetInterpolationTime(DelaySettings?: SubmixEffectDelaySettings,InterpolationTime?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static SetMaximumDelayLength(DelaySettings?: SubmixEffectDelaySettings,MaximumDelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
}

declare class SubmixEffectDelayStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubmixEffectDelayStatics;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectDelayStatics;
	static GetDefaultObject(): SubmixEffectDelayStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectDelayStatics;
	static SetMaximumDelayLength(DelaySettings?: SubmixEffectDelaySettings,MaximumDelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static SetInterpolationTime(DelaySettings?: SubmixEffectDelaySettings,InterpolationTime?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static SetDelayLength(DelaySettings?: SubmixEffectDelaySettings,DelayLength?: number): {DelaySettings: SubmixEffectDelaySettings, $: SubmixEffectDelaySettings};
	static C(Other: UObject | any): SubmixEffectDelayStatics;
}

declare class SubmixEffectDelayPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectDelaySettings;
	DynamicSettings: SubmixEffectDelaySettings;
	static Load(ResourceName: string): SubmixEffectDelayPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectDelayPreset;
	static GetDefaultObject(): SubmixEffectDelayPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectDelayPreset;
	SetSettings(InSettings: SubmixEffectDelaySettings): void;
	SetInterpolationTime(Time: number): void;
	SetDelay(Length: number): void;
	SetDefaultSettings(InSettings: SubmixEffectDelaySettings): void;
	GetMaxDelayInMilliseconds(): number;
	static C(Other: UObject | any): SubmixEffectDelayPreset;
}

declare type ESubmixFilterType = 'LowPass' | 'HighPass' | 'BandPass' | 'BandStop' | 'Count' | 'ESubmixFilterType_MAX';
declare var ESubmixFilterType : { LowPass:'LowPass',HighPass:'HighPass',BandPass:'BandPass',BandStop:'BandStop',Count:'Count',ESubmixFilterType_MAX:'ESubmixFilterType_MAX', };
declare type ESubmixFilterAlgorithm = 'OnePole' | 'StateVariable' | 'Ladder' | 'Count' | 'ESubmixFilterAlgorithm_MAX';
declare var ESubmixFilterAlgorithm : { OnePole:'OnePole',StateVariable:'StateVariable',Ladder:'Ladder',Count:'Count',ESubmixFilterAlgorithm_MAX:'ESubmixFilterAlgorithm_MAX', };
declare class SubmixEffectFilterSettings { 
	FilterType: ESubmixFilterType;
	FilterAlgorithm: ESubmixFilterAlgorithm;
	FilterFrequency: number;
	FilterQ: number;
	clone() : SubmixEffectFilterSettings;
	static C(Other: UObject | any): SubmixEffectFilterSettings;
}

declare class SubmixEffectFilterPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectFilterSettings;
	static Load(ResourceName: string): SubmixEffectFilterPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectFilterPreset;
	static GetDefaultObject(): SubmixEffectFilterPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectFilterPreset;
	SetSettings(InSettings: SubmixEffectFilterSettings): void;
	SetFilterType(InType: ESubmixFilterType): void;
	SetFilterQMod(InQ: number): void;
	SetFilterQ(InQ: number): void;
	SetFilterCutoffFrequencyMod(InFrequency: number): void;
	SetFilterCutoffFrequency(InFrequency: number): void;
	SetFilterAlgorithm(InAlgorithm: ESubmixFilterAlgorithm): void;
	static C(Other: UObject | any): SubmixEffectFilterPreset;
}

declare class SubmixEffectFlexiverbSettings { 
	PreDelay: number;
	DecayTime: number;
	RoomDampening: number;
	Complexity: number;
	clone() : SubmixEffectFlexiverbSettings;
	static C(Other: UObject | any): SubmixEffectFlexiverbSettings;
}

declare class SubmixEffectFlexiverbPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectFlexiverbSettings;
	static Load(ResourceName: string): SubmixEffectFlexiverbPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectFlexiverbPreset;
	static GetDefaultObject(): SubmixEffectFlexiverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectFlexiverbPreset;
	SetSettings(InSettings: SubmixEffectFlexiverbSettings): void;
	static C(Other: UObject | any): SubmixEffectFlexiverbPreset;
}

declare class DynamicsBandSettings { 
	CrossoverTopFrequency: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	ThresholdDb: number;
	Ratio: number;
	KneeBandwidthDb: number;
	InputGainDb: number;
	OutputGainDb: number;
	clone() : DynamicsBandSettings;
	static C(Other: UObject | any): DynamicsBandSettings;
}

declare class SubmixEffectMultibandCompressorSettings { 
	DynamicsProcessorType: ESubmixEffectDynamicsProcessorType;
	PeakMode: ESubmixEffectDynamicsPeakMode;
	LinkMode: ESubmixEffectDynamicsChannelLinkMode;
	LookAheadMsec: number;
	bAnalogMode: boolean;
	bFourPole: boolean;
	bBypass: boolean;
	KeySource: ESubmixEffectDynamicsKeySource;
	ExternalAudioBus: AudioBus;
	ExternalSubmix: SoundSubmix;
	KeyGainDb: number;
	bKeyAudition: boolean;
	Bands: DynamicsBandSettings[];
	clone() : SubmixEffectMultibandCompressorSettings;
	static C(Other: UObject | any): SubmixEffectMultibandCompressorSettings;
}

declare class SubmixEffectMultibandCompressorPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectMultibandCompressorSettings;
	static Load(ResourceName: string): SubmixEffectMultibandCompressorPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectMultibandCompressorPreset;
	static GetDefaultObject(): SubmixEffectMultibandCompressorPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectMultibandCompressorPreset;
	SetSettings(InSettings: SubmixEffectMultibandCompressorSettings): void;
	SetExternalSubmix(Submix: SoundSubmix): void;
	SetAudioBus(AudioBus: AudioBus): void;
	ResetKey(): void;
	static C(Other: UObject | any): SubmixEffectMultibandCompressorPreset;
}

declare class SubmixEffectStereoDelaySettings { 
	DelayMode: EStereoDelaySourceEffect;
	DelayTimeMsec: number;
	Feedback: number;
	DelayRatio: number;
	WetLevel: number;
	DryLevel: number;
	bFilterEnabled: boolean;
	FilterType: EStereoDelayFiltertype;
	FilterFrequency: number;
	FilterQ: number;
	clone() : SubmixEffectStereoDelaySettings;
	static C(Other: UObject | any): SubmixEffectStereoDelaySettings;
}

declare class SubmixEffectStereoDelayPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectStereoDelaySettings;
	static Load(ResourceName: string): SubmixEffectStereoDelayPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectStereoDelayPreset;
	static GetDefaultObject(): SubmixEffectStereoDelayPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectStereoDelayPreset;
	SetSettings(InSettings: SubmixEffectStereoDelaySettings): void;
	static C(Other: UObject | any): SubmixEffectStereoDelayPreset;
}

declare type ETapLineMode = 'SendToChannel' | 'Panning' | 'Disabled' | 'ETapLineMode_MAX';
declare var ETapLineMode : { SendToChannel:'SendToChannel',Panning:'Panning',Disabled:'Disabled',ETapLineMode_MAX:'ETapLineMode_MAX', };
declare class TapDelayInfo { 
	TapLineMode: ETapLineMode;
	DelayLength: number;
	Gain: number;
	OutputChannel: number;
	PanInDegrees: number;
	TapId: number;
	clone() : TapDelayInfo;
	static C(Other: UObject | any): TapDelayInfo;
}

declare class SubmixEffectTapDelaySettings { 
	MaximumDelayLength: number;
	InterpolationTime: number;
	Taps: TapDelayInfo[];
	clone() : SubmixEffectTapDelaySettings;
	static C(Other: UObject | any): SubmixEffectTapDelaySettings;
}

declare class SubmixEffectTapDelayPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectTapDelaySettings;
	static Load(ResourceName: string): SubmixEffectTapDelayPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectTapDelayPreset;
	static GetDefaultObject(): SubmixEffectTapDelayPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectTapDelayPreset;
	SetTap(TapId: number,TapInfo: TapDelayInfo): void;
	SetSettings(InSettings: SubmixEffectTapDelaySettings): void;
	SetInterpolationTime(Time: number): void;
	RemoveTap(TapId: number): void;
	GetTapIds(TapIds?: number[]): {TapIds: number[]};
	GetTap(TapId: number,TapInfo?: TapDelayInfo): {TapInfo: TapDelayInfo};
	GetMaxDelayInMilliseconds(): number;
	AddTap(TapId?: number): {TapId: number};
	static C(Other: UObject | any): SubmixEffectTapDelayPreset;
}

declare type EGranularSynthSeekType = 'FromBeginning' | 'FromCurrentPosition' | 'Count' | 'EGranularSynthSeekType_MAX';
declare var EGranularSynthSeekType : { FromBeginning:'FromBeginning',FromCurrentPosition:'FromCurrentPosition',Count:'Count',EGranularSynthSeekType_MAX:'EGranularSynthSeekType_MAX', };
declare type EGranularSynthEnvelopeType = 'Rectangular' | 'Triangle' | 'DownwardTriangle' | 'UpwardTriangle' | 'ExponentialDecay' | 'ExponentialIncrease' | 'Gaussian' | 'Hanning' | 'Lanczos' | 'Cosine' | 'CosineSquared' | 'Welch' | 'Blackman' | 'BlackmanHarris' | 'Count' | 'EGranularSynthEnvelopeType_MAX';
declare var EGranularSynthEnvelopeType : { Rectangular:'Rectangular',Triangle:'Triangle',DownwardTriangle:'DownwardTriangle',UpwardTriangle:'UpwardTriangle',ExponentialDecay:'ExponentialDecay',ExponentialIncrease:'ExponentialIncrease',Gaussian:'Gaussian',Hanning:'Hanning',Lanczos:'Lanczos',Cosine:'Cosine',CosineSquared:'CosineSquared',Welch:'Welch',Blackman:'Blackman',BlackmanHarris:'BlackmanHarris',Count:'Count',EGranularSynthEnvelopeType_MAX:'EGranularSynthEnvelopeType_MAX', };
declare class GranularSynth extends SynthComponent { 
	GranulatedSoundWave: SoundWave;
	static Load(ResourceName: string): GranularSynth;
	static Find(Outer: UObject, ResourceName: string): GranularSynth;
	static GetDefaultObject(): GranularSynth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GranularSynth;
	SetSustainGain(SustainGain: number): void;
	SetSoundWave(InSoundWave: SoundWave): void;
	SetScrubMode(bScrubMode: boolean): void;
	SetReleaseTimeMsec(ReleaseTimeMsec: number): void;
	SetPlayheadTime(InPositionSec: number,LerpTimeSec: number,SeekType: EGranularSynthSeekType): void;
	SetPlaybackSpeed(InPlayheadRate: number): void;
	SetGrainVolume(BaseVolume: number,VolumeRange: Vector2D): void;
	SetGrainsPerSecond(InGrainsPerSecond: number): void;
	SetGrainProbability(InGrainProbability: number): void;
	SetGrainPitch(BasePitch: number,PitchRange: Vector2D): void;
	SetGrainPan(BasePan: number,PanRange: Vector2D): void;
	SetGrainEnvelopeType(EnvelopeType: EGranularSynthEnvelopeType): void;
	SetGrainDuration(BaseDurationMsec: number,DurationRange: Vector2D): void;
	SetDecayTime(DecayTimeMsec: number): void;
	SetAttackTime(AttackTimeMsec: number): void;
	NoteOn(Note: number,Velocity: number,Duration: number): void;
	NoteOff(Note: number,bKill: boolean): void;
	IsLoaded(): boolean;
	GetSampleDuration(): number;
	GetCurrentPlayheadTime(): number;
	static C(Other: UObject | any): GranularSynth;
}

declare class MonoWaveTableSynthPreset extends UObject { 
	PresetName: string;
	bLockKeyframesToGridBool: boolean;
	LockKeyframesToGrid: number;
	WaveTableResolution: number;
	WaveTable: RuntimeFloatCurve[];
	bNormalizeWaveTables: boolean;
	static Load(ResourceName: string): MonoWaveTableSynthPreset;
	static Find(Outer: UObject, ResourceName: string): MonoWaveTableSynthPreset;
	static GetDefaultObject(): MonoWaveTableSynthPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MonoWaveTableSynthPreset;
	static C(Other: UObject | any): MonoWaveTableSynthPreset;
}

declare type CurveInterpolationType = 'AUTOINTERP' | 'LINEAR' | 'CONSTANT' | 'CurveInterpolationType_MAX';
declare var CurveInterpolationType : { AUTOINTERP:'AUTOINTERP',LINEAR:'LINEAR',CONSTANT:'CONSTANT',CurveInterpolationType_MAX:'CurveInterpolationType_MAX', };
declare class SynthComponentMonoWaveTable extends SynthComponent { 
	OnTableAltered: UnrealEngineMulticastDelegate<(TableIndex: number) => void>;
	OnNumTablesChanged: UnrealEngineMulticastDelegate<() => void>;
	CurrentPreset: MonoWaveTableSynthPreset;
	static Load(ResourceName: string): SynthComponentMonoWaveTable;
	static Find(Outer: UObject, ResourceName: string): SynthComponentMonoWaveTable;
	static GetDefaultObject(): SynthComponentMonoWaveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponentMonoWaveTable;
	SetWaveTablePosition(InPosition: number): void;
	SetSustainPedalState(InSustainPedalState: boolean): void;
	SetPosLfoType(InLfoType: ESynthLFOType): void;
	SetPosLfoFrequency(InLfoFrequency: number): void;
	SetPosLfoDepth(InLfoDepth: number): void;
	SetPositionEnvelopeSustainGain(InSustainGain: number): void;
	SetPositionEnvelopeReleaseTime(InReleaseTimeMsec: number): void;
	SetPositionEnvelopeInvert(bInInvert: boolean): void;
	SetPositionEnvelopeDepth(InDepth: number): void;
	SetPositionEnvelopeDecayTime(InDecayTimeMsec: number): void;
	SetPositionEnvelopeBiasInvert(bInBiasInvert: boolean): void;
	SetPositionEnvelopeBiasDepth(InDepth: number): void;
	SetPositionEnvelopeAttackTime(InAttackTimeMsec: number): void;
	SetLowPassFilterResonance(InNewQ: number): void;
	SetFrequencyWithMidiNote(InMidiNote: number): void;
	SetFrequencyPitchBend(FrequencyOffsetCents: number): void;
	SetFrequency(FrequencyHz: number): void;
	SetFilterEnvelopeSustainGain(InSustainGain: number): void;
	SetFilterEnvelopeReleaseTime(InReleaseTimeMsec: number): void;
	SetFilterEnvelopenDecayTime(InDecayTimeMsec: number): void;
	SetFilterEnvelopeInvert(bInInvert: boolean): void;
	SetFilterEnvelopeDepth(InDepth: number): void;
	SetFilterEnvelopeBiasInvert(bInBiasInvert: boolean): void;
	SetFilterEnvelopeBiasDepth(InDepth: number): void;
	SetFilterEnvelopeAttackTime(InAttackTimeMsec: number): void;
	SetCurveValue(TableIndex: number,KeyframeIndex: number,NewValue: number): boolean;
	SetCurveTangent(TableIndex: number,InNewTangent: number): boolean;
	SetCurveInterpolationType(InterpolationType: CurveInterpolationType,TableIndex: number): boolean;
	SetAmpEnvelopeSustainGain(InSustainGain: number): void;
	SetAmpEnvelopeReleaseTime(InReleaseTimeMsec: number): void;
	SetAmpEnvelopeInvert(bInInvert: boolean): void;
	SetAmpEnvelopeDepth(InDepth: number): void;
	SetAmpEnvelopeDecayTime(InDecayTimeMsec: number): void;
	SetAmpEnvelopeBiasInvert(bInBiasInvert: boolean): void;
	SetAmpEnvelopeBiasDepth(InDepth: number): void;
	SetAmpEnvelopeAttackTime(InAttackTimeMsec: number): void;
	RefreshWaveTable(Index: number): void;
	RefreshAllWaveTables(): void;
	NoteOn(InMidiNote: number,InVelocity: number): void;
	NoteOff(InMidiNote: number): void;
	GetNumTableEntries(): number;
	GetMaxTableIndex(): number;
	GetKeyFrameValuesForTable(TableIndex: number): number[];
	GetCurveTangent(TableIndex: number): number;
	static C(Other: UObject | any): SynthComponentMonoWaveTable;
}

