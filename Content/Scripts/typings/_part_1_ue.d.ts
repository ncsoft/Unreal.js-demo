declare class BTAuxiliaryNode extends BTNode { 
	static Load(ResourceName: string): BTAuxiliaryNode;
	static Find(Outer: UObject, ResourceName: string): BTAuxiliaryNode;
	static GetDefaultObject(): BTAuxiliaryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTAuxiliaryNode;
	static C(Other: UObject | any): BTAuxiliaryNode;
}

declare class BTService extends BTAuxiliaryNode { 
	Interval: number;
	RandomDeviation: number;
	bCallTickOnSearchStart: boolean;
	bRestartTimerOnEachActivation: boolean;
	static Load(ResourceName: string): BTService;
	static Find(Outer: UObject, ResourceName: string): BTService;
	static GetDefaultObject(): BTService;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService;
	static C(Other: UObject | any): BTService;
}

declare class BTTaskNode extends BTNode { 
	Services: BTService[];
	bIgnoreRestartSelf: boolean;
	static Load(ResourceName: string): BTTaskNode;
	static Find(Outer: UObject, ResourceName: string): BTTaskNode;
	static GetDefaultObject(): BTTaskNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTaskNode;
	static C(Other: UObject | any): BTTaskNode;
}

declare type EBTFlowAbortMode = 'None' | 'LowerPriority' | 'Self' | 'Both' | 'EBTFlowAbortMode_MAX';
declare var EBTFlowAbortMode : { None:'None',LowerPriority:'LowerPriority',Self:'Self',Both:'Both',EBTFlowAbortMode_MAX:'EBTFlowAbortMode_MAX', };
declare class BTDecorator extends BTAuxiliaryNode { 
	bInverseCondition: boolean;
	FlowAbortMode: EBTFlowAbortMode;
	static Load(ResourceName: string): BTDecorator;
	static Find(Outer: UObject, ResourceName: string): BTDecorator;
	static GetDefaultObject(): BTDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator;
	static C(Other: UObject | any): BTDecorator;
}

declare type EBTDecoratorLogic = 'Invalid' | 'Test' | 'And' | 'Or' | 'Not' | 'EBTDecoratorLogic_MAX';
declare var EBTDecoratorLogic : { Invalid:'Invalid',Test:'Test',And:'And',Or:'Or',Not:'Not',EBTDecoratorLogic_MAX:'EBTDecoratorLogic_MAX', };
declare class BTDecoratorLogic { 
	Operation: EBTDecoratorLogic;
	Number: number;
	clone() : BTDecoratorLogic;
	static C(Other: UObject | any): BTDecoratorLogic;
}

declare class BTCompositeChild { 
	ChildComposite: BTCompositeNode;
	ChildTask: BTTaskNode;
	Decorators: BTDecorator[];
	DecoratorOps: BTDecoratorLogic[];
	clone() : BTCompositeChild;
	static C(Other: UObject | any): BTCompositeChild;
}

declare class BTCompositeNode extends BTNode { 
	Children: BTCompositeChild[];
	Services: BTService[];
	bApplyDecoratorScope: boolean;
	static Load(ResourceName: string): BTCompositeNode;
	static Find(Outer: UObject, ResourceName: string): BTCompositeNode;
	static GetDefaultObject(): BTCompositeNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTCompositeNode;
	static C(Other: UObject | any): BTCompositeNode;
}

declare class EditedDocumentInfo { 
	EditedObjectPath: SoftObjectPath;
	SavedViewOffset: Vector2D;
	SavedZoomAmount: number;
	EditedObject: UObject;
	clone() : EditedDocumentInfo;
	static C(Other: UObject | any): EditedDocumentInfo;
}

declare class BehaviorTree extends UObject { 
	RootNode: BTCompositeNode;
	BTGraph: EdGraph;
	LastEditedDocuments: EditedDocumentInfo[];
	BlackboardAsset: BlackboardData;
	RootDecorators: BTDecorator[];
	RootDecoratorOps: BTDecoratorLogic[];
	static Load(ResourceName: string): BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): BehaviorTree;
	static GetDefaultObject(): BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTree;
	static C(Other: UObject | any): BehaviorTree;
}

declare class XRDeviceId { 
	SystemName: string;
	DeviceID: number;
	clone() : XRDeviceId;
	static C(Other: UObject | any): XRDeviceId;
	GetDevicePose(bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	IsDeviceTracking(): boolean;
	static GetDevicePose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
}

declare type ETrackingStatus = 'NotTracked' | 'InertialOnly' | 'Tracked' | 'ETrackingStatus_MAX';
declare var ETrackingStatus : { NotTracked:'NotTracked',InertialOnly:'InertialOnly',Tracked:'Tracked',ETrackingStatus_MAX:'ETrackingStatus_MAX', };
declare class XRHMDData { 
	bValid: boolean;
	DeviceName: string;
	ApplicationInstanceID: Guid;
	TrackingStatus: ETrackingStatus;
	Position: Vector;
	Rotation: Quat;
	clone() : XRHMDData;
	static C(Other: UObject | any): XRHMDData;
}

declare type EXRVisualType = 'Controller' | 'Hand' | 'EXRVisualType_MAX';
declare var EXRVisualType : { Controller:'Controller',Hand:'Hand',EXRVisualType_MAX:'EXRVisualType_MAX', };
declare class XRMotionControllerData { 
	bValid: boolean;
	DeviceName: string;
	ApplicationInstanceID: Guid;
	DeviceVisualType: EXRVisualType;
	HandIndex: EControllerHand;
	TrackingStatus: ETrackingStatus;
	GripPosition: Vector;
	GripRotation: Quat;
	AimPosition: Vector;
	AimRotation: Quat;
	HandKeyPositions: Vector[];
	HandKeyRotations: Quat[];
	HandKeyRadii: number[];
	bIsGrasped: boolean;
	clone() : XRMotionControllerData;
	static C(Other: UObject | any): XRMotionControllerData;
}

declare class World extends UObject { 
	Layers: Layer[];
	ActiveGroupActors: Actor[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentLevel: Level;
	NetDriver: NetDriver;
	LineBatcher: LineBatchComponent;
	PersistentLineBatcher: LineBatchComponent;
	ForegroundLineBatcher: LineBatchComponent;
	NetworkManager: GameNetworkManager;
	PhysicsCollisionHandler: PhysicsCollisionHandler;
	ExtraReferencedObjects: UObject[];
	PerModuleDataObjects: UObject[];
	StreamingLevels: LevelStreaming[];
	StreamingLevelsToConsider: StreamingLevelsToConsider;
	ServerStreamingLevelsVisibility: ServerStreamingLevelsVisibility;
	StreamingLevelsPrefix: string;
	CurrentLevelPendingVisibility: Level;
	CurrentLevelPendingInvisibility: Level;
	DemoNetDriver: DemoNetDriver;
	MyParticleEventManager: ParticleEventManager;
	DefaultPhysicsVolume: PhysicsVolume;
	bAreConstraintsDirty: boolean;
	NavigationSystem: NavigationSystemBase;
	AuthorityGameMode: GameModeBase;
	GameState: GameStateBase;
	AISystem: AISystemBase;
	AvoidanceManager: AvoidanceManager;
	Levels: Level[];
	LevelCollections: LevelCollection[];
	CurrentLevel: Level;
	OwningGameInstance: GameInstance;
	ParameterCollectionInstances: MaterialParameterCollectionInstance[];
	CanvasForRenderingToTarget: Canvas;
	CanvasForDrawMaterialToRenderTarget: Canvas;
	EditorViews: LevelViewportInfo[];
	PhysicsField: PhysicsFieldComponent;
	LWILastAssignedUID: number;
	ComponentsThatNeedPreEndOfFrameSync: Set<ActorComponent>;
	ComponentsThatNeedEndOfFrameUpdate: ActorComponent[];
	ComponentsThatNeedEndOfFrameUpdate_OnGameThread: ActorComponent[];
	SelectedLevels: Level[];
	WorldComposition: WorldComposition;
	ContentBundleManager: ContentBundleManager;
	PSCPool: WorldPSCPool;
	static Load(ResourceName: string): World;
	static Find(Outer: UObject, ResourceName: string): World;
	static GetDefaultObject(): World;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): World;
	K2_GetWorldSettings(): WorldSettings;
	HandleTimelineScrubbed(): void;
	static C(Other: UObject | any): World;
	EditorDestroyActor(Actor: Actor,bShouldModifyLevel: boolean): boolean;
	EditorExec(Cmd: string): boolean;
	ExportNavigation(Path: string): string;
	GetDefaultBrush(): Brush;
	InvalidateModelGeometry(InLevel: Level): void;
	RemoveLevelInstance(): void;
	BakeConstraint(Constraint: TickableConstraint,Frames: FrameNumber[],TimeUnit: ESequenceTimeUnit): boolean;
	BakeToControlRig(LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,ExportOptions: AnimSeqExportOption,bReduceKeys: boolean,Tolerance: number,Binding: MovieSceneBindingProxy): boolean;
	FindOrCreateControlRigComponentTrack(LevelSequence: LevelSequence,InBinding: MovieSceneBindingProxy): MovieSceneTrack[];
	FindOrCreateControlRigTrack(LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,InBinding: MovieSceneBindingProxy): MovieSceneTrack;
	ImportFBXToControlRigTrack(InSequence: LevelSequence,InTrack: MovieSceneControlRigParameterTrack,InSection: MovieSceneControlRigParameterSection,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	ExportAnimSequence(Sequence: LevelSequence,AnimSequence: AnimSequence,ExportOption: AnimSeqExportOption,Binding: MovieSceneBindingProxy,bCreateLink: boolean): boolean;
	GetBoundObjects(InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	GetObjectBindings(InSequence: LevelSequence,InObject: UObject[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	ImportFBXToControlRig(InSequence: LevelSequence,ActorWithControlRigTrack: string,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	ImportLevelSequenceFBX(InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InImportFBXSettings: MovieSceneUserImportFBXSettings,InImportFilename: string): boolean;
	GetAvailableAudioInputDevices(OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioInputDeviceInfo[]) => void>): void;
	GetActors(ActorLayer: ActorLayer): Actor[];
	BeginPlay(): void;
	DestroyWorld(): void;
	InitializeActorsForPlay(URL: URL): void;
	GenerateNavigation(NavData: RecastNavMesh): void;
	GetAllActorsOfClassAndTags(ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsOfClassAndTagsInCurrentLevel(ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	GetLevels(): Level[];
	GetModel(): Model;
	GetWorldBounds(): Box;
	IsGameWorld(): boolean;
	IsPlayInEditor(): boolean;
	IsPlayInPreview(): boolean;
	CreateNiagaraSimCache(): NiagaraSimCache;
	AcquireNiagaraGPURayTracedCollisionGroup(): number;
	GetNiagaraParameterCollection(Collection: NiagaraParameterCollection): NiagaraParameterCollectionInstance;
	ReleaseNiagaraGPURayTracedCollisionGroup(CollisionGroup: number): void;
	SetActorNiagaraGPURayTracedCollisionGroup(Actor: Actor,CollisionGroup: number): void;
	SetComponentNiagaraGPURayTracedCollisionGroup(Primitive: PrimitiveComponent,CollisionGroup: number): void;
	SpawnSystemAtLocation(SystemTemplate: NiagaraSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	TraceChannelTestUtil(BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	RunAllFunctionalTests(bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	AutomationWaitForLoading(LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	DisableStatGroup(GroupName: string): void;
	EnableStatGroup(GroupName: string): void;
	SetScalabilityQualityLevelRelativeToMax(Value: number): void;
	SetScalabilityQualityToEpic(): void;
	SetScalabilityQualityToLow(): void;
	TakeAutomationScreenshot(LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotAtCamera(LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotOfUI(LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	GetIsMyTurn(PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	GetMyPlayerIndex(PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	GetPlayerDisplayName(PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	RegisterTurnBasedMatchInterfaceObject(PlayerController: PlayerController,UObject: UObject): void;
	GetCachedAchievementDescription(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	GetCachedAchievementProgress(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	LogBox(BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	LogLocation(Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	LogSegment(SegmentStart: Vector,SegmentEnd: Vector,Text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	LogText(Text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	EvalPhysicsIntegerField(WorldPosition: Vector,IntegerType: EFieldIntegerType): number;
	EvalPhysicsScalarField(WorldPosition: Vector,ScalarType: EFieldScalarType): number;
	EvalPhysicsVectorField(WorldPosition: Vector,VectorType: EFieldVectorType): Vector;
	BoxOverlapActors(BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	BoxOverlapComponents(BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	BoxTraceMulti(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceSingle(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleOverlapActors(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	CapsuleOverlapComponents(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	CapsuleTraceMulti(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceSingle(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	Delay(Duration: number,LatentInfo: LatentActionInfo): void;
	DelayUntilNextTick(LatentInfo: LatentActionInfo): void;
	DrawDebugArrow(LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugBox(Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	DrawDebugCapsule(Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCircle(Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	DrawDebugCone(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugConeInDegrees(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCoordinateSystem(AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	DrawDebugCylinder(Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugFloatHistoryLocation(FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFloatHistoryTransform(FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFrustum(FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugLine(LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugPlane(PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	DrawDebugPoint(Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	DrawDebugSphere(Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugString(TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	ExecuteConsoleCommand(Command: string,SpecificPlayer: PlayerController): void;
	FlushDebugStrings(): void;
	FlushPersistentDebugLines(): void;
	GetGameTimeInSeconds(): number;
	HasMultipleLocalPlayers(): boolean;
	IsDedicatedServer(): boolean;
	IsServer(): boolean;
	IsSplitScreen(): boolean;
	IsStandalone(): boolean;
	K2_ClearAndInvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle};
	K2_ClearTimerHandle(Handle: TimerHandle): void;
	K2_GetTimerElapsedTimeHandle(Handle: TimerHandle): number;
	K2_GetTimerRemainingTimeHandle(Handle: TimerHandle): number;
	K2_IsTimerActiveHandle(Handle: TimerHandle): boolean;
	K2_IsTimerPausedHandle(Handle: TimerHandle): boolean;
	K2_PauseTimerHandle(Handle: TimerHandle): void;
	K2_TimerExistsHandle(Handle: TimerHandle): boolean;
	K2_UnPauseTimerHandle(Handle: TimerHandle): void;
	LineTraceMulti(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceSingle(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LoadAsset(Asset: UObject,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	LoadAssetClass(AssetClass: Class,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	PrintString(InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	PrintText(InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	QuitGame(SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	RetriggerableDelay(Duration: number,LatentInfo: LatentActionInfo): void;
	SetSuppressViewportTransitionMessage(bState: boolean): void;
	SphereOverlapActors(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	SphereOverlapComponents(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SphereTraceMulti(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceSingle(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BeginDrawCanvasToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	ClearRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	ConvertRenderTargetToTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	CreateRenderTarget2D(Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	CreateRenderTarget2DArray(Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	CreateRenderTargetVolume(Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	DrawMaterialToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	EndDrawCanvasToRenderTarget(Context: DrawToRenderTargetContext): void;
	ExportRenderTarget(TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	ExportTexture2D(Texture: Texture2D,FilePath: string,Filename: string): void;
	ImportBufferAsTexture2D(Buffer: number[]): Texture2D;
	ImportFileAsTexture2D(Filename: string): Texture2D;
	ReadRenderTarget(TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	ReadRenderTargetPixel(TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	ReadRenderTargetRaw(TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	ReadRenderTargetRawPixel(TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	ReadRenderTargetRawPixelArea(TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	ReadRenderTargetRawUV(TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	ReadRenderTargetRawUVArea(TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	ReadRenderTargetUV(TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	MinAreaRectangle(InPoints: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutRectLengthX?: number,OutRectLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutRectLengthX: number, OutRectLengthY: number};
	MinimumAreaRectangle(InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	CreateDynamicMaterialInstance(Parent: MaterialInterface,OptionalName: string,CreationFlags: EMIDCreationFlags): MaterialInstanceDynamic;
	GetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string): number;
	GetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	SetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	SetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	ActivateReverbEffect(ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	ApplyRadialDamage(BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	ApplyRadialDamageWithFalloff(BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	AreAnyListenersWithinRange(Location: Vector,MaximumRange: number): boolean;
	BeginDeferredActorSpawnFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	BeginSpawningActorFromBlueprint(Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	Blueprint_PredictProjectilePath_Advanced(PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	Blueprint_PredictProjectilePath_ByObjectType(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	Blueprint_PredictProjectilePath_ByTraceChannel(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	BlueprintSuggestProjectileVelocity(TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	ClearSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	ClearSoundMixModifiers(): void;
	CreatePlayer(ControllerId: number,bSpawnPlayerController: boolean): PlayerController;
	CreatePlayerFromPlatformUser(UserId: PlatformUserId,bSpawnPlayerController: boolean): PlayerController;
	CreateSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	DeactivateReverbEffect(TagName: string): void;
	FlushLevelStreaming(): void;
	GetActiveSpatialPluginName(): string;
	GetActorOfClass(ActorClass: UnrealEngineClass): Actor;
	GetAllActorsOfClass(ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsOfClassWithTag(ActorClass: UnrealEngineClass,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithInterface(Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithTag(Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAudioTimeSeconds(): number;
	GetAvailableSpatialPluginNames(): string[];
	GetClosestListenerLocation(Location: Vector,MaximumRange: number,bAllowAttenuationOverride: boolean,ListenerPosition?: Vector): {ListenerPosition: Vector, $: boolean};
	GetCurrentLevelName(bRemovePrefixString: boolean): string;
	GetCurrentReverbEffect(): ReverbEffect;
	GetEnableWorldRendering(): boolean;
	GetGameInstance(): GameInstance;
	GetGameMode(): GameModeBase;
	GetGameState(): GameStateBase;
	GetGlobalTimeDilation(): number;
	GetMaxAudioChannelCount(): number;
	GetNumLocalPlayerControllers(): number;
	GetNumPlayerControllers(): number;
	GetNumPlayerStates(): number;
	GetPlayerCameraManager(PlayerIndex: number): PlayerCameraManager;
	GetPlayerCharacter(PlayerIndex: number): Character;
	GetPlayerController(PlayerIndex: number): PlayerController;
	GetPlayerControllerFromID(ControllerId: number): PlayerController;
	GetPlayerControllerFromPlatformUser(UserId: PlatformUserId): PlayerController;
	GetPlayerPawn(PlayerIndex: number): Pawn;
	GetPlayerState(PlayerStateIndex: number): PlayerState;
	GetPlayerStateFromUniqueNetId(UniqueId: UniqueNetIdRepl): PlayerState;
	GetRealTimeSeconds(): number;
	GetStreamingLevel(PackageName: string): LevelStreaming;
	GetTimeSeconds(): number;
	GetUnpausedTimeSeconds(): number;
	GetViewportMouseCaptureMode(): EMouseCaptureMode;
	GetWorldDeltaSeconds(): number;
	GetWorldOriginLocation(): IntVector;
	GrassOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	IsGamePaused(): boolean;
	IsSplitscreenForceDisabled(): boolean;
	LoadStreamLevel(LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	LoadStreamLevelBySoftObjectPtr(Level: World,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	OpenLevel(LevelName: string,bAbsolute: boolean,Options: string): void;
	OpenLevelBySoftObjectPtr(Level: World,bAbsolute: boolean,Options: string): void;
	PlayDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	PlayDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	PlaySound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,bIsUISound: boolean): void;
	PlaySoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,InitialParams: InitialActiveSoundParams): void;
	PlayWorldCameraShake(Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	PopSoundMixModifier(InSoundMixModifier: SoundMix): void;
	PushSoundMixModifier(InSoundMixModifier: SoundMix): void;
	RebaseLocalOriginOntoZero(WorldLocation: Vector): Vector;
	RebaseZeroOriginOntoLocal(WorldLocation: Vector): Vector;
	SetActiveSpatialPluginByName(InPluginName: string): boolean;
	SetBaseSoundMix(InSoundMix: SoundMix): void;
	SetEnableWorldRendering(bEnable: boolean): void;
	SetForceDisableSplitscreen(bDisable: boolean): void;
	SetGamePaused(bPaused: boolean): boolean;
	SetGlobalListenerFocusParameters(FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	SetGlobalPitchModulation(PitchModulation: number,TimeSec: number): void;
	SetGlobalTimeDilation(TimeDilation: number): void;
	SetMaxAudioChannelsScaled(MaxChannelCountScale: number): void;
	SetSoundClassDistanceScale(SoundClass: SoundClass,DistanceAttenuationScale: number,TimeSec: number): void;
	SetSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	SetViewportMouseCaptureMode(MouseCaptureMode: EMouseCaptureMode): void;
	SetWorldOriginLocation(NewLocation: IntVector): void;
	SpawnDecalAtLocation(DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	SpawnDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	SpawnDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	SpawnEmitterAtLocation(EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivateSystem: boolean): ParticleSystemComponent;
	SpawnForceFeedbackAtLocation(ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	SpawnSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	SpawnSoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	SuggestProjectileVelocity_CustomArc(OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	UnloadStreamLevel(LevelName: string,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	UnloadStreamLevelBySoftObjectPtr(Level: World,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	FoliageOverlappingBoxCount(StaticMesh: StaticMesh,Box: Box): number;
	FoliageOverlappingBoxTransforms(StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	FoliageOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	AddMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	AddSourceEffectToPresetChain(PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	AddSubmixEffect(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	ClearMasterSubmixEffects(): void;
	ClearSubmixEffectChainOverride(SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	ClearSubmixEffects(SoundSubmix: SoundSubmix): void;
	GetAvailableAudioOutputDevices(OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioOutputDeviceInfo[]) => void>): void;
	GetCurrentAudioOutputDeviceName(OnObtainCurrentDeviceEvent: UnrealEngineDelegate<(CurrentDevice: string) => void>): void;
	GetMagnitudeForFrequencies(Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	GetNumberOfEntriesInSourceEffectChain(PresetChain: SoundEffectSourcePresetChain): number;
	GetPhaseForFrequencies(Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	IsAudioBusActive(AudioBus: AudioBus): boolean;
	PauseRecordingOutput(SubmixToPause: SoundSubmix): void;
	RemoveMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSourceEffectFromPresetChain(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	RemoveSubmixEffect(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSubmixEffectAtIndex(SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	RemoveSubmixEffectPreset(SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSubmixEffectPresetAtIndex(SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	ReplaceSoundEffectSubmix(InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	ReplaceSubmixEffect(InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	ResumeRecordingOutput(SubmixToPause: SoundSubmix): void;
	SetBypassSourceEffectChainEntry(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	SetSubmixEffectChainOverride(SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	StartAnalyzingOutput(SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	StartAudioBus(AudioBus: AudioBus): void;
	StartRecordingOutput(ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	StopAnalyzingOutput(SubmixToStopAnalyzing: SoundSubmix): void;
	StopAudioBus(AudioBus: AudioBus): void;
	StopRecordingOutput(ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	SwapAudioOutputDevice(NewDeviceId: string,OnCompletedDeviceSwap: UnrealEngineDelegate<(SwapResult: SwapAudioOutputResult) => void>): void;
	GetMousePositionOnViewport(): Vector2D;
	GetViewportScale(): number;
	GetViewportSize(): Vector2D;
	GetViewportWidgetGeometry(): Geometry;
	RemoveAllWidgets(): void;
	Create(WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	GetAllWidgetsOfClass(FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetAllWidgetsWithInterface(FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetSafeZonePadding(SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	SetHardwareCursor(CursorShape: EMouseCursor,CursorName: string,Hotspot: Vector2D): boolean;
	AbsoluteToViewport(AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	LocalToViewport(Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	ScreenToViewport(ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	ScreenToWidgetAbsolute(ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	ScreenToWidgetLocal(Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	AddConstraint(InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	CreateFromType(InType: ETransformConstraintType): TickableTransformConstraint;
	CreateTransformableComponentHandle(InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	GetManager(): ConstraintsManager;
	RemoveConstraint(InIndex: number): boolean;
	CreateMoveToProxyObject(Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	SpawnAIFromClass(PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	GetAllActorsOfClassMatchingTagQuery(ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	GetControllerTransformForTime(ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	GetDeviceWorldPose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	GetHMDData(HMDData?: XRHMDData): {HMDData: XRHMDData};
	GetMotionControllerData(Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	GetTrackingToWorldTransform(): Transform;
	GetWorldToMetersScale(): number;
	SetWorldToMetersScale(NewScale: number): void;
	static EditorDestroyActor(World: World,Actor: Actor,bShouldModifyLevel: boolean): boolean;
	static EditorExec(World: World,Cmd: string): boolean;
	static ExportNavigation(InWorld: World,Path: string): string;
	static GetDefaultBrush(World: World): Brush;
	static InvalidateModelGeometry(World: World,InLevel: Level): void;
	static RemoveLevelInstance(World: World): void;
	static BakeConstraint(World: World,Constraint: TickableConstraint,Frames: FrameNumber[],TimeUnit: ESequenceTimeUnit): boolean;
	static BakeToControlRig(World: World,LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,ExportOptions: AnimSeqExportOption,bReduceKeys: boolean,Tolerance: number,Binding: MovieSceneBindingProxy): boolean;
	static FindOrCreateControlRigComponentTrack(World: World,LevelSequence: LevelSequence,InBinding: MovieSceneBindingProxy): MovieSceneTrack[];
	static FindOrCreateControlRigTrack(World: World,LevelSequence: LevelSequence,ControlRigClass: UnrealEngineClass,InBinding: MovieSceneBindingProxy): MovieSceneTrack;
	static ImportFBXToControlRigTrack(World: World,InSequence: LevelSequence,InTrack: MovieSceneControlRigParameterTrack,InSection: MovieSceneControlRigParameterSection,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	static ExportAnimSequence(World: World,Sequence: LevelSequence,AnimSequence: AnimSequence,ExportOption: AnimSeqExportOption,Binding: MovieSceneBindingProxy,bCreateLink: boolean): boolean;
	static GetBoundObjects(InWorld: World,InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	static GetObjectBindings(InWorld: World,InSequence: LevelSequence,InObject: UObject[],InRange: SequencerScriptingRange): SequencerBoundObjects[];
	static ImportFBXToControlRig(World: World,InSequence: LevelSequence,ActorWithControlRigTrack: string,SelectedControlRigNames: string[],ImportFBXControlRigSettings: MovieSceneUserImportFBXControlRigSettings,ImportFilename: string): boolean;
	static ImportLevelSequenceFBX(InWorld: World,InSequence: LevelSequence,InBindings: MovieSceneBindingProxy[],InImportFBXSettings: MovieSceneUserImportFBXSettings,InImportFilename: string): boolean;
	static GetAvailableAudioInputDevices(WorldContextObject: UObject,OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioInputDeviceInfo[]) => void>): void;
	static GetActors(WorldContextObject: UObject,ActorLayer: ActorLayer): Actor[];
	static BeginPlay(World: World): void;
	static DestroyWorld(World: World): void;
	static InitializeActorsForPlay(World: World,URL: URL): void;
	static GenerateNavigation(InWorld: World,NavData: RecastNavMesh): void;
	static GetAllActorsOfClassAndTags(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClassAndTagsInCurrentLevel(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	static GetLevels(World: World): Level[];
	static GetModel(World: World): Model;
	static GetWorldBounds(InWorld: World): Box;
	static IsGameWorld(World: World): boolean;
	static IsPlayInEditor(World: World): boolean;
	static IsPlayInPreview(World: World): boolean;
	static CreateNiagaraSimCache(WorldContextObject: UObject): NiagaraSimCache;
	static AcquireNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject): number;
	static GetNiagaraParameterCollection(WorldContextObject: UObject,Collection: NiagaraParameterCollection): NiagaraParameterCollectionInstance;
	static ReleaseNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,CollisionGroup: number): void;
	static SetActorNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Actor: Actor,CollisionGroup: number): void;
	static SetComponentNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Primitive: PrimitiveComponent,CollisionGroup: number): void;
	static SpawnSystemAtLocation(WorldContextObject: UObject,SystemTemplate: NiagaraSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	static TraceChannelTestUtil(WorldContextObject: UObject,BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	static RunAllFunctionalTests(WorldContextObject: UObject,bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	static AutomationWaitForLoading(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	static DisableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static EnableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: UObject,Value: number): void;
	static SetScalabilityQualityToEpic(WorldContextObject: UObject): void;
	static SetScalabilityQualityToLow(WorldContextObject: UObject): void;
	static TakeAutomationScreenshot(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotAtCamera(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotOfUI(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	static LogBox(WorldContextObject: UObject,BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogLocation(WorldContextObject: UObject,Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogSegment(WorldContextObject: UObject,SegmentStart: Vector,SegmentEnd: Vector,Text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	static LogText(WorldContextObject: UObject,Text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	static EvalPhysicsIntegerField(WorldContextObject: UObject,WorldPosition: Vector,IntegerType: EFieldIntegerType): number;
	static EvalPhysicsScalarField(WorldContextObject: UObject,WorldPosition: Vector,ScalarType: EFieldScalarType): number;
	static EvalPhysicsVectorField(WorldContextObject: UObject,WorldPosition: Vector,VectorType: EFieldVectorType): Vector;
	static BoxOverlapActors(WorldContextObject: UObject,BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static BoxOverlapComponents(WorldContextObject: UObject,BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static BoxTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleOverlapActors(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CapsuleOverlapComponents(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static CapsuleTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static Delay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static DelayUntilNextTick(WorldContextObject: UObject,LatentInfo: LatentActionInfo): void;
	static DrawDebugArrow(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugBox(WorldContextObject: UObject,Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	static DrawDebugCapsule(WorldContextObject: UObject,Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCircle(WorldContextObject: UObject,Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	static DrawDebugCone(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugConeInDegrees(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCoordinateSystem(WorldContextObject: UObject,AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	static DrawDebugCylinder(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFloatHistoryLocation(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFloatHistoryTransform(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFrustum(WorldContextObject: UObject,FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugLine(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugPlane(WorldContextObject: UObject,PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	static DrawDebugPoint(WorldContextObject: UObject,Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	static DrawDebugSphere(WorldContextObject: UObject,Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugString(WorldContextObject: UObject,TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	static ExecuteConsoleCommand(WorldContextObject: UObject,Command: string,SpecificPlayer: PlayerController): void;
	static FlushDebugStrings(WorldContextObject: UObject): void;
	static FlushPersistentDebugLines(WorldContextObject: UObject): void;
	static GetGameTimeInSeconds(WorldContextObject: UObject): number;
	static HasMultipleLocalPlayers(WorldContextObject: UObject): boolean;
	static IsDedicatedServer(WorldContextObject: UObject): boolean;
	static IsServer(WorldContextObject: UObject): boolean;
	static IsSplitScreen(WorldContextObject: UObject): boolean;
	static IsStandalone(WorldContextObject: UObject): boolean;
	static K2_ClearAndInvalidateTimerHandle(WorldContextObject: UObject,Handle?: TimerHandle): {Handle: TimerHandle};
	static K2_ClearTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_GetTimerElapsedTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerRemainingTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_IsTimerActiveHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerPausedHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_PauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_TimerExistsHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_UnPauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static LineTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LoadAsset(WorldContextObject: UObject,Asset: UObject,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	static LoadAssetClass(WorldContextObject: UObject,AssetClass: Class,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	static PrintString(WorldContextObject: UObject,InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static PrintText(WorldContextObject: UObject,InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static QuitGame(WorldContextObject: UObject,SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	static RetriggerableDelay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static SetSuppressViewportTransitionMessage(WorldContextObject: UObject,bState: boolean): void;
	static SphereOverlapActors(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static SphereOverlapComponents(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SphereTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: UObject,RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	static CreateRenderTarget2DArray(WorldContextObject: UObject,Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	static CreateRenderTargetVolume(WorldContextObject: UObject,Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,Filename: string): void;
	static ImportBufferAsTexture2D(WorldContextObject: UObject,Buffer: number[]): Texture2D;
	static ImportFileAsTexture2D(WorldContextObject: UObject,Filename: string): Texture2D;
	static ReadRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	static ReadRenderTargetPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	static ReadRenderTargetRaw(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	static ReadRenderTargetRawPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawPixelArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawUVArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	static MinAreaRectangle(WorldContextObject: UObject,InPoints: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutRectLengthX?: number,OutRectLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutRectLengthX: number, OutRectLengthY: number};
	static MinimumAreaRectangle(WorldContextObject: UObject,InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	static CreateDynamicMaterialInstance(WorldContextObject: UObject,Parent: MaterialInterface,OptionalName: string,CreationFlags: EMIDCreationFlags): MaterialInstanceDynamic;
	static GetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): number;
	static GetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	static SetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	static SetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	static ActivateReverbEffect(WorldContextObject: UObject,ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	static ApplyRadialDamage(WorldContextObject: UObject,BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	static ApplyRadialDamageWithFalloff(WorldContextObject: UObject,BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	static AreAnyListenersWithinRange(WorldContextObject: UObject,Location: Vector,MaximumRange: number): boolean;
	static BeginDeferredActorSpawnFromClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	static BeginSpawningActorFromBlueprint(WorldContextObject: UObject,Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: UObject,PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static BlueprintSuggestProjectileVelocity(WorldContextObject: UObject,TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	static ClearSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	static ClearSoundMixModifiers(WorldContextObject: UObject): void;
	static CreatePlayer(WorldContextObject: UObject,ControllerId: number,bSpawnPlayerController: boolean): PlayerController;
	static CreatePlayerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId,bSpawnPlayerController: boolean): PlayerController;
	static CreateSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static DeactivateReverbEffect(WorldContextObject: UObject,TagName: string): void;
	static FlushLevelStreaming(WorldContextObject: UObject): void;
	static GetActiveSpatialPluginName(WorldContextObject: UObject): string;
	static GetActorOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass): Actor;
	static GetAllActorsOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsOfClassWithTag(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithTag(WorldContextObject: UObject,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAudioTimeSeconds(WorldContextObject: UObject): number;
	static GetAvailableSpatialPluginNames(WorldContextObject: UObject): string[];
	static GetClosestListenerLocation(WorldContextObject: UObject,Location: Vector,MaximumRange: number,bAllowAttenuationOverride: boolean,ListenerPosition?: Vector): {ListenerPosition: Vector, $: boolean};
	static GetCurrentLevelName(WorldContextObject: UObject,bRemovePrefixString: boolean): string;
	static GetCurrentReverbEffect(WorldContextObject: UObject): ReverbEffect;
	static GetEnableWorldRendering(WorldContextObject: UObject): boolean;
	static GetGameInstance(WorldContextObject: UObject): GameInstance;
	static GetGameMode(WorldContextObject: UObject): GameModeBase;
	static GetGameState(WorldContextObject: UObject): GameStateBase;
	static GetGlobalTimeDilation(WorldContextObject: UObject): number;
	static GetMaxAudioChannelCount(WorldContextObject: UObject): number;
	static GetNumLocalPlayerControllers(WorldContextObject: UObject): number;
	static GetNumPlayerControllers(WorldContextObject: UObject): number;
	static GetNumPlayerStates(WorldContextObject: UObject): number;
	static GetPlayerCameraManager(WorldContextObject: UObject,PlayerIndex: number): PlayerCameraManager;
	static GetPlayerCharacter(WorldContextObject: UObject,PlayerIndex: number): Character;
	static GetPlayerController(WorldContextObject: UObject,PlayerIndex: number): PlayerController;
	static GetPlayerControllerFromID(WorldContextObject: UObject,ControllerId: number): PlayerController;
	static GetPlayerControllerFromPlatformUser(WorldContextObject: UObject,UserId: PlatformUserId): PlayerController;
	static GetPlayerPawn(WorldContextObject: UObject,PlayerIndex: number): Pawn;
	static GetPlayerState(WorldContextObject: UObject,PlayerStateIndex: number): PlayerState;
	static GetPlayerStateFromUniqueNetId(WorldContextObject: UObject,UniqueId: UniqueNetIdRepl): PlayerState;
	static GetRealTimeSeconds(WorldContextObject: UObject): number;
	static GetStreamingLevel(WorldContextObject: UObject,PackageName: string): LevelStreaming;
	static GetTimeSeconds(WorldContextObject: UObject): number;
	static GetUnpausedTimeSeconds(WorldContextObject: UObject): number;
	static GetViewportMouseCaptureMode(WorldContextObject: UObject): EMouseCaptureMode;
	static GetWorldDeltaSeconds(WorldContextObject: UObject): number;
	static GetWorldOriginLocation(WorldContextObject: UObject): IntVector;
	static GrassOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static IsGamePaused(WorldContextObject: UObject): boolean;
	static IsSplitscreenForceDisabled(WorldContextObject: UObject): boolean;
	static LoadStreamLevel(WorldContextObject: UObject,LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static LoadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static OpenLevel(WorldContextObject: UObject,LevelName: string,bAbsolute: boolean,Options: string): void;
	static OpenLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,bAbsolute: boolean,Options: string): void;
	static PlayDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	static PlayDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	static PlaySound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,bIsUISound: boolean): void;
	static PlaySoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor,InitialParams: InitialActiveSoundParams): void;
	static PlayWorldCameraShake(WorldContextObject: UObject,Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	static PopSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static PushSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static RebaseLocalOriginOntoZero(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static RebaseZeroOriginOntoLocal(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static SetActiveSpatialPluginByName(WorldContextObject: UObject,InPluginName: string): boolean;
	static SetBaseSoundMix(WorldContextObject: UObject,InSoundMix: SoundMix): void;
	static SetEnableWorldRendering(WorldContextObject: UObject,bEnable: boolean): void;
	static SetForceDisableSplitscreen(WorldContextObject: UObject,bDisable: boolean): void;
	static SetGamePaused(WorldContextObject: UObject,bPaused: boolean): boolean;
	static SetGlobalListenerFocusParameters(WorldContextObject: UObject,FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	static SetGlobalPitchModulation(WorldContextObject: UObject,PitchModulation: number,TimeSec: number): void;
	static SetGlobalTimeDilation(WorldContextObject: UObject,TimeDilation: number): void;
	static SetMaxAudioChannelsScaled(WorldContextObject: UObject,MaxChannelCountScale: number): void;
	static SetSoundClassDistanceScale(WorldContextObject: UObject,SoundClass: SoundClass,DistanceAttenuationScale: number,TimeSec: number): void;
	static SetSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	static SetViewportMouseCaptureMode(WorldContextObject: UObject,MouseCaptureMode: EMouseCaptureMode): void;
	static SetWorldOriginLocation(WorldContextObject: UObject,NewLocation: IntVector): void;
	static SpawnDecalAtLocation(WorldContextObject: UObject,DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	static SpawnDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnEmitterAtLocation(WorldContextObject: UObject,EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivateSystem: boolean): ParticleSystemComponent;
	static SpawnForceFeedbackAtLocation(WorldContextObject: UObject,ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static SpawnSoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SuggestProjectileVelocity_CustomArc(WorldContextObject: UObject,OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	static UnloadStreamLevel(WorldContextObject: UObject,LevelName: string,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static UnloadStreamLevelBySoftObjectPtr(WorldContextObject: UObject,Level: World,LatentInfo: LatentActionInfo,bShouldBlockOnUnload: boolean): void;
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
	static FoliageOverlappingBoxTransforms(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box,OutTransforms?: Transform[]): {OutTransforms: Transform[]};
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static AddSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): number;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static ClearSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,FadeTimeSec: number): void;
	static ClearSubmixEffects(WorldContextObject: UObject,SoundSubmix: SoundSubmix): void;
	static GetAvailableAudioOutputDevices(WorldContextObject: UObject,OnObtainDevicesEvent: UnrealEngineDelegate<(AvailableDevices: AudioOutputDeviceInfo[]) => void>): void;
	static GetCurrentAudioOutputDeviceName(WorldContextObject: UObject,OnObtainCurrentDeviceEvent: UnrealEngineDelegate<(CurrentDevice: string) => void>): void;
	static GetMagnitudeForFrequencies(WorldContextObject: UObject,Frequencies: number[],Magnitudes?: number[],SubmixToAnalyze?: SoundSubmix): {Magnitudes: number[]};
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static GetPhaseForFrequencies(WorldContextObject: UObject,Frequencies: number[],Phases?: number[],SubmixToAnalyze?: SoundSubmix): {Phases: number[]};
	static IsAudioBusActive(WorldContextObject: UObject,AudioBus: AudioBus): boolean;
	static PauseRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static RemoveSubmixEffect(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static RemoveSubmixEffectPreset(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSubmixEffectPresetAtIndex(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixChainIndex: number): void;
	static ReplaceSoundEffectSubmix(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ReplaceSubmixEffect(WorldContextObject: UObject,InSoundSubmix: SoundSubmix,SubmixChainIndex: number,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static ResumeRecordingOutput(WorldContextObject: UObject,SubmixToPause: SoundSubmix): void;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static SetSubmixEffectChainOverride(WorldContextObject: UObject,SoundSubmix: SoundSubmix,SubmixEffectPresetChain: SoundEffectSubmixPreset[],FadeTimeSec: number): void;
	static StartAnalyzingOutput(WorldContextObject: UObject,SubmixToAnalyze: SoundSubmix,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	static StartAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StartRecordingOutput(WorldContextObject: UObject,ExpectedDuration: number,SubmixToRecord: SoundSubmix): void;
	static StopAnalyzingOutput(WorldContextObject: UObject,SubmixToStopAnalyzing: SoundSubmix): void;
	static StopAudioBus(WorldContextObject: UObject,AudioBus: AudioBus): void;
	static StopRecordingOutput(WorldContextObject: UObject,ExportType: EAudioRecordingExportType,Name: string,Path: string,SubmixToRecord: SoundSubmix,ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
	static SwapAudioOutputDevice(WorldContextObject: UObject,NewDeviceId: string,OnCompletedDeviceSwap: UnrealEngineDelegate<(SwapResult: SwapAudioOutputResult) => void>): void;
	static GetMousePositionOnViewport(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportWidgetGeometry(WorldContextObject: UObject): Geometry;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static Create(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetSafeZonePadding(WorldContextObject: UObject,SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	static SetHardwareCursor(WorldContextObject: UObject,CursorShape: EMouseCursor,CursorName: string,Hotspot: Vector2D): boolean;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static ScreenToViewport(WorldContextObject: UObject,ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	static ScreenToWidgetAbsolute(WorldContextObject: UObject,ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	static ScreenToWidgetLocal(WorldContextObject: UObject,Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	static AddConstraint(InWorld: World,InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	static CreateFromType(InWorld: World,InType: ETransformConstraintType): TickableTransformConstraint;
	static CreateTransformableComponentHandle(InWorld: World,InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	static GetManager(InWorld: World): ConstraintsManager;
	static RemoveConstraint(InWorld: World,InIndex: number): boolean;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetControllerTransformForTime(WorldContext: UObject,ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	static GetDeviceWorldPose(WorldContext: UObject,XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetHMDData(WorldContext: UObject,HMDData?: XRHMDData): {HMDData: XRHMDData};
	static GetMotionControllerData(WorldContext: UObject,Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	static GetTrackingToWorldTransform(WorldContext: UObject): Transform;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
}

declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	Tooltip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	Index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bDisplayShadedVolume: boolean;
	ShadedVolumeOpacityValue: number;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare type EComponentMobility = 'Static' | 'Stationary' | 'Movable' | 'EComponentMobility_MAX';
declare var EComponentMobility : { Static:'Static',Stationary:'Stationary',Movable:'Movable',EComponentMobility_MAX:'EComponentMobility_MAX', };
declare type EDetachmentRule = 'KeepRelative' | 'KeepWorld' | 'EDetachmentRule_MAX';
declare var EDetachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',EDetachmentRule_MAX:'EDetachmentRule_MAX', };
declare type EMoveComponentAction = 'Move' | 'Stop' | 'Return' | 'EMoveComponentAction_MAX';
declare var EMoveComponentAction : { Move:'Move',Stop:'Stop',Return:'Return',EMoveComponentAction_MAX:'EMoveComponentAction_MAX', };
declare class ARPin extends UObject { 
	TrackedGeometry: ARTrackedGeometry;
	PinnedComponent: SceneComponent;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	OnARTrackingStateChanged: UnrealEngineMulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
	OnARTransformUpdated: UnrealEngineMulticastDelegate<(OldToNewTransform: Transform) => void>;
	static Load(ResourceName: string): ARPin;
	static Find(Outer: UObject, ResourceName: string): ARPin;
	static GetDefaultObject(): ARPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPin;
	GetTrackingState(): EARTrackingState;
	GetTrackedGeometry(): ARTrackedGeometry;
	GetPinnedComponent(): SceneComponent;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetDebugName(): string;
	DebugDraw(World: World,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static C(Other: UObject | any): ARPin;
	DebugDrawPin(WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	RemovePin(): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static RemovePin(PinToRemove: ARPin): void;
}

declare class SceneComponent extends ActorComponent { 
	PhysicsVolume: PhysicsVolume;
	AttachParent: SceneComponent;
	AttachSocketName: string;
	AttachChildren: SceneComponent[];
	ClientAttachedChildren: SceneComponent[];
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	ComponentVelocity: Vector;
	bComponentToWorldUpdated: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bShouldBeAttached: boolean;
	bShouldSnapLocationWhenAttached: boolean;
	bShouldSnapRotationWhenAttached: boolean;
	bShouldSnapScaleWhenAttached: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bHiddenInGame: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bComputeFastLocalBounds: boolean;
	bComputeBoundsOnceForGame: boolean;
	bComputedBoundsOnceForGame: boolean;
	bIsNotRenderAttachmentRoot: boolean;
	bVisualizeComponent: boolean;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	ReplacementSceneComponent: SceneComponent;
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static GetDefaultObject(): SceneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetMobility(NewMobility: EComponentMobility): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	OnRep_AttachSocketName(): void;
	OnRep_AttachParent(): void;
	OnRep_AttachChildren(): void;
	K2_SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_GetComponentToWorld(): Transform;
	K2_GetComponentScale(): Vector;
	K2_GetComponentRotation(): Rotator;
	K2_GetComponentLocation(): Vector;
	K2_DetachFromComponent(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule,bCallModify: boolean): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): boolean;
	K2_AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	K2_AddWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetShouldUpdatePhysicsVolume(): boolean;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachSocketName(): string;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject | any): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	PinComponent(PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	PinComponentToARPin(Pin: ARPin): boolean;
	PinComponentToTraceResult(TraceResult: ARTraceResult,DebugName: string): ARPin;
	UnpinComponent(): void;
	static SetMobile(SceneComponent: SceneComponent): void;
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
}

declare type ESceneDepthPriorityGroup = 'SDPG_World' | 'SDPG_Foreground' | 'SDPG_MAX';
declare var ESceneDepthPriorityGroup : { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground',SDPG_MAX:'SDPG_MAX', };
declare type EIndirectLightingCacheQuality = 'ILCQ_Off' | 'ILCQ_Point' | 'ILCQ_Volume' | 'ILCQ_MAX';
declare var EIndirectLightingCacheQuality : { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume',ILCQ_MAX:'ILCQ_MAX', };
declare type ELightmapType = 'Default' | 'ForceSurface' | 'ForceVolumetric' | 'ELightmapType_MAX';
declare var ELightmapType : { Default:'Default',ForceSurface:'ForceSurface',ForceVolumetric:'ForceVolumetric',ELightmapType_MAX:'ELightmapType_MAX', };
declare type EHLODBatchingPolicy = 'None' | 'MeshSection' | 'Instancing' | 'EHLODBatchingPolicy_MAX';
declare var EHLODBatchingPolicy : { None:'None',MeshSection:'MeshSection',Instancing:'Instancing',EHLODBatchingPolicy_MAX:'EHLODBatchingPolicy_MAX', };
declare type EHasCustomNavigableGeometry = 'No' | 'Yes' | 'EvenIfNotCollidable' | 'DontExport' | 'EHasCustomNavigableGeometry_MAX';
declare var EHasCustomNavigableGeometry : { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport',EHasCustomNavigableGeometry_MAX:'EHasCustomNavigableGeometry_MAX', };
declare type EHitProxyPriority = 'HPP_World' | 'HPP_Wireframe' | 'HPP_Foreground' | 'HPP_UI' | 'HPP_MAX';
declare var EHitProxyPriority : { HPP_World:'HPP_World',HPP_Wireframe:'HPP_Wireframe',HPP_Foreground:'HPP_Foreground',HPP_UI:'HPP_UI',HPP_MAX:'HPP_MAX', };
declare type ECanBeCharacterBase = 'ECB_No' | 'ECB_Yes' | 'ECB_Owner' | 'ECB_MAX';
declare var ECanBeCharacterBase : { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner',ECB_MAX:'ECB_MAX', };
declare class LightingChannels { 
	bChannel0: boolean;
	bChannel1: boolean;
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject | any): LightingChannels;
}

declare class CustomPrimitiveData { 
	Data: number[];
	clone() : CustomPrimitiveData;
	static C(Other: UObject | any): CustomPrimitiveData;
}

declare type ERuntimeVirtualTextureMainPassType = 'Never' | 'Exclusive' | 'Always' | 'ERuntimeVirtualTextureMainPassType_MAX';
declare var ERuntimeVirtualTextureMainPassType : { Never:'Never',Exclusive:'Exclusive',Always:'Always',ERuntimeVirtualTextureMainPassType_MAX:'ERuntimeVirtualTextureMainPassType_MAX', };
declare type EComponentPhysicsStateChange = 'Created' | 'Destroyed' | 'EComponentPhysicsStateChange_MAX';
declare var EComponentPhysicsStateChange : { Created:'Created',Destroyed:'Destroyed',EComponentPhysicsStateChange_MAX:'EComponentPhysicsStateChange_MAX', };
declare type ERayTracingGroupCullingPriority = 'CP_0_NEVER_CULL' | 'CP_1' | 'CP_2' | 'CP_3' | 'CP_4_DEFAULT' | 'CP_5' | 'CP_6' | 'CP_7' | 'CP_8_QUICKLY_CULL' | 'CP_MAX';
declare var ERayTracingGroupCullingPriority : { CP_0_NEVER_CULL:'CP_0_NEVER_CULL',CP_1:'CP_1',CP_2:'CP_2',CP_3:'CP_3',CP_4_DEFAULT:'CP_4_DEFAULT',CP_5:'CP_5',CP_6:'CP_6',CP_7:'CP_7',CP_8_QUICKLY_CULL:'CP_8_QUICKLY_CULL',CP_MAX:'CP_MAX', };
declare class BodyInstanceAsyncPhysicsTickHandle { 
	clone() : BodyInstanceAsyncPhysicsTickHandle;
	static C(Other: UObject | any): BodyInstanceAsyncPhysicsTickHandle;
	AddForce(Force: Vector,bAccelChange: boolean): void;
	static AddForce(Handle: BodyInstanceAsyncPhysicsTickHandle,Force: Vector,bAccelChange: boolean): void;
}

declare type ERadialImpulseFalloff = 'RIF_Constant' | 'RIF_Linear' | 'RIF_MAX';
declare var ERadialImpulseFalloff : { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear',RIF_MAX:'RIF_MAX', };
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	LightmapType: ELightmapType;
	bEnableAutoLODGeneration: boolean;
	ExcludeForSpecificHLODLevels: number[];
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bIsActorTextureStreamingBuiltData: boolean;
	bIsValidTextureStreamingBuiltData: boolean;
	bNeverDistanceCull: boolean;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bVisibleInReflectionCaptures: boolean;
	bVisibleInRealTimeSkyCaptures: boolean;
	bVisibleInRayTracing: boolean;
	bRenderInMainPass: boolean;
	bRenderInDepthPass: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bEmissiveLightSource: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectIndirectLightingWhileHidden: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bCastContactShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	bExcludeFromLightAttachmentGroup: boolean;
	bReceiveMobileCSMShadows: boolean;
	bSingleSampleShadowFromStationaryLights: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	bApplyImpulseOnDamage: boolean;
	bReplicatePhysicsToAutonomousProxy: boolean;
	bFillCollisionUnderneathForNavmesh: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bIsBeingMovedByEditor: boolean;
	bRenderCustomDepth: boolean;
	bVisibleInSceneCaptureOnly: boolean;
	bHiddenInSceneCapture: boolean;
	bRayTracingFarField: boolean;
	bHasNoStreamableTextures: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	HitProxyPriority: EHitProxyPriority;
	CanBeCharacterBase: ECanBeCharacterBase;
	bUseMaxLODAsImposter: boolean;
	bBatchImpostersAsInstances: boolean;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	VisibilityId: number;
	CustomDepthStencilValue: number;
	CustomPrimitiveData: CustomPrimitiveData;
	CustomPrimitiveDataInternal: CustomPrimitiveData;
	TranslucencySortPriority: number;
	TranslucencySortDistanceOffset: number;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureLodBias: number;
	VirtualTextureCullMips: number;
	VirtualTextureMinCoverage: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	BoundsScale: number;
	MoveIgnoreActors: Actor[];
	MoveIgnoreComponents: PrimitiveComponent[];
	BodyInstance: BodyInstance;
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentPhysicsStateChanged: UnrealEngineMulticastDelegate<(ChangedComponent: PrimitiveComponent, StateChange: EComponentPhysicsStateChange) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	LODParentPrimitive: PrimitiveComponent;
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static GetDefaultObject(): PrimitiveComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	WasRecentlyRendered(Tolerance: number): boolean;
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetVisibleInSceneCaptureOnly(bValue: boolean): void;
	SetVisibleInRayTracing(bNewVisibleInRayTracing: boolean): void;
	SetVectorParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetVectorParameterForCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetUseCCD(InUseCCD: boolean,BoneName: string): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetTranslucencySortDistanceOffset(NewTranslucencySortDistanceOffset: number): void;
	SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetScalarParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetScalarParameterForCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderInDepthPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetReceivesDecals(bNewReceivesDecals: boolean): void;
	SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterialByName(MaterialSlotName: string,Material: MaterialInterface): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLinearDamping(InDamping: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;
	SetHiddenInSceneCapture(bValue: boolean): void;
	SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;
	SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetEmissiveLightSource(NewEmissiveLightSource: boolean): void;
	SetDefaultCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetDefaultCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetDefaultCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetDefaultCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetCullDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string,bUpdateOverlaps: boolean): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetCastInsetShadow(bInCastInsetShadow: boolean): void;
	SetCastHiddenShadow(NewCastHiddenShadow: boolean): void;
	SetCastContactShadow(bInCastContactShadow: boolean): void;
	SetBoundsScale(NewBoundsScale: number): void;
	SetAngularDamping(InDamping: number): void;
	SetAllUseCCD(InUseCCD: boolean): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	K2_SphereTraceComponent(TraceStart: Vector,TraceEnd: Vector,SphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_SphereOverlapComponent(InSphereCentre: Vector,InSphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_IsQueryCollisionEnabled(): boolean;
	K2_IsPhysicsCollisionEnabled(): boolean;
	K2_IsCollisionEnabled(): boolean;
	K2_BoxOverlapComponent(InBoxCentre: Vector,InBox: Box,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IsAnyRigidBodyAwake(): boolean;
	InvalidateLumenSurfaceCache(): void;
	IgnoreComponentWhenMoving(Component: PrimitiveComponent,bShouldIgnore: boolean): void;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
	GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
	GetOverlappingComponents(OutOverlappingComponents?: PrimitiveComponent[]): {OutOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetNumMaterials(): number;
	GetMaterialFromCollisionFaceIndex(FaceIndex: number,SectionIndex?: number): {SectionIndex: number, $: MaterialInterface};
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetGenerateOverlapEvents(): boolean;
	GetCustomPrimitiveDataIndexForVectorParameter(ParameterName: string): number;
	GetCustomPrimitiveDataIndexForScalarParameter(ParameterName: string): number;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetCollisionEnabled(): ECollisionEnabled;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetBodyInstanceAsyncPhysicsTickHandle(BoneName: string,bGetWelded: boolean,Index: number): BodyInstanceAsyncPhysicsTickHandle;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface,OptionalName: string): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
	CopyArrayOfMoveIgnoreComponents(): PrimitiveComponent[];
	CopyArrayOfMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreComponents(): void;
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddVelocityChangeImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddTorqueInRadians(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorqueInDegrees(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocationLocal(Force: Vector,Location: Vector,BoneName: string): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulseInRadians(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulseInDegrees(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject | any): PrimitiveComponent;
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SetCastInsetShadowForAllAttachments(bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
}

declare class MRMeshBodyHolder extends UObject { 
	BodySetup: BodySetup;
	BodyInstance: BodyInstance;
	static Load(ResourceName: string): MRMeshBodyHolder;
	static Find(Outer: UObject, ResourceName: string): MRMeshBodyHolder;
	static GetDefaultObject(): MRMeshBodyHolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshBodyHolder;
	static C(Other: UObject | any): MRMeshBodyHolder;
}

declare class MRMeshComponent extends PrimitiveComponent { 
	Material: MaterialInterface;
	WireframeMaterial: MaterialInterface;
	bCreateMeshProxySections: boolean;
	bUpdateNavMeshOnMeshUpdate: boolean;
	bNeverCreateCollisionMesh: boolean;
	BodyHolders: MRMeshBodyHolder[];
	static Load(ResourceName: string): MRMeshComponent;
	static Find(Outer: UObject, ResourceName: string): MRMeshComponent;
	static GetDefaultObject(): MRMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshComponent;
	SetWireframeMaterial(InMaterial: MaterialInterface): void;
	SetWireframeColor(InColor: LinearColor): void;
	SetUseWireframe(bUseWireframe: boolean): void;
	SetEnableMeshOcclusion(bEnable: boolean): void;
	RequestNavMeshUpdate(): void;
	IsConnected(): boolean;
	GetWireframeColor(): LinearColor;
	GetUseWireframe(): boolean;
	GetEnableMeshOcclusion(): boolean;
	ForceNavMeshUpdate(): void;
	Clear(): void;
	static C(Other: UObject | any): MRMeshComponent;
}

declare type EARObjectClassification = 'NotApplicable' | 'Unknown' | 'Wall' | 'Ceiling' | 'Floor' | 'Table' | 'Seat' | 'Face' | 'Image' | 'World' | 'SceneObject' | 'HandMesh' | 'Door' | 'Window' | 'EARObjectClassification_MAX';
declare var EARObjectClassification : { NotApplicable:'NotApplicable',Unknown:'Unknown',Wall:'Wall',Ceiling:'Ceiling',Floor:'Floor',Table:'Table',Seat:'Seat',Face:'Face',Image:'Image',World:'World',SceneObject:'SceneObject',HandMesh:'HandMesh',Door:'Door',Window:'Window',EARObjectClassification_MAX:'EARObjectClassification_MAX', };
declare type EARSpatialMeshUsageFlags = 'NotApplicable' | 'Visible' | 'Collision' | 'EARSpatialMeshUsageFlags_MAX';
declare var EARSpatialMeshUsageFlags : { NotApplicable:'NotApplicable',Visible:'Visible',Collision:'Collision',EARSpatialMeshUsageFlags_MAX:'EARSpatialMeshUsageFlags_MAX', };
declare class ARTrackedGeometry extends UObject { 
	UniqueId: Guid;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	UnderlyingMesh: MRMeshComponent;
	ObjectClassification: EARObjectClassification;
	SpatialMeshUsageFlags: EARSpatialMeshUsageFlags;
	LastUpdateFrameNumber: number;
	DebugName: string;
	static Load(ResourceName: string): ARTrackedGeometry;
	static Find(Outer: UObject, ResourceName: string): ARTrackedGeometry;
	static GetDefaultObject(): ARTrackedGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedGeometry;
	IsTracked(): boolean;
	HasSpatialMeshUsageFlag(InFlag: EARSpatialMeshUsageFlags): boolean;
	GetUnderlyingMesh(): MRMeshComponent;
	GetTrackingState(): EARTrackingState;
	GetObjectClassification(): EARObjectClassification;
	GetName(): string;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetLastUpdateTimestamp(): number;
	GetLastUpdateFrameNumber(): number;
	GetDebugName(): string;
	static C(Other: UObject | any): ARTrackedGeometry;
	DebugDrawTrackedGeometry(WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
}

declare class ARTraceResult { 
	DistanceFromCamera: number;
	TraceChannel: EARLineTraceChannels;
	LocalTransform: Transform;
	TrackedGeometry: ARTrackedGeometry;
	clone() : ARTraceResult;
	static C(Other: UObject | any): ARTraceResult;
	GetDistanceFromCamera(): number;
	GetLocalToTrackingTransform(): Transform;
	GetLocalToWorldTransform(): Transform;
	GetLocalTransform(): Transform;
	GetTraceChannel(): EARLineTraceChannels;
	GetTrackedGeometry(): ARTrackedGeometry;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
}

declare type EHMDTrackingOrigin = 'Floor' | 'Eye' | 'Stage' | 'EHMDTrackingOrigin_MAX';
declare var EHMDTrackingOrigin : { Floor:'Floor',Eye:'Eye',Stage:'Stage',EHMDTrackingOrigin_MAX:'EHMDTrackingOrigin_MAX', };
declare class Vector2D { 
	X: number;
	Y: number;
	clone() : Vector2D;
	static C(Other: UObject | any): Vector2D;
	Conv_Vector2dToString(): string;
	Add_Vector2DFloat(B: number): Vector2D;
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	BreakVector2D(X?: number,Y?: number): {X: number, Y: number};
	ClampAxes2D(MinAxisVal: number,MaxAxisVal: number): Vector2D;
	Conv_Vector2DToIntPoint(): IntPoint;
	Conv_Vector2DToVector(Z: number): Vector;
	CrossProduct2D(B: Vector2D): number;
	Distance2D(v2: Vector2D): number;
	DistanceSquared2D(v2: Vector2D): number;
	Divide_Vector2DFloat(B: number): Vector2D;
	Divide_Vector2DVector2D(B: Vector2D): Vector2D;
	DotProduct2D(B: Vector2D): number;
	EqualEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	EqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	GetAbs2D(): Vector2D;
	GetAbsMax2D(): number;
	GetMax2D(): number;
	GetMin2D(): number;
	GetRotated2D(AngleDeg: number): Vector2D;
	IsNearlyZero2D(Tolerance: number): boolean;
	IsZero2D(): boolean;
	MakeBox2D(Max: Vector2D): Box2D;
	Multiply_Vector2DFloat(B: number): Vector2D;
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	Negated2D(): Vector2D;
	Normal2D(): Vector2D;
	Normalize2D(Tolerance?: number): {A: Vector2D};
	NormalSafe2D(Tolerance: number): Vector2D;
	NotEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	NotEqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	Set2D(X?: number,Y?: number): {A: Vector2D};
	Spherical2DToUnitCartesian(): Vector;
	Subtract_Vector2DFloat(B: number): Vector2D;
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	ToDirectionAndLength2D(OutDir?: Vector2D,OutLength?: number): {OutDir: Vector2D, OutLength: number};
	ToRounded2D(): Vector2D;
	ToSign2D(): Vector2D;
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	VSize2D(): number;
	VSize2DSquared(): number;
	Conv_Vector2dToText(): string;
	SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	LineTraceTrackedObjects(bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Add_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static BreakVector2D(InVec: Vector2D,X?: number,Y?: number): {X: number, Y: number};
	static ClampAxes2D(A: Vector2D,MinAxisVal: number,MaxAxisVal: number): Vector2D;
	static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static CrossProduct2D(A: Vector2D,B: Vector2D): number;
	static Distance2D(v1: Vector2D,v2: Vector2D): number;
	static DistanceSquared2D(v1: Vector2D,v2: Vector2D): number;
	static Divide_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static DotProduct2D(A: Vector2D,B: Vector2D): number;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static EqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static GetAbs2D(A: Vector2D): Vector2D;
	static GetAbsMax2D(A: Vector2D): number;
	static GetMax2D(A: Vector2D): number;
	static GetMin2D(A: Vector2D): number;
	static GetRotated2D(A: Vector2D,AngleDeg: number): Vector2D;
	static IsNearlyZero2D(A: Vector2D,Tolerance: number): boolean;
	static IsZero2D(A: Vector2D): boolean;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Negated2D(A: Vector2D): Vector2D;
	static Normal2D(A: Vector2D): Vector2D;
	static Normalize2D(A?: Vector2D,Tolerance?: number): {A: Vector2D};
	static NormalSafe2D(A: Vector2D,Tolerance: number): Vector2D;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static NotEqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static Set2D(A?: Vector2D,X?: number,Y?: number): {A: Vector2D};
	static Spherical2DToUnitCartesian(A: Vector2D): Vector;
	static Subtract_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static ToDirectionAndLength2D(A: Vector2D,OutDir?: Vector2D,OutLength?: number): {OutDir: Vector2D, OutLength: number};
	static ToRounded2D(A: Vector2D): Vector2D;
	static ToSign2D(A: Vector2D): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static VSize2D(A: Vector2D): number;
	static VSize2DSquared(A: Vector2D): number;
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	static NextSobolCell2D(Index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static RandomSobolCell2D(Index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static MakeVector2D(X: number,Y: number): Vector2D;
	static Vector2D_One(): Vector2D;
	static Vector2D_Unit45Deg(): Vector2D;
	static Vector2D_Zero(): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
}

declare class Transform { 
	Rotation: Quat;
	Translation: Vector;
	Scale3D: Vector;
	clone() : Transform;
	static C(Other: UObject | any): Transform;
	GetDesiredValue(LastBoneTransform: Transform,DeltaTime: number,MotionType: EMotionExtractor_MotionType,Axis: EMotionExtractor_Axis): number;
	Conv_TransformToString(): string;
	BreakTransform(Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	ComposeTransforms(B: Transform): Transform;
	Conv_TransformToMatrix(): Matrix;
	ConvertTransformToRelative(ParentTransform: Transform): Transform;
	EqualEqual_TransformTransform(B: Transform): boolean;
	FindRelativeLookAtRotation(TargetLocation: Vector): Rotator;
	InverseTransformDirection(Direction: Vector): Vector;
	InverseTransformLocation(Location: Vector): Vector;
	InverseTransformRotation(Rotation: Rotator): Rotator;
	InvertTransform(): Transform;
	MakeRelativeTransform(RelativeTo: Transform): Transform;
	NearlyEqual_TransformTransform(B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	SelectTransform(B: Transform,bPickA: boolean): Transform;
	TEase(B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	TInterpTo(Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	TLerp(B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	Transform_Determinant(): number;
	TransformDirection(Direction: Vector): Vector;
	TransformLocation(Location: Vector): Vector;
	TransformRotation(Rotation: Rotator): Rotator;
	Conv_TransformToText(): string;
	K2_LookAt(TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	CalibrateExternalTrackingToHMD(): void;
	GetPlayAreaRect(OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	UpdateExternalTrackingHMDPosition(): void;
	AddTrackedPointWithName(PointName: string,bDeletePointsWithSameName: boolean): boolean;
	CalculateAlignmentTransform(TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	SetAlignmentTransform(): void;
	static GetDesiredValue(BoneTransform: Transform,LastBoneTransform: Transform,DeltaTime: number,MotionType: EMotionExtractor_MotionType,Axis: EMotionExtractor_Axis): number;
	static Conv_TransformToString(InTrans: Transform): string;
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	static Conv_TransformToMatrix(Transform: Transform): Matrix;
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	static EqualEqual_TransformTransform(A: Transform,B: Transform): boolean;
	static FindRelativeLookAtRotation(StartTransform: Transform,TargetLocation: Vector): Rotator;
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	static InverseTransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static InvertTransform(T: Transform): Transform;
	static MakeRelativeTransform(A: Transform,RelativeTo: Transform): Transform;
	static NearlyEqual_TransformTransform(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	static TEase(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	static TLerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	static Transform_Determinant(Transform: Transform): number;
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	static TransformLocation(T: Transform,Location: Vector): Vector;
	static TransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static Conv_TransformToText(InTrans: Transform): string;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static GetPlayAreaRect(OutTransform?: Transform,OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static GetAlignmentTransform(): Transform;
}

declare class Rotator { 
	Pitch: number;
	Yaw: number;
	Roll: number;
	clone() : Rotator;
	static C(Other: UObject | any): Rotator;
	Conv_RotatorToString(): string;
	BreakRotator(Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	BreakRotIntoAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	ComposeRotators(B: Rotator): Rotator;
	Conv_RotatorToQuaternion(): Quat;
	Conv_RotatorToTransform(): Transform;
	Conv_RotatorToVector(): Vector;
	DynamicWeightedMovingAverage_FRotator(PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	EqualEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	GetAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	GetForwardVector(): Vector;
	GetRightVector(): Vector;
	GetUpVector(): Vector;
	Multiply_RotatorFloat(B: number): Rotator;
	Multiply_RotatorInt(B: number): Rotator;
	NegateRotator(): Rotator;
	NormalizedDeltaRotator(B: Rotator): Rotator;
	NotEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	REase(B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	RInterpTo(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RInterpTo_Constant(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RLerp(B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	SelectRotator(B: Rotator,bPickA: boolean): Rotator;
	WeightedMovingAverage_FRotator(PreviousSample: Rotator,Weight: number): Rotator;
	Conv_RotatorToText(): string;
	IsValidAIRotation(): boolean;
	GetOrientationAndPosition(DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static Conv_RotatorToString(InRot: Rotator): string;
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static ComposeRotators(A: Rotator,B: Rotator): Rotator;
	static Conv_RotatorToQuaternion(InRot: Rotator): Quat;
	static Conv_RotatorToTransform(InRotator: Rotator): Transform;
	static Conv_RotatorToVector(InRot: Rotator): Vector;
	static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	static EqualEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static GetForwardVector(InRot: Rotator): Vector;
	static GetRightVector(InRot: Rotator): Vector;
	static GetUpVector(InRot: Rotator): Vector;
	static Multiply_RotatorFloat(A: Rotator,B: number): Rotator;
	static Multiply_RotatorInt(A: Rotator,B: number): Rotator;
	static NegateRotator(A: Rotator): Rotator;
	static NormalizedDeltaRotator(A: Rotator,B: Rotator): Rotator;
	static NotEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static REase(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RLerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	static WeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,Weight: number): Rotator;
	static Conv_RotatorToText(InRot: Rotator): string;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	static RandomRotator(bRoll: boolean): Rotator;
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
}

declare class VectorSpringState { 
	clone() : VectorSpringState;
	static C(Other: UObject | any): VectorSpringState;
	ResetVectorSpringState(): {SpringState: VectorSpringState};
	SetVectorSpringStateVelocity(Velocity?: Vector): {SpringState: VectorSpringState};
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
	static SetVectorSpringStateVelocity(SpringState?: VectorSpringState,Velocity?: Vector): {SpringState: VectorSpringState};
}

declare class Vector { 
	X: number;
	Y: number;
	Z: number;
	clone() : Vector;
	static C(Other: UObject | any): Vector;
	GetLevelViewportCameraInfo(CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	SetLevelViewportCameraInfo(CameraRotation: Rotator): void;
	GetSelectionBounds(BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	Conv_VectorToString(): string;
	Add_VectorFloat(B: number): Vector;
	Add_VectorInt(B: number): Vector;
	Add_VectorVector(B: Vector): Vector;
	BreakVector(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	ClampVectorSize(Min: number,Max: number): Vector;
	Conv_VectorToLinearColor(): LinearColor;
	Conv_VectorToQuaternion(): Quat;
	Conv_VectorToRotator(): Rotator;
	Conv_VectorToTransform(): Transform;
	Conv_VectorToVector2D(): Vector2D;
	Cross_VectorVector(B: Vector): Vector;
	Divide_VectorFloat(B: number): Vector;
	Divide_VectorInt(B: number): Vector;
	Divide_VectorVector(B: Vector): Vector;
	Dot_VectorVector(B: Vector): number;
	DynamicWeightedMovingAverage_FVector(PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	EqualEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	EqualExactly_VectorVector(B: Vector): boolean;
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	FindLookAtRotation(Target: Vector): Rotator;
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	FTruncVector(): IntVector;
	GetAzimuthAndElevation(ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	GetDirectionUnitVector(To: Vector): Vector;
	GetMaxElement(): number;
	GetMinElement(): number;
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	GetReflectionVector(SurfaceNormal: Vector): Vector;
	GetSlopeDegreeAngles(FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	GreaterGreater_VectorRotator(B: Rotator): Vector;
	IsPointInBox(BoxOrigin: Vector,BoxExtent: Vector): boolean;
	IsPointInBox_Box(Box: Box): boolean;
	IsPointInBoxWithTransform(BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	IsPointInBoxWithTransform_Box(BoxWorldTransform: Transform,BoxExtent: Box): boolean;
	LessLess_VectorRotator(B: Rotator): Vector;
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	LinePlaneIntersection_OriginNormal(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	MakeBox(Max: Vector): Box;
	MakeBoxSphereBounds(BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	MakeRotFromX(): Rotator;
	MakeRotFromXY(Y: Vector): Rotator;
	MakeRotFromXZ(Z: Vector): Rotator;
	MakeRotFromY(): Rotator;
	MakeRotFromYX(X: Vector): Rotator;
	MakeRotFromYZ(Z: Vector): Rotator;
	MakeRotFromZ(): Rotator;
	MakeRotFromZX(X: Vector): Rotator;
	MakeRotFromZY(Y: Vector): Rotator;
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	MirrorVectorByNormal(InNormal: Vector): Vector;
	Multiply_VectorFloat(B: number): Vector;
	Multiply_VectorInt(B: number): Vector;
	Multiply_VectorVector(B: Vector): Vector;
	NegateVector(): Vector;
	Normal(Tolerance: number): Vector;
	NotEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	NotEqualExactly_VectorVector(B: Vector): boolean;
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	ProjectVectorOnToVector(Target: Vector): Vector;
	Quat_MakeFromEuler(): Quat;
	RandomPointInBoundingBox(HalfSize: Vector): Vector;
	RandomPointInBoundingBoxFromStream(HalfSize: Vector,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInDegrees(ConeHalfAngleInDegrees: number): Vector;
	RandomUnitVectorInConeInDegreesFromStream(ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInRadians(ConeHalfAngleInRadians: number): Vector;
	RandomUnitVectorInConeInRadiansFromStream(ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInDegrees(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	RandomUnitVectorInEllipticalConeInDegreesFromStream(MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInRadians(MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	RandomUnitVectorInEllipticalConeInRadiansFromStream(MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	RotateAngleAxis(AngleDeg: number,Axis: Vector): Vector;
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	SelectVector(B: Vector,bPickA: boolean): Vector;
	Subtract_VectorFloat(B: number): Vector;
	Subtract_VectorInt(B: number): Vector;
	Subtract_VectorVector(B: Vector): Vector;
	VEase(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	Vector_AddBounded(InAddVect?: Vector,InRadius?: number): {A: Vector};
	Vector_Assign(InVector?: Vector): {A: Vector};
	Vector_BoundedToBox(InBoxMin: Vector,InBoxMax: Vector): Vector;
	Vector_BoundedToCube(InRadius: number): Vector;
	Vector_ClampSize2D(Min: number,Max: number): Vector;
	Vector_ClampSizeMax(Max: number): Vector;
	Vector_ClampSizeMax2D(Max: number): Vector;
	Vector_ComponentMax(B: Vector): Vector;
	Vector_ComponentMin(B: Vector): Vector;
	Vector_CosineAngle2D(B: Vector): number;
	Vector_Distance(v2: Vector): number;
	Vector_Distance2D(v2: Vector): number;
	Vector_Distance2DSquared(v2: Vector): number;
	Vector_DistanceSquared(v2: Vector): number;
	Vector_GetAbs(): Vector;
	Vector_GetAbsMax(): number;
	Vector_GetAbsMin(): number;
	Vector_GetProjection(): Vector;
	Vector_GetSignVector(): Vector;
	Vector_HeadingAngle(): number;
	Vector_IsNAN(): boolean;
	Vector_IsNearlyZero(Tolerance: number): boolean;
	Vector_IsNormal(): boolean;
	Vector_IsUniform(Tolerance: number): boolean;
	Vector_IsUnit(SquaredLenthTolerance: number): boolean;
	Vector_IsZero(): boolean;
	Vector_MirrorByPlane(InPlane: Plane): Vector;
	Vector_Normal2D(Tolerance: number): Vector;
	Vector_Normalize(Tolerance?: number): {A: Vector};
	Vector_NormalUnsafe(): Vector;
	Vector_ProjectOnToNormal(InNormal: Vector): Vector;
	Vector_Reciprocal(): Vector;
	Vector_Set(X?: number,Y?: number,Z?: number): {A: Vector};
	Vector_SnappedToGrid(InGridSize: number): Vector;
	Vector_ToDegrees(): Vector;
	Vector_ToRadians(): Vector;
	Vector_UnitCartesianToSpherical(): Vector2D;
	Vector_UnwindEuler(): {A: Vector};
	VectorSpringInterp(Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VLerp(B: Vector,Alpha: number): Vector;
	VSize(): number;
	VSizeSquared(): number;
	VSizeXY(): number;
	VSizeXYSquared(): number;
	WeightedMovingAverage_FVector(PreviousSample: Vector,Weight: number): Vector;
	FindNearestActor(ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	Conv_VectorToText(): string;
	CalculateDirection(BaseRotation: Rotator): number;
	K2_TwoBoneIK(JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	IsValidAIDirection(): boolean;
	IsValidAILocation(): boolean;
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	GetTrackingSensorParameters(Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	AddManualEnvironmentCaptureProbe(Extent: Vector): boolean;
	GetObjectClassificationAtLocation(OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	LineTraceTrackedObjects3D(End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	SetARWorldOriginLocationAndRotation(OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static GetLevelViewportCameraInfo(CameraLocation?: Vector,CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	static SetLevelViewportCameraInfo(CameraLocation: Vector,CameraRotation: Rotator): void;
	static GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static Conv_VectorToString(InVec: Vector): string;
	static Add_VectorFloat(A: Vector,B: number): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static BreakVector(InVec: Vector,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static ClampVectorSize(A: Vector,Min: number,Max: number): Vector;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_VectorToQuaternion(InVec: Vector): Quat;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorFloat(A: Vector,B: number): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Dot_VectorVector(A: Vector,B: Vector): number;
	static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static EqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FTruncVector(InVector: Vector): IntVector;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetMaxElement(A: Vector): number;
	static GetMinElement(A: Vector): number;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetSlopeDegreeAngles(MyRightYAxis: Vector,FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsPointInBox_Box(Point: Vector,Box: Box): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static IsPointInBoxWithTransform_Box(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Box): boolean;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static MakeBox(Min: Vector,Max: Vector): Box;
	static MakeBoxSphereBounds(Origin: Vector,BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static Multiply_VectorFloat(A: Vector,B: number): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static NegateVector(A: Vector): Vector;
	static Normal(A: Vector,Tolerance: number): Vector;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static NotEqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static Quat_MakeFromEuler(Euler: Vector): Quat;
	static RandomPointInBoundingBox(Center: Vector,HalfSize: Vector): Vector;
	static RandomPointInBoundingBoxFromStream(Center: Vector,HalfSize: Vector,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static Subtract_VectorFloat(A: Vector,B: number): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static Vector_AddBounded(A?: Vector,InAddVect?: Vector,InRadius?: number): {A: Vector};
	static Vector_Assign(A?: Vector,InVector?: Vector): {A: Vector};
	static Vector_BoundedToBox(InVect: Vector,InBoxMin: Vector,InBoxMax: Vector): Vector;
	static Vector_BoundedToCube(InVect: Vector,InRadius: number): Vector;
	static Vector_ClampSize2D(A: Vector,Min: number,Max: number): Vector;
	static Vector_ClampSizeMax(A: Vector,Max: number): Vector;
	static Vector_ClampSizeMax2D(A: Vector,Max: number): Vector;
	static Vector_ComponentMax(A: Vector,B: Vector): Vector;
	static Vector_ComponentMin(A: Vector,B: Vector): Vector;
	static Vector_CosineAngle2D(A: Vector,B: Vector): number;
	static Vector_Distance(v1: Vector,v2: Vector): number;
	static Vector_Distance2D(v1: Vector,v2: Vector): number;
	static Vector_Distance2DSquared(v1: Vector,v2: Vector): number;
	static Vector_DistanceSquared(v1: Vector,v2: Vector): number;
	static Vector_GetAbs(A: Vector): Vector;
	static Vector_GetAbsMax(A: Vector): number;
	static Vector_GetAbsMin(A: Vector): number;
	static Vector_GetProjection(A: Vector): Vector;
	static Vector_GetSignVector(A: Vector): Vector;
	static Vector_HeadingAngle(A: Vector): number;
	static Vector_IsNAN(A: Vector): boolean;
	static Vector_IsNearlyZero(A: Vector,Tolerance: number): boolean;
	static Vector_IsNormal(A: Vector): boolean;
	static Vector_IsUniform(A: Vector,Tolerance: number): boolean;
	static Vector_IsUnit(A: Vector,SquaredLenthTolerance: number): boolean;
	static Vector_IsZero(A: Vector): boolean;
	static Vector_MirrorByPlane(A: Vector,InPlane: Plane): Vector;
	static Vector_Normal2D(A: Vector,Tolerance: number): Vector;
	static Vector_Normalize(A?: Vector,Tolerance?: number): {A: Vector};
	static Vector_NormalUnsafe(A: Vector): Vector;
	static Vector_ProjectOnToNormal(V: Vector,InNormal: Vector): Vector;
	static Vector_Reciprocal(A: Vector): Vector;
	static Vector_Set(A?: Vector,X?: number,Y?: number,Z?: number): {A: Vector};
	static Vector_SnappedToGrid(InVect: Vector,InGridSize: number): Vector;
	static Vector_ToDegrees(A: Vector): Vector;
	static Vector_ToRadians(A: Vector): Vector;
	static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
	static Vector_UnwindEuler(A?: Vector): {A: Vector};
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VSize(A: Vector): number;
	static VSizeSquared(A: Vector): number;
	static VSizeXY(A: Vector): number;
	static VSizeXYSquared(A: Vector): number;
	static WeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,Weight: number): Vector;
	static FindNearestActor(Origin: Vector,ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	static Conv_VectorToText(InVec: Vector): string;
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static NextSobolCell3D(Index: number,NumCells: number,PreviousValue: Vector): Vector;
	static RandomSobolCell3D(Index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static Conv_DoubleToVector(InDouble: number): Vector;
	static Conv_FloatToVector(InFloat: number): Vector;
	static Conv_IntToVector(inInt: number): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static MakeVector(X: number,Y: number,Z: number): Vector;
	static RandomUnitVector(): Vector;
	static Vector_Backward(): Vector;
	static Vector_Down(): Vector;
	static Vector_Forward(): Vector;
	static Vector_Left(): Vector;
	static Vector_One(): Vector;
	static Vector_Right(): Vector;
	static Vector_Up(): Vector;
	static Vector_Zero(): Vector;
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
}

declare class Vector_NetQuantize100 extends Vector { 
	clone() : Vector_NetQuantize100;
	static C(Other: UObject | any): Vector_NetQuantize100;
	BreakVector_NetQuantize100(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static BreakVector_NetQuantize100(InVec: Vector_NetQuantize100,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static MakeVector_NetQuantize100(X: number,Y: number,Z: number): Vector_NetQuantize100;
}

declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals' | 'EVectorQuantization_MAX';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals',EVectorQuantization_MAX:'EVectorQuantization_MAX', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents' | 'ERotatorQuantization_MAX';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents',ERotatorQuantization_MAX:'ERotatorQuantization_MAX', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	ServerFrame: number;
	ServerPhysicsHandle: number;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORM_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORM_MAX:'DORM_MAX', };
declare type EChildActorComponentTreeViewVisualizationMode = 'UseDefault' | 'ComponentOnly' | 'ComponentWithChildActor' | 'ChildActorOnly' | 'EChildActorComponentTreeViewVisualizationMode_MAX';
declare var EChildActorComponentTreeViewVisualizationMode : { UseDefault:'UseDefault',ComponentOnly:'ComponentOnly',ComponentWithChildActor:'ComponentWithChildActor',ChildActorOnly:'ChildActorOnly',EChildActorComponentTreeViewVisualizationMode_MAX:'EChildActorComponentTreeViewVisualizationMode_MAX', };
declare class ChildActorComponent extends SceneComponent { 
	ChildActorClass: UnrealEngineClass;
	ChildActor: Actor;
	ChildActorTemplate: Actor;
	EditorTreeViewVisualizationMode: EChildActorComponentTreeViewVisualizationMode;
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static GetDefaultObject(): ChildActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	SetChildActorClass(InClass: UnrealEngineClass): void;
	OnChildActorDestroyed(DestroyedActor: Actor): void;
	static C(Other: UObject | any): ChildActorComponent;
}

declare class JavascriptHitProxy { 
	clone() : JavascriptHitProxy;
	static C(Other: UObject | any): JavascriptHitProxy;
	GetActor(): Actor;
	GetName(): string;
	static GetActor(Proxy: JavascriptHitProxy): Actor;
	static GetName(Proxy: JavascriptHitProxy): string;
}

declare class JavascriptEdViewport { 
	clone() : JavascriptEdViewport;
	static C(Other: UObject | any): JavascriptEdViewport;
	GetHitProxy(): JavascriptHitProxy;
	static GetHitProxy(Viewport: JavascriptEdViewport): JavascriptHitProxy;
}

declare class JavascriptViewportClick { 
	clone() : JavascriptViewportClick;
	static C(Other: UObject | any): JavascriptViewportClick;
	GetClickPos(): IntPoint;
	GetDirection(): Vector;
	GetEvent(): EInputEvent;
	GetKey(): Key;
	GetOrigin(): Vector;
	IsAltDown(): boolean;
	IsControlDown(): boolean;
	IsShiftDown(): boolean;
	static GetClickPos(Click: JavascriptViewportClick): IntPoint;
	static GetDirection(Click: JavascriptViewportClick): Vector;
	static GetEvent(Click: JavascriptViewportClick): EInputEvent;
	static GetKey(Click: JavascriptViewportClick): Key;
	static GetOrigin(Click: JavascriptViewportClick): Vector;
	static IsAltDown(Click: JavascriptViewportClick): boolean;
	static IsControlDown(Click: JavascriptViewportClick): boolean;
	static IsShiftDown(Click: JavascriptViewportClick): boolean;
}

declare type EInputActionValueType = 'Boolean' | 'Axis1D' | 'Axis2D' | 'Axis3D' | 'EInputActionValueType_MAX';
declare var EInputActionValueType : { Boolean:'Boolean',Axis1D:'Axis1D',Axis2D:'Axis2D',Axis3D:'Axis3D',EInputActionValueType_MAX:'EInputActionValueType_MAX', };
declare class InputActionValue { 
	clone() : InputActionValue;
	static C(Other: UObject | any): InputActionValue;
	BreakInputActionValue(X?: number,Y?: number,Z?: number,Type?: EInputActionValueType): {X: number, Y: number, Z: number, Type: EInputActionValueType};
	Conv_InputActionValueToAxis1D(): number;
	Conv_InputActionValueToAxis2D(): Vector2D;
	Conv_InputActionValueToAxis3D(): Vector;
	Conv_InputActionValueToBool(): boolean;
	Conv_InputActionValueToString(): string;
	static BreakInputActionValue(InActionValue: InputActionValue,X?: number,Y?: number,Z?: number,Type?: EInputActionValueType): {X: number, Y: number, Z: number, Type: EInputActionValueType};
	static Conv_InputActionValueToAxis1D(InValue: InputActionValue): number;
	static Conv_InputActionValueToAxis2D(InValue: InputActionValue): Vector2D;
	static Conv_InputActionValueToAxis3D(ActionValue: InputActionValue): Vector;
	static Conv_InputActionValueToBool(InValue: InputActionValue): boolean;
	static Conv_InputActionValueToString(ActionValue: InputActionValue): string;
	static MakeInputActionValue(X: number,Y: number,Z: number,MatchValueType: InputActionValue): InputActionValue;
	static MakeInputActionValueOfType(X: number,Y: number,Z: number,ValueType: EInputActionValueType): InputActionValue;
}

declare class PlayerMappableKeyOptions { 
	MetaData: UObject;
	Name: string;
	DisplayName: string;
	DisplayCategory: string;
	clone() : PlayerMappableKeyOptions;
	static C(Other: UObject | any): PlayerMappableKeyOptions;
}

declare class InputModifier extends UObject { 
	static Load(ResourceName: string): InputModifier;
	static Find(Outer: UObject, ResourceName: string): InputModifier;
	static GetDefaultObject(): InputModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifier;
	ModifyRaw(PlayerInput: EnhancedPlayerInput,CurrentValue: InputActionValue,DeltaTime: number): InputActionValue;
	GetVisualizationColor(SampleValue: InputActionValue,FinalValue: InputActionValue): LinearColor;
	static C(Other: UObject | any): InputModifier;
}

declare class EnhancedActionKeyMapping { 
	PlayerMappableOptions: PlayerMappableKeyOptions;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	Action: InputAction;
	Key: Key;
	bIsPlayerMappable: boolean;
	bShouldBeIgnored: boolean;
	clone() : EnhancedActionKeyMapping;
	static C(Other: UObject | any): EnhancedActionKeyMapping;
}

declare class InputMappingContext extends DataAsset { 
	Mappings: EnhancedActionKeyMapping[];
	ContextDescription: string;
	static Load(ResourceName: string): InputMappingContext;
	static Find(Outer: UObject, ResourceName: string): InputMappingContext;
	static GetDefaultObject(): InputMappingContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputMappingContext;
	UnmapKey(Action: InputAction,Key: Key): void;
	UnmapAllKeysFromAction(Action: InputAction): void;
	UnmapAll(): void;
	UnmapAction(Action: InputAction): void;
	MapKey(Action: InputAction,ToKey: Key): EnhancedActionKeyMapping;
	static C(Other: UObject | any): InputMappingContext;
	RequestRebuildControlMappingsUsingContext(bForceImmediately: boolean): void;
	static RequestRebuildControlMappingsUsingContext(Context: InputMappingContext,bForceImmediately: boolean): void;
}

declare type ETriggerEvent = 'None' | 'Triggered' | 'Started' | 'Ongoing' | 'Canceled' | 'Completed' | 'ETriggerEvent_MAX';
declare var ETriggerEvent : { None:'None',Triggered:'Triggered',Started:'Started',Ongoing:'Ongoing',Canceled:'Canceled',Completed:'Completed',ETriggerEvent_MAX:'ETriggerEvent_MAX', };
declare class InputActionInstance { 
	SourceAction: InputAction;
	TriggerEvent: ETriggerEvent;
	LastTriggeredWorldTime: number;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	ElapsedProcessedTime: number;
	ElapsedTriggeredTime: number;
	clone() : InputActionInstance;
	static C(Other: UObject | any): InputActionInstance;
}

declare class InjectedInputArray { 
	clone() : InjectedInputArray;
	static C(Other: UObject | any): InjectedInputArray;
}

declare class EnhancedPlayerInput extends PlayerInput { 
	AppliedInputContexts: Map<InputMappingContext, number>;
	EnhancedActionMappings: EnhancedActionKeyMapping[];
	ActionInstanceData: Map<InputAction, InputActionInstance>;
	KeysPressedThisTick: Map<Key, Vector>;
	InputsInjectedThisTick: Map<InputAction, InjectedInputArray>;
	LastInjectedActions: Set<InputAction>;
	static Load(ResourceName: string): EnhancedPlayerInput;
	static Find(Outer: UObject, ResourceName: string): EnhancedPlayerInput;
	static GetDefaultObject(): EnhancedPlayerInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedPlayerInput;
	static C(Other: UObject | any): EnhancedPlayerInput;
}

declare type ETriggerState = 'None' | 'Ongoing' | 'Triggered' | 'ETriggerState_MAX';
declare var ETriggerState : { None:'None',Ongoing:'Ongoing',Triggered:'Triggered',ETriggerState_MAX:'ETriggerState_MAX', };
declare type ETriggerType = 'Explicit' | 'Implicit' | 'Blocker' | 'ETriggerType_MAX';
declare var ETriggerType : { Explicit:'Explicit',Implicit:'Implicit',Blocker:'Blocker',ETriggerType_MAX:'ETriggerType_MAX', };
declare class InputTrigger extends UObject { 
	ActuationThreshold: number;
	bShouldAlwaysTick: boolean;
	LastValue: InputActionValue;
	static Load(ResourceName: string): InputTrigger;
	static Find(Outer: UObject, ResourceName: string): InputTrigger;
	static GetDefaultObject(): InputTrigger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTrigger;
	UpdateState(PlayerInput: EnhancedPlayerInput,ModifiedValue: InputActionValue,DeltaTime: number): ETriggerState;
	IsActuated(ForValue: InputActionValue): boolean;
	GetTriggerType(): ETriggerType;
	static C(Other: UObject | any): InputTrigger;
}

declare class InputAction extends DataAsset { 
	ActionDescription: string;
	bConsumeInput: boolean;
	bTriggerWhenPaused: boolean;
	bReserveAllMappings: boolean;
	ValueType: EInputActionValueType;
	Triggers: InputTrigger[];
	Modifiers: InputModifier[];
	static Load(ResourceName: string): InputAction;
	static Find(Outer: UObject, ResourceName: string): InputAction;
	static GetDefaultObject(): InputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAction;
	static C(Other: UObject | any): InputAction;
}

declare class ScriptTypedElementHandle { 
	clone() : ScriptTypedElementHandle;
	static C(Other: UObject | any): ScriptTypedElementHandle;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	bNetTemporary: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bCallPreReplication: boolean;
	bCallPreReplicationForReplay: boolean;
	bHidden: boolean;
	bTearOff: boolean;
	bForceNetAddressable: boolean;
	bIsInEditingLevelInstance: boolean;
	bExchangedRoles: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bRelevantForNetworkReplays: boolean;
	bRelevantForLevelBounds: boolean;
	bReplayRewindable: boolean;
	bAllowTickBeforeBeginPlay: boolean;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bBlockInput: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bGenerateOverlapEventsDuringLevelStreaming: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	bIsEditorOnlyActor: boolean;
	bActorSeamlessTraveled: boolean;
	bReplicates: boolean;
	bCanBeInCluster: boolean;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	bReplicateUsingRegisteredSubObjectList: boolean;
	bActorEnableCollision: boolean;
	bActorIsBeingDestroyed: boolean;
	bAsyncPhysicsTickEnabled: boolean;
	UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	InitialLifeSpan: number;
	CustomTimeDilation: number;
	RemoteRole: ENetRole;
	RayTracingGroupId: number;
	GridPlacement: EActorGridPlacement;
	RuntimeGrid: string;
	AttachmentReplication: RepAttachment;
	ReplicatedMovement: RepMovement;
	Owner: Actor;
	NetDriverName: string;
	Role: ENetRole;
	NetDormancy: ENetDormancy;
	SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
	AutoReceiveInput: EAutoReceiveInput;
	InputPriority: number;
	InputComponent: InputComponent;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateFrequency: number;
	MinNetUpdateFrequency: number;
	NetPriority: number;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	HLODLayer: HLODLayer;
	Layers: string[];
	ParentComponentActor: Actor;
	ParentComponent: ChildActorComponent;
	ActorGuid: Guid;
	ContentBundleGuid: Guid;
	DataLayers: ActorDataLayer[];
	DataLayerAssets: DataLayerAsset[];
	GroupActor: Actor;
	SpriteScale: number;
	HiddenEditorViews: number;
	ActorLabel: string;
	FolderPath: string;
	FolderGuid: Guid;
	bHiddenEd: boolean;
	bIsEditorPreviewActor: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	bActorLabelEditable: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bOptimizeBPComponentData: boolean;
	bCanPlayFromHere: boolean;
	bIsSpatiallyLoaded: boolean;
	bHiddenEdTemporary: boolean;
	bForceExternalActorLevelReferenceForPIE: boolean;
	Tags: string[];
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnTakeRadialDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<(DestroyedActor: Actor) => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(Actor: Actor, EndPlayReason: EEndPlayReason) => void>;
	InstanceComponents: ActorComponent[];
	BlueprintCreatedComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static GetDefaultObject(): Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	WasRecentlyRendered(Tolerance: number): boolean;
	UserConstructionScript(): void;
	TearOff(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetRayTracingGroupId(InRaytracingGroupId: number): void;
	SetOwner(NewOwner: Actor): void;
	SetNetDormancy(NewDormancy: ENetDormancy): void;
	SetLifeSpan(InLifespan: number): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	SetFolderPath(NewFolderPath: string): void;
	SetAutoDestroyWhenFinished(bVal: boolean): void;
	SetActorTickInterval(TickInterval: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveRadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceivePointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor,HitInfo: HitResult): void;
	ReceiveHit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveDestroyed(): void;
	ReceiveBeginPlay(): void;
	ReceiveAsyncPhysicsTick(DeltaSeconds: number,SimSeconds: number): void;
	ReceiveAnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceiveActorOnReleased(ButtonReleased: Key): void;
	ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;
	ReceiveActorOnClicked(ButtonPressed: Key): void;
	ReceiveActorEndOverlap(OtherActor: Actor): void;
	ReceiveActorEndCursorOver(): void;
	ReceiveActorBeginOverlap(OtherActor: Actor): void;
	ReceiveActorBeginCursorOver(): void;
	PrestreamTextures(Seconds: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Owner(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	K2_TeleportTo(DestLocation: Vector,DestRotation: Rotator): boolean;
	K2_SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorRotation(NewRotation: Rotator,bTeleportPhysics: boolean): boolean;
	K2_SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_OnReset(): void;
	K2_OnEndViewTarget(PC: PlayerController): void;
	K2_OnBecomeViewTarget(PC: PlayerController): void;
	K2_GetRootComponent(): SceneComponent;
	K2_GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	K2_GetActorRotation(): Rotator;
	K2_GetActorLocation(): Vector;
	K2_DetachFromActor(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule): void;
	K2_DestroyActor(): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachToActor(ParentActor: Actor,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentTo(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AddActorWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
	IsSelectable(): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsHiddenEdAtStartup(): boolean;
	IsHiddenEd(): boolean;
	IsEditable(): boolean;
	IsChildActor(): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetSquaredHorizontalDistanceTo(OtherActor: Actor): number;
	GetSquaredDistanceTo(OtherActor: Actor): number;
	GetRemoteRole(): ENetRole;
	GetRayTracingGroupId(): number;
	GetParentComponent(): ChildActorComponent;
	GetParentActor(): Actor;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLocalRole(): ENetRole;
	GetLifeSpan(): number;
	GetLevelTransform(): Transform;
	GetLevel(): Level;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetGameTimeSinceCreation(): number;
	GetFolderPath(): string;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetDefaultActorLabel(): string;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByInterface(Interface: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetAttachParentSocketName(): string;
	GetAttachParentActor(): Actor;
	GetAttachedActors(OutActors?: Actor[],bResetArray?: boolean,bRecursivelyIncludeAttachedActors?: boolean): {OutActors: Actor[]};
	GetAllChildActors(ChildActors?: Actor[],bIncludeDescendants?: boolean): {ChildActors: Actor[]};
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorTickInterval(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorLabel(bCreateIfNone: boolean): string;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector,bIncludeFromChildActors?: boolean): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	FinishAddComponent(Component: ActorComponent,bManualAttachment: boolean,RelativeTransform: Transform): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponentByClass(Class: UnrealEngineClass,bManualAttachment: boolean,RelativeTransform: Transform,bDeferredFinish: boolean): ActorComponent;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject,bDeferredFinish: boolean): ActorComponent;
	ActorHasTag(Tag: string): boolean;
	static C(Other: UObject | any): Actor;
	GetWorldPositionFromJavascriptEdViewport(Viewport: JavascriptEdViewport,OutVector?: Vector): {OutVector: Vector, $: boolean};
	ClearActorLabel(): void;
	GetActorLabel(): string;
	GetActorLocation(): Vector;
	GetActorRotation(): Rotator;
	GetFolderPath(): string;
	GetWorldPositionFromViewportClick(Click: JavascriptViewportClick,OutHitResult?: HitResult): {OutHitResult: HitResult, $: boolean};
	IsActorLabelEditable(): boolean;
	OpenCreateBlueprintFromActorDialog(): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorLabelUnique(NewActorLabel: string,InExistingActorLabels: string[]): void;
	SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetFolderPath(NewFolderPath: string): void;
	SetFolderPath_Recursively(NewFolderPath: string): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	DestroyActor(): boolean;
	PilotLevelActor(): void;
	SetActorSelectionState(bShouldBeSelected: boolean): void;
	AddActorToLayer(Layer: ActorLayer): void;
	RemoveActorFromLayer(Layer: ActorLayer): void;
	Actor_GetWorld(): World;
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetLastRenderTime(): number;
	GetLevel(): Level;
	IsPendingKill(): boolean;
	ReregisterAllComponents(): void;
	SetActorFlags(Flags: number): void;
	SetRootComponent(Component: SceneComponent): void;
	GetBoundActionValue(Action: InputAction): InputActionValue;
	ConvertActorToLightWeightInstance(): ActorInstanceHandle;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	K2_AcquireEditorActorElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	AddDeviceVisualizationComponentBlocking(XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	AddNamedDeviceVisualizationComponentBlocking(SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static GetWorldPositionFromJavascriptEdViewport(Actor: Actor,Viewport: JavascriptEdViewport,OutVector?: Vector): {OutVector: Vector, $: boolean};
	static ClearActorLabel(Actor: Actor): void;
	static GetActorLabel(Actor: Actor): string;
	static GetActorLocation(Actor: Actor): Vector;
	static GetActorRotation(Actor: Actor): Rotator;
	static GetFolderPath(Actor: Actor): string;
	static GetWorldPositionFromViewportClick(Actor: Actor,Click: JavascriptViewportClick,OutHitResult?: HitResult): {OutHitResult: HitResult, $: boolean};
	static IsActorLabelEditable(Actor: Actor): boolean;
	static OpenCreateBlueprintFromActorDialog(Actor: Actor): void;
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	static SetActorLabelUnique(Actor: Actor,NewActorLabel: string,InExistingActorLabels: string[]): void;
	static SetActorLocation(Actor: Actor,NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	static DestroyActor(ActorToDestroy: Actor): boolean;
	static PilotLevelActor(ActorToPilot: Actor): void;
	static SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	static AddActorToLayer(InActor: Actor,Layer: ActorLayer): void;
	static RemoveActorFromLayer(InActor: Actor,Layer: ActorLayer): void;
	static Actor_GetWorld(Actor: Actor): World;
	static GetComponentsByClass(Actor: Actor,ComponentClass: UnrealEngineClass): ActorComponent[];
	static GetLastRenderTime(Actor: Actor): number;
	static GetLevel(Actor: Actor): Level;
	static IsPendingKill(InActor: Actor): boolean;
	static ReregisterAllComponents(Actor: Actor): void;
	static SetActorFlags(Actor: Actor,Flags: number): void;
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	static GetBoundActionValue(Actor: Actor,Action: InputAction): InputActionValue;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static K2_AcquireEditorActorElementHandle(Actor: Actor,bAllowCreate: boolean): ScriptTypedElementHandle;
	static GetAIController(ControlledActor: Actor): AIController;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
}

declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	UCSSerializationIndex: number;
	bNetAddressable: boolean;
	bReplicateUsingRegisteredSubObjectList: boolean;
	bReplicates: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bCanEverAffectNavigation: boolean;
	bIsEditorOnly: boolean;
	bIsVisualizationComponent: boolean;
	bNeedsUCSSerializationIndexEvaluted: boolean;
	CreationMethod: EComponentCreationMethod;
	OnComponentActivated: UnrealEngineMulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
	OnComponentDeactivated: UnrealEngineMulticastDelegate<(Component: ActorComponent) => void>;
	UCSModifiedProperties: SimpleMemberReference[];
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static GetDefaultObject(): ActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickIntervalAndCooldown(TickInterval: number): void;
	SetComponentTickInterval(TickInterval: number): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetAutoActivate(bNewAutoActivate: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveBeginPlay(): void;
	ReceiveAsyncPhysicsTick(DeltaSeconds: number,SimSeconds: number): void;
	OnRep_IsActive(): void;
	K2_DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	GetComponentTickInterval(): number;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
	static C(Other: UObject | any): ActorComponent;
	IsRegistered(): boolean;
	MarkRenderStateDirty(): void;
	RegisterComponent(): void;
	ReregisterComponent(): void;
	UnregisterComponent(): void;
	K2_AcquireEditorComponentElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	static MarkRenderStateDirty(Component: ActorComponent): void;
	static RegisterComponent(ActorComponent: ActorComponent): void;
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	static UnregisterComponent(ActorComponent: ActorComponent): void;
	static K2_AcquireEditorComponentElementHandle(Component: ActorComponent,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	bHasValidCookedData: boolean;
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare class BlueprintMacroCosmeticInfo { 
	clone() : BlueprintMacroCosmeticInfo;
	static C(Other: UObject | any): BlueprintMacroCosmeticInfo;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame' | 'TL_MAX';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame',TL_MAX:'TL_MAX', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	bIsExpanded: boolean;
	bIsCurveViewSynchronized: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class TTEventTrack extends TTTrackBase { 
	FunctionName: string;
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTPropertyTrack extends TTTrackBase { 
	PropertyName: string;
	clone() : TTPropertyTrack;
	static C(Other: UObject | any): TTPropertyTrack;
}

declare class TTFloatTrack extends TTPropertyTrack { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTPropertyTrack { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class TTLinearColorTrack extends TTPropertyTrack { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TTTrackId { 
	TrackType: number;
	TrackIndex: number;
	clone() : TTTrackId;
	static C(Other: UObject | any): TTTrackId;
}

declare class TimelineTemplate extends UObject { 
	TimelineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	TimelineTickGroup: ETickingGroup;
	VariableName: string;
	DirectionPropertyName: string;
	UpdateFunctionName: string;
	FinishedFunctionName: string;
	TrackDisplayOrder: TTTrackId[];
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class BPComponentClassOverride { 
	ComponentName: string;
	ComponentClass: UnrealEngineClass;
	clone() : BPComponentClassOverride;
	static C(Other: UObject | any): BPComponentClassOverride;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Never' | 'COND_NetGroup' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Never:'COND_Never',COND_NetGroup:'COND_NetGroup',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: number;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class BPEditorBookmarkNode { 
	NodeGuid: Guid;
	ParentGuid: Guid;
	DisplayName: string;
	clone() : BPEditorBookmarkNode;
	static C(Other: UObject | any): BPEditorBookmarkNode;
}

declare class Breakpoint extends UObject { 
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: EdGraphNode;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class BlueprintExtension extends UObject { 
	static Load(ResourceName: string): BlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintExtension;
	static GetDefaultObject(): BlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintExtension;
	static C(Other: UObject | any): BlueprintExtension;
}

declare class Blueprint extends BlueprintCore { 
	ParentClass: UnrealEngineClass;
	BlueprintType: EBlueprintType;
	bRecompileOnLoad: boolean;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bBeingCompiled: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	bDisplayCompilePIEWarning: boolean;
	bDeprecate: boolean;
	bDuplicatingReadOnly: boolean;
	ShouldCookPropertyGuidsValue: EShouldCookBlueprintPropertyGuids;
	NativizationFlag: EBlueprintNativizationFlag;
	CompileMode: EBlueprintCompileMode;
	Status: EBlueprintStatus;
	BlueprintDisplayName: string;
	BlueprintDescription: string;
	BlueprintNamespace: string;
	BlueprintCategory: string;
	HideCategories: string[];
	BlueprintSystemVersion: number;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: Map<EdGraph, BlueprintMacroCosmeticInfo>;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	InheritableComponentHandler: InheritableComponentHandler;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImportedNamespaces: Set<string>;
	ImplementedInterfaces: BPInterfaceDescription[];
	LastEditedDocuments: EditedDocumentInfo[];
	Bookmarks: Map<Guid, EditedDocumentInfo>;
	BookmarkNodes: BPEditorBookmarkNode[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: Map<string, number>;
	OldToNewComponentTemplateNames: Map<string, string>;
	Extensions: BlueprintExtension[];
	ThumbnailInfo: ThumbnailInfo;
	CrcLastCompiledCDO: number;
	CrcLastCompiledSignature: number;
	bCachedDependenciesUpToDate: boolean;
	CachedDependencies: Set<Blueprint>;
	CachedDependents: Set<Blueprint>;
	CachedUDSDependencies: Set<Struct>;
	OriginalClass: UnrealEngineClass;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	AddComponentsToBlueprint(Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	CompileBlueprint(): void;
	GetParentClassOfBlueprint(): UnrealEngineClass;
	RemoveComponentFromBlueprint(RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	AddFunctionGraph(FuncName: string): EdGraph;
	CompileBlueprint(): void;
	FindEventGraph(): EdGraph;
	FindGraph(GraphName: string): EdGraph;
	RemoveFunctionGraph(FuncName: string): void;
	RemoveGraph(Graph: EdGraph): void;
	RemoveUnusedNodes(): void;
	RemoveUnusedVariables(): number;
	ReparentBlueprint(NewParentClass: UnrealEngineClass): void;
	ReplaceVariableReferences(OldVarName: string,NewVarName: string): void;
	SetBlueprintVariableExposeOnSpawn(VariableName: string,bExposeOnSpawn: boolean): void;
	SetBlueprintVariableExposeToCinematics(VariableName: string,bExposeToCinematics: boolean): void;
	SetBlueprintVariableInstanceEditable(VariableName: string,bInstanceEditable: boolean): void;
	UpgradeOperatorNodes(): void;
	static AddComponentsToBlueprint(Blueprint: Blueprint,Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static GetParentClassOfBlueprint(Blueprint: Blueprint): UnrealEngineClass;
	static RemoveComponentFromBlueprint(Blueprint: Blueprint,RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static SetBlueprintVariableExposeOnSpawn(Blueprint: Blueprint,VariableName: string,bExposeOnSpawn: boolean): void;
	static SetBlueprintVariableExposeToCinematics(Blueprint: Blueprint,VariableName: string,bExposeToCinematics: boolean): void;
	static SetBlueprintVariableInstanceEditable(Blueprint: Blueprint,VariableName: string,bInstanceEditable: boolean): void;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
}

declare type ERigVMGraphNotifType = 'GraphChanged' | 'NodeAdded' | 'NodeRemoved' | 'NodeSelected' | 'NodeDeselected' | 'NodeSelectionChanged' | 'NodePositionChanged' | 'NodeSizeChanged' | 'NodeColorChanged' | 'PinAdded' | 'PinRemoved' | 'PinRenamed' | 'PinExpansionChanged' | 'PinWatchedChanged' | 'PinArraySizeChanged' | 'PinDefaultValueChanged' | 'PinDirectionChanged' | 'PinTypeChanged' | 'PinIndexChanged' | 'LinkAdded' | 'LinkRemoved' | 'CommentTextChanged' | 'RerouteCompactnessChanged' | 'VariableAdded' | 'VariableRemoved' | 'VariableRenamed' | 'InteractionBracketOpened' | 'InteractionBracketClosed' | 'InteractionBracketCanceled' | 'PinBoundVariableChanged' | 'NodeRenamed' | 'NodeReferenceChanged' | 'NodeCategoryChanged' | 'NodeKeywordsChanged' | 'NodeDescriptionChanged' | 'VariableRemappingChanged' | 'Invalid' | 'ERigVMGraphNotifType_MAX';
declare var ERigVMGraphNotifType : { GraphChanged:'GraphChanged',NodeAdded:'NodeAdded',NodeRemoved:'NodeRemoved',NodeSelected:'NodeSelected',NodeDeselected:'NodeDeselected',NodeSelectionChanged:'NodeSelectionChanged',NodePositionChanged:'NodePositionChanged',NodeSizeChanged:'NodeSizeChanged',NodeColorChanged:'NodeColorChanged',PinAdded:'PinAdded',PinRemoved:'PinRemoved',PinRenamed:'PinRenamed',PinExpansionChanged:'PinExpansionChanged',PinWatchedChanged:'PinWatchedChanged',PinArraySizeChanged:'PinArraySizeChanged',PinDefaultValueChanged:'PinDefaultValueChanged',PinDirectionChanged:'PinDirectionChanged',PinTypeChanged:'PinTypeChanged',PinIndexChanged:'PinIndexChanged',LinkAdded:'LinkAdded',LinkRemoved:'LinkRemoved',CommentTextChanged:'CommentTextChanged',RerouteCompactnessChanged:'RerouteCompactnessChanged',VariableAdded:'VariableAdded',VariableRemoved:'VariableRemoved',VariableRenamed:'VariableRenamed',InteractionBracketOpened:'InteractionBracketOpened',InteractionBracketClosed:'InteractionBracketClosed',InteractionBracketCanceled:'InteractionBracketCanceled',PinBoundVariableChanged:'PinBoundVariableChanged',NodeRenamed:'NodeRenamed',NodeReferenceChanged:'NodeReferenceChanged',NodeCategoryChanged:'NodeCategoryChanged',NodeKeywordsChanged:'NodeKeywordsChanged',NodeDescriptionChanged:'NodeDescriptionChanged',VariableRemappingChanged:'VariableRemappingChanged',Invalid:'Invalid',ERigVMGraphNotifType_MAX:'ERigVMGraphNotifType_MAX', };
declare type ERigVMPinDirection = 'Input' | 'Output' | 'IO' | 'Visible' | 'Hidden' | 'Invalid' | 'ERigVMPinDirection_MAX';
declare var ERigVMPinDirection : { Input:'Input',Output:'Output',IO:'IO',Visible:'Visible',Hidden:'Hidden',Invalid:'Invalid',ERigVMPinDirection_MAX:'ERigVMPinDirection_MAX', };
declare class RigVMLink extends UObject { 
	SourcePinPath: string;
	TargetPinPath: string;
	static Load(ResourceName: string): RigVMLink;
	static Find(Outer: UObject, ResourceName: string): RigVMLink;
	static GetDefaultObject(): RigVMLink;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLink;
	GetTargetPin(): RigVMPin;
	GetSourcePin(): RigVMPin;
	GetPinPathRepresentation(): string;
	GetOppositePin(InPin: RigVMPin): RigVMPin;
	GetLinkIndex(): number;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLink;
}

declare class RigVMTemplatePreferredType { 
	Argument: string;
	TypeIndex: number;
	TypeString: string;
	clone() : RigVMTemplatePreferredType;
	static C(Other: UObject | any): RigVMTemplatePreferredType;
}

declare class RigVMTemplateNode extends RigVMNode { 
	TemplateNotation: string;
	ResolvedFunctionName: string;
	PreferredPermutationTypes: string[];
	PreferredPermutationPairs: RigVMTemplatePreferredType[];
	static Load(ResourceName: string): RigVMTemplateNode;
	static Find(Outer: UObject, ResourceName: string): RigVMTemplateNode;
	static GetDefaultObject(): RigVMTemplateNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMTemplateNode;
	IsSingleton(): boolean;
	IsResolved(): boolean;
	IsFullyUnresolved(): boolean;
	GetScriptStruct(): ScriptStruct;
	GetNotation(): string;
	static C(Other: UObject | any): RigVMTemplateNode;
}

declare class RigVMUnitNode extends RigVMTemplateNode { 
	ScriptStruct: ScriptStruct;
	MethodName: string;
	static Load(ResourceName: string): RigVMUnitNode;
	static Find(Outer: UObject, ResourceName: string): RigVMUnitNode;
	static GetDefaultObject(): RigVMUnitNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUnitNode;
	GetStructDefaultValue(): string;
	GetMethodName(): string;
	static C(Other: UObject | any): RigVMUnitNode;
}

declare class RigVMInjectionInfo extends UObject { 
	UnitNode: RigVMUnitNode;
	UNode: RigVMNode;
	bInjectedAsInput: boolean;
	InputPin: RigVMPin;
	OutputPin: RigVMPin;
	static Load(ResourceName: string): RigVMInjectionInfo;
	static Find(Outer: UObject, ResourceName: string): RigVMInjectionInfo;
	static GetDefaultObject(): RigVMInjectionInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInjectionInfo;
	GetPin(): RigVMPin;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMInjectionInfo;
}

declare class RigVMPin extends UObject { 
	DisplayName: string;
	Direction: ERigVMPinDirection;
	bIsExpanded: boolean;
	bIsConstant: boolean;
	bRequiresWatch: boolean;
	bIsDynamicArray: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	CPPTypeObjectPath: string;
	DefaultValue: string;
	CustomWidgetName: string;
	SubPins: RigVMPin[];
	Links: RigVMLink[];
	InjectionInfos: RigVMInjectionInfo[];
	BoundVariablePath: string;
	static Load(ResourceName: string): RigVMPin;
	static Find(Outer: UObject, ResourceName: string): RigVMPin;
	static GetDefaultObject(): RigVMPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPin;
	RequiresWatch(bCheckExposedPinChain: boolean): boolean;
	IsWildCard(): boolean;
	IsUObject(): boolean;
	IsStructMember(): boolean;
	IsStruct(): boolean;
	IsStringType(): boolean;
	IsRootPin(): boolean;
	IsReferenceCountedContainer(): boolean;
	IsLinkedTo(InPin: RigVMPin): boolean;
	IsInterface(): boolean;
	IsExpanded(): boolean;
	IsExecuteContext(): boolean;
	IsEnum(): boolean;
	IsDynamicArray(): boolean;
	IsDefinedAsConstant(): boolean;
	IsArrayElement(): boolean;
	IsArray(): boolean;
	GetToolTipText(): string;
	GetTargetLinks(bRecursive: boolean): RigVMLink[];
	GetSubPins(): RigVMPin[];
	GetSubPinPath(InParentPin: RigVMPin,bIncludeParentPinName: boolean): string;
	GetSourceLinks(bRecursive: boolean): RigVMLink[];
	GetSegmentPath(bIncludeRootPin: boolean): string;
	GetScriptStruct(): ScriptStruct;
	GetRootPin(): RigVMPin;
	GetPinPath(bUseNodePath: boolean): string;
	GetPinIndex(): number;
	GetPinForLink(): RigVMPin;
	GetParentPin(): RigVMPin;
	GetOriginalPinFromInjectedNode(): RigVMPin;
	GetNode(): RigVMNode;
	GetLinks(): RigVMLink[];
	GetLinkedTargetPins(bRecursive: boolean): RigVMPin[];
	GetLinkedSourcePins(bRecursive: boolean): RigVMPin[];
	GetGraph(): RigVMGraph;
	GetEnum(): Enum;
	GetDisplayName(): string;
	GetDirection(): ERigVMPinDirection;
	GetDefaultValue(): string;
	GetCustomWidgetName(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	GetArraySize(): number;
	GetArrayElementCppType(): string;
	GetAbsolutePinIndex(): number;
	FindSubPin(InPinPath: string): RigVMPin;
	FindLinkForPin(InOtherPin: RigVMPin): RigVMLink;
	ContainsWildCardSubPin(): boolean;
	static C(Other: UObject | any): RigVMPin;
}

declare type ERigVMUserWorkflowType = 'Invalid' | 'NodeContext' | 'PinContext' | 'OnPinDefaultChanged' | 'All' | 'ERigVMUserWorkflowType_MAX';
declare var ERigVMUserWorkflowType : { Invalid:'Invalid',NodeContext:'NodeContext',PinContext:'PinContext',OnPinDefaultChanged:'OnPinDefaultChanged',All:'All',ERigVMUserWorkflowType_MAX:'ERigVMUserWorkflowType_MAX', };
declare class RigVMUserWorkflowOptions extends UObject { 
	Subject: UObject;
	Workflow: RigVMUserWorkflow;
	static Load(ResourceName: string): RigVMUserWorkflowOptions;
	static Find(Outer: UObject, ResourceName: string): RigVMUserWorkflowOptions;
	static GetDefaultObject(): RigVMUserWorkflowOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUserWorkflowOptions;
	RequiresDialog(): boolean;
	ReportWarning(InMessage: string): void;
	ReportInfo(InMessage: string): void;
	ReportError(InMessage: string): void;
	IsValid(): boolean;
	static C(Other: UObject | any): RigVMUserWorkflowOptions;
}

declare class RigVMUserWorkflow { 
	Title: string;
	Tooltip: string;
	Type: ERigVMUserWorkflowType;
	PerformDynamicDelegate: UnrealEngineDelegate<(InOptions: RigVMUserWorkflowOptions, InController: UObject) => boolean>;
	OptionsClass: UnrealEngineClass;
	clone() : RigVMUserWorkflow;
	static C(Other: UObject | any): RigVMUserWorkflow;
}

declare class RigVMNode extends UObject { 
	NodeTitle: string;
	Position: Vector2D;
	Size: Vector2D;
	NodeColor: LinearColor;
	PreviousName: string;
	bHasBreakpoint: boolean;
	bHaltedAtThisNode: boolean;
	Pins: RigVMPin[];
	OrphanedPins: RigVMPin[];
	static Load(ResourceName: string): RigVMNode;
	static Find(Outer: UObject, ResourceName: string): RigVMNode;
	static GetDefaultObject(): RigVMNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMNode;
	SetHasBreakpoint(bValue: boolean): void;
	SetExecutionIsHaltedAtThisNode(bValue: boolean): void;
	IsVisibleInUI(): boolean;
	IsSelected(): boolean;
	IsPure(): boolean;
	IsMutable(): boolean;
	IsLoopNode(): boolean;
	IsLinkedTo(InNode: RigVMNode): boolean;
	IsInputAggregate(): boolean;
	IsInjected(): boolean;
	IsEvent(): boolean;
	IsDefinedAsVarying(): boolean;
	IsDefinedAsConstant(): boolean;
	IsAggregate(): boolean;
	HasPinOfDirection(InDirection: ERigVMPinDirection): boolean;
	HasOutputPin(bIncludeIO: boolean): boolean;
	HasOrphanedPins(): boolean;
	HasIOPin(): boolean;
	HasInputPin(bIncludeIO: boolean): boolean;
	HasBreakpoint(): boolean;
	GetToolTipText(): string;
	GetSupportedWorkflows(InType: ERigVMUserWorkflowType,InSubject: UObject): RigVMUserWorkflow[];
	GetSize(): Vector2D;
	GetSecondAggregatePin(): RigVMPin;
	GetRootGraph(): RigVMGraph;
	GetPreviousFName(): string;
	GetPosition(): Vector2D;
	GetPins(): RigVMPin[];
	GetOrphanedPins(): RigVMPin[];
	GetOppositeAggregatePin(): RigVMPin;
	GetNodeTitle(): string;
	GetNodePath(bRecursive: boolean): string;
	GetNodeIndex(): number;
	GetNodeColor(): LinearColor;
	GetNextAggregateName(InLastAggregatePinName: string): string;
	GetLinks(): RigVMLink[];
	GetLinkedTargetNodes(): RigVMNode[];
	GetLinkedSourceNodes(): RigVMNode[];
	GetInjectionInfo(): RigVMInjectionInfo;
	GetGraph(): RigVMGraph;
	GetFirstAggregatePin(): RigVMPin;
	GetEventName(): string;
	GetAllPinsRecursively(): RigVMPin[];
	GetAggregateOutputs(): RigVMPin[];
	GetAggregateInputs(): RigVMPin[];
	FindPin(InPinPath: string): RigVMPin;
	ExecutionIsHaltedAtThisNode(): boolean;
	CanOnlyExistOnce(): boolean;
	CanBeUpgraded(): boolean;
	static C(Other: UObject | any): RigVMNode;
}

declare class RigVMGraphVariableDescription { 
	Name: string;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphVariableDescription;
	static C(Other: UObject | any): RigVMGraphVariableDescription;
}

declare class RigVMLibraryNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMLibraryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMLibraryNode;
	static GetDefaultObject(): RigVMLibraryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLibraryNode;
	GetLibrary(): RigVMFunctionLibrary;
	GetContainedGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLibraryNode;
}

declare class RigVMFunctionReferenceNode extends RigVMLibraryNode { 
	ReferencedNodePtr: RigVMLibraryNode;
	VariableMap: Map<string, string>;
	static Load(ResourceName: string): RigVMFunctionReferenceNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReferenceNode;
	static GetDefaultObject(): RigVMFunctionReferenceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReferenceNode;
	static C(Other: UObject | any): RigVMFunctionReferenceNode;
}

declare class RigVMFunctionReferenceArray { 
	FunctionReferences: RigVMFunctionReferenceNode[];
	clone() : RigVMFunctionReferenceArray;
	static C(Other: UObject | any): RigVMFunctionReferenceArray;
}

declare class RigVMBuildData extends UObject { 
	FunctionReferences: Map<RigVMLibraryNode, RigVMFunctionReferenceArray>;
	static Load(ResourceName: string): RigVMBuildData;
	static Find(Outer: UObject, ResourceName: string): RigVMBuildData;
	static GetDefaultObject(): RigVMBuildData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBuildData;
	static C(Other: UObject | any): RigVMBuildData;
}

declare class RigVMFunctionLibrary extends RigVMGraph { 
	FunctionReferences: Map<RigVMLibraryNode, RigVMFunctionReferenceArray>;
	LocalizedFunctions: Map<string, RigVMLibraryNode>;
	static Load(ResourceName: string): RigVMFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionLibrary;
	static GetDefaultObject(): RigVMFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionLibrary;
	GetReferencesForFunction(InFunctionName: string): RigVMFunctionReferenceNode[];
	GetReferencePathsForFunction(InFunctionName: string): string[];
	GetFunctions(): RigVMLibraryNode[];
	GetBuildData(): RigVMBuildData;
	FindFunctionForNode(InNode: RigVMNode): RigVMLibraryNode;
	FindFunction(InFunctionName: string): RigVMLibraryNode;
	static C(Other: UObject | any): RigVMFunctionLibrary;
}

declare class RigVMFunctionReturnNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMFunctionReturnNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReturnNode;
	static GetDefaultObject(): RigVMFunctionReturnNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReturnNode;
	static C(Other: UObject | any): RigVMFunctionReturnNode;
}

declare class RigVMFunctionEntryNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMFunctionEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionEntryNode;
	static GetDefaultObject(): RigVMFunctionEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionEntryNode;
	static C(Other: UObject | any): RigVMFunctionEntryNode;
}

declare class RigVMGraph extends UObject { 
	Nodes: RigVMNode[];
	Links: RigVMLink[];
	SelectedNodes: string[];
	DefaultFunctionLibraryPtr: RigVMGraph;
	ExecuteContextStruct: ScriptStruct;
	bEditable: boolean;
	LocalVariables: RigVMGraphVariableDescription[];
	static Load(ResourceName: string): RigVMGraph;
	static Find(Outer: UObject, ResourceName: string): RigVMGraph;
	static GetDefaultObject(): RigVMGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMGraph;
	SetDefaultFunctionLibrary(InFunctionLibrary: RigVMFunctionLibrary): void;
	IsTopLevelGraph(): boolean;
	IsRootGraph(): boolean;
	IsNodeSelected(InNodeName: string): boolean;
	GetVariableDescriptions(): RigVMGraphVariableDescription[];
	GetSelectNodes(): string[];
	GetRootGraph(): RigVMGraph;
	GetReturnNode(): RigVMFunctionReturnNode;
	GetParentGraph(): RigVMGraph;
	GetOutputArguments(): RigVMGraphVariableDescription[];
	GetNodes(): RigVMNode[];
	GetNodePath(): string;
	GetLocalVariables(bIncludeInputArguments: boolean): RigVMGraphVariableDescription[];
	GetLinks(): RigVMLink[];
	GetInputArguments(): RigVMGraphVariableDescription[];
	GetGraphName(): string;
	GetEntryNode(): RigVMFunctionEntryNode;
	GetDefaultFunctionLibrary(): RigVMFunctionLibrary;
	GetContainedGraphs(bRecursive: boolean): RigVMGraph[];
	FindPin(InPinPath: string): RigVMPin;
	FindNodeByName(InNodeName: string): RigVMNode;
	FindNode(InNodePath: string): RigVMNode;
	FindLink(InLinkPinPathRepresentation: string): RigVMLink;
	static C(Other: UObject | any): RigVMGraph;
}

declare class RigVMActionKey { 
	ScriptStructPath: string;
	ExportedText: string;
	clone() : RigVMActionKey;
	static C(Other: UObject | any): RigVMActionKey;
}

declare class RigVMActionStack extends UObject { 
	ActionIndex: number;
	UndoActions: RigVMActionKey[];
	RedoActions: RigVMActionKey[];
	static Load(ResourceName: string): RigVMActionStack;
	static Find(Outer: UObject, ResourceName: string): RigVMActionStack;
	static GetDefaultObject(): RigVMActionStack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMActionStack;
	Undo(InController: RigVMController): boolean;
	Redo(InController: RigVMController): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	CloseUndoBracket(InController: RigVMController): boolean;
	CancelUndoBracket(InController: RigVMController): boolean;
	static C(Other: UObject | any): RigVMActionStack;
}

declare class RigVMCollapseNode extends RigVMLibraryNode { 
	ContainedGraph: RigVMGraph;
	NodeCategory: string;
	NodeKeywords: string;
	NodeDescription: string;
	static Load(ResourceName: string): RigVMCollapseNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCollapseNode;
	static GetDefaultObject(): RigVMCollapseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCollapseNode;
	static C(Other: UObject | any): RigVMCollapseNode;
}

declare class RigVMVariableNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMVariableNode;
	static Find(Outer: UObject, ResourceName: string): RigVMVariableNode;
	static GetDefaultObject(): RigVMVariableNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMVariableNode;
	IsLocalVariable(): boolean;
	IsInputArgument(): boolean;
	IsGetter(): boolean;
	IsExternalVariable(): boolean;
	GetVariableName(): string;
	GetVariableDescription(): RigVMGraphVariableDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMVariableNode;
}

declare class RigVMSelectNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMSelectNode;
	static Find(Outer: UObject, ResourceName: string): RigVMSelectNode;
	static GetDefaultObject(): RigVMSelectNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMSelectNode;
	static C(Other: UObject | any): RigVMSelectNode;
}

declare class RigVMRerouteNode extends RigVMTemplateNode { 
	bShowAsFullNode: boolean;
	static Load(ResourceName: string): RigVMRerouteNode;
	static Find(Outer: UObject, ResourceName: string): RigVMRerouteNode;
	static GetDefaultObject(): RigVMRerouteNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMRerouteNode;
	GetShowsAsFullNode(): boolean;
	static C(Other: UObject | any): RigVMRerouteNode;
}

declare class RigVMGraphParameterDescription { 
	Name: string;
	bIsInput: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphParameterDescription;
	static C(Other: UObject | any): RigVMGraphParameterDescription;
}

declare class RigVMParameterNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMParameterNode;
	static Find(Outer: UObject, ResourceName: string): RigVMParameterNode;
	static GetDefaultObject(): RigVMParameterNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMParameterNode;
	IsInput(): boolean;
	GetParameterName(): string;
	GetParameterDescription(): RigVMGraphParameterDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMParameterNode;
}

declare class RigVMInvokeEntryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMInvokeEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMInvokeEntryNode;
	static GetDefaultObject(): RigVMInvokeEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInvokeEntryNode;
	GetEntryName(): string;
	static C(Other: UObject | any): RigVMInvokeEntryNode;
}

declare class RigVMIfNode extends RigVMTemplateNode { 
	static Load(ResourceName: string): RigVMIfNode;
	static Find(Outer: UObject, ResourceName: string): RigVMIfNode;
	static GetDefaultObject(): RigVMIfNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMIfNode;
	static C(Other: UObject | any): RigVMIfNode;
}

declare class RigVMEnumNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMEnumNode;
	static Find(Outer: UObject, ResourceName: string): RigVMEnumNode;
	static GetDefaultObject(): RigVMEnumNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMEnumNode;
	GetEnum(): Enum;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMEnumNode;
}

declare class RigVMCommentNode extends RigVMNode { 
	CommentText: string;
	FontSize: number;
	bBubbleVisible: boolean;
	bColorBubble: boolean;
	static Load(ResourceName: string): RigVMCommentNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCommentNode;
	static GetDefaultObject(): RigVMCommentNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCommentNode;
	GetCommentText(): string;
	GetCommentFontSize(): number;
	GetCommentColorBubble(): boolean;
	GetCommentBubbleVisible(): boolean;
	static C(Other: UObject | any): RigVMCommentNode;
}

declare class RigVMBranchNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMBranchNode;
	static Find(Outer: UObject, ResourceName: string): RigVMBranchNode;
	static GetDefaultObject(): RigVMBranchNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBranchNode;
	static C(Other: UObject | any): RigVMBranchNode;
}

declare class RigVMArrayNode extends RigVMTemplateNode { 
	OpCode: ERigVMOpCode;
	static Load(ResourceName: string): RigVMArrayNode;
	static Find(Outer: UObject, ResourceName: string): RigVMArrayNode;
	static GetDefaultObject(): RigVMArrayNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMArrayNode;
	GetOpCode(): ERigVMOpCode;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMArrayNode;
}

declare class RigVMController extends UObject { 
	ModifiedEventDynamic: UnrealEngineMulticastDelegate<(NotifType: ERigVMGraphNotifType, Graph: RigVMGraph, Subject: UObject) => void>;
	Graphs: RigVMGraph[];
	ActionStack: RigVMActionStack;
	static Load(ResourceName: string): RigVMController;
	static Find(Outer: UObject, ResourceName: string): RigVMController;
	static GetDefaultObject(): RigVMController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMController;
	UpgradeNodes(InNodeNames: string[],bRecursive: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	UnresolveTemplateNodes(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	Undo(): boolean;
	UnbindPinFromVariable(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetUnitNodeDefaults(InNode: RigVMUnitNode,InDefaults: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRerouteCompactnessByName(InNodeName: string,bShowAsFullNode: boolean,bSetupUndoRedo: boolean): boolean;
	SetRerouteCompactness(InNode: RigVMNode,bShowAsFullNode: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRemappedVariable(InFunctionRefNode: RigVMFunctionReferenceNode,InInnerVariableName: string,InOuterVariableName: string,bSetupUndoRedo: boolean): boolean;
	SetPinIsWatched(InPinPath: string,bIsWatched: boolean,bSetupUndoRedo: boolean): boolean;
	SetPinExpansion(InPinPath: string,bIsExpanded: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetPinDefaultValue(InPinPath: string,InDefaultValue: string,bResizeArrays: boolean,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSizeByName(InNodeName: string,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSize(InNode: RigVMNode,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSelection(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePositionByName(InNodeName: string,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePosition(InNode: RigVMNode,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeKeywordsByName(InNodeName: string,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeKeywords(InNode: RigVMCollapseNode,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeDescriptionByName(InNodeName: string,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeDescription(InNode: RigVMCollapseNode,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeColorByName(InNodeName: string,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeColor(InNode: RigVMNode,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeCategoryByName(InNodeName: string,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeCategory(InNode: RigVMCollapseNode,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableTypeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableType(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableDefaultValue(InVariableName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bNotify: boolean): boolean;
	SetIsRunningUnitTest(bIsRunning: boolean): void;
	SetGraph(InGraph: RigVMGraph): void;
	SetExposedPinIndex(InPinName: string,InNewIndex: number,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentTextByName(InNodeName: string,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentText(InNode: RigVMNode,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetArrayPinSize(InArrayPinPath: string,InSize: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SelectNodeByName(InNodeName: string,bSelect: boolean,bSetupUndoRedo: boolean): boolean;
	SelectNode(InNode: RigVMNode,bSelect: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResolveWildCardPin(InPinPath: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResetPinDefaultValue(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ReplaceParameterNodeWithVariable(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): RigVMVariableNode;
	RenameVariable(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameParameter(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameNode(InNode: RigVMNode,InNewName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameLocalVariable(InVariableName: string,InNewVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameFunction(InOldFunctionName: string,InNewFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RenameExposedPin(InOldPinName: string,InNewPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveNodeByName(InNodeName: string,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveNode(InNode: RigVMNode,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveLocalVariable(InVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveInjectedNode(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveFunctionFromLibrary(InFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RemoveExposedPin(InPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveAggregatePin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RefreshVariableNode(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bSetupOrphanPins: boolean): void;
	Redo(): boolean;
	PushGraph(InGraph: RigVMGraph,bSetupUndoRedo: boolean): void;
	PromotePinToVariable(InPinPath: string,bCreateVariableNode: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	PromoteFunctionReferenceNodeToCollapseNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bRemoveFunctionDefinition: boolean): string;
	PromoteCollapseNodeToFunctionReferenceNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InExistingFunctionDefinitionPath: string): string;
	PopGraph(bSetupUndoRedo: boolean): RigVMGraph;
	PerformUserWorkflow(InWorkflow: RigVMUserWorkflow,InOptions: RigVMUserWorkflowOptions,bSetupUndoRedo: boolean): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	MakeVariableNodeFromBinding(InPinPath: string,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	MakeOptionsForWorkflow(InSubject: UObject,InWorkflow: RigVMUserWorkflow): RigVMUserWorkflowOptions;
	MakeBindingsFromVariableNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	LocalizeFunctions(InFunctionDefinitions: RigVMLibraryNode[],bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): Map<RigVMLibraryNode, RigVMLibraryNode>;
	LocalizeFunction(InFunctionDefinition: RigVMLibraryNode,bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	IsReportingEnabled(): boolean;
	InsertArrayPin(InArrayPinPath: string,InIndex: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	ImportNodesFromText(InText: string,bSetupUndoRedo: boolean,bPrintPythonCommands: boolean): string[];
	static GetUnitStructsForTemplate(InNotation: string): ScriptStruct[];
	GetTopLevelGraph(): RigVMGraph;
	static GetTemplateForUnitStruct(InFunction: ScriptStruct,InMethodName: string): string;
	static GetRegisteredUnitStructs(): ScriptStruct[];
	static GetRegisteredTemplates(): string[];
	GetPinDefaultValue(InPinPath: string): string;
	GetGraph(): RigVMGraph;
	GeneratePythonCommands(): string[];
	ExportSelectedNodesToText(): string;
	ExportNodesToText(InNodeNames: string[]): string;
	ExpandLibraryNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	EnableReporting(bEnabled: boolean): void;
	EjectNodeFromPin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode;
	DuplicateArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	CollapseNodes(InNodeNames: string[],InCollapseNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bIsAggregate: boolean): RigVMCollapseNode;
	CloseUndoBracket(): boolean;
	ClearNodeSelection(bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ClearArrayPin(InArrayPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ChangeExposedPinType(InPinName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo?: boolean,bSetupOrphanPins?: boolean,bPrintPythonCommand?: boolean): {bSetupUndoRedo: boolean, $: boolean};
	CanImportNodesFromText(InText: string): boolean;
	CancelUndoBracket(): boolean;
	BreakLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BreakAllLinks(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BindPinToVariable(InPinPath: string,InNewBoundVariablePath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddVariableNodeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddVariableNode(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddUnitNodeWithDefaults(InScriptStruct: ScriptStruct,InDefaults: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNodeFromStructPath(InScriptStructPath: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNode(InScriptStruct: ScriptStruct,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddTemplateNode(InNotation: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMTemplateNode;
	AddSelectNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMSelectNode;
	AddSelectNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMSelectNode;
	AddRerouteNodeOnPin(InPinPath: string,bAsInput: boolean,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLinkPath(InLinkPinPathRepresentation: string,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLink(InLink: RigVMLink,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddParameterNodeFromObjectPath(InParameterName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddParameterNode(InParameterName: string,InCPPType: string,InCPPTypeObject: UObject,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddLocalVariableFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean): RigVMGraphVariableDescription;
	AddLocalVariable(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraphVariableDescription;
	AddLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InUserDirection: ERigVMPinDirection): boolean;
	AddInvokeEntryNode(InEntryName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInvokeEntryNode;
	AddInjectedNodeFromStructPath(InPinPath: string,bAsInput: boolean,InScriptStructPath: string,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean): RigVMInjectionInfo;
	AddInjectedNode(InPinPath: string,bAsInput: boolean,InScriptStruct: ScriptStruct,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInjectionInfo;
	AddIfNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMIfNode;
	AddIfNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMIfNode;
	AddFunctionToLibrary(InFunctionName: string,bMutable: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	AddFunctionReferenceNode(InFunctionDefinition: RigVMLibraryNode,InNodePosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMFunctionReferenceNode;
	AddFreeRerouteNode(bShowAsFullNode: boolean,InCPPType: string,InCPPTypeObjectPath: string,bIsConstant: boolean,InCustomWidgetName: string,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMRerouteNode;
	AddExposedPin(InPinName: string,InDirection: ERigVMPinDirection,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddEnumNode(InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMEnumNode;
	AddCommentNode(InCommentText: string,InPosition: Vector2D,InSize: Vector2D,InColor: LinearColor,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCommentNode;
	AddBranchNode(InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMBranchNode;
	AddArrayPin(InArrayPinPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddArrayNodeFromObjectPath(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddArrayNode(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObject: UObject,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddAggregatePin(InNodeName: string,InPinName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	static C(Other: UObject | any): RigVMController;
}

declare class ControlRigGraph extends EdGraph { 
	ModelNodePath: string;
	bIsFunctionDefinition: boolean;
	TemplateController: RigVMController;
	static Load(ResourceName: string): ControlRigGraph;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraph;
	static GetDefaultObject(): ControlRigGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraph;
	static C(Other: UObject | any): ControlRigGraph;
}

declare class RigGraphDisplaySettings { 
	bShowNodeInstructionIndex: boolean;
	bShowNodeRunCounts: boolean;
	NodeRunLowerBound: number;
	NodeRunLimit: number;
	MinMicroSeconds: number;
	MaxMicroSeconds: number;
	TotalMicroSeconds: number;
	bAutoDetermineRange: boolean;
	LastMinMicroSeconds: number;
	LastMaxMicroSeconds: number;
	MinDurationColor: LinearColor;
	MaxDurationColor: LinearColor;
	clone() : RigGraphDisplaySettings;
	static C(Other: UObject | any): RigGraphDisplaySettings;
}

declare class RigVMParserASTSettings { 
	bFoldAssignments: boolean;
	bFoldLiterals: boolean;
	bFoldConstantBranches: boolean;
	LinksToSkip: RigVMLink[];
	clone() : RigVMParserASTSettings;
	static C(Other: UObject | any): RigVMParserASTSettings;
}

declare class RigVMCompileSettings { 
	SurpressInfoMessages: boolean;
	SurpressWarnings: boolean;
	SurpressErrors: boolean;
	EnablePinWatches: boolean;
	IsPreprocessorPhase: boolean;
	ASTSettings: RigVMParserASTSettings;
	SetupNodeInstructionIndex: boolean;
	clone() : RigVMCompileSettings;
	static C(Other: UObject | any): RigVMCompileSettings;
}

declare class ControlRigPythonSettings { 
	clone() : ControlRigPythonSettings;
	static C(Other: UObject | any): ControlRigPythonSettings;
}

declare class RigVMClient { 
	Models: RigVMGraph[];
	FunctionLibrary: RigVMFunctionLibrary;
	Controllers: Map<SoftObjectPath, RigVMController>;
	UndoRedoIndex: number;
	clone() : RigVMClient;
	static C(Other: UObject | any): RigVMClient;
}

declare class ControlRigPublicFunctionArg { 
	Name: string;
	CPPType: string;
	CPPTypeObjectPath: string;
	bIsArray: boolean;
	Direction: ERigVMPinDirection;
	clone() : ControlRigPublicFunctionArg;
	static C(Other: UObject | any): ControlRigPublicFunctionArg;
}

declare class ControlRigPublicFunctionData { 
	Name: string;
	DisplayName: string;
	Category: string;
	Keywords: string;
	ReturnValue: ControlRigPublicFunctionArg;
	Arguments: ControlRigPublicFunctionArg[];
	clone() : ControlRigPublicFunctionData;
	static C(Other: UObject | any): ControlRigPublicFunctionData;
}

declare class RigVMReferenceNodeData { 
	ReferenceNodePath: string;
	ReferencedFunctionPath: string;
	clone() : RigVMReferenceNodeData;
	static C(Other: UObject | any): RigVMReferenceNodeData;
}

declare type ERigVMMemoryType = 'Work' | 'Literal' | 'External' | 'Debug' | 'Invalid' | 'ERigVMMemoryType_MAX';
declare var ERigVMMemoryType : { Work:'Work',Literal:'Literal',External:'External',Debug:'Debug',Invalid:'Invalid',ERigVMMemoryType_MAX:'ERigVMMemoryType_MAX', };
declare class RigVMOperand { 
	MemoryType: ERigVMMemoryType;
	RegisterIndex: number;
	RegisterOffset: number;
	clone() : RigVMOperand;
	static C(Other: UObject | any): RigVMOperand;
}

declare class RigElement { 
	Name: string;
	Index: number;
	clone() : RigElement;
	static C(Other: UObject | any): RigElement;
}

declare class RigBone extends RigElement { 
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	GlobalTransform: Transform;
	LocalTransform: Transform;
	Dependents: number[];
	Type: ERigBoneType;
	clone() : RigBone;
	static C(Other: UObject | any): RigBone;
}

declare class RigBoneHierarchy { 
	Bones: RigBone[];
	clone() : RigBoneHierarchy;
	static C(Other: UObject | any): RigBoneHierarchy;
}

declare type ERigSpaceType = 'Global' | 'Bone' | 'Control' | 'Space' | 'ERigSpaceType_MAX';
declare var ERigSpaceType : { Global:'Global',Bone:'Bone',Control:'Control',Space:'Space',ERigSpaceType_MAX:'ERigSpaceType_MAX', };
declare class RigSpace extends RigElement { 
	SpaceType: ERigSpaceType;
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	LocalTransform: Transform;
	clone() : RigSpace;
	static C(Other: UObject | any): RigSpace;
}

declare class RigSpaceHierarchy { 
	Spaces: RigSpace[];
	clone() : RigSpaceHierarchy;
	static C(Other: UObject | any): RigSpaceHierarchy;
}

declare class RigControl extends RigElement { 
	ControlType: ERigControlType;
	DisplayName: string;
	ParentName: string;
	ParentIndex: number;
	SpaceName: string;
	SpaceIndex: number;
	OffsetTransform: Transform;
	InitialValue: RigControlValue;
	Value: RigControlValue;
	PrimaryAxis: ERigControlAxis;
	bIsCurve: boolean;
	bAnimatable: boolean;
	bLimitTranslation: boolean;
	bLimitRotation: boolean;
	bLimitScale: boolean;
	bDrawLimits: boolean;
	MinimumValue: RigControlValue;
	MaximumValue: RigControlValue;
	bGizmoEnabled: boolean;
	bGizmoVisible: boolean;
	GizmoName: string;
	GizmoTransform: Transform;
	GizmoColor: LinearColor;
	Dependents: number[];
	bIsTransientControl: boolean;
	ControlEnum: Enum;
	clone() : RigControl;
	static C(Other: UObject | any): RigControl;
}

declare class RigControlHierarchy { 
	Controls: RigControl[];
	clone() : RigControlHierarchy;
	static C(Other: UObject | any): RigControlHierarchy;
}

declare class RigCurve extends RigElement { 
	Value: number;
	clone() : RigCurve;
	static C(Other: UObject | any): RigCurve;
}

declare class RigCurveContainer { 
	Curves: RigCurve[];
	clone() : RigCurveContainer;
	static C(Other: UObject | any): RigCurveContainer;
}

declare class RigHierarchyContainer { 
	BoneHierarchy: RigBoneHierarchy;
	SpaceHierarchy: RigSpaceHierarchy;
	ControlHierarchy: RigControlHierarchy;
	CurveContainer: RigCurveContainer;
	clone() : RigHierarchyContainer;
	static C(Other: UObject | any): RigHierarchyContainer;
}

declare class ControlRigValidationPass extends UObject { 
	static Load(ResourceName: string): ControlRigValidationPass;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidationPass;
	static GetDefaultObject(): ControlRigValidationPass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidationPass;
	static C(Other: UObject | any): ControlRigValidationPass;
}

declare class ControlRigValidator extends UObject { 
	Passes: ControlRigValidationPass[];
	static Load(ResourceName: string): ControlRigValidator;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidator;
	static GetDefaultObject(): ControlRigValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidator;
	static C(Other: UObject | any): ControlRigValidator;
}

declare class ControlRigBlueprint extends Blueprint { 
	FunctionLibraryEdGraph: ControlRigGraph;
	RigGraphDisplaySettings: RigGraphDisplaySettings;
	HierarchySettings: RigHierarchySettings;
	VMRuntimeSettings: RigVMRuntimeSettings;
	VMCompileSettings: RigVMCompileSettings;
	PythonLogSettings: ControlRigPythonSettings;
	Model: RigVMGraph;
	FunctionLibrary: RigVMFunctionLibrary;
	RigVMClient: RigVMClient;
	PublicFunctions: ControlRigPublicFunctionData[];
	FunctionReferenceNodeData: RigVMReferenceNodeData[];
	TemplateModel: RigVMGraph;
	TemplateController: RigVMController;
	PinToOperandMap: Map<string, RigVMOperand>;
	GizmoLibrary: ControlRigShapeLibrary;
	ShapeLibraries: ControlRigShapeLibrary[];
	Statistics: RigVMStatistics;
	DrawContainer: ControlRigDrawContainer;
	Influences: RigInfluenceMapPerEvent;
	HierarchyContainer: RigHierarchyContainer;
	Hierarchy: RigHierarchy;
	bSupportsInversion: boolean;
	bSupportsControls: boolean;
	PreviewSkeletalMesh: SkeletalMesh;
	SourceHierarchyImport: UObject;
	SourceCurveImport: UObject;
	SupportedEventNames: string[];
	bExposesAnimatableControls: boolean;
	bAutoRecompileVM: boolean;
	bVMRecompilationRequired: boolean;
	bIsCompiling: boolean;
	VMRecompilationBracket: number;
	Validator: ControlRigValidator;
	DebugBoneRadius: number;
	static Load(ResourceName: string): ControlRigBlueprint;
	static Find(Outer: UObject, ResourceName: string): ControlRigBlueprint;
	static GetDefaultObject(): ControlRigBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigBlueprint;
	SuspendNotifications(bSuspendNotifs: boolean): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	RequestControlRigInit(): void;
	RequestAutoVMRecompilation(): void;
	RenameMemberVariable(InOldName: string,InNewName: string): boolean;
	RemoveModel(InName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveMemberVariable(InName: string): boolean;
	RecompileVMIfRequired(): void;
	RecompileVM(): void;
	GetPreviewMesh(): SkeletalMesh;
	GetOrCreateController(InGraph: RigVMGraph): RigVMController;
	GetModel(InEdGraph: EdGraph): RigVMGraph;
	GetMemberVariables(): RigVMGraphVariableDescription[];
	GetLocalFunctionLibrary(): RigVMFunctionLibrary;
	GetHierarchyController(): RigHierarchyController;
	GetDefaultModel(): RigVMGraph;
	static GetCurrentlyOpenRigBlueprints(): ControlRigBlueprint[];
	GetControlRigClass(): UnrealEngineClass;
	GetControllerByName(InGraphName: string): RigVMController;
	GetController(InGraph: RigVMGraph): RigVMController;
	static GetAvailableRigUnits(): Struct[];
	GetAllModels(): RigVMGraph[];
	GeneratePythonCommands(InNewBlueprintName: string): string[];
	CreateControlRig(): ControlRig;
	ChangeMemberVariableType(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): boolean;
	AddModel(InName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraph;
	AddMemberVariable(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): string;
	static C(Other: UObject | any): ControlRigBlueprint;
	GetController(): RigVMController;
	GetHierarchy(): RigHierarchy;
	GetHierarchyController(): RigHierarchyController;
	GetModel(): RigVMGraph;
	GetPreviewMesh(): SkeletalMesh;
	RecompileVM(): void;
	RecompileVMIfRequired(): void;
	RequestAutoVMRecompilation(): void;
	RequestControlRigInit(): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	static GetController(InRigBlueprint: ControlRigBlueprint): RigVMController;
	static GetHierarchy(InRigBlueprint: ControlRigBlueprint): RigHierarchy;
	static GetHierarchyController(InRigBlueprint: ControlRigBlueprint): RigHierarchyController;
	static GetModel(InRigBlueprint: ControlRigBlueprint): RigVMGraph;
	static GetPreviewMesh(InRigBlueprint: ControlRigBlueprint): SkeletalMesh;
	static RecompileVM(InRigBlueprint: ControlRigBlueprint): void;
	static RecompileVMIfRequired(InRigBlueprint: ControlRigBlueprint): void;
	static RequestAutoVMRecompilation(InRigBlueprint: ControlRigBlueprint): void;
	static RequestControlRigInit(InRigBlueprint: ControlRigBlueprint): void;
	static SetPreviewMesh(InRigBlueprint: ControlRigBlueprint,PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
}

declare class DirectoryItem { 
	Name: string;
	bIsDirectory: boolean;
	clone() : DirectoryItem;
	static C(Other: UObject | any): DirectoryItem;
}

declare type EFileRead_JS = 'FILEREAD_None' | 'FILEREAD_NoFail' | 'FILEREAD_Silent' | 'FILEREAD_NotUsedDummy' | 'FILEREAD_AllowWrite' | 'FILEREAD_MAX';
declare var EFileRead_JS : { FILEREAD_None:'FILEREAD_None',FILEREAD_NoFail:'FILEREAD_NoFail',FILEREAD_Silent:'FILEREAD_Silent',FILEREAD_NotUsedDummy:'FILEREAD_NotUsedDummy',FILEREAD_AllowWrite:'FILEREAD_AllowWrite',FILEREAD_MAX:'FILEREAD_MAX', };
declare class JavascriptStubStruct { 
	clone() : JavascriptStubStruct;
	static C(Other: UObject | any): JavascriptStubStruct;
}

declare class JavascriptFunction { 
	clone() : JavascriptFunction;
	static C(Other: UObject | any): JavascriptFunction;
	CallJS(CustomStruct: JavascriptStubStruct): void;
	static CallJS(UFunction: JavascriptFunction,CustomStruct: JavascriptStubStruct): void;
}

declare class ReadStringFromFileHandle { 
	clone() : ReadStringFromFileHandle;
	static C(Other: UObject | any): ReadStringFromFileHandle;
}

declare type EJavascriptEncodingOptions = 'AutoDetect' | 'ForceAnsi' | 'ForceUnicode' | 'ForceUTF8' | 'ForceUTF8WithoutBOM' | 'EJavascriptEncodingOptions_MAX';
declare var EJavascriptEncodingOptions : { AutoDetect:'AutoDetect',ForceAnsi:'ForceAnsi',ForceUnicode:'ForceUnicode',ForceUTF8:'ForceUTF8',ForceUTF8WithoutBOM:'ForceUTF8WithoutBOM',EJavascriptEncodingOptions_MAX:'EJavascriptEncodingOptions_MAX', };
declare class AudioEngineSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): AudioEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioEngineSubsystem;
	static GetDefaultObject(): AudioEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEngineSubsystem;
	static C(Other: UObject | any): AudioEngineSubsystem;
}

declare class GameInstanceSubsystem extends Subsystem { 
	static Load(ResourceName: string): GameInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameInstanceSubsystem;
	static GetDefaultObject(): GameInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstanceSubsystem;
	static C(Other: UObject | any): GameInstanceSubsystem;
}

declare class WorldSubsystem extends Subsystem { 
	static Load(ResourceName: string): WorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldSubsystem;
	static GetDefaultObject(): WorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSubsystem;
	static C(Other: UObject | any): WorldSubsystem;
}

declare class CollisionProfileName { 
	Name: string;
	clone() : CollisionProfileName;
	static C(Other: UObject | any): CollisionProfileName;
}

declare type EPropertyAccessChangeNotifyMode = 'Default' | 'Never' | 'Always' | 'EPropertyAccessChangeNotifyMode_MAX';
declare var EPropertyAccessChangeNotifyMode : { Default:'Default',Never:'Never',Always:'Always',EPropertyAccessChangeNotifyMode_MAX:'EPropertyAccessChangeNotifyMode_MAX', };
declare class GenericStruct { 
	Data: number;
	clone() : GenericStruct;
	static C(Other: UObject | any): GenericStruct;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static Find(Outer: UObject, ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): Class;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	ExecuteUbergraph(EntryPoint: number): void;
	static C(Other: UObject | any): UObject;
	AddWhitelistedObject(): void;
	BroadcastAssetCreated(): void;
	ConditionalBeginDestroybyUObject(): boolean;
	GetUniqueID(): number;
	MarkPackageDirty(): boolean;
	ModifyObject(bAlwaysMarkDirty: boolean): void;
	OpenEditorForAsset(): boolean;
	PostEditChange(): void;
	CastToControlRigBlueprint(Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	SpawnActorFromObject(Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	CheckoutLoadedAsset(): boolean;
	ConsolidateAssets(AssetsToConsolidate: UObject[]): boolean;
	DeleteLoadedAsset(): boolean;
	DuplicateLoadedAsset(DestinationAssetPath: string): UObject;
	GetMetadataTag(Tag: string): string;
	GetMetadataTagValues(): Map<string, string>;
	GetPathNameForLoadedAsset(): string;
	RemoveMetadataTag(Tag: string): void;
	RenameLoadedAsset(DestinationAssetPath: string): boolean;
	SaveLoadedAsset(bOnlyIfIsDirty: boolean): boolean;
	SetMetadataTag(Tag: string,Value: string): void;
	GetCapturableProperties(): string[];
	RenameAsset(NewName: string): void;
	DestroyUObject(): void;
	ConvertRelativePathToFull(RelativePath: string): string;
	CreateEnum(Name: string,DisplayNames: string[],Flags: string[]): Enum;
	CreatePackage(PackageName: string): Package;
	Duplicate(Outer: UObject,Name: string): UObject;
	FindObjectWithOuter(ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	FindPackage(PackageName: string): Package;
	GetArchetypePathName(): string;
	GetDir(WhichDir: string): string;
	GetFields(bIncludeSuper: boolean): Field[];
	GetFileSize(Filename: string): number;
	GetName(): string;
	GetObjectsWithOuter(Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetOuter(): UObject;
	GetOutermost(): UObject;
	HasAnyFlags(Flags: number): boolean;
	ReadDirectory(Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	ReadFile(Filename: string): boolean;
	ReadStringFromFile(Filename: string,ReadFlags: EFileRead_JS): string;
	ReadStringFromFileAsync(Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	SetObjectFlags(Flags: number): void;
	WriteFile(Filename: string): boolean;
	WriteStringToFile(Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	GetDatasmithUserData(): DatasmithAssetUserData;
	GetDatasmithUserDataKeysAndValuesForValue(StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	GetDatasmithUserDataValueForKey(Key: string,bPartialMatchKey: boolean): string;
	GetDatasmithUserDataValuesForKey(Key: string,bPartialMatchKey: boolean): string[];
	RedirectVislog(DestinationOwner: UObject): void;
	GetAudioEngineSubsystem(Class: UnrealEngineClass): AudioEngineSubsystem;
	GetGameInstanceSubsystem(Class: UnrealEngineClass): GameInstanceSubsystem;
	GetLocalPlayerSubsystem(Class: UnrealEngineClass): LocalPlayerSubsystem;
	GetWorldSubsystem(Class: UnrealEngineClass): WorldSubsystem;
	MarkPropertyDirty(PropertyName: string): void;
	MarkPropertyDirtyFromRepIndex(RepIndex: number,PropertyName: string): void;
	Conv_ObjectToClass(Class: UnrealEngineClass): UnrealEngineClass;
	Conv_ObjectToSoftObjectReference(): UObject;
	Conv_SoftObjectReferenceToObject(): UObject;
	Conv_SoftObjectReferenceToString(): string;
	Conv_SoftObjRefToSoftObjPath(): SoftObjectPath;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	EqualEqual_SoftObjectReference(B: UObject): boolean;
	GetDisplayName(): string;
	GetEditorProperty(PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	GetObjectName(): string;
	GetOuterObject(): UObject;
	GetPathName(): string;
	GetPrimaryAssetIdFromObject(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftObjectReference(): PrimaryAssetId;
	GetSoftObjectPath(): SoftObjectPath;
	GetSystemPath(): string;
	IsValid(): boolean;
	IsValidSoftObjectReference(): boolean;
	K2_ClearTimer(FunctionName: string): void;
	K2_GetTimerElapsedTime(FunctionName: string): number;
	K2_GetTimerRemainingTime(FunctionName: string): number;
	K2_IsTimerActive(FunctionName: string): boolean;
	K2_IsTimerPaused(FunctionName: string): boolean;
	K2_PauseTimer(FunctionName: string): void;
	K2_SetTimer(FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	K2_SetTimerForNextTick(FunctionName: string): TimerHandle;
	K2_TimerExists(FunctionName: string): boolean;
	K2_UnPauseTimer(FunctionName: string): void;
	LoadAsset_Blocking(): UObject;
	NotEqual_SoftObjectReference(B: UObject): boolean;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetColorPropertyByName(PropertyName: string,Value: Color): void;
	SetDoublePropertyByName(PropertyName: string,Value: number): void;
	SetEditorProperty(PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	SetFieldPathPropertyByName(PropertyName: string,Value: any): void;
	SetInt64PropertyByName(PropertyName: string,Value: number): void;
	SetInterfacePropertyByName(PropertyName: string,Value: Interface): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetSoftClassPropertyByName(PropertyName: string,Value: Class): void;
	SetSoftObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVector3fPropertyByName(PropertyName: string,Value: Vector3f): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	SnapshotObject(): void;
	TransactObject(): void;
	Conv_ObjectToString(): string;
	EqualEqual_ObjectObject(B: UObject): boolean;
	NotEqual_ObjectObject(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetObjectClass(): UnrealEngineClass;
	ObjectIsA(ObjectClass: UnrealEngineClass): boolean;
	K2_AcquireEditorObjectElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	SetSetPropertyByName(PropertyName: string,Value: Set<number>): void;
	SetMapPropertyByName(PropertyName: string,Value: Map<number, number>): void;
	Conv_ObjectToText(): string;
	GetBlueprintAsset(): Blueprint;
	static AddWhitelistedObject(InObject: UObject): void;
	static BroadcastAssetCreated(NewAsset: UObject): void;
	static ConditionalBeginDestroybyUObject(TargetObject: UObject): boolean;
	static GetUniqueID(InObject: UObject): number;
	static MarkPackageDirty(InObject: UObject): boolean;
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	static OpenEditorForAsset(Asset: UObject): boolean;
	static PostEditChange(InObject: UObject): void;
	static CastToControlRigBlueprint(UObject: UObject,Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	static SpawnActorFromObject(ObjectToUse: UObject,Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	static CheckoutLoadedAsset(AssetToCheckout: UObject): boolean;
	static ConsolidateAssets(AssetToConsolidateTo: UObject,AssetsToConsolidate: UObject[]): boolean;
	static DeleteLoadedAsset(AssetToDelete: UObject): boolean;
	static DuplicateLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): UObject;
	static GetMetadataTag(UObject: UObject,Tag: string): string;
	static GetMetadataTagValues(UObject: UObject): Map<string, string>;
	static GetPathNameForLoadedAsset(LoadedAsset: UObject): string;
	static RemoveMetadataTag(UObject: UObject,Tag: string): void;
	static RenameLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): boolean;
	static SaveLoadedAsset(AssetToSave: UObject,bOnlyIfIsDirty: boolean): boolean;
	static SetMetadataTag(UObject: UObject,Tag: string,Value: string): void;
	static GetCapturableProperties(ActorOrClass: UObject): string[];
	static RenameAsset(Asset: UObject,NewName: string): void;
	static DestroyUObject(UObject: UObject): void;
	static ConvertRelativePathToFull(UObject: UObject,RelativePath: string): string;
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[],Flags: string[]): Enum;
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	static GetArchetypePathName(UObject: UObject): string;
	static GetDir(UObject: UObject,WhichDir: string): string;
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	static GetFileSize(UObject: UObject,Filename: string): number;
	static GetName(UObject: UObject): string;
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetOuter(UObject: UObject): UObject;
	static GetOutermost(UObject: UObject): UObject;
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	static ReadFile(UObject: UObject,Filename: string): boolean;
	static ReadStringFromFile(UObject: UObject,Filename: string,ReadFlags: EFileRead_JS): string;
	static ReadStringFromFileAsync(UObject: UObject,Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	static WriteFile(UObject: UObject,Filename: string): boolean;
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	static GetDatasmithUserData(UObject: UObject): DatasmithAssetUserData;
	static GetDatasmithUserDataKeysAndValuesForValue(UObject: UObject,StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	static GetDatasmithUserDataValueForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string;
	static GetDatasmithUserDataValuesForKey(UObject: UObject,Key: string,bPartialMatchKey: boolean): string[];
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static Conv_SoftObjRefToSoftObjPath(SoftObjectReference: UObject): SoftObjectPath;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static GetDisplayName(UObject: UObject): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetObjectName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetPathName(UObject: UObject): string;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetSoftObjectPath(UObject: UObject): SoftObjectPath;
	static GetSystemPath(UObject: UObject): string;
	static IsValid(UObject: UObject): boolean;
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetInterfacePropertyByName(UObject: UObject,PropertyName: string,Value: Interface): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SnapshotObject(UObject: UObject): void;
	static TransactObject(UObject: UObject): void;
	static Conv_ObjectToString(InObj: UObject): string;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static ObjectIsA(UObject: UObject,ObjectClass: UnrealEngineClass): boolean;
	static K2_AcquireEditorObjectElementHandle(UObject: UObject,bAllowCreate: boolean): ScriptTypedElementHandle;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: Set<number>): void;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: Map<number, number>): void;
	static Conv_ObjectToText(InObj: UObject): string;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
}

declare class GCObjectReferencer extends UObject { 
	static Load(ResourceName: string): GCObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): GCObjectReferencer;
	static GetDefaultObject(): GCObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject | any): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	static Load(ResourceName: string): TextBuffer;
	static Find(Outer: UObject, ResourceName: string): TextBuffer;
	static GetDefaultObject(): TextBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject | any): TextBuffer;
}

declare class DelegateFunction extends UFunction { 
	static Load(ResourceName: string): DelegateFunction;
	static Find(Outer: UObject, ResourceName: string): DelegateFunction;
	static GetDefaultObject(): DelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject | any): DelegateFunction;
}

declare class SparseDelegateFunction extends DelegateFunction { 
	static Load(ResourceName: string): SparseDelegateFunction;
	static Find(Outer: UObject, ResourceName: string): SparseDelegateFunction;
	static GetDefaultObject(): SparseDelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SparseDelegateFunction;
	static C(Other: UObject | any): SparseDelegateFunction;
}

declare class DynamicClass extends Class { 
	static Load(ResourceName: string): DynamicClass;
	static Find(Outer: UObject, ResourceName: string): DynamicClass;
	static GetDefaultObject(): DynamicClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicClass;
	static C(Other: UObject | any): DynamicClass;
}

declare class LinkerPlaceholderClass extends Class { 
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject | any): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderExportObject;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject | any): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderFunction;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject | any): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	static Load(ResourceName: string): MetaData;
	static Find(Outer: UObject, ResourceName: string): MetaData;
	static GetDefaultObject(): MetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject | any): MetaData;
}

declare class ObjectRedirector extends UObject { 
	static Load(ResourceName: string): ObjectRedirector;
	static Find(Outer: UObject, ResourceName: string): ObjectRedirector;
	static GetDefaultObject(): ObjectRedirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject | any): ObjectRedirector;
}

declare class Property extends Field { 
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static GetDefaultObject(): Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject | any): Property;
}

declare class EnumProperty extends Property { 
	static Load(ResourceName: string): EnumProperty;
	static Find(Outer: UObject, ResourceName: string): EnumProperty;
	static GetDefaultObject(): EnumProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumProperty;
	static C(Other: UObject | any): EnumProperty;
}

declare class ArrayProperty extends Property { 
	static Load(ResourceName: string): ArrayProperty;
	static Find(Outer: UObject, ResourceName: string): ArrayProperty;
	static GetDefaultObject(): ArrayProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject | any): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	static Load(ResourceName: string): ObjectPropertyBase;
	static Find(Outer: UObject, ResourceName: string): ObjectPropertyBase;
	static GetDefaultObject(): ObjectPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject | any): ObjectPropertyBase;
}

declare class BoolProperty extends Property { 
	static Load(ResourceName: string): BoolProperty;
	static Find(Outer: UObject, ResourceName: string): BoolProperty;
	static GetDefaultObject(): BoolProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject | any): BoolProperty;
}

declare class NumericProperty extends Property { 
	static Load(ResourceName: string): NumericProperty;
	static Find(Outer: UObject, ResourceName: string): NumericProperty;
	static GetDefaultObject(): NumericProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject | any): NumericProperty;
}

declare class ByteProperty extends NumericProperty { 
	static Load(ResourceName: string): ByteProperty;
	static Find(Outer: UObject, ResourceName: string): ByteProperty;
	static GetDefaultObject(): ByteProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject | any): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): ObjectProperty;
	static Find(Outer: UObject, ResourceName: string): ObjectProperty;
	static GetDefaultObject(): ObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject | any): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	static Load(ResourceName: string): ClassProperty;
	static Find(Outer: UObject, ResourceName: string): ClassProperty;
	static GetDefaultObject(): ClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject | any): ClassProperty;
}

declare class DelegateProperty extends Property { 
	static Load(ResourceName: string): DelegateProperty;
	static Find(Outer: UObject, ResourceName: string): DelegateProperty;
	static GetDefaultObject(): DelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject | any): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	static Load(ResourceName: string): DoubleProperty;
	static Find(Outer: UObject, ResourceName: string): DoubleProperty;
	static GetDefaultObject(): DoubleProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject | any): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	static Load(ResourceName: string): FloatProperty;
	static Find(Outer: UObject, ResourceName: string): FloatProperty;
	static GetDefaultObject(): FloatProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject | any): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	static Load(ResourceName: string): IntProperty;
	static Find(Outer: UObject, ResourceName: string): IntProperty;
	static GetDefaultObject(): IntProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject | any): IntProperty;
}

declare class Int8Property extends NumericProperty { 
	static Load(ResourceName: string): Int8Property;
	static Find(Outer: UObject, ResourceName: string): Int8Property;
	static GetDefaultObject(): Int8Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject | any): Int8Property;
}

declare class Int16Property extends NumericProperty { 
	static Load(ResourceName: string): Int16Property;
	static Find(Outer: UObject, ResourceName: string): Int16Property;
	static GetDefaultObject(): Int16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject | any): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	static Load(ResourceName: string): Int64Property;
	static Find(Outer: UObject, ResourceName: string): Int64Property;
	static GetDefaultObject(): Int64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject | any): Int64Property;
}

declare class InterfaceProperty extends Property { 
	static Load(ResourceName: string): InterfaceProperty;
	static Find(Outer: UObject, ResourceName: string): InterfaceProperty;
	static GetDefaultObject(): InterfaceProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject | any): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): LazyObjectProperty;
	static Find(Outer: UObject, ResourceName: string): LazyObjectProperty;
	static GetDefaultObject(): LazyObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject | any): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	static Load(ResourceName: string): MapProperty;
	static Find(Outer: UObject, ResourceName: string): MapProperty;
	static GetDefaultObject(): MapProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject | any): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	static Load(ResourceName: string): MulticastDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegateProperty;
	static GetDefaultObject(): MulticastDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject | any): MulticastDelegateProperty;
}

declare class MulticastInlineDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastInlineDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegateProperty;
	static GetDefaultObject(): MulticastInlineDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegateProperty;
	static C(Other: UObject | any): MulticastInlineDelegateProperty;
}

declare class MulticastSparseDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastSparseDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastSparseDelegateProperty;
	static GetDefaultObject(): MulticastSparseDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastSparseDelegateProperty;
	static C(Other: UObject | any): MulticastSparseDelegateProperty;
}

declare class NameProperty extends Property { 
	static Load(ResourceName: string): NameProperty;
	static Find(Outer: UObject, ResourceName: string): NameProperty;
	static GetDefaultObject(): NameProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject | any): NameProperty;
}

declare class SetProperty extends Property { 
	static Load(ResourceName: string): SetProperty;
	static Find(Outer: UObject, ResourceName: string): SetProperty;
	static GetDefaultObject(): SetProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SetProperty;
	static C(Other: UObject | any): SetProperty;
}

declare class SoftObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): SoftObjectProperty;
	static Find(Outer: UObject, ResourceName: string): SoftObjectProperty;
	static GetDefaultObject(): SoftObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftObjectProperty;
	static C(Other: UObject | any): SoftObjectProperty;
}

declare class SoftClassProperty extends SoftObjectProperty { 
	static Load(ResourceName: string): SoftClassProperty;
	static Find(Outer: UObject, ResourceName: string): SoftClassProperty;
	static GetDefaultObject(): SoftClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftClassProperty;
	static C(Other: UObject | any): SoftClassProperty;
}

declare class StrProperty extends Property { 
	static Load(ResourceName: string): StrProperty;
	static Find(Outer: UObject, ResourceName: string): StrProperty;
	static GetDefaultObject(): StrProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject | any): StrProperty;
}

declare class StructProperty extends Property { 
	static Load(ResourceName: string): StructProperty;
	static Find(Outer: UObject, ResourceName: string): StructProperty;
	static GetDefaultObject(): StructProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject | any): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	static Load(ResourceName: string): UInt16Property;
	static Find(Outer: UObject, ResourceName: string): UInt16Property;
	static GetDefaultObject(): UInt16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject | any): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	static Load(ResourceName: string): UInt32Property;
	static Find(Outer: UObject, ResourceName: string): UInt32Property;
	static GetDefaultObject(): UInt32Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject | any): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	static Load(ResourceName: string): UInt64Property;
	static Find(Outer: UObject, ResourceName: string): UInt64Property;
	static GetDefaultObject(): UInt64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject | any): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): WeakObjectProperty;
	static Find(Outer: UObject, ResourceName: string): WeakObjectProperty;
	static GetDefaultObject(): WeakObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject | any): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	static Load(ResourceName: string): TextProperty;
	static Find(Outer: UObject, ResourceName: string): TextProperty;
	static GetDefaultObject(): TextProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject | any): TextProperty;
}

declare class PropertyWrapper extends UObject { 
	static Load(ResourceName: string): PropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): PropertyWrapper;
	static GetDefaultObject(): PropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyWrapper;
	static C(Other: UObject | any): PropertyWrapper;
}

declare class MulticastDelegatePropertyWrapper extends PropertyWrapper { 
	static Load(ResourceName: string): MulticastDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastDelegatePropertyWrapper;
}

declare class MulticastInlineDelegatePropertyWrapper extends MulticastDelegatePropertyWrapper { 
	static Load(ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastInlineDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastInlineDelegatePropertyWrapper;
}

declare class InputCoreTypes extends UObject { 
	static Load(ResourceName: string): InputCoreTypes;
	static Find(Outer: UObject, ResourceName: string): InputCoreTypes;
	static GetDefaultObject(): InputCoreTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject | any): InputCoreTypes;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerBase;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject | any): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleAsset;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject | any): SlateWidgetStyleAsset;
}

declare class FontFaceInterface extends Interface { 
	static Load(ResourceName: string): FontFaceInterface;
	static Find(Outer: UObject, ResourceName: string): FontFaceInterface;
	static GetDefaultObject(): FontFaceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFaceInterface;
	static C(Other: UObject | any): FontFaceInterface;
}

declare class FontProviderInterface extends Interface { 
	static Load(ResourceName: string): FontProviderInterface;
	static Find(Outer: UObject, ResourceName: string): FontProviderInterface;
	static GetDefaultObject(): FontProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject | any): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	static Load(ResourceName: string): SlateTypes;
	static Find(Outer: UObject, ResourceName: string): SlateTypes;
	static GetDefaultObject(): SlateTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject | any): SlateTypes;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerInterface;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject | any): SlateWidgetStyleContainerInterface;
}

declare class StyleColorList { 
	StyleColors: LinearColor;
	clone() : StyleColorList;
	static C(Other: UObject | any): StyleColorList;
}

declare class SlateThemeManager extends UObject { 
	CurrentThemeId: Guid;
	ActiveColors: StyleColorList;
	static Load(ResourceName: string): SlateThemeManager;
	static Find(Outer: UObject, ResourceName: string): SlateThemeManager;
	static GetDefaultObject(): SlateThemeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateThemeManager;
	static C(Other: UObject | any): SlateThemeManager;
}

declare class ToolMenuBase extends UObject { 
	static Load(ResourceName: string): ToolMenuBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuBase;
	static GetDefaultObject(): ToolMenuBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuBase;
	static C(Other: UObject | any): ToolMenuBase;
}

declare class SlateSettings extends UObject { 
	bExplicitCanvasChildZOrder: boolean;
	static Load(ResourceName: string): SlateSettings;
	static Find(Outer: UObject, ResourceName: string): SlateSettings;
	static GetDefaultObject(): SlateSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateSettings;
	static C(Other: UObject | any): SlateSettings;
}

declare class SlateWidgetStyle { 
	clone() : SlateWidgetStyle;
	static C(Other: UObject | any): SlateWidgetStyle;
}

declare class SlateSound { 
	ResourceObject: UObject;
	clone() : SlateSound;
	static C(Other: UObject | any): SlateSound;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalForeground: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	DisabledForeground: SlateColor;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
	clone() : ButtonStyle;
	static C(Other: UObject | any): ButtonStyle;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ButtonWidgetStyle;
	static GetDefaultObject(): ButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject | any): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = 'CheckBox' | 'ToggleButton' | 'ESlateCheckBoxType_MAX';
declare var ESlateCheckBoxType : { CheckBox:'CheckBox',ToggleButton:'ToggleButton',ESlateCheckBoxType_MAX:'ESlateCheckBoxType_MAX', };
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	BackgroundImage: SlateBrush;
	BackgroundHoveredImage: SlateBrush;
	BackgroundPressedImage: SlateBrush;
	ForegroundColor: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	CheckedForeground: SlateColor;
	CheckedHoveredForeground: SlateColor;
	CheckedPressedForeground: SlateColor;
	UndeterminedForeground: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
	clone() : CheckBoxStyle;
	static C(Other: UObject | any): CheckBoxStyle;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): CheckBoxWidgetStyle;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject | any): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
	ContentPadding: Margin;
	DownArrowPadding: Margin;
	DownArrowAlign: EVerticalAlignment;
	clone() : ComboButtonStyle;
	static C(Other: UObject | any): ComboButtonStyle;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	ContentPadding: Margin;
	MenuRowPadding: Margin;
	PressedSound: string;
	SelectionChangeSound: string;
	clone() : ComboBoxStyle;
	static C(Other: UObject | any): ComboBoxStyle;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboBoxWidgetStyle;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject | any): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboButtonWidgetStyle;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject | any): ComboButtonWidgetStyle;
}

declare class FontOutlineSettings { 
	OutlineSize: number;
	bSeparateFillAlpha: boolean;
	bApplyOutlineToDropShadows: boolean;
	OutlineMaterial: UObject;
	OutlineColor: LinearColor;
	clone() : FontOutlineSettings;
	static C(Other: UObject | any): FontOutlineSettings;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	OutlineSettings: FontOutlineSettings;
	TypefaceFontName: string;
	Size: number;
	LetterSpacing: number;
	SkewAmount: number;
	FontName: string;
	Hinting: EFontHinting;
	clone() : SlateFontInfo;
	static C(Other: UObject | any): SlateFontInfo;
}

declare type ETextTransformPolicy = 'None' | 'ToLower' | 'ToUpper' | 'ETextTransformPolicy_MAX';
declare var ETextTransformPolicy : { None:'None',ToLower:'ToLower',ToUpper:'ToUpper',ETextTransformPolicy_MAX:'ETextTransformPolicy_MAX', };
declare type ETextOverflowPolicy = 'Clip' | 'Ellipsis' | 'ETextOverflowPolicy_MAX';
declare var ETextOverflowPolicy : { Clip:'Clip',Ellipsis:'Ellipsis',ETextOverflowPolicy_MAX:'ETextOverflowPolicy_MAX', };
declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: SlateColor;
	HighlightShape: SlateBrush;
	StrikeBrush: SlateBrush;
	UnderlineBrush: SlateBrush;
	TransformPolicy: ETextTransformPolicy;
	OverflowPolicy: ETextOverflowPolicy;
	clone() : TextBlockStyle;
	static C(Other: UObject | any): TextBlockStyle;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
	Thickness: number;
	clone() : ScrollBarStyle;
	static C(Other: UObject | any): ScrollBarStyle;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	TextStyle: TextBlockStyle;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	FocusedForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
	clone() : EditableTextBoxStyle;
	static C(Other: UObject | any): EditableTextBoxStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextBoxWidgetStyle;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject | any): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
	clone() : EditableTextStyle;
	static C(Other: UObject | any): EditableTextStyle;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextWidgetStyle;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject | any): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
	EnableFillAnimation: boolean;
	clone() : ProgressBarStyle;
	static C(Other: UObject | any): ProgressBarStyle;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	static Load(ResourceName: string): ProgressWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ProgressWidgetStyle;
	static GetDefaultObject(): ProgressWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject | any): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBarWidgetStyle;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject | any): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	BarThickness: number;
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
	clone() : ScrollBoxStyle;
	static C(Other: UObject | any): ScrollBoxStyle;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxWidgetStyle;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject | any): ScrollBoxWidgetStyle;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	ActiveBackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	HoveredFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
	InsetPadding: Margin;
	clone() : SpinBoxStyle;
	static C(Other: UObject | any): SpinBoxStyle;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): SpinBoxWidgetStyle;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject | any): SpinBoxWidgetStyle;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): TextBlockWidgetStyle;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject | any): TextBlockWidgetStyle;
}

declare class TypedElementHandleLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementHandleLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementHandleLibrary;
	static GetDefaultObject(): TypedElementHandleLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHandleLibrary;
	static Release(ElementHandle?: ScriptTypedElementHandle): {ElementHandle: ScriptTypedElementHandle};
	static NotEqual(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static IsSet(ElementHandle: ScriptTypedElementHandle): boolean;
	static Equal(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementHandleLibrary;
}

declare class ScriptTypedElementListProxy { 
	clone() : ScriptTypedElementListProxy;
	static C(Other: UObject | any): ScriptTypedElementListProxy;
}

declare class TypedElementRegistry extends UObject { 
	static Load(ResourceName: string): TypedElementRegistry;
	static Find(Outer: UObject, ResourceName: string): TypedElementRegistry;
	static GetDefaultObject(): TypedElementRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementRegistry;
	static GetInstance(): TypedElementRegistry;
	GetElementInterface(InElementHandle: ScriptTypedElementHandle,InBaseInterfaceType: UnrealEngineClass): UObject;
	static C(Other: UObject | any): TypedElementRegistry;
}

declare class TypedElementListLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementListLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementListLibrary;
	static GetDefaultObject(): TypedElementListLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementListLibrary;
	static Shrink(ElementList: ScriptTypedElementListProxy): void;
	static Reset(ElementList: ScriptTypedElementListProxy): void;
	static Reserve(ElementList: ScriptTypedElementListProxy,Size: number): void;
	static Remove(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Num(ElementList: ScriptTypedElementListProxy): number;
	static IsValidIndex(ElementList: ScriptTypedElementListProxy,Index: number): boolean;
	static HasElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): boolean;
	static HasElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): boolean;
	static GetElementInterface(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle,BaseInterfaceType: UnrealEngineClass): UObject;
	static GetElementHandles(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	static GetElementHandleAt(ElementList: ScriptTypedElementListProxy,Index: number): ScriptTypedElementHandle;
	static Empty(ElementList: ScriptTypedElementListProxy,Slack: number): void;
	static CreateScriptElementList(Registry: TypedElementRegistry): ScriptTypedElementListProxy;
	static CountElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): number;
	static CountElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): number;
	static Contains(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Clone(ElementList: ScriptTypedElementListProxy): ScriptTypedElementListProxy;
	static AppendList(ElementList: ScriptTypedElementListProxy,OtherElementList: ScriptTypedElementListProxy): void;
	static Append(ElementList: ScriptTypedElementListProxy,ElementHandles: ScriptTypedElementHandle[]): void;
	static Add(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementListLibrary;
}

declare class TypedElementCounterInterface extends Interface { 
	static Load(ResourceName: string): TypedElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementCounterInterface;
	static GetDefaultObject(): TypedElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCounterInterface;
	static C(Other: UObject | any): TypedElementCounterInterface;
}

declare class TestTypedElementInterfaceA extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceA;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA;
	static GetDefaultObject(): TestTypedElementInterfaceA;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA;
	SetDisplayName(InElementHandle: ScriptTypedElementHandle,InNewName: string,bNotify: boolean): boolean;
	GetDisplayName(InElementHandle: ScriptTypedElementHandle): string;
	static C(Other: UObject | any): TestTypedElementInterfaceA;
}

declare class TestTypedElementInterfaceB extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceB;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceB;
	static GetDefaultObject(): TestTypedElementInterfaceB;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceB;
	MarkAsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceB;
}

declare class TestTypedElementInterfaceC extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceC;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceC;
	static GetDefaultObject(): TestTypedElementInterfaceC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceC;
	GetIsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceC;
}

declare class TestTypedElementInterfaceA_ImplTyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplTyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplTyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplTyped;
}

declare class TestTypedElementInterfaceA_ImplUntyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplUntyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplUntyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplUntyped;
}

declare class TestTypedElementInterfaceBAndC_Typed extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static GetDefaultObject(): TestTypedElementInterfaceBAndC_Typed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceBAndC_Typed;
	static C(Other: UObject | any): TestTypedElementInterfaceBAndC_Typed;
}

declare type ETypedElementChildInclusionMethod = 'None' | 'Immediate' | 'Recursive' | 'ETypedElementChildInclusionMethod_MAX';
declare var ETypedElementChildInclusionMethod : { None:'None',Immediate:'Immediate',Recursive:'Recursive',ETypedElementChildInclusionMethod_MAX:'ETypedElementChildInclusionMethod_MAX', };
declare class TypedElementSelectionOptions { 
	bAllowHidden: boolean;
	bAllowGroups: boolean;
	bAllowLegacyNotifications: boolean;
	bWarnIfLocked: boolean;
	ChildElementInclusionMethod: ETypedElementChildInclusionMethod;
	clone() : TypedElementSelectionOptions;
	static C(Other: UObject | any): TypedElementSelectionOptions;
}

declare class TypedElementSelectionSetState { 
	CreatedFromSelectionSet: TypedElementSelectionSet;
	clone() : TypedElementSelectionSetState;
	static C(Other: UObject | any): TypedElementSelectionSetState;
}

declare class TypedElementIsSelectedOptions { 
	bAllowIndirect: boolean;
	clone() : TypedElementIsSelectedOptions;
	static C(Other: UObject | any): TypedElementIsSelectedOptions;
}

declare type ETypedElementSelectionMethod = 'Primary' | 'Secondary' | 'ETypedElementSelectionMethod_MAX';
declare var ETypedElementSelectionMethod : { Primary:'Primary',Secondary:'Secondary',ETypedElementSelectionMethod_MAX:'ETypedElementSelectionMethod_MAX', };
declare class TypedElementSelectionSet extends UObject { 
	OnPreSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	OnSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	static Load(ResourceName: string): TypedElementSelectionSet;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSet;
	static GetDefaultObject(): TypedElementSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSet;
	SetSelection(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	RestoreSelectionState(InSelectionState: TypedElementSelectionSetState): void;
	K2_GetSelectedElementHandles(InBaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	HasSelectedObjects(InRequiredClass: UnrealEngineClass): boolean;
	HasSelectedElements(InBaseInterfaceType: UnrealEngineClass): boolean;
	GetTopSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	GetSelectedObjects(InRequiredClass: UnrealEngineClass): UObject[];
	GetNumSelectedElements(): number;
	GetCurrentSelectionState(): TypedElementSelectionSetState;
	GetBottomSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	DeselectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CountSelectedObjects(InRequiredClass: UnrealEngineClass): number;
	CountSelectedElements(InBaseInterfaceType: UnrealEngineClass): number;
	ClearSelection(InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementSelectionSet;
}

declare class TypedElementSelectionNormalizationOptions { 
	bExpandGroups: boolean;
	bFollowAttachment: boolean;
	clone() : TypedElementSelectionNormalizationOptions;
	static C(Other: UObject | any): TypedElementSelectionNormalizationOptions;
}

declare class TypedElementSelectionSetLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementSelectionSetLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSetLibrary;
	static GetDefaultObject(): TypedElementSelectionSetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSetLibrary;
	static SetSelectionFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static SelectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static GetNormalizedSelection(SelectionSet: TypedElementSelectionSet,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static GetNormalizedElementList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static DeselectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static C(Other: UObject | any): TypedElementSelectionSetLibrary;
}

declare class TypedElementAssetDataInterface extends Interface { 
	static Load(ResourceName: string): TypedElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementAssetDataInterface;
	static GetDefaultObject(): TypedElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementAssetDataInterface;
	GetAssetData(InElementHandle: ScriptTypedElementHandle): AssetData;
	GetAllReferencedAssetDatas(InElementHandle: ScriptTypedElementHandle): AssetData[];
	static C(Other: UObject | any): TypedElementAssetDataInterface;
}

declare class TypedElementHierarchyInterface extends Interface { 
	static Load(ResourceName: string): TypedElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementHierarchyInterface;
	static GetDefaultObject(): TypedElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHierarchyInterface;
	GetParentElement(InElementHandle: ScriptTypedElementHandle,bAllowCreate: boolean): ScriptTypedElementHandle;
	GetChildElements(InElementHandle: ScriptTypedElementHandle,OutElementHandles?: ScriptTypedElementHandle[],bAllowCreate?: boolean): {OutElementHandles: ScriptTypedElementHandle[]};
	static C(Other: UObject | any): TypedElementHierarchyInterface;
}

declare class TypedElementObjectInterface extends Interface { 
	static Load(ResourceName: string): TypedElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementObjectInterface;
	static GetDefaultObject(): TypedElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementObjectInterface;
	GetObjectClass(InElementHandle: ScriptTypedElementHandle): UnrealEngineClass;
	GetObject(InElementHandle: ScriptTypedElementHandle): UObject;
	static C(Other: UObject | any): TypedElementObjectInterface;
}

declare class TypedElementSelectionInterface extends Interface { 
	static Load(ResourceName: string): TypedElementSelectionInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionInterface;
	static GetDefaultObject(): TypedElementSelectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionInterface;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InCurrentSelection: ScriptTypedElementListProxy,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy): boolean;
	static C(Other: UObject | any): TypedElementSelectionInterface;
}

declare type EMobileShadowQuality = 'NoFiltering' | 'PCF_1x1' | 'PCF_3x3' | 'PCF_5x5' | 'EMobileShadowQuality_MAX';
declare var EMobileShadowQuality : { NoFiltering:'NoFiltering',PCF_1x1:'PCF_1x1',PCF_3x3:'PCF_3x3',PCF_5x5:'PCF_5x5',EMobileShadowQuality_MAX:'EMobileShadowQuality_MAX', };
declare class MaterialQualityOverrides { 
	bDiscardQualityDuringCook: boolean;
	bEnableOverride: boolean;
	bForceFullyRough: boolean;
	bForceNonMetal: boolean;
	bForceDisableLMDirectionality: boolean;
	bForceDisablePreintegratedGF: boolean;
	bDisableMaterialNormalCalculation: boolean;
	MobileShadowQuality: EMobileShadowQuality;
	clone() : MaterialQualityOverrides;
	static C(Other: UObject | any): MaterialQualityOverrides;
}

declare class ShaderPlatformQualitySettings extends UObject { 
	QualityOverrides: MaterialQualityOverrides;
	static Load(ResourceName: string): ShaderPlatformQualitySettings;
	static Find(Outer: UObject, ResourceName: string): ShaderPlatformQualitySettings;
	static GetDefaultObject(): ShaderPlatformQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderPlatformQualitySettings;
	static C(Other: UObject | any): ShaderPlatformQualitySettings;
}

declare class MaterialShaderQualitySettings extends UObject { 
	ForwardSettingMap: Map<string, ShaderPlatformQualitySettings>;
	static Load(ResourceName: string): MaterialShaderQualitySettings;
	static Find(Outer: UObject, ResourceName: string): MaterialShaderQualitySettings;
	static GetDefaultObject(): MaterialShaderQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialShaderQualitySettings;
	static C(Other: UObject | any): MaterialShaderQualitySettings;
}

declare class DeveloperSettings extends UObject { 
	static Load(ResourceName: string): DeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettings;
	static GetDefaultObject(): DeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject | any): DeveloperSettings;
}

declare class DeveloperSettingsBackedByCVars extends DeveloperSettings { 
	static Load(ResourceName: string): DeveloperSettingsBackedByCVars;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettingsBackedByCVars;
	static GetDefaultObject(): DeveloperSettingsBackedByCVars;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettingsBackedByCVars;
	static C(Other: UObject | any): DeveloperSettingsBackedByCVars;
}

declare class PlatformSettings extends UObject { 
	static Load(ResourceName: string): PlatformSettings;
	static Find(Outer: UObject, ResourceName: string): PlatformSettings;
	static GetDefaultObject(): PlatformSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettings;
	static C(Other: UObject | any): PlatformSettings;
}

declare class PlatformSettingsInstances { 
	PlatformInstance: PlatformSettings;
	OtherPlatforms: Map<string, PlatformSettings>;
	clone() : PlatformSettingsInstances;
	static C(Other: UObject | any): PlatformSettingsInstances;
}

declare class PlatformSettingsManager extends UObject { 
	SettingsMap: Map<UnrealEngineClass, PlatformSettingsInstances>;
	static Load(ResourceName: string): PlatformSettingsManager;
	static Find(Outer: UObject, ResourceName: string): PlatformSettingsManager;
	static GetDefaultObject(): PlatformSettingsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettingsManager;
	static C(Other: UObject | any): PlatformSettingsManager;
}

declare type ECookProgressDisplayMode = 'Nothing' | 'RemainingPackages' | 'PackageNames' | 'NamesAndRemainingPackages' | 'Instigators' | 'InstigatorsAndCount' | 'InstigatorsAndNames' | 'InstigatorsAndNamesAndCount' | 'Max' | 'ECookProgressDisplayMode_MAX';
declare var ECookProgressDisplayMode : { Nothing:'Nothing',RemainingPackages:'RemainingPackages',PackageNames:'PackageNames',NamesAndRemainingPackages:'NamesAndRemainingPackages',Instigators:'Instigators',InstigatorsAndCount:'InstigatorsAndCount',InstigatorsAndNames:'InstigatorsAndNames',InstigatorsAndNamesAndCount:'InstigatorsAndNamesAndCount',Max:'Max',ECookProgressDisplayMode_MAX:'ECookProgressDisplayMode_MAX', };
declare type EBlueprintComponentDataCookingMethod = 'Disabled' | 'AllBlueprints' | 'EnabledBlueprintsOnly' | 'EBlueprintComponentDataCookingMethod_MAX';
declare var EBlueprintComponentDataCookingMethod : { Disabled:'Disabled',AllBlueprints:'AllBlueprints',EnabledBlueprintsOnly:'EnabledBlueprintsOnly',EBlueprintComponentDataCookingMethod_MAX:'EBlueprintComponentDataCookingMethod_MAX', };
declare type EBlueprintPropertyGuidsCookingMethod = 'Disabled' | 'AllBlueprints' | 'EnabledBlueprintsOnly' | 'EBlueprintPropertyGuidsCookingMethod_MAX';
declare var EBlueprintPropertyGuidsCookingMethod : { Disabled:'Disabled',AllBlueprints:'AllBlueprints',EnabledBlueprintsOnly:'EnabledBlueprintsOnly',EBlueprintPropertyGuidsCookingMethod_MAX:'EBlueprintPropertyGuidsCookingMethod_MAX', };
declare type ETextureFormatASTCCompressor = 'IntelISPC' | 'Arm' | 'Max' | 'ETextureFormatASTCCompressor_MAX';
declare var ETextureFormatASTCCompressor : { IntelISPC:'IntelISPC',Arm:'Arm',Max:'Max',ETextureFormatASTCCompressor_MAX:'ETextureFormatASTCCompressor_MAX', };
declare class CookerSettings extends DeveloperSettings { 
	bEnableCookOnTheSide: boolean;
	bEnableBuildDDCInBackground: boolean;
	bIterativeCookingForLaunchOn: boolean;
	bIterativeCookingForFileCookContent: boolean;
	bCookOnTheFlyForLaunchOn: boolean;
	CookProgressDisplayMode: ECookProgressDisplayMode;
	bIgnoreIniSettingsOutOfDateForIteration: boolean;
	bIgnoreScriptPackagesOutOfDateForIteration: boolean;
	bCompileBlueprintsInDevelopmentMode: boolean;
	BlueprintComponentDataCookingMethod: EBlueprintComponentDataCookingMethod;
	BlueprintPropertyGuidsCookingMethod: EBlueprintPropertyGuidsCookingMethod;
	ClassesExcludedOnDedicatedServer: string[];
	ModulesExcludedOnDedicatedServer: string[];
	ClassesExcludedOnDedicatedClient: string[];
	ModulesExcludedOnDedicatedClient: string[];
	VersionedIntRValues: string[];
	DefaultASTCQualityBySpeed: number;
	DefaultASTCQualityBySize: number;
	DefaultASTCCompressor: ETextureFormatASTCCompressor;
	bAllowASTCHDRProfile: boolean;
	bAllowCookedDataInEditorBuilds: boolean;
	bCookBlueprintComponentTemplateData: boolean;
	static Load(ResourceName: string): CookerSettings;
	static Find(Outer: UObject, ResourceName: string): CookerSettings;
	static GetDefaultObject(): CookerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerSettings;
	static C(Other: UObject | any): CookerSettings;
}

declare type EProjectPackagingBuild = 'Always' | 'Never' | 'IfProjectHasCode' | 'IfEditorWasBuiltLocally' | 'EProjectPackagingBuild_MAX';
declare var EProjectPackagingBuild : { Always:'Always',Never:'Never',IfProjectHasCode:'IfProjectHasCode',IfEditorWasBuiltLocally:'IfEditorWasBuiltLocally',EProjectPackagingBuild_MAX:'EProjectPackagingBuild_MAX', };
declare type EProjectPackagingBuildConfigurations = 'PPBC_Debug' | 'PPBC_DebugGame' | 'PPBC_Development' | 'PPBC_Test' | 'PPBC_Shipping' | 'PPBC_MAX';
declare var EProjectPackagingBuildConfigurations : { PPBC_Debug:'PPBC_Debug',PPBC_DebugGame:'PPBC_DebugGame',PPBC_Development:'PPBC_Development',PPBC_Test:'PPBC_Test',PPBC_Shipping:'PPBC_Shipping',PPBC_MAX:'PPBC_MAX', };
declare type EProjectPackagingBlueprintNativizationMethod = 'Disabled' | 'Inclusive' | 'Exclusive' | 'EProjectPackagingBlueprintNativizationMethod_MAX';
declare var EProjectPackagingBlueprintNativizationMethod : { Disabled:'Disabled',Inclusive:'Inclusive',Exclusive:'Exclusive',EProjectPackagingBlueprintNativizationMethod_MAX:'EProjectPackagingBlueprintNativizationMethod_MAX', };
declare type EAssetRegistryWritebackMethod = 'Disabled' | 'OriginalFile' | 'AdjacentFile' | 'EAssetRegistryWritebackMethod_MAX';
declare var EAssetRegistryWritebackMethod : { Disabled:'Disabled',OriginalFile:'OriginalFile',AdjacentFile:'AdjacentFile',EAssetRegistryWritebackMethod_MAX:'EAssetRegistryWritebackMethod_MAX', };
declare type EProjectPackagingInternationalizationPresets = 'English' | 'EFIGS' | 'EFIGSCJK' | 'CJK' | 'All' | 'EProjectPackagingInternationalizationPresets_MAX';
declare var EProjectPackagingInternationalizationPresets : { English:'English',EFIGS:'EFIGS',EFIGSCJK:'EFIGSCJK',CJK:'CJK',All:'All',EProjectPackagingInternationalizationPresets_MAX:'EProjectPackagingInternationalizationPresets_MAX', };
declare class ProjectBuildSettings { 
	Name: string;
	HelpText: string;
	SpecificPlatforms: string[];
	BuildCookRunParams: string;
	clone() : ProjectBuildSettings;
	static C(Other: UObject | any): ProjectBuildSettings;
}

declare class ProjectPackagingSettings extends UObject { 
	Build: EProjectPackagingBuild;
	BuildConfiguration: EProjectPackagingBuildConfigurations;
	BuildTarget: string;
	LaunchOnTarget: string;
	StagingDirectory: DirectoryPath;
	FullRebuild: boolean;
	ForDistribution: boolean;
	IncludeDebugFiles: boolean;
	BlueprintNativizationMethod: EProjectPackagingBlueprintNativizationMethod;
	NativizeBlueprintAssets: FilePath[];
	bIncludeNativizedAssetsInProjectGeneration: boolean;
	bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
	UsePakFile: boolean;
	bUseIoStore: boolean;
	bUseZenStore: boolean;
	bMakeBinaryConfig: boolean;
	bGenerateChunks: boolean;
	bGenerateNoChunks: boolean;
	bChunkHardReferencesOnly: boolean;
	bForceOneChunkPerFile: boolean;
	MaxChunkSize: number;
	bBuildHttpChunkInstallData: boolean;
	HttpChunkInstallDataDirectory: DirectoryPath;
	WriteBackMetadataToAssetRegistry: EAssetRegistryWritebackMethod;
	bCompressed: boolean;
	PackageCompressionFormat: string;
	bForceUseProjectCompressionFormatIgnoreHardwareOverride: boolean;
	PackageAdditionalCompressionOptions: string;
	PackageCompressionMethod: string;
	PackageCompressionLevel_DebugDevelopment: number;
	PackageCompressionLevel_TestShipping: number;
	PackageCompressionLevel_Distribution: number;
	PackageCompressionMinBytesSaved: number;
	PackageCompressionMinPercentSaved: number;
	bPackageCompressionEnableDDC: boolean;
	PackageCompressionMinSizeToConsiderDDC: number;
	HttpChunkInstallDataVersion: string;
	IncludePrerequisites: boolean;
	IncludeAppLocalPrerequisites: boolean;
	bShareMaterialShaderCode: boolean;
	bDeterministicShaderCodeOrder: boolean;
	bSharedMaterialNativeLibraries: boolean;
	ApplocalPrerequisitesDirectory: DirectoryPath;
	IncludeCrashReporter: boolean;
	InternationalizationPreset: EProjectPackagingInternationalizationPresets;
	CulturesToStage: string[];
	LocalizationTargetsToChunk: string[];
	LocalizationTargetCatchAllChunkId: number;
	bCookAll: boolean;
	bCookMapsOnly: boolean;
	bEncryptIniFiles: boolean;
	bEncryptPakIndex: boolean;
	GenerateEarlyDownloaderPakFile: boolean;
	bSkipEditorContent: boolean;
	bSkipMovies: boolean;
	UFSMovies: string[];
	NonUFSMovies: string[];
	CompressedChunkWildcard: string[];
	IniKeyBlacklist: string[];
	IniKeyDenylist: string[];
	IniSectionBlacklist: string[];
	IniSectionDenylist: string[];
	EarlyDownloaderPakFileFiles: string[];
	MapsToCook: FilePath[];
	DirectoriesToAlwaysCook: DirectoryPath[];
	DirectoriesToNeverCook: DirectoryPath[];
	TestDirectoriesToNotSearch: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFSServer: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFSServer: DirectoryPath[];
	ProjectCustomBuilds: ProjectBuildSettings[];
	EngineCustomBuilds: ProjectBuildSettings[];
	PerPlatformBuildConfig: Map<string, EProjectPackagingBuildConfigurations>;
	PerPlatformTargetFlavorName: Map<string, string>;
	PerPlatformBuildTarget: Map<string, string>;
	static Load(ResourceName: string): ProjectPackagingSettings;
	static Find(Outer: UObject, ResourceName: string): ProjectPackagingSettings;
	static GetDefaultObject(): ProjectPackagingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectPackagingSettings;
	static C(Other: UObject | any): ProjectPackagingSettings;
}

declare class ClothingAssetFactoryBase extends UObject { 
	static Load(ResourceName: string): ClothingAssetFactoryBase;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactoryBase;
	static GetDefaultObject(): ClothingAssetFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactoryBase;
	static C(Other: UObject | any): ClothingAssetFactoryBase;
}

declare class NetAnalyticsDataConfig { 
	DataName: string;
	bEnabled: boolean;
	clone() : NetAnalyticsDataConfig;
	static C(Other: UObject | any): NetAnalyticsDataConfig;
}

declare class NetAnalyticsAggregatorConfig extends UObject { 
	NetAnalyticsData: NetAnalyticsDataConfig[];
	static Load(ResourceName: string): NetAnalyticsAggregatorConfig;
	static Find(Outer: UObject, ResourceName: string): NetAnalyticsAggregatorConfig;
	static GetDefaultObject(): NetAnalyticsAggregatorConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetAnalyticsAggregatorConfig;
	static C(Other: UObject | any): NetAnalyticsAggregatorConfig;
}

declare class StatePerObjectConfig extends UObject { 
	PerObjectConfigSection: string;
	bEnabled: boolean;
	static Load(ResourceName: string): StatePerObjectConfig;
	static Find(Outer: UObject, ResourceName: string): StatePerObjectConfig;
	static GetDefaultObject(): StatePerObjectConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatePerObjectConfig;
	static C(Other: UObject | any): StatePerObjectConfig;
}

declare class EscalationManagerConfig extends StatePerObjectConfig { 
	EscalationSeverity: string[];
	static Load(ResourceName: string): EscalationManagerConfig;
	static Find(Outer: UObject, ResourceName: string): EscalationManagerConfig;
	static GetDefaultObject(): EscalationManagerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EscalationManagerConfig;
	static C(Other: UObject | any): EscalationManagerConfig;
}

declare class JsonUtilitiesDummyObject extends UObject { 
	static Load(ResourceName: string): JsonUtilitiesDummyObject;
	static Find(Outer: UObject, ResourceName: string): JsonUtilitiesDummyObject;
	static GetDefaultObject(): JsonUtilitiesDummyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonUtilitiesDummyObject;
	static C(Other: UObject | any): JsonUtilitiesDummyObject;
}

declare class ARFilter { 
	PackageNames: string[];
	PackagePaths: string[];
	ObjectPaths: string[];
	SoftObjectPaths: SoftObjectPath[];
	ClassNames: string[];
	ClassPaths: TopLevelAssetPath[];
	RecursiveClassesExclusionSet: Set<string>;
	RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>;
	bRecursivePaths: boolean;
	bRecursiveClasses: boolean;
	bIncludeOnlyOnDiskAssets: boolean;
	clone() : ARFilter;
	static C(Other: UObject | any): ARFilter;
	BreakARFilter(PackageNames?: string[],PackagePaths?: string[],SoftObjectPaths?: SoftObjectPath[],ClassPaths?: TopLevelAssetPath[],RecursiveClassPathsExclusionSet?: Set<TopLevelAssetPath>,ClassNames?: string[],RecursiveClassesExclusionSet?: Set<string>,bRecursivePaths?: boolean,bRecursiveClasses?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {PackageNames: string[], PackagePaths: string[], SoftObjectPaths: SoftObjectPath[], ClassPaths: TopLevelAssetPath[], RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>, ClassNames: string[], RecursiveClassesExclusionSet: Set<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean};
	static BreakARFilter(InARFilter: ARFilter,PackageNames?: string[],PackagePaths?: string[],SoftObjectPaths?: SoftObjectPath[],ClassPaths?: TopLevelAssetPath[],RecursiveClassPathsExclusionSet?: Set<TopLevelAssetPath>,ClassNames?: string[],RecursiveClassesExclusionSet?: Set<string>,bRecursivePaths?: boolean,bRecursiveClasses?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {PackageNames: string[], PackagePaths: string[], SoftObjectPaths: SoftObjectPath[], ClassPaths: TopLevelAssetPath[], RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>, ClassNames: string[], RecursiveClassesExclusionSet: Set<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean};
	static MakeARFilter(PackageNames: string[],PackagePaths: string[],SoftObjectPaths: SoftObjectPath[],ClassPaths: TopLevelAssetPath[],RecursiveClassPathsExclusionSet: Set<TopLevelAssetPath>,ClassNames: string[],RecursiveClassesExclusionSet: Set<string>,bRecursivePaths: boolean,bRecursiveClasses: boolean,bIncludeOnlyOnDiskAssets: boolean): ARFilter;
}

declare class TagAndValue { 
	Tag: string;
	Value: string;
	clone() : TagAndValue;
	static C(Other: UObject | any): TagAndValue;
}

declare class AssetRegistryHelpers extends UObject { 
	static Load(ResourceName: string): AssetRegistryHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryHelpers;
	static GetDefaultObject(): AssetRegistryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryHelpers;
	static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
	static SetFilterTagsAndValues(InFilter: ARFilter,InTagsAndValues: TagAndValue[]): ARFilter;
	static IsValid(InAssetData: AssetData): boolean;
	static IsUAsset(InAssetData: AssetData): boolean;
	static IsRedirector(InAssetData: AssetData): boolean;
	static IsAssetLoaded(InAssetData: AssetData): boolean;
	static GetTagValue(InAssetData: AssetData,InTagName: string,OutTagValue?: string): {OutTagValue: string, $: boolean};
	static GetFullName(InAssetData: AssetData): string;
	static GetExportTextName(InAssetData: AssetData): string;
	static GetClass(InAssetData: AssetData): UnrealEngineClass;
	static GetBlueprintAssets(InFilter: ARFilter,OutAssetData?: AssetData[]): {OutAssetData: AssetData[]};
	static GetAsset(InAssetData: AssetData): UObject;
	static CreateAssetData(InAsset: UObject,bAllowBlueprintClass: boolean): AssetData;
	static C(Other: UObject | any): AssetRegistryHelpers;
}

declare class AssetRegistryDependencyOptions { 
	bIncludeSoftPackageReferences: boolean;
	bIncludeHardPackageReferences: boolean;
	bIncludeSearchableNames: boolean;
	bIncludeSoftManagementReferences: boolean;
	bIncludeHardManagementReferences: boolean;
	clone() : AssetRegistryDependencyOptions;
	static C(Other: UObject | any): AssetRegistryDependencyOptions;
}

declare class AssetRegistry extends Interface { 
	static Load(ResourceName: string): AssetRegistry;
	static Find(Outer: UObject, ResourceName: string): AssetRegistry;
	static GetDefaultObject(): AssetRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistry;
	WaitForPackage(PackageName: string): void;
	WaitForCompletion(): void;
	UseFilterToExcludeAssets(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	SearchAllAssets(bSynchronousSearch: boolean): void;
	ScanPathsSynchronous(InPaths: string[],bForceRescan: boolean,bIgnoreDenyListScanFilters: boolean): void;
	ScanModifiedAssetFiles(InFilePaths: string[]): void;
	ScanFilesSynchronous(InFilePaths: string[],bForceRescan: boolean): void;
	RunAssetsThroughFilter(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	PrioritizeSearchPath(PathToPrioritize: string): void;
	K2_GetReferencers(PackageName: string,ReferenceOptions: AssetRegistryDependencyOptions,OutReferencers?: string[]): {OutReferencers: string[], $: boolean};
	K2_GetDependencies(PackageName: string,DependencyOptions: AssetRegistryDependencyOptions,OutDependencies?: string[]): {OutDependencies: string[], $: boolean};
	K2_GetAssetByObjectPath(ObjectPath: SoftObjectPath,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	IsSearchAsync(): boolean;
	IsSearchAllAssets(): boolean;
	IsLoadingAssets(): boolean;
	HasAssets(PackagePath: string,bRecursive: boolean): boolean;
	GetSubPaths(InBasePath: string,OutPathList?: string[],bInRecurse?: boolean): {OutPathList: string[]};
	GetDerivedClassNames(ClassNames: TopLevelAssetPath[],ExcludedClassNames: Set<TopLevelAssetPath>,OutDerivedClassNames?: Set<TopLevelAssetPath>): {OutDerivedClassNames: Set<TopLevelAssetPath>};
	GetAssetsByPaths(PackagePaths: string[],OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPath(PackagePath: string,OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPackageName(PackageName: string,OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean,bSkipARFilteredAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByClass(ClassPathName: TopLevelAssetPath,OutAssetData?: AssetData[],bSearchSubClasses?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssets(Filter: ARFilter,OutAssetData?: AssetData[],bSkipARFilteredAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetByObjectPath(ObjectPath: string,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	GetAncestorClassNames(ClassPathName: TopLevelAssetPath,OutAncestorClassNames?: TopLevelAssetPath[]): {OutAncestorClassNames: TopLevelAssetPath[], $: boolean};
	GetAllCachedPaths(OutPathList?: string[]): {OutPathList: string[]};
	GetAllAssets(OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	static C(Other: UObject | any): AssetRegistry;
}

declare class AssetRegistryImpl extends UObject { 
	static Load(ResourceName: string): AssetRegistryImpl;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryImpl;
	static GetDefaultObject(): AssetRegistryImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryImpl;
	static C(Other: UObject | any): AssetRegistryImpl;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
	clone() : AutoCompleteCommand;
	static C(Other: UObject | any): AutoCompleteCommand;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	BackgroundOpacityPercentage: number;
	bOrderTopToBottom: boolean;
	bDisplayHelpInAutoComplete: boolean;
	InputColor: Color;
	HistoryColor: Color;
	AutoCompleteCommandColor: Color;
	AutoCompleteCVarColor: Color;
	AutoCompleteFadedColor: Color;
	static Load(ResourceName: string): ConsoleSettings;
	static Find(Outer: UObject, ResourceName: string): ConsoleSettings;
	static GetDefaultObject(): ConsoleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject | any): ConsoleSettings;
}

declare class TemplateMapInfoOverride { 
	Thumbnail: SoftObjectPath;
	Map: SoftObjectPath;
	DisplayName: string;
	clone() : TemplateMapInfoOverride;
	static C(Other: UObject | any): TemplateMapInfoOverride;
}

declare type ETwoPlayerSplitScreenType = 'Horizontal' | 'Vertical' | 'ETwoPlayerSplitScreenType_MAX';
declare var ETwoPlayerSplitScreenType : { Horizontal:'Horizontal',Vertical:'Vertical',ETwoPlayerSplitScreenType_MAX:'ETwoPlayerSplitScreenType_MAX', };
declare type EThreePlayerSplitScreenType = 'FavorTop' | 'FavorBottom' | 'Vertical' | 'Horizontal' | 'EThreePlayerSplitScreenType_MAX';
declare var EThreePlayerSplitScreenType : { FavorTop:'FavorTop',FavorBottom:'FavorBottom',Vertical:'Vertical',Horizontal:'Horizontal',EThreePlayerSplitScreenType_MAX:'EThreePlayerSplitScreenType_MAX', };
declare type EFourPlayerSplitScreenType = 'Grid' | 'Vertical' | 'Horizontal' | 'EFourPlayerSplitScreenType_MAX';
declare var EFourPlayerSplitScreenType : { Grid:'Grid',Vertical:'Vertical',Horizontal:'Horizontal',EFourPlayerSplitScreenType_MAX:'EFourPlayerSplitScreenType_MAX', };
declare class GameModeName { 
	Name: string;
	GameMode: SoftClassPath;
	clone() : GameModeName;
	static C(Other: UObject | any): GameModeName;
}

declare class GameMapsSettings extends UObject { 
	EditorStartupMap: SoftObjectPath;
	EditorTemplateMapOverrides: TemplateMapInfoOverride[];
	LocalMapOptions: string;
	TransitionMap: SoftObjectPath;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
	bOffsetPlayerGamepadIds: boolean;
	GameInstanceClass: SoftClassPath;
	GameDefaultMap: SoftObjectPath;
	ServerDefaultMap: SoftObjectPath;
	GlobalDefaultGameMode: SoftClassPath;
	GlobalDefaultServerGameMode: SoftClassPath;
	GameModeMapPrefixes: GameModeName[];
	GameModeClassAliases: GameModeName[];
	static Load(ResourceName: string): GameMapsSettings;
	static Find(Outer: UObject, ResourceName: string): GameMapsSettings;
	static GetDefaultObject(): GameMapsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer: boolean): void;
	GetSkipAssigningGamepadToPlayer1(): boolean;
	static GetGameMapsSettings(): GameMapsSettings;
	static C(Other: UObject | any): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static Find(Outer: UObject, ResourceName: string): GameNetworkManagerSettings;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject | any): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	static Load(ResourceName: string): GameSessionSettings;
	static Find(Outer: UObject, ResourceName: string): GameSessionSettings;
	static GetDefaultObject(): GameSessionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject | any): GameSessionSettings;
}

declare class GeneralEngineSettings extends UObject { 
	static Load(ResourceName: string): GeneralEngineSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralEngineSettings;
	static GetDefaultObject(): GeneralEngineSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject | any): GeneralEngineSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	ProjectDebugTitleInfo: string;
	bShouldWindowPreserveAspectRatio: boolean;
	bUseBorderlessWindow: boolean;
	bStartInVR: boolean;
	bAllowWindowResize: boolean;
	bAllowClose: boolean;
	bAllowMaximize: boolean;
	bAllowMinimize: boolean;
	EyeOffsetForFakeStereoRenderingDevice: number;
	FOVForFakeStereoRenderingDevice: number;
	static Load(ResourceName: string): GeneralProjectSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralProjectSettings;
	static GetDefaultObject(): GeneralProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject | any): GeneralProjectSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	static Load(ResourceName: string): HudSettings;
	static Find(Outer: UObject, ResourceName: string): HudSettings;
	static GetDefaultObject(): HudSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject | any): HudSettings;
}

declare class HandlerComponentFactory extends UObject { 
	static Load(ResourceName: string): HandlerComponentFactory;
	static Find(Outer: UObject, ResourceName: string): HandlerComponentFactory;
	static GetDefaultObject(): HandlerComponentFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandlerComponentFactory;
	static C(Other: UObject | any): HandlerComponentFactory;
}

declare class PacketHandlerProfileConfig extends UObject { 
	Components: string[];
	static Load(ResourceName: string): PacketHandlerProfileConfig;
	static Find(Outer: UObject, ResourceName: string): PacketHandlerProfileConfig;
	static GetDefaultObject(): PacketHandlerProfileConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PacketHandlerProfileConfig;
	static C(Other: UObject | any): PacketHandlerProfileConfig;
}

declare class ChaosPhysicalMaterial extends UObject { 
	Friction: number;
	StaticFriction: number;
	Restitution: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	SleepingLinearVelocityThreshold: number;
	SleepingAngularVelocityThreshold: number;
	static Load(ResourceName: string): ChaosPhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): ChaosPhysicalMaterial;
	static GetDefaultObject(): ChaosPhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosPhysicalMaterial;
	static C(Other: UObject | any): ChaosPhysicalMaterial;
}

declare type EClusterUnionMethod = 'PointImplicit' | 'DelaunayTriangulation' | 'MinimalSpanningSubsetDelaunayTriangulation' | 'PointImplicitAugmentedWithMinimalDelaunay' | 'BoundsOverlapFilteredDelaunayTriangulation' | 'None' | 'EClusterUnionMethod_MAX';
declare var EClusterUnionMethod : { PointImplicit:'PointImplicit',DelaunayTriangulation:'DelaunayTriangulation',MinimalSpanningSubsetDelaunayTriangulation:'MinimalSpanningSubsetDelaunayTriangulation',PointImplicitAugmentedWithMinimalDelaunay:'PointImplicitAugmentedWithMinimalDelaunay',BoundsOverlapFilteredDelaunayTriangulation:'BoundsOverlapFilteredDelaunayTriangulation',None:'None',EClusterUnionMethod_MAX:'EClusterUnionMethod_MAX', };
declare class SolverCollisionFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	clone() : SolverCollisionFilterSettings;
	static C(Other: UObject | any): SolverCollisionFilterSettings;
}

declare class SolverBreakingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverBreakingFilterSettings;
	static C(Other: UObject | any): SolverBreakingFilterSettings;
}

declare class SolverTrailingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverTrailingFilterSettings;
	static C(Other: UObject | any): SolverTrailingFilterSettings;
}

declare class ChaosSolverConfiguration { 
	PositionIterations: number;
	VelocityIterations: number;
	ProjectionIterations: number;
	CollisionMarginFraction: number;
	CollisionMarginMax: number;
	CollisionCullDistance: number;
	CollisionMaxPushOutVelocity: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterUnionMethod;
	bGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	bGenerateBreakData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	bGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	Iterations: number;
	PushOutIterations: number;
	bGenerateContactGraph: boolean;
	clone() : ChaosSolverConfiguration;
	static C(Other: UObject | any): ChaosSolverConfiguration;
}

declare class PhysicsSettingsCore extends DeveloperSettings { 
	DefaultGravityZ: number;
	DefaultTerminalVelocity: number;
	DefaultFluidFriction: number;
	SimulateScratchMemorySize: number;
	RagdollAggregateThreshold: number;
	TriangleMeshTriangleMinAreaThreshold: number;
	bEnableShapeSharing: boolean;
	bEnablePCM: boolean;
	bEnableStabilization: boolean;
	bWarnMissingLocks: boolean;
	bEnable2DPhysics: boolean;
	bDefaultHasComplexCollision: boolean;
	BounceThresholdVelocity: number;
	FrictionCombineMode: EFrictionCombineMode;
	RestitutionCombineMode: EFrictionCombineMode;
	MaxAngularVelocity: number;
	MaxDepenetrationVelocity: number;
	ContactOffsetMultiplier: number;
	MinContactOffset: number;
	MaxContactOffset: number;
	bSimulateSkeletalMeshOnDedicatedServer: boolean;
	DefaultShapeComplexity: ECollisionTraceFlag;
	SolverOptions: ChaosSolverConfiguration;
	static Load(ResourceName: string): PhysicsSettingsCore;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettingsCore;
	static GetDefaultObject(): PhysicsSettingsCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettingsCore;
	static C(Other: UObject | any): PhysicsSettingsCore;
}

declare class AudioParameterControllerInterface extends Interface { 
	static Load(ResourceName: string): AudioParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): AudioParameterControllerInterface;
	static GetDefaultObject(): AudioParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterControllerInterface;
	SetTriggerParameter(InName: string): void;
	SetStringParameter(InName: string,InValue: string): void;
	SetStringArrayParameter(InName: string,InValue: string[]): void;
	SetParameters_Blueprint(InParameters: AudioParameter[]): void;
	SetObjectParameter(InName: string,InValue: UObject): void;
	SetObjectArrayParameter(InName: string,InValue: UObject[]): void;
	SetIntParameter(InName: string,inInt: number): void;
	SetIntArrayParameter(InName: string,InValue: number[]): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetFloatArrayParameter(InName: string,InValue: number[]): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	SetBoolArrayParameter(InName: string,InValue: boolean[]): void;
	ResetParameters(): void;
	static C(Other: UObject | any): AudioParameterControllerInterface;
}

declare class AudioCodecEncoderSettings extends UObject { 
	Version: number;
	static Load(ResourceName: string): AudioCodecEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioCodecEncoderSettings;
	static GetDefaultObject(): AudioCodecEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioCodecEncoderSettings;
	static C(Other: UObject | any): AudioCodecEncoderSettings;
}

declare class AudioEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): AudioEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): AudioEndpointSettingsBase;
	static GetDefaultObject(): AudioEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEndpointSettingsBase;
	static C(Other: UObject | any): AudioEndpointSettingsBase;
}

declare class DummyEndpointSettings extends AudioEndpointSettingsBase { 
	static Load(ResourceName: string): DummyEndpointSettings;
	static Find(Outer: UObject, ResourceName: string): DummyEndpointSettings;
	static GetDefaultObject(): DummyEndpointSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DummyEndpointSettings;
	static C(Other: UObject | any): DummyEndpointSettings;
}

declare class SoundfieldEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSettingsBase;
	static GetDefaultObject(): SoundfieldEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSettingsBase;
	static C(Other: UObject | any): SoundfieldEndpointSettingsBase;
}

declare class SoundfieldEffectSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEffectSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectSettingsBase;
	static GetDefaultObject(): SoundfieldEffectSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectSettingsBase;
	static C(Other: UObject | any): SoundfieldEffectSettingsBase;
}

declare class SoundfieldEffectBase extends UObject { 
	Settings: SoundfieldEffectSettingsBase;
	static Load(ResourceName: string): SoundfieldEffectBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectBase;
	static GetDefaultObject(): SoundfieldEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectBase;
	static C(Other: UObject | any): SoundfieldEffectBase;
}

declare class WaveformTransformationChain extends UObject { 
	Transformations: WaveformTransformationBase[];
	static Load(ResourceName: string): WaveformTransformationChain;
	static Find(Outer: UObject, ResourceName: string): WaveformTransformationChain;
	static GetDefaultObject(): WaveformTransformationChain;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveformTransformationChain;
	static C(Other: UObject | any): WaveformTransformationChain;
}

declare type EPcmBitDepthConversion = 'SameAsSource' | 'Int16' | 'Float32' | 'EPcmBitDepthConversion_MAX';
declare var EPcmBitDepthConversion : { SameAsSource:'SameAsSource',Int16:'Int16',Float32:'Float32',EPcmBitDepthConversion_MAX:'EPcmBitDepthConversion_MAX', };
declare class AudioPcmEncoderSettings extends AudioCodecEncoderSettings { 
	BitDepthConversion: EPcmBitDepthConversion;
	static Load(ResourceName: string): AudioPcmEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioPcmEncoderSettings;
	static GetDefaultObject(): AudioPcmEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioPcmEncoderSettings;
	static C(Other: UObject | any): AudioPcmEncoderSettings;
}

declare class ClothConfigBase extends UObject { 
	static Load(ResourceName: string): ClothConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothConfigBase;
	static GetDefaultObject(): ClothConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigBase;
	static C(Other: UObject | any): ClothConfigBase;
}

declare class ClothSharedSimConfigBase extends UObject { 
	static Load(ResourceName: string): ClothSharedSimConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothSharedSimConfigBase;
	static GetDefaultObject(): ClothSharedSimConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedSimConfigBase;
	static C(Other: UObject | any): ClothSharedSimConfigBase;
}

declare class ClothVertBoneData { 
	NumInfluences: number;
	BoneIndices: number;
	BoneWeights: number;
	clone() : ClothVertBoneData;
	static C(Other: UObject | any): ClothVertBoneData;
}

declare class ClothPhysicalMeshDataBase_Legacy extends UObject { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: number[];
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	NumFixedVerts: number;
	MaxBoneWeights: number;
	SelfCollisionIndices: number[];
	static Load(ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static GetDefaultObject(): ClothPhysicalMeshDataBase_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothPhysicalMeshDataBase_Legacy;
	static C(Other: UObject | any): ClothPhysicalMeshDataBase_Legacy;
}

declare class DataStream extends UObject { 
	static Load(ResourceName: string): DataStream;
	static Find(Outer: UObject, ResourceName: string): DataStream;
	static GetDefaultObject(): DataStream;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataStream;
	static C(Other: UObject | any): DataStream;
}

declare class IrisObjectReferencePackageMap extends UObject { 
	static Load(ResourceName: string): IrisObjectReferencePackageMap;
	static Find(Outer: UObject, ResourceName: string): IrisObjectReferencePackageMap;
	static GetDefaultObject(): IrisObjectReferencePackageMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IrisObjectReferencePackageMap;
	static C(Other: UObject | any): IrisObjectReferencePackageMap;
}

declare class NetBlobHandler extends UObject { 
	static Load(ResourceName: string): NetBlobHandler;
	static Find(Outer: UObject, ResourceName: string): NetBlobHandler;
	static GetDefaultObject(): NetBlobHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetBlobHandler;
	static C(Other: UObject | any): NetBlobHandler;
}

declare class NetObjectPrioritizerConfig extends UObject { 
	static Load(ResourceName: string): NetObjectPrioritizerConfig;
	static Find(Outer: UObject, ResourceName: string): NetObjectPrioritizerConfig;
	static GetDefaultObject(): NetObjectPrioritizerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetObjectPrioritizerConfig;
	static C(Other: UObject | any): NetObjectPrioritizerConfig;
}

declare class NetObjectCountLimiterConfig extends NetObjectPrioritizerConfig { 
	static Load(ResourceName: string): NetObjectCountLimiterConfig;
	static Find(Outer: UObject, ResourceName: string): NetObjectCountLimiterConfig;
	static GetDefaultObject(): NetObjectCountLimiterConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetObjectCountLimiterConfig;
	static C(Other: UObject | any): NetObjectCountLimiterConfig;
}

declare class NetObjectFilterConfig extends UObject { 
	static Load(ResourceName: string): NetObjectFilterConfig;
	static Find(Outer: UObject, ResourceName: string): NetObjectFilterConfig;
	static GetDefaultObject(): NetObjectFilterConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetObjectFilterConfig;
	static C(Other: UObject | any): NetObjectFilterConfig;
}

declare class NetObjectFilter extends UObject { 
	static Load(ResourceName: string): NetObjectFilter;
	static Find(Outer: UObject, ResourceName: string): NetObjectFilter;
	static GetDefaultObject(): NetObjectFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetObjectFilter;
	static C(Other: UObject | any): NetObjectFilter;
}

declare class NetObjectPrioritizer extends UObject { 
	static Load(ResourceName: string): NetObjectPrioritizer;
	static Find(Outer: UObject, ResourceName: string): NetObjectPrioritizer;
	static GetDefaultObject(): NetObjectPrioritizer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetObjectPrioritizer;
	static C(Other: UObject | any): NetObjectPrioritizer;
}

declare class ReplicationBridge extends UObject { 
	static Load(ResourceName: string): ReplicationBridge;
	static Find(Outer: UObject, ResourceName: string): ReplicationBridge;
	static GetDefaultObject(): ReplicationBridge;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplicationBridge;
	static C(Other: UObject | any): ReplicationBridge;
}

declare class ObjectReplicationBridge extends ReplicationBridge { 
	static Load(ResourceName: string): ObjectReplicationBridge;
	static Find(Outer: UObject, ResourceName: string): ObjectReplicationBridge;
	static GetDefaultObject(): ObjectReplicationBridge;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectReplicationBridge;
	static C(Other: UObject | any): ObjectReplicationBridge;
}

declare class SequentialPartialNetBlobHandlerConfig extends UObject { 
	static Load(ResourceName: string): SequentialPartialNetBlobHandlerConfig;
	static Find(Outer: UObject, ResourceName: string): SequentialPartialNetBlobHandlerConfig;
	static GetDefaultObject(): SequentialPartialNetBlobHandlerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequentialPartialNetBlobHandlerConfig;
	static C(Other: UObject | any): SequentialPartialNetBlobHandlerConfig;
}

declare class SequentialPartialNetBlobHandler extends NetBlobHandler { 
	static Load(ResourceName: string): SequentialPartialNetBlobHandler;
	static Find(Outer: UObject, ResourceName: string): SequentialPartialNetBlobHandler;
	static GetDefaultObject(): SequentialPartialNetBlobHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequentialPartialNetBlobHandler;
	static C(Other: UObject | any): SequentialPartialNetBlobHandler;
}

declare class SphereWithOwnerBoostNetObjectPrioritizerConfig extends NetObjectPrioritizerConfig { 
	static Load(ResourceName: string): SphereWithOwnerBoostNetObjectPrioritizerConfig;
	static Find(Outer: UObject, ResourceName: string): SphereWithOwnerBoostNetObjectPrioritizerConfig;
	static GetDefaultObject(): SphereWithOwnerBoostNetObjectPrioritizerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereWithOwnerBoostNetObjectPrioritizerConfig;
	static C(Other: UObject | any): SphereWithOwnerBoostNetObjectPrioritizerConfig;
}

declare type EMultiBoxType = 'MenuBar' | 'ToolBar' | 'VerticalToolBar' | 'SlimHorizontalToolBar' | 'UniformToolBar' | 'Menu' | 'ButtonRow' | 'EMultiBoxType_MAX';
declare var EMultiBoxType : { MenuBar:'MenuBar',ToolBar:'ToolBar',VerticalToolBar:'VerticalToolBar',SlimHorizontalToolBar:'SlimHorizontalToolBar',UniformToolBar:'UniformToolBar',Menu:'Menu',ButtonRow:'ButtonRow',EMultiBoxType_MAX:'EMultiBoxType_MAX', };
declare class ToolMenuOwner { 
	clone() : ToolMenuOwner;
	static C(Other: UObject | any): ToolMenuOwner;
}

declare class ToolMenuContext { 
	ContextObjects: UObject[];
	clone() : ToolMenuContext;
	static C(Other: UObject | any): ToolMenuContext;
}

declare type EMultiBlockType = 'None' | 'ButtonRow' | 'EditableText' | 'Heading' | 'MenuEntry' | 'Separator' | 'ToolBarButton' | 'ToolBarComboButton' | 'Widget' | 'EMultiBlockType_MAX';
declare var EMultiBlockType : { None:'None',ButtonRow:'ButtonRow',EditableText:'EditableText',Heading:'Heading',MenuEntry:'MenuEntry',Separator:'Separator',ToolBarButton:'ToolBarButton',ToolBarComboButton:'ToolBarComboButton',Widget:'Widget',EMultiBlockType_MAX:'EMultiBlockType_MAX', };
declare type EUserInterfaceActionType = 'None' | 'Button' | 'ToggleButton' | 'RadioButton' | 'Check' | 'CollapsedButton' | 'EUserInterfaceActionType_MAX';
declare var EUserInterfaceActionType : { None:'None',Button:'Button',ToggleButton:'ToggleButton',RadioButton:'RadioButton',Check:'Check',CollapsedButton:'CollapsedButton',EUserInterfaceActionType_MAX:'EUserInterfaceActionType_MAX', };
declare type EToolMenuInsertType = 'Default' | 'Before' | 'After' | 'First' | 'EToolMenuInsertType_MAX';
declare var EToolMenuInsertType : { Default:'Default',Before:'Before',After:'After',First:'First',EToolMenuInsertType_MAX:'EToolMenuInsertType_MAX', };
declare class ToolMenuInsert { 
	Name: string;
	Position: EToolMenuInsertType;
	clone() : ToolMenuInsert;
	static C(Other: UObject | any): ToolMenuInsert;
}

declare class ScriptSlateIcon { 
	StyleSetName: string;
	StyleName: string;
	SmallStyleName: string;
	clone() : ScriptSlateIcon;
	static C(Other: UObject | any): ScriptSlateIcon;
}

declare class ToolMenuEntryScriptDataAdvanced { 
	TutorialHighlight: string;
	EntryType: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	StyleNameOverride: string;
	bIsSubMenu: boolean;
	bOpenSubMenuOnClick: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bSimpleComboBox: boolean;
	clone() : ToolMenuEntryScriptDataAdvanced;
	static C(Other: UObject | any): ToolMenuEntryScriptDataAdvanced;
}

declare class ToolMenuEntryScriptData { 
	Menu: string;
	Section: string;
	Name: string;
	Label: string;
	Tooltip: string;
	Icon: ScriptSlateIcon;
	OwnerName: string;
	InsertPosition: ToolMenuInsert;
	Advanced: ToolMenuEntryScriptDataAdvanced;
	clone() : ToolMenuEntryScriptData;
	static C(Other: UObject | any): ToolMenuEntryScriptData;
}

declare type ECheckBoxState = 'Unchecked' | 'Checked' | 'Undetermined' | 'ECheckBoxState_MAX';
declare var ECheckBoxState : { Unchecked:'Unchecked',Checked:'Checked',Undetermined:'Undetermined',ECheckBoxState_MAX:'ECheckBoxState_MAX', };
declare class ToolMenuEntryScript extends UObject { 
	Data: ToolMenuEntryScriptData;
	static Load(ResourceName: string): ToolMenuEntryScript;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryScript;
	static GetDefaultObject(): ToolMenuEntryScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryScript;
	RegisterMenuEntry(): void;
	IsVisible(Context: ToolMenuContext): boolean;
	InitEntry(OwnerName: string,Menu: string,Section: string,Name: string,Label: string,Tooltip: string): void;
	GetToolTip(Context: ToolMenuContext): string;
	GetLabel(Context: ToolMenuContext): string;
	GetIcon(Context: ToolMenuContext): ScriptSlateIcon;
	GetCheckState(Context: ToolMenuContext): ECheckBoxState;
	Execute(Context: ToolMenuContext): void;
	ConstructMenuEntry(Menu: ToolMenu,SectionName: string,Context: ToolMenuContext): void;
	CanExecute(Context: ToolMenuContext): boolean;
	static C(Other: UObject | any): ToolMenuEntryScript;
}

declare class ToolMenuEntry { 
	Name: string;
	Owner: ToolMenuOwner;
	Type: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	TutorialHighlightName: string;
	InsertPosition: ToolMenuInsert;
	bShouldCloseWindowAfterMenuSelection: boolean;
	ScriptObject: ToolMenuEntryScript;
	StyleNameOverride: string;
	bCommandIsKeybindOnly: boolean;
	clone() : ToolMenuEntry;
	static C(Other: UObject | any): ToolMenuEntry;
}

declare class ToolMenuSectionDynamic extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionDynamic;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionDynamic;
	static GetDefaultObject(): ToolMenuSectionDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionDynamic;
	ConstructSections(Menu: ToolMenu,Context: ToolMenuContext): void;
	static C(Other: UObject | any): ToolMenuSectionDynamic;
}

declare class ToolMenuSection { 
	Name: string;
	Owner: ToolMenuOwner;
	Blocks: ToolMenuEntry[];
	InsertPosition: ToolMenuInsert;
	Context: ToolMenuContext;
	ToolMenuSectionDynamic: ToolMenuSectionDynamic;
	clone() : ToolMenuSection;
	static C(Other: UObject | any): ToolMenuSection;
}

declare class ToolMenu extends ToolMenuBase { 
	MenuName: string;
	MenuParent: string;
	StyleName: string;
	TutorialHighlightName: string;
	MenuType: EMultiBoxType;
	bShouldCleanupContextOnDestroy: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bCloseSelfOnly: boolean;
	bSearchable: boolean;
	bToolBarIsFocusable: boolean;
	bToolBarForceSmallIcons: boolean;
	bPreventCustomization: boolean;
	MenuOwner: ToolMenuOwner;
	Context: ToolMenuContext;
	Sections: ToolMenuSection[];
	SubMenuParent: ToolMenu;
	SubMenuSourceEntryName: string;
	static Load(ResourceName: string): ToolMenu;
	static Find(Outer: UObject, ResourceName: string): ToolMenu;
	static GetDefaultObject(): ToolMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenu;
	InitMenu(Owner: ToolMenuOwner,Name: string,Parent: string,Type: EMultiBoxType): void;
	AddSubMenuScript(Owner: string,SectionName: string,Name: string,Label: string,Tooltip: string): ToolMenu;
	AddSectionScript(SectionName: string,Label: string,InsertName: string,InsertType: EToolMenuInsertType): void;
	AddMenuEntryObject(InObject: ToolMenuEntryScript): void;
	AddMenuEntry(SectionName: string,Args: ToolMenuEntry): void;
	AddDynamicSectionScript(SectionName: string,UObject: ToolMenuSectionDynamic): void;
	static C(Other: UObject | any): ToolMenu;
}

declare class ToolMenuContextBase extends UObject { 
	static Load(ResourceName: string): ToolMenuContextBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextBase;
	static GetDefaultObject(): ToolMenuContextBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextBase;
	static C(Other: UObject | any): ToolMenuContextBase;
}

declare class SlateTabManagerContext extends ToolMenuContextBase { 
	static Load(ResourceName: string): SlateTabManagerContext;
	static Find(Outer: UObject, ResourceName: string): SlateTabManagerContext;
	static GetDefaultObject(): SlateTabManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTabManagerContext;
	static C(Other: UObject | any): SlateTabManagerContext;
}

declare type ECustomizedToolMenuVisibility = 'None' | 'Visible' | 'Hidden' | 'ECustomizedToolMenuVisibility_MAX';
declare var ECustomizedToolMenuVisibility : { None:'None',Visible:'Visible',Hidden:'Hidden',ECustomizedToolMenuVisibility_MAX:'ECustomizedToolMenuVisibility_MAX', };
declare class CustomizedToolMenuEntry { 
	Visibility: ECustomizedToolMenuVisibility;
	clone() : CustomizedToolMenuEntry;
	static C(Other: UObject | any): CustomizedToolMenuEntry;
}

declare class CustomizedToolMenuSection { 
	Visibility: ECustomizedToolMenuVisibility;
	clone() : CustomizedToolMenuSection;
	static C(Other: UObject | any): CustomizedToolMenuSection;
}

declare class CustomizedToolMenuNameArray { 
	Names: string[];
	clone() : CustomizedToolMenuNameArray;
	static C(Other: UObject | any): CustomizedToolMenuNameArray;
}

declare class CustomizedToolMenu { 
	Name: string;
	Entries: Map<string, CustomizedToolMenuEntry>;
	Sections: Map<string, CustomizedToolMenuSection>;
	EntryOrder: Map<string, CustomizedToolMenuNameArray>;
	SectionOrder: string[];
	clone() : CustomizedToolMenu;
	static C(Other: UObject | any): CustomizedToolMenu;
}

declare class ToolMenus extends UObject { 
	CustomizedMenus: CustomizedToolMenu[];
	MenuSubstitutionsDuringGenerate: Map<string, string>;
	Menus: Map<string, ToolMenu>;
	static Load(ResourceName: string): ToolMenus;
	static Find(Outer: UObject, ResourceName: string): ToolMenus;
	static GetDefaultObject(): ToolMenus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenus;
	UnregisterOwnerByName(InOwnerName: string): void;
	SetSectionPosition(MenuName: string,SectionName: string,OtherSectionName: string,PositionType: EToolMenuInsertType): void;
	SetSectionLabel(MenuName: string,SectionName: string,Label: string): void;
	RemoveSection(MenuName: string,Section: string): void;
	RemoveMenu(MenuName: string): void;
	RemoveEntry(MenuName: string,Section: string,Name: string): void;
	RegisterMenu(Name: string,Parent: string,Type: EMultiBoxType,bWarnIfAlreadyRegistered: boolean): ToolMenu;
	RefreshMenuWidget(Name: string): boolean;
	RefreshAllWidgets(): void;
	IsMenuRegistered(Name: string): boolean;
	static Get(): ToolMenus;
	FindMenu(Name: string): ToolMenu;
	static FindContext(InContext: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	ExtendMenu(Name: string): ToolMenu;
	static AddMenuEntryObject(MenuEntryObject: ToolMenuEntryScript): boolean;
	static C(Other: UObject | any): ToolMenus;
}

declare class ToolMenuContextExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuContextExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextExtensions;
	static GetDefaultObject(): ToolMenuContextExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextExtensions;
	static FindByClass(Context: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	static C(Other: UObject | any): ToolMenuContextExtensions;
}

declare type EToolMenuStringCommandType = 'Command' | 'Python' | 'Custom' | 'EToolMenuStringCommandType_MAX';
declare var EToolMenuStringCommandType : { Command:'Command',Python:'Python',Custom:'Custom',EToolMenuStringCommandType_MAX:'EToolMenuStringCommandType_MAX', };
declare class ToolMenuStringCommand { 
	Type: EToolMenuStringCommandType;
	CustomType: string;
	string: string;
	clone() : ToolMenuStringCommand;
	static C(Other: UObject | any): ToolMenuStringCommand;
}

declare class ToolMenuEntryExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuEntryExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryExtensions;
	static GetDefaultObject(): ToolMenuEntryExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryExtensions;
	static SetToolTip(Target?: ToolMenuEntry,Tooltip?: string): {Target: ToolMenuEntry};
	static SetStringCommand(Target?: ToolMenuEntry,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Target: ToolMenuEntry};
	static SetLabel(Target?: ToolMenuEntry,Label?: string): {Target: ToolMenuEntry};
	static SetIcon(Target?: ToolMenuEntry,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {Target: ToolMenuEntry};
	static MakeToolMenuOwner(Name: string): ToolMenuOwner;
	static MakeStringCommand(Type: EToolMenuStringCommandType,CustomType: string,string: string): ToolMenuStringCommand;
	static MakeScriptSlateIcon(StyleSetName: string,StyleName: string,SmallStyleName: string): ScriptSlateIcon;
	static InitMenuEntry(InOwner: string,InName: string,InLabel: string,InToolTip: string,CommandType: EToolMenuStringCommandType,CustomCommandType: string,CommandString: string): ToolMenuEntry;
	static GetToolTip(Target: ToolMenuEntry): string;
	static GetLabel(Target: ToolMenuEntry): string;
	static BreakToolMenuOwner(InValue: ToolMenuOwner,Name?: string): {Name: string};
	static BreakStringCommand(InValue: ToolMenuStringCommand,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Type: EToolMenuStringCommandType, CustomType: string, string: string};
	static BreakScriptSlateIcon(InValue: ScriptSlateIcon,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {StyleSetName: string, StyleName: string, SmallStyleName: string};
	static C(Other: UObject | any): ToolMenuEntryExtensions;
}

declare class ToolMenuSectionExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionExtensions;
	static GetDefaultObject(): ToolMenuSectionExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionExtensions;
	static SetLabel(Section?: ToolMenuSection,Label?: string): {Section: ToolMenuSection};
	static GetLabel(Section: ToolMenuSection): string;
	static AddEntryObject(Section?: ToolMenuSection,InObject?: ToolMenuEntryScript): {Section: ToolMenuSection};
	static AddEntry(Section?: ToolMenuSection,Args?: ToolMenuEntry): {Section: ToolMenuSection};
	static C(Other: UObject | any): ToolMenuSectionExtensions;
}

declare class InterchangeResult extends UObject { 
	SourceAssetName: string;
	DestinationAssetName: string;
	AssetType: UnrealEngineClass;
	InterchangeKey: string;
	static Load(ResourceName: string): InterchangeResult;
	static Find(Outer: UObject, ResourceName: string): InterchangeResult;
	static GetDefaultObject(): InterchangeResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResult;
	static C(Other: UObject | any): InterchangeResult;
}

declare class InterchangeResultsContainer extends UObject { 
	Results: InterchangeResult[];
	static Load(ResourceName: string): InterchangeResultsContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultsContainer;
	static GetDefaultObject(): InterchangeResultsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultsContainer;
	static C(Other: UObject | any): InterchangeResultsContainer;
}

declare class InterchangeFactoryBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangeFactoryBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBase;
	static GetDefaultObject(): InterchangeFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBase;
	GetFactoryClass(): UnrealEngineClass;
	static C(Other: UObject | any): InterchangeFactoryBase;
}

declare class InterchangeSourceData extends UObject { 
	Filename: string;
	static Load(ResourceName: string): InterchangeSourceData;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceData;
	static GetDefaultObject(): InterchangeSourceData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceData;
	SetFilename(InFilename: string): boolean;
	GetFilename(): string;
	static C(Other: UObject | any): InterchangeSourceData;
}

declare class InterchangeWriterBase extends UObject { 
	static Load(ResourceName: string): InterchangeWriterBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeWriterBase;
	static GetDefaultObject(): InterchangeWriterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeWriterBase;
	static C(Other: UObject | any): InterchangeWriterBase;
}

declare class InterchangePipelinePropertyStatePerContext { 
	bVisible: boolean;
	clone() : InterchangePipelinePropertyStatePerContext;
	static C(Other: UObject | any): InterchangePipelinePropertyStatePerContext;
}

declare class InterchangePipelinePropertyStates { 
	bLocked: boolean;
	ImportStates: InterchangePipelinePropertyStatePerContext;
	ReimportStates: InterchangePipelinePropertyStatePerContext;
	clone() : InterchangePipelinePropertyStates;
	static C(Other: UObject | any): InterchangePipelinePropertyStates;
}

declare type EInterchangeNodeContainerType = 'None' | 'TranslatedScene' | 'TranslatedAsset' | 'FactoryData' | 'EInterchangeNodeContainerType_MAX';
declare var EInterchangeNodeContainerType : { None:'None',TranslatedScene:'TranslatedScene',TranslatedAsset:'TranslatedAsset',FactoryData:'FactoryData',EInterchangeNodeContainerType_MAX:'EInterchangeNodeContainerType_MAX', };
declare class InterchangeBaseNode extends UObject { 
	static Load(ResourceName: string): InterchangeBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNode;
	static GetDefaultObject(): InterchangeBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNode;
	SetParentUid(ParentUid: string): boolean;
	SetEnabled(bIsEnabled: boolean): boolean;
	SetDisplayLabel(DisplayName: string): boolean;
	SetAssetName(AssetName: string): boolean;
	RemoveTargetNodeUid(AssetUid: string): boolean;
	RemoveAttribute(NodeAttributeKey: string): boolean;
	IsEnabled(): boolean;
	InitializeNode(UniqueId: string,DisplayLabel: string,NodeContainerType: EInterchangeNodeContainerType): void;
	GetVector2Attribute(NodeAttributeKey: string,OutValue?: Vector2f): {OutValue: Vector2f, $: boolean};
	GetUniqueID(): string;
	GetTargetNodeUids(OutTargetAssets?: string[]): {OutTargetAssets: string[]};
	GetTargetNodeCount(): number;
	GetStringAttribute(NodeAttributeKey: string,OutValue?: string): {OutValue: string, $: boolean};
	GetParentUid(): string;
	GetNodeContainerType(): EInterchangeNodeContainerType;
	GetLinearColorAttribute(NodeAttributeKey: string,OutValue?: LinearColor): {OutValue: LinearColor, $: boolean};
	GetInt32Attribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetGuidAttribute(NodeAttributeKey: string,OutValue?: Guid): {OutValue: Guid, $: boolean};
	GetFloatAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetDoubleAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetDisplayLabel(): string;
	GetBooleanAttribute(NodeAttributeKey: string,OutValue?: boolean): {OutValue: boolean, $: boolean};
	GetAssetName(): string;
	AddVector2Attribute(NodeAttributeKey: string,Value: Vector2f): boolean;
	AddTargetNodeUid(AssetUid: string): boolean;
	AddStringAttribute(NodeAttributeKey: string,Value: string): boolean;
	AddLinearColorAttribute(NodeAttributeKey: string,Value: LinearColor): boolean;
	AddInt32Attribute(NodeAttributeKey: string,Value: number): boolean;
	AddGuidAttribute(NodeAttributeKey: string,Value: Guid): boolean;
	AddFloatAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddDoubleAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddBooleanAttribute(NodeAttributeKey: string,Value: boolean): boolean;
	static C(Other: UObject | any): InterchangeBaseNode;
}

declare type EReimportStrategyFlags = 'ApplyNoProperties' | 'ApplyPipelineProperties' | 'ApplyEditorChangedProperties' | 'EReimportStrategyFlags_MAX';
declare var EReimportStrategyFlags : { ApplyNoProperties:'ApplyNoProperties',ApplyPipelineProperties:'ApplyPipelineProperties',ApplyEditorChangedProperties:'ApplyEditorChangedProperties',EReimportStrategyFlags_MAX:'EReimportStrategyFlags_MAX', };
declare class InterchangeFactoryBaseNode extends InterchangeBaseNode { 
	static Load(ResourceName: string): InterchangeFactoryBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBaseNode;
	static GetDefaultObject(): InterchangeFactoryBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBaseNode;
	SetReimportStrategyFlags(ReimportStrategyFlags: EReimportStrategyFlags): boolean;
	SetCustomSubPath(AttributeValue: string): boolean;
	SetCustomReferenceObject(AttributeValue: SoftObjectPath): boolean;
	RemoveFactoryDependencyUid(DependencyUid: string): boolean;
	GetReimportStrategyFlags(): EReimportStrategyFlags;
	GetFactoryDependency(Index: number,OutDependency?: string): {OutDependency: string};
	GetFactoryDependenciesCount(): number;
	GetFactoryDependencies(OutDependencies?: string[]): {OutDependencies: string[]};
	GetCustomSubPath(AttributeValue?: string): {AttributeValue: string, $: boolean};
	GetCustomReferenceObject(AttributeValue?: SoftObjectPath): {AttributeValue: SoftObjectPath, $: boolean};
	AddFactoryDependencyUid(DependencyUid: string): boolean;
	static C(Other: UObject | any): InterchangeFactoryBaseNode;
}

declare class InterchangeBaseNodeContainer extends UObject { 
	Nodes: Map<string, InterchangeBaseNode>;
	static Load(ResourceName: string): InterchangeBaseNodeContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNodeContainer;
	static GetDefaultObject(): InterchangeBaseNodeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNodeContainer;
	SetNodeParentUid(NodeUniqueID: string,NewParentNodeUid: string): boolean;
	SaveToFile(Filename: string): void;
	ResetChildrenCache(): void;
	LoadFromFile(Filename: string): void;
	IsNodeUidValid(NodeUniqueID: string): boolean;
	GetRoots(RootNodes?: string[]): {RootNodes: string[]};
	GetNodes(ClassNode: UnrealEngineClass,OutNodes?: string[]): {OutNodes: string[]};
	GetNodeChildrenUids(NodeUniqueID: string): string[];
	GetNodeChildrenCount(NodeUniqueID: string): number;
	GetNodeChildren(NodeUniqueID: string,ChildIndex: number): InterchangeBaseNode;
	GetNode(NodeUniqueID: string): InterchangeBaseNode;
	GetFactoryNode(NodeUniqueID: string): InterchangeFactoryBaseNode;
	ComputeChildrenCache(): void;
	AddNode(UNode: InterchangeBaseNode): string;
	static C(Other: UObject | any): InterchangeBaseNodeContainer;
}

declare type EInterchangePipelineTask = 'PreFactoryImport' | 'PostFactoryImport' | 'Export' | 'EInterchangePipelineTask_MAX';
declare var EInterchangePipelineTask : { PreFactoryImport:'PreFactoryImport',PostFactoryImport:'PostFactoryImport',Export:'Export',EInterchangePipelineTask_MAX:'EInterchangePipelineTask_MAX', };
declare class InterchangePipelineBase extends UObject { 
	Results: InterchangeResultsContainer;
	PropertiesStates: Map<string, InterchangePipelinePropertyStates>;
	static Load(ResourceName: string): InterchangePipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineBase;
	static GetDefaultObject(): InterchangePipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineBase;
	ScriptedSetReimportSourceIndex(ReimportObjectClass: UnrealEngineClass,SourceFileIndex: number): void;
	ScriptedExecutePreImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,SourceDatas: InterchangeSourceData[]): void;
	ScriptedExecutePostImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,FactoryNodeKey: string,CreatedAsset: UObject,bIsAReimport: boolean): void;
	ScriptedExecuteExportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer): void;
	ScriptedCanExecuteOnAnyThread(PipelineTask: EInterchangePipelineTask): boolean;
	FindOrAddPropertyStates(PropertyPath: string): InterchangePipelinePropertyStates;
	DoesPropertyStatesExist(PropertyPath: string): boolean;
	static C(Other: UObject | any): InterchangePipelineBase;
}

declare class InterchangeResultSuccess extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultSuccess;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultSuccess;
	static GetDefaultObject(): InterchangeResultSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultSuccess;
	static C(Other: UObject | any): InterchangeResultSuccess;
}

declare class InterchangeResultWarning extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultWarning;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning;
	static GetDefaultObject(): InterchangeResultWarning;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning;
	static C(Other: UObject | any): InterchangeResultWarning;
}

declare class InterchangeResultError extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultError;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError;
	static GetDefaultObject(): InterchangeResultError;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError;
	static C(Other: UObject | any): InterchangeResultError;
}

declare class InterchangeResultWarning_Generic extends InterchangeResultWarning { 
	Text: string;
	static Load(ResourceName: string): InterchangeResultWarning_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning_Generic;
	static GetDefaultObject(): InterchangeResultWarning_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning_Generic;
	static C(Other: UObject | any): InterchangeResultWarning_Generic;
}

declare class InterchangeResultError_Generic extends InterchangeResultError { 
	Text: string;
	static Load(ResourceName: string): InterchangeResultError_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_Generic;
	static GetDefaultObject(): InterchangeResultError_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_Generic;
	static C(Other: UObject | any): InterchangeResultError_Generic;
}

declare class InterchangeResultError_ReimportFail extends InterchangeResultError { 
	static Load(ResourceName: string): InterchangeResultError_ReimportFail;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_ReimportFail;
	static GetDefaultObject(): InterchangeResultError_ReimportFail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_ReimportFail;
	static C(Other: UObject | any): InterchangeResultError_ReimportFail;
}

declare class InterchangeTranslatorBase extends UObject { 
	Results: InterchangeResultsContainer;
	SourceData: InterchangeSourceData;
	static Load(ResourceName: string): InterchangeTranslatorBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeTranslatorBase;
	static GetDefaultObject(): InterchangeTranslatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeTranslatorBase;
	static C(Other: UObject | any): InterchangeTranslatorBase;
}

declare class InterchangeAnimationAPI extends UObject { 
	static Load(ResourceName: string): InterchangeAnimationAPI;
	static Find(Outer: UObject, ResourceName: string): InterchangeAnimationAPI;
	static GetDefaultObject(): InterchangeAnimationAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAnimationAPI;
	static SetCustomNodeTransformPayloadKey(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: string): boolean;
	static SetCustomNodeTransformAnimationStartTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomNodeTransformAnimationKeyCount(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomNodeTransformAnimationEndTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: number): boolean;
	static SetCustomIsNodeTransformAnimated(InterchangeBaseNode: InterchangeBaseNode,AttributeValue: boolean): boolean;
	static GetCustomNodeTransformPayloadKey(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: string): {AttributeValue: string, $: boolean};
	static GetCustomNodeTransformAnimationStartTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomNodeTransformAnimationKeyCount(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomNodeTransformAnimationEndTime(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: number): {AttributeValue: number, $: boolean};
	static GetCustomIsNodeTransformAnimated(InterchangeBaseNode: InterchangeBaseNode,AttributeValue?: boolean): {AttributeValue: boolean, $: boolean};
	static C(Other: UObject | any): InterchangeAnimationAPI;
}

declare class InterchangeSourceNode extends InterchangeBaseNode { 
	static Load(ResourceName: string): InterchangeSourceNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceNode;
	static GetDefaultObject(): InterchangeSourceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceNode;
	SetCustomSourceTimelineStart(AttributeValue: number): boolean;
	SetCustomSourceTimelineEnd(AttributeValue: number): boolean;
	SetCustomSourceFrameRateNumerator(AttributeValue: number): boolean;
	SetCustomSourceFrameRateDenominator(AttributeValue: number): boolean;
	SetCustomImportUnusedMaterial(AttributeValue: boolean): boolean;
	SetCustomAnimatedTimeStart(AttributeValue: number): boolean;
	SetCustomAnimatedTimeEnd(AttributeValue: number): boolean;
	InitializeSourceNode(UniqueId: string,DisplayLabel: string): void;
	GetCustomSourceTimelineStart(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceTimelineEnd(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceFrameRateNumerator(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomSourceFrameRateDenominator(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomImportUnusedMaterial(AttributeValue?: boolean): {AttributeValue: boolean, $: boolean};
	GetCustomAnimatedTimeStart(AttributeValue?: number): {AttributeValue: number, $: boolean};
	GetCustomAnimatedTimeEnd(AttributeValue?: number): {AttributeValue: number, $: boolean};
	static C(Other: UObject | any): InterchangeSourceNode;
}

declare class InterchangeUserDefinedAttributeInfo { 
	Name: string;
	clone() : InterchangeUserDefinedAttributeInfo;
	static C(Other: UObject | any): InterchangeUserDefinedAttributeInfo;
}

declare class InterchangeUserDefinedAttributesAPI extends UObject { 
	static Load(ResourceName: string): InterchangeUserDefinedAttributesAPI;
	static Find(Outer: UObject, ResourceName: string): InterchangeUserDefinedAttributesAPI;
	static GetDefaultObject(): InterchangeUserDefinedAttributesAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeUserDefinedAttributesAPI;
	static RemoveUserDefinedAttribute(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string): boolean;
	static GetUserDefinedAttributeInfos(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeInfos?: InterchangeUserDefinedAttributeInfo[]): {UserDefinedAttributeInfos: InterchangeUserDefinedAttributeInfo[]};
	static GetUserDefinedAttribute_Int32(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_FString(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: string,OutPayloadKey?: string): {OutValue: string, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Float(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Double(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: number,OutPayloadKey?: string): {OutValue: number, OutPayloadKey: string, $: boolean};
	static GetUserDefinedAttribute_Boolean(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,OutValue?: boolean,OutPayloadKey?: string): {OutValue: boolean, OutPayloadKey: string, $: boolean};
	static DuplicateAllUserDefinedAttribute(InterchangeSourceNode: InterchangeBaseNode,InterchangeDestinationNode: InterchangeBaseNode,bAddSourceNodeName: boolean): void;
	static CreateUserDefinedAttribute_Int32(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_FString(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: string,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Float(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Double(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: number,PayloadKey: string): boolean;
	static CreateUserDefinedAttribute_Boolean(InterchangeNode: InterchangeBaseNode,UserDefinedAttributeName: string,Value: boolean,PayloadKey: string): boolean;
	static C(Other: UObject | any): InterchangeUserDefinedAttributesAPI;
}

declare class FilterBarContext extends UObject { 
	static Load(ResourceName: string): FilterBarContext;
	static Find(Outer: UObject, ResourceName: string): FilterBarContext;
	static GetDefaultObject(): FilterBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FilterBarContext;
	static C(Other: UObject | any): FilterBarContext;
}

declare class PropertyConfigFileDisplayRow extends UObject { 
	ConfigFileName: string;
	ExternalProperty: any;
	bIsFileWritable: boolean;
	static Load(ResourceName: string): PropertyConfigFileDisplayRow;
	static Find(Outer: UObject, ResourceName: string): PropertyConfigFileDisplayRow;
	static GetDefaultObject(): PropertyConfigFileDisplayRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyConfigFileDisplayRow;
	static C(Other: UObject | any): PropertyConfigFileDisplayRow;
}

declare class ConfigHierarchyPropertyView extends UObject { 
	EditProperty: any;
	ConfigFilePropertyObjects: PropertyConfigFileDisplayRow[];
	static Load(ResourceName: string): ConfigHierarchyPropertyView;
	static Find(Outer: UObject, ResourceName: string): ConfigHierarchyPropertyView;
	static GetDefaultObject(): ConfigHierarchyPropertyView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConfigHierarchyPropertyView;
	static C(Other: UObject | any): ConfigHierarchyPropertyView;
}

declare class LiveLinkController extends UObject { 
	static Load(ResourceName: string): LiveLinkController;
	static Find(Outer: UObject, ResourceName: string): LiveLinkController;
	static GetDefaultObject(): LiveLinkController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkController;
	static C(Other: UObject | any): LiveLinkController;
}

declare class LiveLinkFrameInterpolationProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static GetDefaultObject(): LiveLinkFrameInterpolationProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameInterpolationProcessor;
	static C(Other: UObject | any): LiveLinkFrameInterpolationProcessor;
}

declare class LiveLinkFramePreProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFramePreProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFramePreProcessor;
	static GetDefaultObject(): LiveLinkFramePreProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFramePreProcessor;
	static C(Other: UObject | any): LiveLinkFramePreProcessor;
}

declare class LiveLinkRole extends UObject { 
	static Load(ResourceName: string): LiveLinkRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkRole;
	static GetDefaultObject(): LiveLinkRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkRole;
	static C(Other: UObject | any): LiveLinkRole;
}

declare type ELiveLinkSourceMode = 'Latest' | 'EngineTime' | 'Timecode' | 'ELiveLinkSourceMode_MAX';
declare var ELiveLinkSourceMode : { Latest:'Latest',EngineTime:'EngineTime',Timecode:'Timecode',ELiveLinkSourceMode_MAX:'ELiveLinkSourceMode_MAX', };
declare class LiveLinkSourceBufferManagementSettings { 
	bValidEngineTimeEnabled: boolean;
	ValidEngineTime: number;
	EngineTimeOffset: number;
	EngineTimeClockOffset: number;
	SmoothEngineTimeOffset: number;
	TimecodeFrameRate: FrameRate;
	bGenerateSubFrame: boolean;
	DetectedFrameRate: FrameRate;
	bUseTimecodeSmoothLatest: boolean;
	SourceTimecodeFrameRate: FrameRate;
	bValidTimecodeFrameEnabled: boolean;
	ValidTimecodeFrame: number;
	TimecodeFrameOffset: number;
	TimecodeClockOffset: number;
	LatestOffset: number;
	MaxNumberOfFrameToBuffered: number;
	bKeepAtLeastOneFrame: boolean;
	clone() : LiveLinkSourceBufferManagementSettings;
	static C(Other: UObject | any): LiveLinkSourceBufferManagementSettings;
}

declare class LiveLinkSourceFactory extends UObject { 
	static Load(ResourceName: string): LiveLinkSourceFactory;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceFactory;
	static GetDefaultObject(): LiveLinkSourceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceFactory;
	static C(Other: UObject | any): LiveLinkSourceFactory;
}

declare class LiveLinkSubjectName { 
	Name: string;
	clone() : LiveLinkSubjectName;
	static C(Other: UObject | any): LiveLinkSubjectName;
}

declare class LiveLinkSourceDebugInfo { 
	SubjectName: LiveLinkSubjectName;
	SnapshotIndex: number;
	NumberOfBufferAtSnapshot: number;
	clone() : LiveLinkSourceDebugInfo;
	static C(Other: UObject | any): LiveLinkSourceDebugInfo;
}

declare class LiveLinkSourceSettings extends UObject { 
	Mode: ELiveLinkSourceMode;
	BufferSettings: LiveLinkSourceBufferManagementSettings;
	ConnectionString: string;
	Factory: UnrealEngineClass;
	SourceDebugInfos: LiveLinkSourceDebugInfo[];
	static Load(ResourceName: string): LiveLinkSourceSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceSettings;
	static GetDefaultObject(): LiveLinkSourceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceSettings;
	static C(Other: UObject | any): LiveLinkSourceSettings;
}

declare class LiveLinkCurveConversionSettings { 
	CurveConversionAssetMap: Map<string, SoftObjectPath>;
	clone() : LiveLinkCurveConversionSettings;
	static C(Other: UObject | any): LiveLinkCurveConversionSettings;
}

declare class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings { 
	CurveConversionSettings: LiveLinkCurveConversionSettings;
	static Load(ResourceName: string): LiveLinkCurveRemapSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCurveRemapSettings;
	static GetDefaultObject(): LiveLinkCurveRemapSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCurveRemapSettings;
	static C(Other: UObject | any): LiveLinkCurveRemapSettings;
}

declare class LiveLinkFrameTranslator extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameTranslator;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameTranslator;
	static GetDefaultObject(): LiveLinkFrameTranslator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameTranslator;
	static C(Other: UObject | any): LiveLinkFrameTranslator;
}

declare class LiveLinkSubjectSettings extends UObject { 
	PreProcessors: LiveLinkFramePreProcessor[];
	InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
	Translators: LiveLinkFrameTranslator[];
	Role: UnrealEngineClass;
	FrameRate: FrameRate;
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkSubjectSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSubjectSettings;
	static GetDefaultObject(): LiveLinkSubjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSubjectSettings;
	static C(Other: UObject | any): LiveLinkSubjectSettings;
}

declare class LiveLinkVirtualSubject extends UObject { 
	Role: UnrealEngineClass;
	Subjects: LiveLinkSubjectName[];
	FrameTranslators: LiveLinkFrameTranslator[];
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkVirtualSubject;
	static Find(Outer: UObject, ResourceName: string): LiveLinkVirtualSubject;
	static GetDefaultObject(): LiveLinkVirtualSubject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkVirtualSubject;
	static C(Other: UObject | any): LiveLinkVirtualSubject;
}

declare class LiveLinkBasicRole extends LiveLinkRole { 
	static Load(ResourceName: string): LiveLinkBasicRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkBasicRole;
	static GetDefaultObject(): LiveLinkBasicRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkBasicRole;
	static C(Other: UObject | any): LiveLinkBasicRole;
}

declare class LiveLinkAnimationRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkAnimationRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkAnimationRole;
	static GetDefaultObject(): LiveLinkAnimationRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkAnimationRole;
	static C(Other: UObject | any): LiveLinkAnimationRole;
}

declare class LiveLinkTransformRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkTransformRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkTransformRole;
	static GetDefaultObject(): LiveLinkTransformRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkTransformRole;
	static C(Other: UObject | any): LiveLinkTransformRole;
}

declare class LiveLinkCameraRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkCameraRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCameraRole;
	static GetDefaultObject(): LiveLinkCameraRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCameraRole;
	static C(Other: UObject | any): LiveLinkCameraRole;
}

declare class LiveLinkLightRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkLightRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkLightRole;
	static GetDefaultObject(): LiveLinkLightRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkLightRole;
	static C(Other: UObject | any): LiveLinkLightRole;
}

declare type EPIEPreviewDeviceType = 'Unset' | 'Android' | 'IOS' | 'TVOS' | 'Switch' | 'MAX';
declare var EPIEPreviewDeviceType : { Unset:'Unset',Android:'Android',IOS:'IOS',TVOS:'TVOS',Switch:'Switch',MAX:'MAX', };
declare class PIEPreviewDeviceSpecification extends UObject { 
	PreviewDeviceType: EPIEPreviewDeviceType;
	GPUFamily: string;
	GLVersion: string;
	VulkanVersion: string;
	AndroidVersion: string;
	DeviceMake: string;
	DeviceModel: string;
	DeviceBuildNumber: string;
	UsingHoudini: boolean;
	Hardware: string;
	Chipset: string;
	static Load(ResourceName: string): PIEPreviewDeviceSpecification;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewDeviceSpecification;
	static GetDefaultObject(): PIEPreviewDeviceSpecification;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewDeviceSpecification;
	static C(Other: UObject | any): PIEPreviewDeviceSpecification;
}

declare class EditorInteractiveGizmoConditionalBuilder extends Interface { 
	static Load(ResourceName: string): EditorInteractiveGizmoConditionalBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoConditionalBuilder;
	static GetDefaultObject(): EditorInteractiveGizmoConditionalBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoConditionalBuilder;
	static C(Other: UObject | any): EditorInteractiveGizmoConditionalBuilder;
}

declare class InputBehavior extends UObject { 
	static Load(ResourceName: string): InputBehavior;
	static Find(Outer: UObject, ResourceName: string): InputBehavior;
	static GetDefaultObject(): InputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehavior;
	static C(Other: UObject | any): InputBehavior;
}

declare class BehaviorInfo { 
	Behavior: InputBehavior;
	clone() : BehaviorInfo;
	static C(Other: UObject | any): BehaviorInfo;
}

declare class InputBehaviorSet extends UObject { 
	Behaviors: BehaviorInfo[];
	static Load(ResourceName: string): InputBehaviorSet;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSet;
	static GetDefaultObject(): InputBehaviorSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSet;
	static C(Other: UObject | any): InputBehaviorSet;
}

declare class InteractiveGizmo extends UObject { 
	InputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InteractiveGizmo;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmo;
	static GetDefaultObject(): InteractiveGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmo;
	static C(Other: UObject | any): InteractiveGizmo;
}

declare class ActiveGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveGizmo;
	static C(Other: UObject | any): ActiveGizmo;
}

declare class InteractiveGizmoBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoBuilder;
	static GetDefaultObject(): InteractiveGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoBuilder;
	static C(Other: UObject | any): InteractiveGizmoBuilder;
}

declare class InteractiveGizmoManager extends UObject { 
	ActiveGizmos: ActiveGizmo[];
	GizmoBuilders: Map<string, InteractiveGizmoBuilder>;
	static Load(ResourceName: string): InteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoManager;
	static GetDefaultObject(): InteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoManager;
	static C(Other: UObject | any): InteractiveGizmoManager;
}

declare type EEditorGizmoCategory = 'Accessory' | 'Primary' | 'EEditorGizmoCategory_MAX';
declare var EEditorGizmoCategory : { Accessory:'Accessory',Primary:'Primary',EEditorGizmoCategory_MAX:'EEditorGizmoCategory_MAX', };
declare class EditorGizmoRegistryCategoryEntry extends UObject { 
	GizmoTypes: InteractiveGizmoBuilder[];
	CategoryName: string;
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry;
}

declare class EditorInteractiveGizmoRegistry extends UObject { 
	GizmoCategoryMap: Map<EEditorGizmoCategory, EditorGizmoRegistryCategoryEntry>;
	static Load(ResourceName: string): EditorInteractiveGizmoRegistry;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoRegistry;
	static GetDefaultObject(): EditorInteractiveGizmoRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoRegistry;
	static C(Other: UObject | any): EditorInteractiveGizmoRegistry;
}

declare class ActiveEditorGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveEditorGizmo;
	static C(Other: UObject | any): ActiveEditorGizmo;
}

declare class EditorInteractiveGizmoManager extends InteractiveGizmoManager { 
	Registry: EditorInteractiveGizmoRegistry;
	ActiveEditorGizmos: ActiveEditorGizmo[];
	CachedGizmoMap: Map<InteractiveGizmoBuilder, InteractiveGizmo>;
	static Load(ResourceName: string): EditorInteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoManager;
	static GetDefaultObject(): EditorInteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoManager;
	static C(Other: UObject | any): EditorInteractiveGizmoManager;
}

declare class EditorGizmoRegistryCategoryEntry_ConditionalSelection extends EditorGizmoRegistryCategoryEntry { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
}

declare class EditorGizmoRegistryCategoryEntry_Primary extends EditorGizmoRegistryCategoryEntry_ConditionalSelection { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_Primary;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_Primary;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_Primary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_Primary;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_Primary;
}

declare class EditorGizmoRegistryCategoryEntry_Accessory extends EditorGizmoRegistryCategoryEntry_ConditionalSelection { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_Accessory;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_Accessory;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_Accessory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_Accessory;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_Accessory;
}

declare class EditorInteractiveGizmoSelectionBuilder extends Interface { 
	static Load(ResourceName: string): EditorInteractiveGizmoSelectionBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoSelectionBuilder;
	static GetDefaultObject(): EditorInteractiveGizmoSelectionBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoSelectionBuilder;
	static C(Other: UObject | any): EditorInteractiveGizmoSelectionBuilder;
}

declare class EditorInteractiveGizmoSubsystem extends EditorSubsystem { 
	TransformGizmoBuilder: InteractiveGizmoBuilder;
	Registry: EditorInteractiveGizmoRegistry;
	static Load(ResourceName: string): EditorInteractiveGizmoSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoSubsystem;
	static GetDefaultObject(): EditorInteractiveGizmoSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoSubsystem;
	static C(Other: UObject | any): EditorInteractiveGizmoSubsystem;
}

declare class TransformProxy extends UObject { 
	bRotatePerObject: boolean;
	bSetPivotMode: boolean;
	SharedTransform: Transform;
	InitialSharedTransform: Transform;
	static Load(ResourceName: string): TransformProxy;
	static Find(Outer: UObject, ResourceName: string): TransformProxy;
	static GetDefaultObject(): TransformProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformProxy;
	static C(Other: UObject | any): TransformProxy;
}

declare class GizmoElementMaterialAttribute { 
	Value: MaterialInterface;
	bOverridesChildState: boolean;
	clone() : GizmoElementMaterialAttribute;
	static C(Other: UObject | any): GizmoElementMaterialAttribute;
}

declare class GizmoElementColorAttribute { 
	Value: LinearColor;
	bHasValue: boolean;
	bOverridesChildState: boolean;
	clone() : GizmoElementColorAttribute;
	static C(Other: UObject | any): GizmoElementColorAttribute;
}

declare class GizmoElementMeshRenderStateAttributes { 
	Material: GizmoElementMaterialAttribute;
	HoverMaterial: GizmoElementMaterialAttribute;
	InteractMaterial: GizmoElementMaterialAttribute;
	VertexColor: GizmoElementColorAttribute;
	HoverVertexColor: GizmoElementColorAttribute;
	InteractVertexColor: GizmoElementColorAttribute;
	clone() : GizmoElementMeshRenderStateAttributes;
	static C(Other: UObject | any): GizmoElementMeshRenderStateAttributes;
}

declare type EGizmoElementState = 'None' | 'Visible' | 'Hittable' | 'VisibleAndHittable' | 'EGizmoElementState_MAX';
declare var EGizmoElementState : { None:'None',Visible:'Visible',Hittable:'Hittable',VisibleAndHittable:'VisibleAndHittable',EGizmoElementState_MAX:'EGizmoElementState_MAX', };
declare type EGizmoElementInteractionState = 'None' | 'Hovering' | 'Interacting' | 'EGizmoElementInteractionState_MAX';
declare var EGizmoElementInteractionState : { None:'None',Hovering:'Hovering',Interacting:'Interacting',EGizmoElementInteractionState_MAX:'EGizmoElementInteractionState_MAX', };
declare type EGizmoElementViewDependentType = 'None' | 'Axis' | 'Plane' | 'EGizmoElementViewDependentType_MAX';
declare var EGizmoElementViewDependentType : { None:'None',Axis:'Axis',Plane:'Plane',EGizmoElementViewDependentType_MAX:'EGizmoElementViewDependentType_MAX', };
declare type EGizmoElementViewAlignType = 'None' | 'PointOnly' | 'PointEye' | 'PointScreen' | 'Axial' | 'EGizmoElementViewAlignType_MAX';
declare var EGizmoElementViewAlignType : { None:'None',PointOnly:'PointOnly',PointEye:'PointEye',PointScreen:'PointScreen',Axial:'Axial',EGizmoElementViewAlignType_MAX:'EGizmoElementViewAlignType_MAX', };
declare class GizmoElementBase extends UObject { 
	bEnabled: boolean;
	bEnabledForPerspectiveProjection: boolean;
	bEnabledForOrthographicProjection: boolean;
	bEnabledForDefaultState: boolean;
	bEnabledForHoveringState: boolean;
	bEnabledForInteractingState: boolean;
	PartIdentifier: number;
	MeshRenderAttributes: GizmoElementMeshRenderStateAttributes;
	ElementState: EGizmoElementState;
	ElementInteractionState: EGizmoElementInteractionState;
	ViewDependentType: EGizmoElementViewDependentType;
	ViewDependentAxis: Vector;
	ViewDependentAngleTol: number;
	ViewDependentAxialMaxCosAngleTol: number;
	ViewDependentPlanarMinCosAngleTol: number;
	ViewAlignType: EGizmoElementViewAlignType;
	ViewAlignAxis: Vector;
	ViewAlignNormal: Vector;
	ViewAlignAxialAngleTol: number;
	ViewAlignAxialMaxCosAngleTol: number;
	PixelHitDistanceThreshold: number;
	static Load(ResourceName: string): GizmoElementBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementBase;
	static GetDefaultObject(): GizmoElementBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementBase;
	static C(Other: UObject | any): GizmoElementBase;
}

declare class GizmoViewContext extends UObject { 
	static Load(ResourceName: string): GizmoViewContext;
	static Find(Outer: UObject, ResourceName: string): GizmoViewContext;
	static GetDefaultObject(): GizmoViewContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoViewContext;
	static C(Other: UObject | any): GizmoViewContext;
}

declare class GizmoElementHitMultiTarget extends UObject { 
	GizmoElement: GizmoElementBase;
	GizmoViewContext: GizmoViewContext;
	GizmoTransformProxy: TransformProxy;
	static Load(ResourceName: string): GizmoElementHitMultiTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoElementHitMultiTarget;
	static GetDefaultObject(): GizmoElementHitMultiTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementHitMultiTarget;
	static C(Other: UObject | any): GizmoElementHitMultiTarget;
}

declare class AnyButtonInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): AnyButtonInputBehavior;
	static Find(Outer: UObject, ResourceName: string): AnyButtonInputBehavior;
	static GetDefaultObject(): AnyButtonInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnyButtonInputBehavior;
	static C(Other: UObject | any): AnyButtonInputBehavior;
}

declare class ClickDragInputBehavior extends AnyButtonInputBehavior { 
	bUpdateModifiersDuringDrag: boolean;
	static Load(ResourceName: string): ClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ClickDragInputBehavior;
	static GetDefaultObject(): ClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragInputBehavior;
	static C(Other: UObject | any): ClickDragInputBehavior;
}

declare class TransformGizmoSource extends Interface { 
	static Load(ResourceName: string): TransformGizmoSource;
	static Find(Outer: UObject, ResourceName: string): TransformGizmoSource;
	static GetDefaultObject(): TransformGizmoSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformGizmoSource;
	static C(Other: UObject | any): TransformGizmoSource;
}

declare class GizmoElementLineRenderStateAttributes { 
	LineColor: GizmoElementColorAttribute;
	HoverLineColor: GizmoElementColorAttribute;
	InteractLineColor: GizmoElementColorAttribute;
	clone() : GizmoElementLineRenderStateAttributes;
	static C(Other: UObject | any): GizmoElementLineRenderStateAttributes;
}

declare class GizmoElementLineBase extends GizmoElementBase { 
	LineRenderAttributes: GizmoElementLineRenderStateAttributes;
	LineThickness: number;
	bScreenSpaceLine: boolean;
	HoverLineThicknessMultiplier: number;
	InteractLineThicknessMultiplier: number;
	static Load(ResourceName: string): GizmoElementLineBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementLineBase;
	static GetDefaultObject(): GizmoElementLineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementLineBase;
	static C(Other: UObject | any): GizmoElementLineBase;
}

declare class GizmoElementGroup extends GizmoElementLineBase { 
	bConstantScale: boolean;
	bHitOwner: boolean;
	Elements: GizmoElementBase[];
	static Load(ResourceName: string): GizmoElementGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoElementGroup;
	static GetDefaultObject(): GizmoElementGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementGroup;
	static C(Other: UObject | any): GizmoElementGroup;
}

declare class GizmoElementCylinder extends GizmoElementBase { 
	Base: Vector;
	Direction: Vector;
	Height: number;
	Radius: number;
	NumSides: number;
	static Load(ResourceName: string): GizmoElementCylinder;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCylinder;
	static GetDefaultObject(): GizmoElementCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCylinder;
	static C(Other: UObject | any): GizmoElementCylinder;
}

declare class GizmoElementCone extends GizmoElementBase { 
	Origin: Vector;
	Direction: Vector;
	Height: number;
	Radius: number;
	NumSides: number;
	static Load(ResourceName: string): GizmoElementCone;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCone;
	static GetDefaultObject(): GizmoElementCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCone;
	static C(Other: UObject | any): GizmoElementCone;
}

declare class GizmoElementBox extends GizmoElementBase { 
	Center: Vector;
	Dimensions: Vector;
	UpDirection: Vector;
	SideDirection: Vector;
	static Load(ResourceName: string): GizmoElementBox;
	static Find(Outer: UObject, ResourceName: string): GizmoElementBox;
	static GetDefaultObject(): GizmoElementBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementBox;
	static C(Other: UObject | any): GizmoElementBox;
}

declare type EGizmoElementArrowHeadType = 'Cone' | 'Cube' | 'EGizmoElementArrowHeadType_MAX';
declare var EGizmoElementArrowHeadType : { Cone:'Cone',Cube:'Cube',EGizmoElementArrowHeadType_MAX:'EGizmoElementArrowHeadType_MAX', };
declare class GizmoElementArrow extends GizmoElementBase { 
	CylinderElement: GizmoElementCylinder;
	ConeElement: GizmoElementCone;
	BoxElement: GizmoElementBox;
	Base: Vector;
	Direction: Vector;
	SideDirection: Vector;
	BodyLength: number;
	BodyRadius: number;
	HeadLength: number;
	HeadRadius: number;
	NumSides: number;
	HeadType: EGizmoElementArrowHeadType;
	static Load(ResourceName: string): GizmoElementArrow;
	static Find(Outer: UObject, ResourceName: string): GizmoElementArrow;
	static GetDefaultObject(): GizmoElementArrow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementArrow;
	static C(Other: UObject | any): GizmoElementArrow;
}

declare class GizmoElementRectangle extends GizmoElementLineBase { 
	Center: Vector;
	Width: number;
	Height: number;
	UpDirection: Vector;
	SideDirection: Vector;
	bDrawMesh: boolean;
	bDrawLine: boolean;
	bHitMesh: boolean;
	bHitLine: boolean;
	static Load(ResourceName: string): GizmoElementRectangle;
	static Find(Outer: UObject, ResourceName: string): GizmoElementRectangle;
	static GetDefaultObject(): GizmoElementRectangle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementRectangle;
	static C(Other: UObject | any): GizmoElementRectangle;
}

declare type EGizmoElementPartialType = 'None' | 'Partial' | 'PartialViewDependent' | 'EGizmoElementPartialType_MAX';
declare var EGizmoElementPartialType : { None:'None',Partial:'Partial',PartialViewDependent:'PartialViewDependent',EGizmoElementPartialType_MAX:'EGizmoElementPartialType_MAX', };
declare class GizmoElementCircleBase extends GizmoElementLineBase { 
	Center: Vector;
	Axis0: Vector;
	Axis1: Vector;
	Radius: number;
	NumSegments: number;
	PartialType: EGizmoElementPartialType;
	PartialStartAngle: number;
	PartialEndAngle: number;
	PartialViewDependentMaxCosTol: number;
	static Load(ResourceName: string): GizmoElementCircleBase;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCircleBase;
	static GetDefaultObject(): GizmoElementCircleBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCircleBase;
	static C(Other: UObject | any): GizmoElementCircleBase;
}

declare class GizmoElementTorus extends GizmoElementCircleBase { 
	InnerRadius: number;
	NumInnerSlices: number;
	bEndCaps: boolean;
	static Load(ResourceName: string): GizmoElementTorus;
	static Find(Outer: UObject, ResourceName: string): GizmoElementTorus;
	static GetDefaultObject(): GizmoElementTorus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementTorus;
	static C(Other: UObject | any): GizmoElementTorus;
}

declare class GizmoElementCircle extends GizmoElementCircleBase { 
	bDrawMesh: boolean;
	bDrawLine: boolean;
	bHitMesh: boolean;
	bHitLine: boolean;
	static Load(ResourceName: string): GizmoElementCircle;
	static Find(Outer: UObject, ResourceName: string): GizmoElementCircle;
	static GetDefaultObject(): GizmoElementCircle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoElementCircle;
	static C(Other: UObject | any): GizmoElementCircle;
}

declare class GizmoConstantFrameAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	TangentX: Vector;
	TangentY: Vector;
	static Load(ResourceName: string): GizmoConstantFrameAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantFrameAxisSource;
	static GetDefaultObject(): GizmoConstantFrameAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantFrameAxisSource;
	static C(Other: UObject | any): GizmoConstantFrameAxisSource;
}

declare class ToolContextTransactionProvider extends Interface { 
	static Load(ResourceName: string): ToolContextTransactionProvider;
	static Find(Outer: UObject, ResourceName: string): ToolContextTransactionProvider;
	static GetDefaultObject(): ToolContextTransactionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolContextTransactionProvider;
	static C(Other: UObject | any): ToolContextTransactionProvider;
}

declare class GizmoObjectModifyStateTarget extends UObject { 
	TransactionManager: ToolContextTransactionProvider;
	static Load(ResourceName: string): GizmoObjectModifyStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectModifyStateTarget;
	static GetDefaultObject(): GizmoObjectModifyStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectModifyStateTarget;
	static C(Other: UObject | any): GizmoObjectModifyStateTarget;
}

declare type EGizmoTransformMode = 'None' | 'Translate' | 'Rotate' | 'Scale' | 'Max' | 'EGizmoTransformMode_MAX';
declare var EGizmoTransformMode : { None:'None',Translate:'Translate',Rotate:'Rotate',Scale:'Scale',Max:'Max',EGizmoTransformMode_MAX:'EGizmoTransformMode_MAX', };
declare type EAxisList = 'None' | 'X' | 'Y' | 'Z' | 'Screen' | 'XY' | 'XZ' | 'YZ' | 'XYZ' | 'All' | 'ZRotation' | 'Rotate2D' | 'EAxisList_MAX';
declare var EAxisList : { None:'None',X:'X',Y:'Y',Z:'Z',Screen:'Screen',XY:'XY',XZ:'XZ',YZ:'YZ',XYZ:'XYZ',All:'All',ZRotation:'ZRotation',Rotate2D:'Rotate2D',EAxisList_MAX:'EAxisList_MAX', };
declare type ETransformGizmoPartIdentifier = 'Default' | 'TranslateAll' | 'TranslateXAxis' | 'TranslateYAxis' | 'TranslateZAxis' | 'TranslateXYPlanar' | 'TranslateYZPlanar' | 'TranslateXZPlanar' | 'TranslateScreenSpace' | 'RotateAll' | 'RotateXAxis' | 'RotateYAxis' | 'RotateZAxis' | 'RotateScreenSpace' | 'RotateArcball' | 'RotateArcballInnerCircle' | 'ScaleAll' | 'ScaleXAxis' | 'ScaleYAxis' | 'ScaleZAxis' | 'ScaleXYPlanar' | 'ScaleYZPlanar' | 'ScaleXZPlanar' | 'ScaleUniform' | 'Max' | 'ETransformGizmoPartIdentifier_MAX';
declare var ETransformGizmoPartIdentifier : { Default:'Default',TranslateAll:'TranslateAll',TranslateXAxis:'TranslateXAxis',TranslateYAxis:'TranslateYAxis',TranslateZAxis:'TranslateZAxis',TranslateXYPlanar:'TranslateXYPlanar',TranslateYZPlanar:'TranslateYZPlanar',TranslateXZPlanar:'TranslateXZPlanar',TranslateScreenSpace:'TranslateScreenSpace',RotateAll:'RotateAll',RotateXAxis:'RotateXAxis',RotateYAxis:'RotateYAxis',RotateZAxis:'RotateZAxis',RotateScreenSpace:'RotateScreenSpace',RotateArcball:'RotateArcball',RotateArcballInnerCircle:'RotateArcballInnerCircle',ScaleAll:'ScaleAll',ScaleXAxis:'ScaleXAxis',ScaleYAxis:'ScaleYAxis',ScaleZAxis:'ScaleZAxis',ScaleXYPlanar:'ScaleXYPlanar',ScaleYZPlanar:'ScaleYZPlanar',ScaleXZPlanar:'ScaleXZPlanar',ScaleUniform:'ScaleUniform',Max:'Max',ETransformGizmoPartIdentifier_MAX:'ETransformGizmoPartIdentifier_MAX', };
declare class TransformGizmo extends InteractiveGizmo { 
	ActiveTarget: TransformProxy;
	HitTarget: GizmoElementHitMultiTarget;
	MouseBehavior: ClickDragInputBehavior;
	TransformGizmoSource: TransformGizmoSource;
	GizmoElementRoot: GizmoElementGroup;
	GizmoViewContext: GizmoViewContext;
	bVisible: boolean;
	bInInteraction: boolean;
	bSnapToWorldGrid: boolean;
	bGridSizeIsExplicit: boolean;
	ExplicitGridSize: Vector;
	bRotationGridSizeIsExplicit: boolean;
	ExplicitRotationGridSize: Rotator;
	bSnapToWorldRotGrid: boolean;
	TranslateXAxisElement: GizmoElementArrow;
	TranslateYAxisElement: GizmoElementArrow;
	TranslateZAxisElement: GizmoElementArrow;
	TranslateScreenSpaceElement: GizmoElementRectangle;
	TranslatePlanarXYElement: GizmoElementRectangle;
	TranslatePlanarYZElement: GizmoElementRectangle;
	TranslatePlanarXZElement: GizmoElementRectangle;
	RotateXAxisElement: GizmoElementTorus;
	RotateYAxisElement: GizmoElementTorus;
	RotateZAxisElement: GizmoElementTorus;
	RotateOuterCircleElement: GizmoElementCircle;
	RotateArcballOuterElement: GizmoElementCircle;
	RotateArcballInnerElement: GizmoElementCircle;
	RotateScreenSpaceElement: GizmoElementCircle;
	ScaleXAxisElement: GizmoElementArrow;
	ScaleYAxisElement: GizmoElementArrow;
	ScaleZAxisElement: GizmoElementArrow;
	ScalePlanarXYElement: GizmoElementRectangle;
	ScalePlanarYZElement: GizmoElementRectangle;
	ScalePlanarXZElement: GizmoElementRectangle;
	ScaleUniformElement: GizmoElementBox;
	CameraAxisSource: GizmoConstantFrameAxisSource;
	StateTarget: GizmoObjectModifyStateTarget;
	TransparentVertexColorMaterial: MaterialInterface;
	GridMaterial: MaterialInterface;
	AxisMaterialX: MaterialInstanceDynamic;
	AxisMaterialY: MaterialInstanceDynamic;
	AxisMaterialZ: MaterialInstanceDynamic;
	CurrentAxisMaterial: MaterialInstanceDynamic;
	GreyMaterial: MaterialInstanceDynamic;
	WhiteMaterial: MaterialInstanceDynamic;
	OpaquePlaneMaterialXY: MaterialInstanceDynamic;
	ScaleMultiplier: number;
	CurrentTransform: Transform;
	CurrentMode: EGizmoTransformMode;
	CurrentAxisToDraw: EAxisList;
	LastHitPart: ETransformGizmoPartIdentifier;
	InteractionAxisList: EAxisList;
	InteractionAxisOrigin: Vector;
	InteractionAxisDirection: Vector;
	InteractionAxisStartParam: number;
	InteractionAxisCurrParam: number;
	InteractionPlanarOrigin: Vector;
	InteractionPlanarNormal: Vector;
	InteractionPlanarAxisX: Vector;
	InteractionPlanarAxisY: Vector;
	InteractionPlanarStartPoint: Vector;
	InteractionPlanarCurrPoint: Vector;
	InteractionStartAngle: number;
	InteractionCurrAngle: number;
	InteractionScreenAxisDirection: Vector2D;
	InteractionScreenStartPos: Vector2D;
	InteractionScreenEndPos: Vector2D;
	InteractionScreenCurrPos: Vector2D;
	static Load(ResourceName: string): TransformGizmo;
	static Find(Outer: UObject, ResourceName: string): TransformGizmo;
	static GetDefaultObject(): TransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformGizmo;
	static C(Other: UObject | any): TransformGizmo;
}

declare class EditorTransformGizmo extends TransformGizmo { 
	static Load(ResourceName: string): EditorTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): EditorTransformGizmo;
	static GetDefaultObject(): EditorTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformGizmo;
	static C(Other: UObject | any): EditorTransformGizmo;
}

declare class EditorTransformGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): EditorTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorTransformGizmoBuilder;
	static GetDefaultObject(): EditorTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformGizmoBuilder;
	static C(Other: UObject | any): EditorTransformGizmoBuilder;
}

declare class EditorTransformGizmoSource extends UObject { 
	static Load(ResourceName: string): EditorTransformGizmoSource;
	static Find(Outer: UObject, ResourceName: string): EditorTransformGizmoSource;
	static GetDefaultObject(): EditorTransformGizmoSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformGizmoSource;
	static C(Other: UObject | any): EditorTransformGizmoSource;
}

declare class EditorTransformProxy extends TransformProxy { 
	static Load(ResourceName: string): EditorTransformProxy;
	static Find(Outer: UObject, ResourceName: string): EditorTransformProxy;
	static GetDefaultObject(): EditorTransformProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformProxy;
	static C(Other: UObject | any): EditorTransformProxy;
}

declare class InputRouter extends UObject { 
	bAutoInvalidateOnHover: boolean;
	bAutoInvalidateOnCapture: boolean;
	ActiveInputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InputRouter;
	static Find(Outer: UObject, ResourceName: string): InputRouter;
	static GetDefaultObject(): InputRouter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputRouter;
	static C(Other: UObject | any): InputRouter;
}

declare class ToolTargetFactory extends UObject { 
	static Load(ResourceName: string): ToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): ToolTargetFactory;
	static GetDefaultObject(): ToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetFactory;
	static C(Other: UObject | any): ToolTargetFactory;
}

declare class ToolTargetManager extends UObject { 
	Factories: ToolTargetFactory[];
	static Load(ResourceName: string): ToolTargetManager;
	static Find(Outer: UObject, ResourceName: string): ToolTargetManager;
	static GetDefaultObject(): ToolTargetManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetManager;
	static C(Other: UObject | any): ToolTargetManager;
}

declare class InteractiveTool extends UObject { 
	InputBehaviors: InputBehaviorSet;
	ToolPropertyObjects: UObject[];
	static Load(ResourceName: string): InteractiveTool;
	static Find(Outer: UObject, ResourceName: string): InteractiveTool;
	static GetDefaultObject(): InteractiveTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveTool;
	static C(Other: UObject | any): InteractiveTool;
}

declare class InteractiveToolBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveToolBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolBuilder;
	static GetDefaultObject(): InteractiveToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolBuilder;
	static C(Other: UObject | any): InteractiveToolBuilder;
}

declare class InteractiveToolManager extends UObject { 
	ActiveLeftTool: InteractiveTool;
	ActiveRightTool: InteractiveTool;
	ToolBuilders: Map<string, InteractiveToolBuilder>;
	static Load(ResourceName: string): InteractiveToolManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolManager;
	static GetDefaultObject(): InteractiveToolManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolManager;
	static C(Other: UObject | any): InteractiveToolManager;
}

declare class ContextObjectStore extends UObject { 
	ContextObjects: UObject[];
	static Load(ResourceName: string): ContextObjectStore;
	static Find(Outer: UObject, ResourceName: string): ContextObjectStore;
	static GetDefaultObject(): ContextObjectStore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContextObjectStore;
	static C(Other: UObject | any): ContextObjectStore;
}

declare class InteractiveToolsContext extends UObject { 
	InputRouter: InputRouter;
	TargetManager: ToolTargetManager;
	ToolManager: InteractiveToolManager;
	GizmoManager: InteractiveGizmoManager;
	ContextObjectStore: ContextObjectStore;
	ToolManagerClass: Class;
	static Load(ResourceName: string): InteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolsContext;
	static GetDefaultObject(): InteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolsContext;
	static C(Other: UObject | any): InteractiveToolsContext;
}

declare class EditorInteractiveToolsContext extends InteractiveToolsContext { 
	StandardVertexColorMaterial: MaterialInterface;
	static Load(ResourceName: string): EditorInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveToolsContext;
	static GetDefaultObject(): EditorInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveToolsContext;
	static C(Other: UObject | any): EditorInteractiveToolsContext;
}

declare class EdModeInteractiveToolsContext extends EditorInteractiveToolsContext { 
	ParentModeManagerToolsContext: ModeManagerInteractiveToolsContext;
	static Load(ResourceName: string): EdModeInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): EdModeInteractiveToolsContext;
	static GetDefaultObject(): EdModeInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdModeInteractiveToolsContext;
	static C(Other: UObject | any): EdModeInteractiveToolsContext;
}

declare class ModeManagerInteractiveToolsContext extends EditorInteractiveToolsContext { 
	EdModeToolsContexts: EdModeInteractiveToolsContext[];
	static Load(ResourceName: string): ModeManagerInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): ModeManagerInteractiveToolsContext;
	static GetDefaultObject(): ModeManagerInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModeManagerInteractiveToolsContext;
	static C(Other: UObject | any): ModeManagerInteractiveToolsContext;
}

declare class EdMode extends UObject { 
	ModeToolsContext: EdModeInteractiveToolsContext;
	SettingsClass: Class;
	SettingsObject: UObject;
	static Load(ResourceName: string): EdMode;
	static Find(Outer: UObject, ResourceName: string): EdMode;
	static GetDefaultObject(): EdMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdMode;
	static C(Other: UObject | any): EdMode;
}

declare class InteractiveToolStack { 
	clone() : InteractiveToolStack;
	static C(Other: UObject | any): InteractiveToolStack;
}

declare class ToolStackContext extends UObject { 
	EdMode: EdMode;
	ToolStacks: Map<string, InteractiveToolStack>;
	static Load(ResourceName: string): ToolStackContext;
	static Find(Outer: UObject, ResourceName: string): ToolStackContext;
	static GetDefaultObject(): ToolStackContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolStackContext;
	static C(Other: UObject | any): ToolStackContext;
}

declare class WidgetToolsContext extends ModeManagerInteractiveToolsContext { 
	static Load(ResourceName: string): WidgetToolsContext;
	static Find(Outer: UObject, ResourceName: string): WidgetToolsContext;
	static GetDefaultObject(): WidgetToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetToolsContext;
	static C(Other: UObject | any): WidgetToolsContext;
}

declare class PIEPreviewSettings extends UObject { 
	WindowPosX: number;
	WindowPosY: number;
	WindowScalingFactor: number;
	static Load(ResourceName: string): PIEPreviewSettings;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewSettings;
	static GetDefaultObject(): PIEPreviewSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewSettings;
	static C(Other: UObject | any): PIEPreviewSettings;
}

declare type EMovieSceneCaptureProtocolState = 'Idle' | 'Initialized' | 'Capturing' | 'Finalizing' | 'EMovieSceneCaptureProtocolState_MAX';
declare var EMovieSceneCaptureProtocolState : { Idle:'Idle',Initialized:'Initialized',Capturing:'Capturing',Finalizing:'Finalizing',EMovieSceneCaptureProtocolState_MAX:'EMovieSceneCaptureProtocolState_MAX', };
declare class MovieSceneCaptureProtocolBase extends UObject { 
	State: EMovieSceneCaptureProtocolState;
	static Load(ResourceName: string): MovieSceneCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolBase;
	IsCapturing(): boolean;
	GetState(): EMovieSceneCaptureProtocolState;
	static C(Other: UObject | any): MovieSceneCaptureProtocolBase;
}

declare class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneAudioCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneAudioCaptureProtocolBase;
}

declare class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	static Load(ResourceName: string): NullAudioCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): NullAudioCaptureProtocol;
	static GetDefaultObject(): NullAudioCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullAudioCaptureProtocol;
	static C(Other: UObject | any): NullAudioCaptureProtocol;
}

declare class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	Filename: string;
	static Load(ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static GetDefaultObject(): MasterAudioSubmixCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MasterAudioSubmixCaptureProtocol;
	static C(Other: UObject | any): MasterAudioSubmixCaptureProtocol;
}

declare class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneImageCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneImageCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneImageCaptureProtocolBase;
}

declare class CompositionGraphCapturePasses { 
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject | any): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = 'HCGM_Rec709' | 'HCGM_P3DCI' | 'HCGM_Rec2020' | 'HCGM_ACES' | 'HCGM_ACEScg' | 'HCGM_Linear' | 'HCGM_MAX';
declare var EHDRCaptureGamut : { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg',HCGM_Linear:'HCGM_Linear',HCGM_MAX:'HCGM_MAX', };
declare class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	IncludeRenderPasses: CompositionGraphCapturePasses;
	bCaptureFramesInHDR: boolean;
	HDRCompressionQuality: number;
	CaptureGamut: EHDRCaptureGamut;
	PostProcessingMaterial: SoftObjectPath;
	bDisableScreenPercentage: boolean;
	PostProcessingMaterialPtr: MaterialInterface;
	static Load(ResourceName: string): CompositionGraphCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureProtocol;
	static GetDefaultObject(): CompositionGraphCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureProtocol;
	static C(Other: UObject | any): CompositionGraphCaptureProtocol;
}

declare class MovieSceneCaptureInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject | any): MovieSceneCaptureInterface;
}

declare class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase { 
	static Load(ResourceName: string): FrameGrabberProtocol;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocol;
	static GetDefaultObject(): FrameGrabberProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocol;
	static C(Other: UObject | any): FrameGrabberProtocol;
}

declare class ImageSequenceProtocol extends FrameGrabberProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol;
	static GetDefaultObject(): ImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol;
	static C(Other: UObject | any): ImageSequenceProtocol;
}

declare class CompressedImageSequenceProtocol extends ImageSequenceProtocol { 
	CompressionQuality: number;
	static Load(ResourceName: string): CompressedImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): CompressedImageSequenceProtocol;
	static GetDefaultObject(): CompressedImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompressedImageSequenceProtocol;
	static C(Other: UObject | any): CompressedImageSequenceProtocol;
}

declare class ImageSequenceProtocol_BMP extends ImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_BMP;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_BMP;
	static GetDefaultObject(): ImageSequenceProtocol_BMP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_BMP;
	static C(Other: UObject | any): ImageSequenceProtocol_BMP;
}

declare class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_PNG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_PNG;
	static GetDefaultObject(): ImageSequenceProtocol_PNG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_PNG;
	static C(Other: UObject | any): ImageSequenceProtocol_PNG;
}

declare class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_JPG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_JPG;
	static GetDefaultObject(): ImageSequenceProtocol_JPG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_JPG;
	static C(Other: UObject | any): ImageSequenceProtocol_JPG;
}

declare class ImageSequenceProtocol_EXR extends ImageSequenceProtocol { 
	bCompressed: boolean;
	CaptureGamut: EHDRCaptureGamut;
	static Load(ResourceName: string): ImageSequenceProtocol_EXR;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_EXR;
	static GetDefaultObject(): ImageSequenceProtocol_EXR;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_EXR;
	static C(Other: UObject | any): ImageSequenceProtocol_EXR;
}

declare class CaptureResolution { 
	ResX: number;
	ResY: number;
	clone() : CaptureResolution;
	static C(Other: UObject | any): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	OutputDirectory: DirectoryPath;
	GameModeOverride: UnrealEngineClass;
	OutputFormat: string;
	bOverwriteExisting: boolean;
	bUseRelativeFrameNumbers: boolean;
	HandleFrames: number;
	MovieExtension: string;
	ZeroPadFrameNumbers: number;
	FrameRate: FrameRate;
	bUseCustomFrameRate: boolean;
	CustomFrameRate: FrameRate;
	Resolution: CaptureResolution;
	bEnableTextureStreaming: boolean;
	bCinematicEngineScalability: boolean;
	bCinematicMode: boolean;
	bAllowMovement: boolean;
	bAllowTurning: boolean;
	bShowPlayer: boolean;
	bShowHUD: boolean;
	bUsePathTracer: boolean;
	PathTracerSamplePerPixel: number;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject | any): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	ImageCaptureProtocolType: SoftClassPath;
	AudioCaptureProtocolType: SoftClassPath;
	ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
	AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
	Settings: MovieSceneCaptureSettings;
	bUseSeparateProcess: boolean;
	bCloseEditorWhenCaptureStarts: boolean;
	AdditionalCommandLineArguments: string;
	InheritedCommandLineArguments: string;
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static GetDefaultObject(): MovieSceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	SetImageCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	SetAudioCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;
	GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCapture;
	RenderMovie(OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
	static RenderMovie(InCaptureSettings: MovieSceneCapture,OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
}

declare class LevelCapture extends MovieSceneCapture { 
	bAutoStartCapture: boolean;
	PrerequisiteActorId: Guid;
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static GetDefaultObject(): LevelCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject | any): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	static IsCaptureInProgress(): boolean;
	static GetCaptureFrameNumber(): number;
	static GetCaptureElapsedTime(): number;
	static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;
	static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCaptureEnvironment;
}

declare class CapturedPixelsID { 
	Identifiers: Map<string, string>;
	clone() : CapturedPixelsID;
	static C(Other: UObject | any): CapturedPixelsID;
}

declare class CapturedPixels { 
	clone() : CapturedPixels;
	static C(Other: UObject | any): CapturedPixels;
}

declare class FrameMetrics { 
	TotalElapsedTime: number;
	FrameDelta: number;
	FrameNumber: number;
	NumDroppedFrames: number;
	clone() : FrameMetrics;
	static C(Other: UObject | any): FrameMetrics;
}

declare class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	World: World;
	static Load(ResourceName: string): UserDefinedCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedCaptureProtocol;
	static GetDefaultObject(): UserDefinedCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedCaptureProtocol;
	StopCapturingFinalPixels(): void;
	StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;
	ResolveBuffer(Buffer: Texture,BufferID: CapturedPixelsID): void;
	OnWarmUp(): void;
	OnTick(): void;
	OnStartCapture(): void;
	OnSetup(): boolean;
	OnPreTick(): void;
	OnPixelsReceived(Pixels: CapturedPixels,ID: CapturedPixelsID,FrameMetrics: FrameMetrics): void;
	OnPauseCapture(): void;
	OnFinalize(): void;
	OnCaptureFrame(): void;
	OnCanFinalize(): boolean;
	OnBeginFinalize(): void;
	GetCurrentFrameMetrics(): FrameMetrics;
	GenerateFilename(InFrameMetrics: FrameMetrics): string;
	static C(Other: UObject | any): UserDefinedCaptureProtocol;
}

declare class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol { 
	Format: EDesiredImageFormat;
	bEnableCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): UserDefinedImageCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedImageCaptureProtocol;
	static GetDefaultObject(): UserDefinedImageCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedImageCaptureProtocol;
	WriteImageToDisk(PixelData: CapturedPixels,StreamID: CapturedPixelsID,FrameMetrics: FrameMetrics,bCopyImageData: boolean): void;
	GenerateFilenameForCurrentFrame(): string;
	GenerateFilenameForBuffer(Buffer: Texture,StreamID: CapturedPixelsID): string;
	static C(Other: UObject | any): UserDefinedImageCaptureProtocol;
}

declare class VideoCaptureProtocol extends FrameGrabberProtocol { 
	bUseCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): VideoCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureProtocol;
	static GetDefaultObject(): VideoCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureProtocol;
	static C(Other: UObject | any): VideoCaptureProtocol;
}

declare class SequenceRecordingBase extends UObject { 
	static Load(ResourceName: string): SequenceRecordingBase;
	static Find(Outer: UObject, ResourceName: string): SequenceRecordingBase;
	static GetDefaultObject(): SequenceRecordingBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecordingBase;
	static C(Other: UObject | any): SequenceRecordingBase;
}

declare class ActorRecordingSettings { 
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject | any): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	bRecordInWorldSpace: boolean;
	bRemoveRootAnimation: boolean;
	bAutoSaveAsset: boolean;
	SampleFrameRate: FrameRate;
	Length: number;
	Interpolation: EAnimInterpolationType;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	bRecordTransforms: boolean;
	bRecordMorphTargets: boolean;
	bRecordAttributeCurves: boolean;
	bRecordMaterialCurves: boolean;
	IncludeAnimationNames: string[];
	ExcludeAnimationNames: string[];
	clone() : AnimationRecordingSettings;
	static C(Other: UObject | any): AnimationRecordingSettings;
}

declare class ActorRecording extends SequenceRecordingBase { 
	ActorSettings: ActorRecordingSettings;
	bActive: boolean;
	bCreateLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	TargetName: string;
	TakeNumber: number;
	bSpecifyTargetAnimation: boolean;
	TargetAnimation: AnimSequence;
	AnimationSettings: AnimationRecordingSettings;
	bRecordToPossessable: boolean;
	ActorToRecord: Actor;
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static GetDefaultObject(): ActorRecording;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject | any): ActorRecording;
}

declare class AnimationRecordingParameters extends UObject { 
	SampleFrameRate: FrameRate;
	bEndAfterDuration: boolean;
	MaximumDurationSeconds: number;
	SampleRate: number;
	static Load(ResourceName: string): AnimationRecordingParameters;
	static Find(Outer: UObject, ResourceName: string): AnimationRecordingParameters;
	static GetDefaultObject(): AnimationRecordingParameters;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationRecordingParameters;
	static C(Other: UObject | any): AnimationRecordingParameters;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	bRecordTransforms: boolean;
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject | any): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderActorGroup extends UObject { 
	GroupName: string;
	SequenceName: string;
	SequenceRecordingBasePath: DirectoryPath;
	bSpecifyTargetLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	bDuplicateTargetLevelSequence: boolean;
	bRecordTargetLevelSequenceLength: boolean;
	RecordedActors: ActorRecording[];
	static Load(ResourceName: string): SequenceRecorderActorGroup;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderActorGroup;
	static GetDefaultObject(): SequenceRecorderActorGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderActorGroup;
	static C(Other: UObject | any): SequenceRecorderActorGroup;
}

declare class SequenceRecorderGroup extends Actor { 
	ActorGroups: SequenceRecorderActorGroup[];
	static GetDefaultObject(): SequenceRecorderGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderGroup;
	static C(Other: UObject | any): SequenceRecorderGroup;
}

declare class BlueprintFunctionLibrary extends UObject { 
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionLibrary;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject | any): BlueprintFunctionLibrary;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	static StopRecordingSequence(): void;
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	static IsRecordingSequence(): boolean;
	static C(Other: UObject | any): SequenceRecorderBlueprintLibrary;
}

declare type EAudioRecordingMode = 'None' | 'AudioTrack' | 'EAudioRecordingMode_MAX';
declare var EAudioRecordingMode : { None:'None',AudioTrack:'AudioTrack',EAudioRecordingMode_MAX:'EAudioRecordingMode_MAX', };
declare class SequenceRecorderActorFilter { 
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject | any): SequenceRecorderActorFilter;
}

declare class MovieSceneSequenceLoopCount { 
	Value: number;
	clone() : MovieSceneSequenceLoopCount;
	static C(Other: UObject | any): MovieSceneSequenceLoopCount;
}

declare class MovieSceneSequenceTickInterval { 
	TickIntervalSeconds: number;
	EvaluationBudgetMicroseconds: number;
	bTickWhenPaused: boolean;
	bAllowRounding: boolean;
	clone() : MovieSceneSequenceTickInterval;
	static C(Other: UObject | any): MovieSceneSequenceTickInterval;
}

declare class MovieSceneSequencePlaybackSettings { 
	bAutoPlay: boolean;
	LoopCount: MovieSceneSequenceLoopCount;
	TickInterval: MovieSceneSequenceTickInterval;
	PlayRate: number;
	StartTime: number;
	bRandomStartTime: boolean;
	bRestoreState: boolean;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	bDisableCameraCuts: boolean;
	bPauseAtEnd: boolean;
	bInheritTickIntervalFromOwner: boolean;
	clone() : MovieSceneSequencePlaybackSettings;
	static C(Other: UObject | any): MovieSceneSequencePlaybackSettings;
}

declare class MovieSceneSequencePlayerObserver extends Interface { 
	static Load(ResourceName: string): MovieSceneSequencePlayerObserver;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequencePlayerObserver;
	static GetDefaultObject(): MovieSceneSequencePlayerObserver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequencePlayerObserver;
	static C(Other: UObject | any): MovieSceneSequencePlayerObserver;
}

declare type EMovieScenePlayerStatus = 'Stopped' | 'Playing' | 'Scrubbing' | 'Jumping' | 'Stepping' | 'Paused' | 'MAX';
declare var EMovieScenePlayerStatus : { Stopped:'Stopped',Playing:'Playing',Scrubbing:'Scrubbing',Jumping:'Jumping',Stepping:'Stepping',Paused:'Paused',MAX:'MAX', };
declare class MovieSceneSequenceReplProperties { 
	LastKnownPosition: FrameTime;
	LastKnownStatus: EMovieScenePlayerStatus;
	LastKnownNumLoops: number;
	clone() : MovieSceneSequenceReplProperties;
	static C(Other: UObject | any): MovieSceneSequenceReplProperties;
}

declare class MovieScenePlaybackClient extends Interface { 
	static Load(ResourceName: string): MovieScenePlaybackClient;
	static Find(Outer: UObject, ResourceName: string): MovieScenePlaybackClient;
	static GetDefaultObject(): MovieScenePlaybackClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePlaybackClient;
	static C(Other: UObject | any): MovieScenePlaybackClient;
}

declare class MovieSceneSequenceTickManager extends UObject { 
	static Load(ResourceName: string): MovieSceneSequenceTickManager;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequenceTickManager;
	static GetDefaultObject(): MovieSceneSequenceTickManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequenceTickManager;
	static C(Other: UObject | any): MovieSceneSequenceTickManager;
}

declare type EMovieScenePositionType = 'Frame' | 'Time' | 'MarkedFrame' | 'EMovieScenePositionType_MAX';
declare var EMovieScenePositionType : { Frame:'Frame',Time:'Time',MarkedFrame:'MarkedFrame',EMovieScenePositionType_MAX:'EMovieScenePositionType_MAX', };
declare type EUpdatePositionMethod = 'Play' | 'Jump' | 'Scrub' | 'EUpdatePositionMethod_MAX';
declare var EUpdatePositionMethod : { Play:'Play',Jump:'Jump',Scrub:'Scrub',EUpdatePositionMethod_MAX:'EUpdatePositionMethod_MAX', };
declare class MovieSceneSequencePlaybackParams { 
	Frame: FrameTime;
	Time: number;
	MarkedFrame: string;
	PositionType: EMovieScenePositionType;
	UpdateMethod: EUpdatePositionMethod;
	bHasJumped: boolean;
	clone() : MovieSceneSequencePlaybackParams;
	static C(Other: UObject | any): MovieSceneSequencePlaybackParams;
	PlayTo(): void;
	static PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams): void;
}

declare class MovieSceneSequencePlayToParams { 
	bExclusive: boolean;
	clone() : MovieSceneSequencePlayToParams;
	static C(Other: UObject | any): MovieSceneSequencePlayToParams;
}

declare class MovieSceneSequencePlayer extends UObject { 
	Observer: MovieSceneSequencePlayerObserver;
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnPlayReverse: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	Status: EMovieScenePlayerStatus;
	bReversePlayback: boolean;
	Sequence: MovieSceneSequence;
	StartTime: FrameNumber;
	DurationFrames: number;
	DurationSubFrames: number;
	CurrentNumLoops: number;
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
	NetSyncProps: MovieSceneSequenceReplProperties;
	PlaybackClient: MovieScenePlaybackClient;
	TickManager: MovieSceneSequenceTickManager;
	static Load(ResourceName: string): MovieSceneSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequencePlayer;
	static GetDefaultObject(): MovieSceneSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequencePlayer;
	StopAtCurrentTime(): void;
	Stop(): void;
	SetTimeRange(StartTime: number,Duration: number): void;
	SetPlayRate(PlayRate: number): void;
	SetPlaybackPosition(PlaybackParams: MovieSceneSequencePlaybackParams): void;
	SetFrameRate(FrameRate: FrameRate): void;
	SetFrameRange(StartFrame: number,Duration: number,SubFrames: number): void;
	SetDisableCameraCuts(bInDisableCameraCuts: boolean): void;
	ScrubToSeconds(TimeInSeconds: number): void;
	ScrubToMarkedFrame(InLabel: string): boolean;
	ScrubToFrame(NewPosition: FrameTime): void;
	Scrub(): void;
	RPC_OnStopEvent(StoppedTime: FrameTime): void;
	RPC_OnFinishPlaybackEvent(StoppedTime: FrameTime): void;
	RPC_ExplicitServerUpdateEvent(Method: EUpdatePositionMethod,RelevantTime: FrameTime): void;
	RestoreState(): void;
	PlayToSeconds(TimeInSeconds: number): void;
	PlayToMarkedFrame(InLabel: string): boolean;
	PlayToFrame(NewPosition: FrameTime): void;
	PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams,PlayToParams: MovieSceneSequencePlayToParams): void;
	PlayReverse(): void;
	PlayLooping(NumLoops: number): void;
	Play(): void;
	Pause(): void;
	JumpToSeconds(TimeInSeconds: number): void;
	JumpToMarkedFrame(InLabel: string): boolean;
	JumpToFrame(NewPosition: FrameTime): void;
	IsReversed(): boolean;
	IsPlaying(): boolean;
	IsPaused(): boolean;
	GoToEndAndStop(): void;
	GetStartTime(): QualifiedFrameTime;
	GetSequenceName(bAddClientInfo: boolean): string;
	GetSequence(): MovieSceneSequence;
	GetPlayRate(): number;
	GetObjectBindings(InObject: UObject): MovieSceneObjectBindingID[];
	GetFrameRate(): FrameRate;
	GetFrameDuration(): number;
	GetEndTime(): QualifiedFrameTime;
	GetDuration(): QualifiedFrameTime;
	GetDisableCameraCuts(): boolean;
	GetCurrentTime(): QualifiedFrameTime;
	GetBoundObjects(ObjectBinding: MovieSceneObjectBindingID): UObject[];
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MovieSceneSequencePlayer;
}

declare class LevelSequencePlayer extends MovieSceneSequencePlayer { 
	OnCameraCut: UnrealEngineMulticastDelegate<(CameraComponent: CameraComponent) => void>;
	static Load(ResourceName: string): LevelSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): LevelSequencePlayer;
	static GetDefaultObject(): LevelSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequencePlayer;
	GetActiveCameraComponent(): CameraComponent;
	static CreateLevelSequencePlayer(WorldContextObject: UObject,LevelSequence: LevelSequence,Settings: MovieSceneSequencePlaybackSettings,OutActor?: LevelSequenceActor): {OutActor: LevelSequenceActor, $: LevelSequencePlayer};
	static C(Other: UObject | any): LevelSequencePlayer;
}

declare class LevelSequenceCameraSettings { 
	bOverrideAspectRatioAxisConstraint: boolean;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	clone() : LevelSequenceCameraSettings;
	static C(Other: UObject | any): LevelSequenceCameraSettings;
}

declare class LevelSequenceBurnInInitSettings extends UObject { 
	static Load(ResourceName: string): LevelSequenceBurnInInitSettings;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInInitSettings;
	static GetDefaultObject(): LevelSequenceBurnInInitSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInInitSettings;
	static C(Other: UObject | any): LevelSequenceBurnInInitSettings;
}

declare class LevelSequenceBurnInOptions extends UObject { 
	bUseBurnIn: boolean;
	BurnInClass: SoftClassPath;
	Settings: LevelSequenceBurnInInitSettings;
	static Load(ResourceName: string): LevelSequenceBurnInOptions;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInOptions;
	static GetDefaultObject(): LevelSequenceBurnInOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInOptions;
	SetBurnIn(InBurnInClass: SoftClassPath): void;
	static C(Other: UObject | any): LevelSequenceBurnInOptions;
}

declare class MovieSceneBindingOverrideData { 
	ObjectBindingID: MovieSceneObjectBindingID;
	UObject: UObject;
	bOverridesDefault: boolean;
	clone() : MovieSceneBindingOverrideData;
	static C(Other: UObject | any): MovieSceneBindingOverrideData;
}

declare class MovieSceneBindingOverrides extends UObject { 
	BindingData: MovieSceneBindingOverrideData[];
	static Load(ResourceName: string): MovieSceneBindingOverrides;
	static Find(Outer: UObject, ResourceName: string): MovieSceneBindingOverrides;
	static GetDefaultObject(): MovieSceneBindingOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBindingOverrides;
	static C(Other: UObject | any): MovieSceneBindingOverrides;
}

declare class LevelSequencePlayerSnapshot { 
	MasterName: string;
	MasterTime: QualifiedFrameTime;
	SourceTime: QualifiedFrameTime;
	CurrentShotName: string;
	CurrentShotLocalTime: QualifiedFrameTime;
	CurrentShotSourceTime: QualifiedFrameTime;
	SourceTimecode: string;
	CameraComponent: CameraComponent;
	ActiveShot: LevelSequence;
	ShotID: MovieSceneSequenceID;
	clone() : LevelSequencePlayerSnapshot;
	static C(Other: UObject | any): LevelSequencePlayerSnapshot;
}

declare class LevelSequenceBurnIn extends UserWidget { 
	FrameInformation: LevelSequencePlayerSnapshot;
	LevelSequenceActor: LevelSequenceActor;
	static Load(ResourceName: string): LevelSequenceBurnIn;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnIn;
	static GetDefaultObject(): LevelSequenceBurnIn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnIn;
	SetSettings(InSettings: UObject): void;
	GetSettingsClass(): UnrealEngineClass;
	static C(Other: UObject | any): LevelSequenceBurnIn;
}

declare class LevelSequenceActor extends Actor { 
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	SequencePlayer: LevelSequencePlayer;
	LevelSequenceAsset: LevelSequence;
	LevelSequence: SoftObjectPath;
	CameraSettings: LevelSequenceCameraSettings;
	BurnInOptions: LevelSequenceBurnInOptions;
	BindingOverrides: MovieSceneBindingOverrides;
	bAutoPlay: boolean;
	bOverrideInstanceData: boolean;
	bReplicatePlayback: boolean;
	DefaultInstanceData: UObject;
	BurnInInstance: LevelSequenceBurnIn;
	bShowBurnin: boolean;
	static GetDefaultObject(): LevelSequenceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceActor;
	ShowBurnin(): void;
	SetSequence(InSequence: LevelSequence): void;
	SetReplicatePlayback(ReplicatePlayback: boolean): void;
	SetBindingByTag(BindingTag: string,Actors: Actor[],bAllowBindingsFromAsset: boolean): void;
	SetBinding(Binding: MovieSceneObjectBindingID,Actors: Actor[],bAllowBindingsFromAsset: boolean): void;
	ResetBindings(): void;
	ResetBinding(Binding: MovieSceneObjectBindingID): void;
	RemoveBindingByTag(Tag: string,Actor: Actor): void;
	RemoveBinding(Binding: MovieSceneObjectBindingID,Actor: Actor): void;
	LoadSequence(): LevelSequence;
	HideBurnin(): void;
	GetSequencePlayer(): LevelSequencePlayer;
	GetSequence(): LevelSequence;
	FindNamedBindings(Tag: string): MovieSceneObjectBindingID[];
	FindNamedBinding(Tag: string): MovieSceneObjectBindingID;
	AddBindingByTag(BindingTag: string,Actor: Actor,bAllowBindingsFromAsset: boolean): void;
	AddBinding(Binding: MovieSceneObjectBindingID,Actor: Actor,bAllowBindingsFromAsset: boolean): void;
	static C(Other: UObject | any): LevelSequenceActor;
}

declare class PropertiesToRecordForClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject | any): PropertiesToRecordForClass;
}

declare class PropertiesToRecordForActorClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForActorClass;
	static C(Other: UObject | any): PropertiesToRecordForActorClass;
}

declare class SettingsForActorClass { 
	Class: UnrealEngineClass;
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject | any): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	bCreateLevelSequence: boolean;
	bImmersiveMode: boolean;
	SequenceLength: number;
	RecordingDelay: number;
	bAllowLooping: boolean;
	GlobalTimeDilation: number;
	bIgnoreTimeDilation: boolean;
	AnimationSubDirectory: string;
	RecordAudio: EAudioRecordingMode;
	AudioGain: number;
	bSplitAudioChannelsIntoSeparateTracks: boolean;
	bReplaceRecordedAudio: boolean;
	AudioTrackName: string;
	AudioSubDirectory: string;
	bRecordNearbySpawnedActors: boolean;
	NearbyActorRecordingProximity: number;
	bRecordWorldSettingsActor: boolean;
	bReduceKeys: boolean;
	bAutoSaveAsset: boolean;
	ActorFilter: SequenceRecorderActorFilter;
	LevelSequenceActorsToTrigger: LevelSequenceActor[];
	DefaultAnimationSettings: AnimationRecordingSettings;
	bRecordSequencerSpawnedActors: boolean;
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	ActorsAndPropertiesToRecord: PropertiesToRecordForActorClass[];
	PerActorSettings: SettingsForActorClass[];
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static GetDefaultObject(): SequenceRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject | any): SequenceRecorderSettings;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	LevelSequenceAsset: SoftObjectPath;
	ShotName: string;
	bUseCustomStartFrame: boolean;
	CustomStartFrame: FrameNumber;
	bUseCustomEndFrame: boolean;
	CustomEndFrame: FrameNumber;
	WarmUpFrameCount: number;
	DelayBeforeWarmUp: number;
	DelayBeforeShotWarmUp: number;
	DelayEveryFrame: number;
	BurnInOptions: LevelSequenceBurnInOptions;
	bWriteEditDecisionList: boolean;
	bWriteFinalCutProXML: boolean;
	LevelSequenceActor: LevelSequenceActor;
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject | any): AutomatedLevelSequenceCapture;
}

declare class BoolChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	bValue: boolean;
	static Load(ResourceName: string): BoolChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): BoolChannelKeyProxy;
	static GetDefaultObject(): BoolChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolChannelKeyProxy;
	static C(Other: UObject | any): BoolChannelKeyProxy;
}

declare class MovieSceneDoubleValue { 
	Value: number;
	Tangent: MovieSceneTangentData;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	PaddingByte: number;
	clone() : MovieSceneDoubleValue;
	static C(Other: UObject | any): MovieSceneDoubleValue;
}

declare class DoubleChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneDoubleValue;
	static Load(ResourceName: string): DoubleChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): DoubleChannelKeyProxy;
	static GetDefaultObject(): DoubleChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleChannelKeyProxy;
	static C(Other: UObject | any): DoubleChannelKeyProxy;
}

declare class FloatChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneFloatValue;
	static Load(ResourceName: string): FloatChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): FloatChannelKeyProxy;
	static GetDefaultObject(): FloatChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatChannelKeyProxy;
	static C(Other: UObject | any): FloatChannelKeyProxy;
}

declare class IntegerChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: number;
	static Load(ResourceName: string): IntegerChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): IntegerChannelKeyProxy;
	static GetDefaultObject(): IntegerChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntegerChannelKeyProxy;
	static C(Other: UObject | any): IntegerChannelKeyProxy;
}

declare class K2Node_GetSequenceBinding extends K2Node { 
	SourceSequence: SoftObjectPath;
	Binding: MovieSceneObjectBindingID;
	static Load(ResourceName: string): K2Node_GetSequenceBinding;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBinding;
	static GetDefaultObject(): K2Node_GetSequenceBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBinding;
	static C(Other: UObject | any): K2Node_GetSequenceBinding;
}

declare class MovieSceneEventBlueprintExtension extends BlueprintExtension { 
	EventSections: MovieSceneEventSectionBase[];
	static Load(ResourceName: string): MovieSceneEventBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEventBlueprintExtension;
	static GetDefaultObject(): MovieSceneEventBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventBlueprintExtension;
	static C(Other: UObject | any): MovieSceneEventBlueprintExtension;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	ComponentName: string;
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject | any): MovieSceneToolsPropertyTrackSettings;
}

declare type EMovieSceneToolsPropertyTrackType = 'FloatTrack' | 'DoubleTrack' | 'EMovieSceneToolsPropertyTrackType_MAX';
declare var EMovieSceneToolsPropertyTrackType : { FloatTrack:'FloatTrack',DoubleTrack:'DoubleTrack',EMovieSceneToolsPropertyTrackType_MAX:'EMovieSceneToolsPropertyTrackType_MAX', };
declare class MovieSceneToolsFbxSettings { 
	FbxPropertyName: string;
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	PropertyType: EMovieSceneToolsPropertyTrackType;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject | any): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	DefaultStartTime: number;
	DefaultDuration: number;
	ShotDirectory: string;
	ShotPrefix: string;
	FirstShotNumber: number;
	ShotIncrement: number;
	ShotNumDigits: number;
	TakeNumDigits: number;
	FirstTakeNumber: number;
	TakeSeparator: string;
	SubSequenceSeparator: string;
	FbxSettings: MovieSceneToolsFbxSettings[];
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject | any): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = 'Draft' | 'Normal' | 'Best' | 'EThumbnailQuality_MAX';
declare var EThumbnailQuality : { Draft:'Draft',Normal:'Normal',Best:'Best',EThumbnailQuality_MAX:'EThumbnailQuality_MAX', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	bDrawThumbnails: boolean;
	bDrawSingleThumbnails: boolean;
	ThumbnailSize: IntPoint;
	Quality: EThumbnailQuality;
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject | any): MovieSceneUserThumbnailSettings;
}

declare class ContentBrowserFrontEndFilterExtension extends UObject { 
	static Load(ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static GetDefaultObject(): ContentBrowserFrontEndFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFrontEndFilterExtension;
	static C(Other: UObject | any): ContentBrowserFrontEndFilterExtension;
}

declare class ContentBrowserAssetContextMenuContext extends UObject { 
	SelectedAssets: AssetData[];
	CommonClass: UnrealEngineClass;
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserAssetContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetContextMenuContext;
	LoadSelectedObjects(): UObject[];
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): ContentBrowserAssetContextMenuContext;
}

declare class ContentBrowserAssetViewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetViewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetViewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAssetViewContextMenuContext;
}

declare class ContentBrowserMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserMenuContext;
	static GetDefaultObject(): ContentBrowserMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserMenuContext;
	static C(Other: UObject | any): ContentBrowserMenuContext;
}

declare class ContentBrowserFolderContext extends ContentBrowserMenuContext { 
	bCanBeModified: boolean;
	bNoFolderOnDisk: boolean;
	NumAssetPaths: number;
	NumClassPaths: number;
	SelectedPackagePaths: string[];
	static Load(ResourceName: string): ContentBrowserFolderContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFolderContext;
	static GetDefaultObject(): ContentBrowserFolderContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFolderContext;
	static C(Other: UObject | any): ContentBrowserFolderContext;
}

declare class ContentBrowserFilterListContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserFilterListContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFilterListContext;
	static GetDefaultObject(): ContentBrowserFilterListContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFilterListContext;
	static C(Other: UObject | any): ContentBrowserFilterListContext;
}

declare class ContentBrowserAddNewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAddNewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAddNewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAddNewContextMenuContext;
}

declare class ContentBrowserToolbarMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserToolbarMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserToolbarMenuContext;
	static GetDefaultObject(): ContentBrowserToolbarMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserToolbarMenuContext;
	static C(Other: UObject | any): ContentBrowserToolbarMenuContext;
}

declare class TextFilterKeyValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterKeyValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandler;
	static GetDefaultObject(): TextFilterKeyValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandler;
	static C(Other: UObject | any): TextFilterKeyValueHandler;
}

declare class TextFilterKeyValueHandlerEntry { 
	Key: string;
	HandlerClass: Class;
	clone() : TextFilterKeyValueHandlerEntry;
	static C(Other: UObject | any): TextFilterKeyValueHandlerEntry;
}

declare class TextFilterKeyValueHandlers extends UObject { 
	TextFilterKeyValueHandlers: TextFilterKeyValueHandlerEntry[];
	static Load(ResourceName: string): TextFilterKeyValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandlers;
	static GetDefaultObject(): TextFilterKeyValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandlers;
	static C(Other: UObject | any): TextFilterKeyValueHandlers;
}

declare class TextFilterValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandler;
	static GetDefaultObject(): TextFilterValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandler;
	static C(Other: UObject | any): TextFilterValueHandler;
}

declare class TextFilterValueHandlers extends UObject { 
	TextFilterValueHandlers: Class[];
	static Load(ResourceName: string): TextFilterValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandlers;
	static GetDefaultObject(): TextFilterValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandlers;
	static C(Other: UObject | any): TextFilterValueHandlers;
}

declare class MotionTrailToolOptions extends UObject { 
	bShowTrails: boolean;
	TrailColor: LinearColor;
	bShowFullTrail: boolean;
	TrailThickness: number;
	FramesBefore: number;
	FramesAfter: number;
	EvalsPerFrame: number;
	bShowKeys: boolean;
	bShowFrameNumber: boolean;
	KeyColor: LinearColor;
	KeySize: number;
	bShowMarks: boolean;
	MarkColor: LinearColor;
	MarkSize: number;
	bLockMarksToFrames: boolean;
	SecondsPerMark: number;
	static Load(ResourceName: string): MotionTrailToolOptions;
	static Find(Outer: UObject, ResourceName: string): MotionTrailToolOptions;
	static GetDefaultObject(): MotionTrailToolOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrailToolOptions;
	static C(Other: UObject | any): MotionTrailToolOptions;
}

declare class MovieSceneCopyableBinding extends UObject { 
	SpawnableObjectTemplate: UObject;
	Tracks: MovieSceneTrack[];
	Binding: MovieSceneBinding;
	Spawnable: MovieSceneSpawnable;
	Possessable: MovieScenePossessable;
	BoundObjectNames: string[];
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableBinding;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableBinding;
	static GetDefaultObject(): MovieSceneCopyableBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableBinding;
	static C(Other: UObject | any): MovieSceneCopyableBinding;
}

declare class MovieSceneCopyableTrack extends UObject { 
	Track: MovieSceneTrack;
	bIsAMasterTrack: boolean;
	bIsACameraCutTrack: boolean;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableTrack;
	static GetDefaultObject(): MovieSceneCopyableTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableTrack;
	static C(Other: UObject | any): MovieSceneCopyableTrack;
}

declare class Exporter extends UObject { 
	SupportedClass: UnrealEngineClass;
	ExportRootScope: UObject;
	FormatExtension: string[];
	FormatDescription: string[];
	PreferredFormatIndex: number;
	TextIndent: number;
	bText: boolean;
	bSelectedOnly: boolean;
	bForceFileOperations: boolean;
	ExportTask: AssetExportTask;
	static Load(ResourceName: string): Exporter;
	static Find(Outer: UObject, ResourceName: string): Exporter;
	static GetDefaultObject(): Exporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Exporter;
	ScriptRunAssetExportTask(Task: AssetExportTask): boolean;
	static RunAssetExportTasks(ExportTasks: AssetExportTask[]): boolean;
	static RunAssetExportTask(Task: AssetExportTask): boolean;
	static C(Other: UObject | any): Exporter;
}

declare class AssetExportTask extends UObject { 
	UObject: UObject;
	Exporter: Exporter;
	Filename: string;
	bSelected: boolean;
	bReplaceIdentical: boolean;
	bPrompt: boolean;
	bAutomated: boolean;
	bUseFileArchive: boolean;
	bWriteEmptyFiles: boolean;
	IgnoreObjectList: UObject[];
	Options: UObject;
	Errors: string[];
	static Load(ResourceName: string): AssetExportTask;
	static Find(Outer: UObject, ResourceName: string): AssetExportTask;
	static GetDefaultObject(): AssetExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetExportTask;
	static C(Other: UObject | any): AssetExportTask;
}

declare class SequencerExportTask extends AssetExportTask { 
	SequencerContext: UObject;
	static Load(ResourceName: string): SequencerExportTask;
	static Find(Outer: UObject, ResourceName: string): SequencerExportTask;
	static GetDefaultObject(): SequencerExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerExportTask;
	static C(Other: UObject | any): SequencerExportTask;
}

declare class MovieSceneDoubleChannel extends MovieSceneChannel { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	Times: FrameNumber[];
	Values: MovieSceneDoubleValue[];
	DefaultValue: number;
	bHasDefaultValue: boolean;
	KeyHandles: MovieSceneKeyHandleMap;
	TickResolution: FrameRate;
	bShowCurve: boolean;
	clone() : MovieSceneDoubleChannel;
	static C(Other: UObject | any): MovieSceneDoubleChannel;
}

declare class MovieSceneChannelOverrideContainer extends MovieSceneSignedObject { 
	static Load(ResourceName: string): MovieSceneChannelOverrideContainer;
	static Find(Outer: UObject, ResourceName: string): MovieSceneChannelOverrideContainer;
	static GetDefaultObject(): MovieSceneChannelOverrideContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneChannelOverrideContainer;
	static C(Other: UObject | any): MovieSceneChannelOverrideContainer;
}

declare class MovieSceneSectionChannelOverrideRegistry extends UObject { 
	Overrides: Map<string, MovieSceneChannelOverrideContainer>;
	static Load(ResourceName: string): MovieSceneSectionChannelOverrideRegistry;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSectionChannelOverrideRegistry;
	static GetDefaultObject(): MovieSceneSectionChannelOverrideRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSectionChannelOverrideRegistry;
	static C(Other: UObject | any): MovieSceneSectionChannelOverrideRegistry;
}

declare class MovieScene3DTransformSectionConstraints extends UObject { 
	ConstraintsChannels: ConstraintAndActiveChannel[];
	static Load(ResourceName: string): MovieScene3DTransformSectionConstraints;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionConstraints;
	static GetDefaultObject(): MovieScene3DTransformSectionConstraints;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionConstraints;
	static C(Other: UObject | any): MovieScene3DTransformSectionConstraints;
}

declare type EShow3DTrajectory = 'EST_OnlyWhenSelected' | 'EST_Always' | 'EST_Never' | 'EST_MAX';
declare var EShow3DTrajectory : { EST_OnlyWhenSelected:'EST_OnlyWhenSelected',EST_Always:'EST_Always',EST_Never:'EST_Never',EST_MAX:'EST_MAX', };
declare class MovieScene3DTransformSection extends MovieSceneSection { 
	TransformMask: MovieSceneTransformMask;
	Translation: MovieSceneDoubleChannel;
	Rotation: MovieSceneDoubleChannel;
	Scale: MovieSceneDoubleChannel;
	ManualWeight: MovieSceneFloatChannel;
	OverrideRegistry: MovieSceneSectionChannelOverrideRegistry;
	Constraints: MovieScene3DTransformSectionConstraints;
	bUseQuaternionInterpolation: boolean;
	Show3DTrajectory: EShow3DTrajectory;
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSection;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject | any): MovieScene3DTransformSection;
}

declare class SequencerKeyActor extends Actor { 
	KeyMeshComponent: StaticMeshComponent;
	AssociatedActor: Actor;
	TrackSection: MovieScene3DTransformSection;
	KeyTime: number;
	static GetDefaultObject(): SequencerKeyActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerKeyActor;
	static C(Other: UObject | any): SequencerKeyActor;
}

declare class MovieSceneKeyStructType extends ScriptStruct { 
	SourceTimesProperty: any;
	SourceValuesProperty: any;
	DestTimeProperty: any;
	DestValueProperty: any;
	static Load(ResourceName: string): MovieSceneKeyStructType;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyStructType;
	static GetDefaultObject(): MovieSceneKeyStructType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyStructType;
	static C(Other: UObject | any): MovieSceneKeyStructType;
}

declare class SequencerMeshTrail extends Actor { 
	static GetDefaultObject(): SequencerMeshTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerMeshTrail;
	static C(Other: UObject | any): SequencerMeshTrail;
}

declare class SequencerSettingsContainer extends UObject { 
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static GetDefaultObject(): SequencerSettingsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject | any): SequencerSettingsContainer;
}

declare type EAutoChangeMode = 'AutoKey' | 'AutoTrack' | 'All' | 'None' | 'EAutoChangeMode_MAX';
declare var EAutoChangeMode : { AutoKey:'AutoKey',AutoTrack:'AutoTrack',All:'All',None:'None',EAutoChangeMode_MAX:'EAutoChangeMode_MAX', };
declare type EAllowEditsMode = 'AllEdits' | 'AllowSequencerEditsOnly' | 'AllowLevelEditsOnly' | 'EAllowEditsMode_MAX';
declare var EAllowEditsMode : { AllEdits:'AllEdits',AllowSequencerEditsOnly:'AllowSequencerEditsOnly',AllowLevelEditsOnly:'AllowLevelEditsOnly',EAllowEditsMode_MAX:'EAllowEditsMode_MAX', };
declare type EKeyGroupMode = 'KeyChanged' | 'KeyGroup' | 'KeyAll' | 'EKeyGroupMode_MAX';
declare var EKeyGroupMode : { KeyChanged:'KeyChanged',KeyGroup:'KeyGroup',KeyAll:'KeyAll',EKeyGroupMode_MAX:'EKeyGroupMode_MAX', };
declare type EMovieSceneKeyInterpolation = 'Auto' | 'User' | 'Break' | 'Linear' | 'Constant' | 'EMovieSceneKeyInterpolation_MAX';
declare var EMovieSceneKeyInterpolation : { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant',EMovieSceneKeyInterpolation_MAX:'EMovieSceneKeyInterpolation_MAX', };
declare type ESequencerSpawnPosition = 'SSP_Origin' | 'SSP_PlaceInFrontOfCamera' | 'SSP_MAX';
declare var ESequencerSpawnPosition : { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera',SSP_MAX:'SSP_MAX', };
declare type ESequencerZoomPosition = 'SZP_CurrentTime' | 'SZP_MousePosition' | 'SZP_MAX';
declare var ESequencerZoomPosition : { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition',SZP_MAX:'SZP_MAX', };
declare type ESequencerLoopMode = 'SLM_NoLoop' | 'SLM_Loop' | 'SLM_LoopSelectionRange' | 'SLM_MAX';
declare var ESequencerLoopMode : { SLM_NoLoop:'SLM_NoLoop',SLM_Loop:'SLM_Loop',SLM_LoopSelectionRange:'SLM_LoopSelectionRange',SLM_MAX:'SLM_MAX', };
declare type EFrameNumberDisplayFormats = 'NonDropFrameTimecode' | 'DropFrameTimecode' | 'Seconds' | 'Frames' | 'MAX_Count' | 'EFrameNumberDisplayFormats_MAX';
declare var EFrameNumberDisplayFormats : { NonDropFrameTimecode:'NonDropFrameTimecode',DropFrameTimecode:'DropFrameTimecode',Seconds:'Seconds',Frames:'Frames',MAX_Count:'MAX_Count',EFrameNumberDisplayFormats_MAX:'EFrameNumberDisplayFormats_MAX', };
declare class SequencerSettings extends UObject { 
	AutoChangeMode: EAutoChangeMode;
	AllowEditsMode: EAllowEditsMode;
	KeyGroupMode: EKeyGroupMode;
	KeyInterpolation: EMovieSceneKeyInterpolation;
	bAutoSetTrackDefaults: boolean;
	SpawnPosition: ESequencerSpawnPosition;
	bCreateSpawnableCameras: boolean;
	bShowRangeSlider: boolean;
	bIsSnapEnabled: boolean;
	bSnapKeyTimesToInterval: boolean;
	bSnapKeyTimesToKeys: boolean;
	bSnapSectionTimesToInterval: boolean;
	bSnapSectionTimesToSections: boolean;
	bSnapKeysAndSectionsToPlayRange: boolean;
	bSnapPlayTimeToKeys: boolean;
	bSnapPlayTimeToSections: boolean;
	bSnapPlayTimeToMarkers: boolean;
	bSnapPlayTimeToInterval: boolean;
	bSnapPlayTimeToPressedKey: boolean;
	bSnapPlayTimeToDraggedKey: boolean;
	bSnapCurveValueToInterval: boolean;
	bShowSelectedNodesOnly: boolean;
	bRewindOnRecord: boolean;
	bLeftMouseDragDoesMarquee: boolean;
	ZoomPosition: ESequencerZoomPosition;
	bAutoScrollEnabled: boolean;
	bLinkCurveEditorTimeRange: boolean;
	bSynchronizeCurveEditorSelection: boolean;
	bIsolateCurveEditorToSelection: boolean;
	LoopMode: ESequencerLoopMode;
	bKeepCursorInPlayRangeWhileScrubbing: boolean;
	bKeepPlayRangeInSectionBounds: boolean;
	ZeroPadFrames: number;
	JumpFrameIncrement: FrameNumber;
	bShowLayerBars: boolean;
	bShowKeyBars: boolean;
	bInfiniteKeyAreas: boolean;
	bShowChannelColors: boolean;
	bShowStatusBar: boolean;
	bShowTickLines: boolean;
	bShowSequencerToolbar: boolean;
	KeyAreaCurveExtents: string;
	KeyAreaHeightWithCurves: number;
	ReduceKeysTolerance: number;
	bDeleteKeysWhenTrimming: boolean;
	bDisableSectionsAfterBaking: boolean;
	bCleanPlaybackMode: boolean;
	bActivateRealtimeViewports: boolean;
	bEvaluateSubSequencesInIsolation: boolean;
	bRerunConstructionScripts: boolean;
	bShowDebugVisualization: boolean;
	bVisualizePreAndPostRoll: boolean;
	bCompileDirectorOnEvaluate: boolean;
	TrajectoryPathCap: number;
	FrameNumberDisplayFormat: EFrameNumberDisplayFormats;
	MovieRendererName: string;
	bAutoExpandNodesOnSelection: boolean;
	TreeViewWidth: number;
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static GetDefaultObject(): SequencerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject | any): SequencerSettings;
}

declare class SequencerToolMenuContext extends UObject { 
	static Load(ResourceName: string): SequencerToolMenuContext;
	static Find(Outer: UObject, ResourceName: string): SequencerToolMenuContext;
	static GetDefaultObject(): SequencerToolMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerToolMenuContext;
	static C(Other: UObject | any): SequencerToolMenuContext;
}

declare class SequencerTrackFilterExtension extends UObject { 
	static Load(ResourceName: string): SequencerTrackFilterExtension;
	static Find(Outer: UObject, ResourceName: string): SequencerTrackFilterExtension;
	static GetDefaultObject(): SequencerTrackFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerTrackFilterExtension;
	static C(Other: UObject | any): SequencerTrackFilterExtension;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	static Load(ResourceName: string): SoundNode;
	static Find(Outer: UObject, ResourceName: string): SoundNode;
	static GetDefaultObject(): SoundNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject | any): SoundNode;
}

declare class SoundCue extends SoundBase { 
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: SoundAttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	SubtitlePriority: number;
	bPrimeOnLoad: boolean;
	bOverrideAttenuation: boolean;
	bExcludeFromRandomNodeBranchCulling: boolean;
	bHasPlayWhenSilent: boolean;
	CookedQualityIndex: number;
	static Load(ResourceName: string): SoundCue;
	static Find(Outer: UObject, ResourceName: string): SoundCue;
	static GetDefaultObject(): SoundCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject | any): SoundCue;
	PrimeSoundCueForPlayback(): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
}

declare class VREditorAssetContainer extends DataAsset { 
	DockableWindowCloseSound: SoundBase;
	DockableWindowOpenSound: SoundBase;
	DockableWindowDropSound: SoundBase;
	DockableWindowDragSound: SoundBase;
	DropFromContentBrowserSound: SoundBase;
	RadialMenuOpenSound: SoundBase;
	RadialMenuCloseSound: SoundBase;
	TeleportSound: SoundBase;
	ButtonPressSound: SoundCue;
	AutoScaleSound: SoundBase;
	GenericHMDMesh: StaticMesh;
	PlaneMesh: StaticMesh;
	CylinderMesh: StaticMesh;
	LaserPointerStartMesh: StaticMesh;
	LaserPointerMesh: StaticMesh;
	LaserPointerEndMesh: StaticMesh;
	LaserPointerHoverMesh: StaticMesh;
	VivePreControllerMesh: StaticMesh;
	OculusControllerMesh: StaticMesh;
	GenericControllerMesh: StaticMesh;
	TeleportRootMesh: StaticMesh;
	WindowMesh: StaticMesh;
	WindowSelectionBarMesh: StaticMesh;
	WindowCloseButtonMesh: StaticMesh;
	RadialMenuMainMesh: StaticMesh;
	RadialMenuPointerMesh: StaticMesh;
	PointerCursorMesh: StaticMesh;
	LineSegmentCylinderMesh: StaticMesh;
	JointSphereMesh: StaticMesh;
	DockingButtonMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	LaserPointerMaterial: MaterialInterface;
	LaserPointerTranslucentMaterial: MaterialInterface;
	WorldMovementPostProcessMaterial: Material;
	TextMaterial: MaterialInterface;
	VivePreControllerMaterial: MaterialInterface;
	OculusControllerMaterial: MaterialInterface;
	TeleportMaterial: MaterialInterface;
	WindowMaterial: MaterialInterface;
	WindowTranslucentMaterial: MaterialInterface;
	LineMaterial: Material;
	TranslucentTextMaterial: MaterialInterface;
	WidgetMaterial: MaterialInterface;
	CameraWidgetMaterial: MaterialInterface;
	TextFont: Font;
	static Load(ResourceName: string): VREditorAssetContainer;
	static Find(Outer: UObject, ResourceName: string): VREditorAssetContainer;
	static GetDefaultObject(): VREditorAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAssetContainer;
	static C(Other: UObject | any): VREditorAssetContainer;
}

declare class EditorWorldExtensionActorData { 
	Actor: Actor;
	bValidForPIE: boolean;
	clone() : EditorWorldExtensionActorData;
	static C(Other: UObject | any): EditorWorldExtensionActorData;
}

declare class EditorWorldExtension extends UObject { 
	ExtensionActors: EditorWorldExtensionActorData[];
	static Load(ResourceName: string): EditorWorldExtension;
	static Find(Outer: UObject, ResourceName: string): EditorWorldExtension;
	static GetDefaultObject(): EditorWorldExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorWorldExtension;
	static C(Other: UObject | any): EditorWorldExtension;
}

declare class PostProcessComponent extends SceneComponent { 
	Settings: PostProcessSettings;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	bEnabled: boolean;
	bUnbound: boolean;
	static Load(ResourceName: string): PostProcessComponent;
	static Find(Outer: UObject, ResourceName: string): PostProcessComponent;
	static GetDefaultObject(): PostProcessComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PostProcessComponent;
	static C(Other: UObject | any): PostProcessComponent;
}

declare class VREditorAvatarActor extends Actor { 
	HeadMeshComponent: StaticMeshComponent;
	WorldMovementGridMeshComponent: StaticMeshComponent;
	WorldMovementGridMID: MaterialInstanceDynamic;
	WorldMovementGridOpacity: number;
	bIsDrawingWorldMovementPostProcess: boolean;
	WorldMovementPostProcessMaterial: MaterialInstanceDynamic;
	ScaleProgressMeshComponent: StaticMeshComponent;
	CurrentScaleProgressMeshComponent: StaticMeshComponent;
	UserScaleIndicatorText: TextRenderComponent;
	FixedUserScaleMID: MaterialInstanceDynamic;
	TranslucentFixedUserScaleMID: MaterialInstanceDynamic;
	CurrentUserScaleMID: MaterialInstanceDynamic;
	TranslucentCurrentUserScaleMID: MaterialInstanceDynamic;
	PostProcessComponent: PostProcessComponent;
	VRMode: VREditorMode;
	static GetDefaultObject(): VREditorAvatarActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAvatarActor;
	static C(Other: UObject | any): VREditorAvatarActor;
}

declare class VREditorBaseActor extends Actor { 
	VRMode: VREditorMode;
	static GetDefaultObject(): VREditorBaseActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseActor;
	static C(Other: UObject | any): VREditorBaseActor;
}

declare class VREditorFloatingUICreationContext { 
	WidgetClass: UnrealEngineClass;
	PanelID: string;
	ParentActor: Actor;
	PanelSpawnOffset: Transform;
	PanelSize: Vector2D;
	PanelMesh: StaticMesh;
	EditorUISize: number;
	bHideWindowHandles: boolean;
	bMaskOutWidgetBackground: boolean;
	bNoCloseButton: boolean;
	clone() : VREditorFloatingUICreationContext;
	static C(Other: UObject | any): VREditorFloatingUICreationContext;
}

declare type EWidgetSpace = 'World' | 'Screen' | 'EWidgetSpace_MAX';
declare var EWidgetSpace : { World:'World',Screen:'Screen',EWidgetSpace_MAX:'EWidgetSpace_MAX', };
declare type EWidgetTimingPolicy = 'RealTime' | 'GameTime' | 'EWidgetTimingPolicy_MAX';
declare var EWidgetTimingPolicy : { RealTime:'RealTime',GameTime:'GameTime',EWidgetTimingPolicy_MAX:'EWidgetTimingPolicy_MAX', };
declare type EWindowVisibility = 'Visible' | 'SelfHitTestInvisible' | 'EWindowVisibility_MAX';
declare var EWindowVisibility : { Visible:'Visible',SelfHitTestInvisible:'SelfHitTestInvisible',EWindowVisibility_MAX:'EWindowVisibility_MAX', };
declare type EWidgetBlendMode = 'Opaque' | 'Masked' | 'Transparent' | 'EWidgetBlendMode_MAX';
declare var EWidgetBlendMode : { Opaque:'Opaque',Masked:'Masked',Transparent:'Transparent',EWidgetBlendMode_MAX:'EWidgetBlendMode_MAX', };
declare type EWidgetGeometryMode = 'Plane' | 'Cylinder' | 'EWidgetGeometryMode_MAX';
declare var EWidgetGeometryMode : { Plane:'Plane',Cylinder:'Cylinder',EWidgetGeometryMode_MAX:'EWidgetGeometryMode_MAX', };
declare type ETickMode = 'Disabled' | 'Enabled' | 'Automatic' | 'ETickMode_MAX';
declare var ETickMode : { Disabled:'Disabled',Enabled:'Enabled',Automatic:'Automatic',ETickMode_MAX:'ETickMode_MAX', };
declare class WidgetComponent extends MeshComponent { 
	Space: EWidgetSpace;
	TimingPolicy: EWidgetTimingPolicy;
	WidgetClass: UnrealEngineClass;
	DrawSize: IntPoint;
	bManuallyRedraw: boolean;
	bRedrawRequested: boolean;
	RedrawTime: number;
	CurrentDrawSize: IntPoint;
	bDrawAtDesiredSize: boolean;
	Pivot: Vector2D;
	bReceiveHardwareInput: boolean;
	bWindowFocusable: boolean;
	WindowVisibility: EWindowVisibility;
	bApplyGammaCorrection: boolean;
	OwnerPlayer: LocalPlayer;
	BackgroundColor: LinearColor;
	TintColorAndOpacity: LinearColor;
	OpacityFromTexture: number;
	BlendMode: EWidgetBlendMode;
	bIsTwoSided: boolean;
	TickWhenOffscreen: boolean;
	BodySetup: BodySetup;
	TranslucentMaterial: MaterialInterface;
	TranslucentMaterial_OneSided: MaterialInterface;
	OpaqueMaterial: MaterialInterface;
	OpaqueMaterial_OneSided: MaterialInterface;
	MaskedMaterial: MaterialInterface;
	MaskedMaterial_OneSided: MaterialInterface;
	RenderTarget: TextureRenderTarget2D;
	MaterialInstance: MaterialInstanceDynamic;
	bAddedToScreen: boolean;
	bEditTimeUsable: boolean;
	SharedLayerName: string;
	LayerZOrder: number;
	GeometryMode: EWidgetGeometryMode;
	CylinderArcAngle: number;
	TickMode: ETickMode;
	Widget: UserWidget;
	static Load(ResourceName: string): WidgetComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetComponent;
	static GetDefaultObject(): WidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetComponent;
	SetWindowVisibility(InVisibility: EWindowVisibility): void;
	SetWindowFocusable(bInWindowFocusable: boolean): void;
	SetWidgetSpace(NewSpace: EWidgetSpace): void;
	SetWidget(Widget: UserWidget): void;
	SetTwoSided(bWantTwoSided: boolean): void;
	SetTintColorAndOpacity(NewTintColorAndOpacity: LinearColor): void;
	SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean): void;
	SetTickMode(InTickMode: ETickMode): void;
	SetRedrawTime(InRedrawTime: number): void;
	SetPivot(InPivot: Vector2D): void;
	SetOwnerPlayer(LocalPlayer: LocalPlayer): void;
	SetManuallyRedraw(bUseManualRedraw: boolean): void;
	SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;
	SetDrawSize(Size: Vector2D): void;
	SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean): void;
	SetCylinderArcAngle(InCylinderArcAngle: number): void;
	SetBackgroundColor(NewBackgroundColor: LinearColor): void;
	RequestRenderUpdate(): void;
	RequestRedraw(): void;
	IsWidgetVisible(): boolean;
	GetWindowVisiblility(): EWindowVisibility;
	GetWindowFocusable(): boolean;
	GetWidgetSpace(): EWidgetSpace;
	GetWidget(): UserWidget;
	GetUserWidgetObject(): UserWidget;
	GetTwoSided(): boolean;
	GetTickWhenOffscreen(): boolean;
	GetRenderTarget(): TextureRenderTarget2D;
	GetRedrawTime(): number;
	GetPivot(): Vector2D;
	GetOwnerPlayer(): LocalPlayer;
	GetMaterialInstance(): MaterialInstanceDynamic;
	GetManuallyRedraw(): boolean;
	GetGeometryMode(): EWidgetGeometryMode;
	GetDrawSize(): Vector2D;
	GetDrawAtDesiredSize(): boolean;
	GetCylinderArcAngle(): number;
	GetCurrentDrawSize(): Vector2D;
	static C(Other: UObject | any): WidgetComponent;
}

declare type EVREditorWidgetDrawingPolicy = 'Always' | 'Hovering' | 'EVREditorWidgetDrawingPolicy_MAX';
declare var EVREditorWidgetDrawingPolicy : { Always:'Always',Hovering:'Hovering',EVREditorWidgetDrawingPolicy_MAX:'EVREditorWidgetDrawingPolicy_MAX', };
declare class VREditorWidgetComponent extends WidgetComponent { 
	DrawingPolicy: EVREditorWidgetDrawingPolicy;
	bIsHovering: boolean;
	bHasEverDrawn: boolean;
	static Load(ResourceName: string): VREditorWidgetComponent;
	static Find(Outer: UObject, ResourceName: string): VREditorWidgetComponent;
	static GetDefaultObject(): VREditorWidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorWidgetComponent;
	static C(Other: UObject | any): VREditorWidgetComponent;
}

declare class VREditorFloatingUI extends VREditorBaseActor { 
	CreationContext: VREditorFloatingUICreationContext;
	UserWidget: UserWidget;
	WidgetComponent: VREditorWidgetComponent;
	WindowMeshComponent: StaticMeshComponent;
	UserWidgetClass: UnrealEngineClass;
	static GetDefaultObject(): VREditorFloatingUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorFloatingUI;
	static C(Other: UObject | any): VREditorFloatingUI;
}

declare class VREditorRadialFloatingUI extends VREditorBaseActor { 
	WidgetComponents: VREditorWidgetComponent[];
	WindowMeshComponent: StaticMeshComponent;
	ArrowMeshComponent: StaticMeshComponent;
	CentralWidgetComponent: VREditorWidgetComponent;
	static GetDefaultObject(): VREditorRadialFloatingUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorRadialFloatingUI;
	static C(Other: UObject | any): VREditorRadialFloatingUI;
}

declare class ViewportDragOperation extends UObject { 
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static GetDefaultObject(): ViewportDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject | any): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	DragOperation: ViewportDragOperation;
	DragOperationSubclass: UnrealEngineClass;
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject | any): ViewportDragOperationComponent;
}

declare class VREditorDockableWindow extends VREditorFloatingUI { 
	DockButtonMeshComponent: StaticMeshComponent;
	SelectionBarMeshComponent: StaticMeshComponent;
	CloseButtonMeshComponent: StaticMeshComponent;
	DockButtonMID: MaterialInstanceDynamic;
	SelectionBarMID: MaterialInstanceDynamic;
	SelectionBarTranslucentMID: MaterialInstanceDynamic;
	CloseButtonMID: MaterialInstanceDynamic;
	CloseButtonTranslucentMID: MaterialInstanceDynamic;
	DragOperationComponent: ViewportDragOperationComponent;
	static GetDefaultObject(): VREditorDockableWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorDockableWindow;
	static C(Other: UObject | any): VREditorDockableWindow;
}

declare class ViewportActionKeyInput { 
	ActionType: string;
	Event: EInputEvent;
	bIsInputCaptured: boolean;
	bIsAxis: boolean;
	clone() : ViewportActionKeyInput;
	static C(Other: UObject | any): ViewportActionKeyInput;
}

declare class ViewportTransformer extends UObject { 
	ViewportWorldInteraction: ViewportWorldInteraction;
	static Load(ResourceName: string): ViewportTransformer;
	static Find(Outer: UObject, ResourceName: string): ViewportTransformer;
	static GetDefaultObject(): ViewportTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportTransformer;
	Shutdown(): void;
	ShouldCenterTransformGizmoPivot(): boolean;
	OnStopDragging(Interactor: ViewportInteractor): void;
	OnStartDragging(Interactor: ViewportInteractor): void;
	Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
	CanAlignToActors(): boolean;
	static C(Other: UObject | any): ViewportTransformer;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject | any): GizmoHandle;
}

declare class GizmoHandleGroup extends SceneComponent { 
	GizmoMaterial: MaterialInterface;
	TranslucentGizmoMaterial: MaterialInterface;
	Handles: GizmoHandle[];
	OwningTransformGizmoActor: BaseTransformGizmo;
	DragOperationComponent: ViewportDragOperationComponent;
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static GetDefaultObject(): GizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject | any): GizmoHandleGroup;
}

declare class BaseTransformGizmo extends Actor { 
	SceneComponent: SceneComponent;
	AllHandleGroups: GizmoHandleGroup[];
	WorldInteraction: ViewportWorldInteraction;
	static GetDefaultObject(): BaseTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject | any): BaseTransformGizmo;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static GetDefaultObject(): MouseCursorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject | any): MouseCursorInteractor;
}

declare class ViewportInteractionAssetContainer extends DataAsset { 
	GizmoHandleSelectedSound: SoundBase;
	GizmoHandleDropSound: SoundBase;
	SelectionChangeSound: SoundBase;
	SelectionDropSound: SoundBase;
	SelectionStartDragSound: SoundBase;
	GridSnapSound: SoundBase;
	ActorSnapSound: SoundBase;
	UndoSound: SoundBase;
	RedoSound: SoundBase;
	GridMesh: StaticMesh;
	TranslationHandleMesh: StaticMesh;
	UniformScaleHandleMesh: StaticMesh;
	ScaleHandleMesh: StaticMesh;
	PlaneTranslationHandleMesh: StaticMesh;
	RotationHandleMesh: StaticMesh;
	RotationHandleSelectedMesh: StaticMesh;
	StartRotationIndicatorMesh: StaticMesh;
	CurrentRotationIndicatorMesh: StaticMesh;
	FreeRotationHandleMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	TransformGizmoMaterial: MaterialInterface;
	TranslucentTransformGizmoMaterial: MaterialInterface;
	static Load(ResourceName: string): ViewportInteractionAssetContainer;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractionAssetContainer;
	static GetDefaultObject(): ViewportInteractionAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractionAssetContainer;
	static C(Other: UObject | any): ViewportInteractionAssetContainer;
}

declare class ViewportWorldInteraction extends EditorWorldExtension { 
	Interactors: ViewportInteractor[];
	ViewportTransformer: ViewportTransformer;
	TransformGizmoActor: BaseTransformGizmo;
	SnapGridActor: Actor;
	SnapGridMeshComponent: StaticMeshComponent;
	SnapGridMID: MaterialInstanceDynamic;
	DefaultMouseCursorInteractor: MouseCursorInteractor;
	ActorsToExcludeFromHitTest: Actor[];
	AssetContainer: ViewportInteractionAssetContainer;
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static GetDefaultObject(): ViewportWorldInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	SetWorldToMetersScale(NewWorldToMetersScale: number,bCompensateRoomWorldScale: boolean): void;
	SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;
	SetHeadTransform(NewHeadTransform: Transform): void;
	RemoveInteractor(Interactor: ViewportInteractor): void;
	GetWorldScaleFactor(): number;
	GetTransformGizmoActor(): BaseTransformGizmo;
	GetRoomTransform(): Transform;
	GetRoomSpaceHeadTransform(): Transform;
	GetInteractors(): ViewportInteractor[];
	GetHeadTransform(): Transform;
	AddInteractor(Interactor: ViewportInteractor): void;
	AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: Actor): void;
	static C(Other: UObject | any): ViewportWorldInteraction;
}

declare type EHitResultGizmoFilterMode = 'All' | 'NoGizmos' | 'GizmosOnly' | 'EHitResultGizmoFilterMode_MAX';
declare var EHitResultGizmoFilterMode : { All:'All',NoGizmos:'NoGizmos',GizmosOnly:'GizmosOnly',EHitResultGizmoFilterMode_MAX:'EHitResultGizmoFilterMode_MAX', };
declare type EViewportInteractionDraggingMode = 'Nothing' | 'TransformablesWithGizmo' | 'TransformablesAtLaserImpact' | 'AssistingDrag' | 'TransformablesFreely' | 'World' | 'Interactable' | 'Material' | 'EViewportInteractionDraggingMode_MAX';
declare var EViewportInteractionDraggingMode : { Nothing:'Nothing',TransformablesWithGizmo:'TransformablesWithGizmo',TransformablesAtLaserImpact:'TransformablesAtLaserImpact',AssistingDrag:'AssistingDrag',TransformablesFreely:'TransformablesFreely',World:'World',Interactable:'Interactable',Material:'Material',EViewportInteractionDraggingMode_MAX:'EViewportInteractionDraggingMode_MAX', };
declare class ViewportInteractor extends UObject { 
	KeyToActionMap: Map<Key, ViewportActionKeyInput>;
	WorldInteraction: ViewportWorldInteraction;
	OtherInteractor: ViewportInteractor;
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static GetDefaultObject(): ViewportInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	Tick(DeltaTime: number): void;
	Shutdown(): void;
	SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;
	SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;
	SetCanCarry(bInCanCarry: boolean): void;
	IsHoveringOverGizmo(): boolean;
	HandleInputKey_BP(Action: ViewportActionKeyInput,Key: Key,Event: EInputEvent,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	HandleInputAxis_BP(Action: ViewportActionKeyInput,Key: Key,Delta: number,DeltaTime: number,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	GetWorldInteraction(): ViewportWorldInteraction;
	GetTransformAndForwardVector(OutHandTransform?: Transform,OutForwardVector?: Vector): {OutHandTransform: Transform, OutForwardVector: Vector, $: boolean};
	GetTransform(): Transform;
	GetRoomSpaceTransform(): Transform;
	GetOtherInteractor(): ViewportInteractor;
	GetLastTransform(): Transform;
	GetLastRoomSpaceTransform(): Transform;
	GetLaserPointer(LaserPointerStart?: Vector,LaserPointerEnd?: Vector,bEvenIfBlocked?: boolean,LaserLengthOverride?: number): {LaserPointerStart: Vector, LaserPointerEnd: Vector, $: boolean};
	GetHoverLocation(): Vector;
	GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;
	GetDraggingMode(): EViewportInteractionDraggingMode;
	CanCarry(): boolean;
	static C(Other: UObject | any): ViewportInteractor;
}

declare class MotionControllerComponent extends PrimitiveComponent { 
	PlayerIndex: number;
	Hand: EControllerHand;
	MotionSource: string;
	bDisableLowLatencyUpdate: boolean;
	CurrentTrackingStatus: ETrackingStatus;
	bDisplayDeviceModel: boolean;
	DisplayModelSource: string;
	CustomDisplayMesh: StaticMesh;
	DisplayMeshMaterialOverrides: MaterialInterface[];
	DisplayComponent: PrimitiveComponent;
	static Load(ResourceName: string): MotionControllerComponent;
	static Find(Outer: UObject, ResourceName: string): MotionControllerComponent;
	static GetDefaultObject(): MotionControllerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionControllerComponent;
	SetTrackingSource(NewSource: EControllerHand): void;
	SetTrackingMotionSource(NewSource: string): void;
	SetShowDeviceModel(bShowControllerModel: boolean): void;
	SetDisplayModelSource(NewDisplayModelSource: string): void;
	SetCustomDisplayMesh(NewDisplayMesh: StaticMesh): void;
	SetAssociatedPlayerIndex(NewPlayer: number): void;
	OnMotionControllerUpdated(): void;
	IsTracked(): boolean;
	GetTrackingSource(): EControllerHand;
	GetParameterValue(InName: string,bValueFound?: boolean): {bValueFound: boolean, $: number};
	GetHandJointPosition(jointIndex: number,bValueFound?: boolean): {bValueFound: boolean, $: Vector};
	static C(Other: UObject | any): MotionControllerComponent;
	DisableMotionTrackingForComponent(): void;
	EnableMotionTrackingForComponent(): boolean;
	IsMotionTrackingEnabledForComponent(): boolean;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
}

declare type EInterpCurveMode = 'CIM_Linear' | 'CIM_CurveAuto' | 'CIM_Constant' | 'CIM_CurveUser' | 'CIM_CurveBreak' | 'CIM_CurveAutoClamped' | 'CIM_MAX';
declare var EInterpCurveMode : { CIM_Linear:'CIM_Linear',CIM_CurveAuto:'CIM_CurveAuto',CIM_Constant:'CIM_Constant',CIM_CurveUser:'CIM_CurveUser',CIM_CurveBreak:'CIM_CurveBreak',CIM_CurveAutoClamped:'CIM_CurveAutoClamped',CIM_MAX:'CIM_MAX', };
declare class InterpCurvePointVector { 
	InVal: number;
	OutVal: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector;
	static C(Other: UObject | any): InterpCurvePointVector;
}

declare class InterpCurveVector { 
	Points: InterpCurvePointVector[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveVector;
	static C(Other: UObject | any): InterpCurveVector;
}

declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineMetadata extends UObject { 
	static Load(ResourceName: string): SplineMetadata;
	static Find(Outer: UObject, ResourceName: string): SplineMetadata;
	static GetDefaultObject(): SplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadata;
	static C(Other: UObject | any): SplineMetadata;
}

declare class SplineCurves { 
	Position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	MetaData: SplineMetadata;
	Version: number;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World' | 'ESplineCoordinateSpace_MAX';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World',ESplineCoordinateSpace_MAX:'ESplineCoordinateSpace_MAX', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent' | 'ESplinePointType_MAX';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent',ESplinePointType_MAX:'ESplinePointType_MAX', };
declare class SplinePoint { 
	InputKey: number;
	Position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	EditorTangentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentColor(TangentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetScaleAtSplinePoint(PointIndex: number,InScaleVector: Vector,bUpdateSpline: boolean): void;
	SetRotationAtSplinePoint(PointIndex: number,InRotation: Rotator,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(Index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetVectorPropertyAtSplinePoint(Index: number,PropertyName: string): Vector;
	GetVectorPropertyAtSplineInputKey(InKey: number,PropertyName: string): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTimeAtDistanceAlongSpline(Distance: number): number;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtSplineInputKey(InKey: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplineSegments(): number;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyValueAtDistanceAlongSpline(Distance: number): number;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetFloatPropertyAtSplinePoint(Index: number,PropertyName: string): number;
	GetFloatPropertyAtSplineInputKey(InKey: number,PropertyName: string): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	DivideSplineIntoPolylineRecursiveWithDistances(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[],OutDistancesAlongSpline?: number[]): {OutPoints: Vector[], OutDistancesAlongSpline: number[], $: boolean};
	DivideSplineIntoPolylineRecursive(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineToPolyLine(CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineSegmentToPolyLine(SplinePointStartIndex: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(Position: Vector): void;
	AddSplinePointAtIndex(Position: Vector,Index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(Position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(Position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndScale: Vector2D;
	EndTangent: Vector;
	EndRoll: number;
	EndOffset: Vector2D;
	clone() : SplineMeshParams;
	static C(Other: UObject | any): SplineMeshParams;
}

declare type ESplineMeshAxis = 'X' | 'Y' | 'Z' | 'ESplineMeshAxis_MAX';
declare var ESplineMeshAxis : { X:'X',Y:'Y',Z:'Z',ESplineMeshAxis_MAX:'ESplineMeshAxis_MAX', };
declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	SplineBoundaryMin: number;
	CachedMeshBodySetupGuid: Guid;
	BodySetup: BodySetup;
	SplineBoundaryMax: number;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	bMeshDirty: boolean;
	ForwardAxis: ESplineMeshAxis;
	VirtualTextureMainPassMaxDrawDistance: number;
	bSelected: boolean;
	static Load(ResourceName: string): SplineMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SplineMeshComponent;
	static GetDefaultObject(): SplineMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	UpdateMesh(): void;
	SetStartTangent(StartTangent: Vector,bUpdateMesh: boolean): void;
	SetStartScale(StartScale: Vector2D,bUpdateMesh: boolean): void;
	SetStartRoll(StartRoll: number,bUpdateMesh: boolean): void;
	SetStartPosition(StartPos: Vector,bUpdateMesh: boolean): void;
	SetStartOffset(StartOffset: Vector2D,bUpdateMesh: boolean): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector,bUpdateMesh: boolean): void;
	SetSplineUpDir(InSplineUpDir: Vector,bUpdateMesh: boolean): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis,bUpdateMesh: boolean): void;
	SetEndTangent(EndTangent: Vector,bUpdateMesh: boolean): void;
	SetEndScale(EndScale: Vector2D,bUpdateMesh: boolean): void;
	SetEndRoll(EndRoll: number,bUpdateMesh: boolean): void;
	SetEndPosition(EndPos: Vector,bUpdateMesh: boolean): void;
	SetEndOffset(EndOffset: Vector2D,bUpdateMesh: boolean): void;
	SetBoundaryMin(InBoundaryMin: number,bUpdateMesh: boolean): void;
	SetBoundaryMax(InBoundaryMax: number,bUpdateMesh: boolean): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
	static C(Other: UObject | any): SplineMeshComponent;
}

declare type ECastRayTracedShadow = 'Disabled' | 'UseProjectSetting' | 'Enabled' | 'ECastRayTracedShadow_MAX';
declare var ECastRayTracedShadow : { Disabled:'Disabled',UseProjectSetting:'UseProjectSetting',Enabled:'Enabled',ECastRayTracedShadow_MAX:'ECastRayTracedShadow_MAX', };
declare class LightComponentBase extends SceneComponent { 
	LightGuid: Guid;
	Brightness: number;
	Intensity: number;
	LightColor: Color;
	bAffectsWorld: boolean;
	CastShadows: boolean;
	CastStaticShadows: boolean;
	CastDynamicShadows: boolean;
	bAffectTranslucentLighting: boolean;
	bTransmission: boolean;
	bCastVolumetricShadow: boolean;
	bCastDeepShadow: boolean;
	bCastRaytracedShadow: boolean;
	CastRaytracedShadow: ECastRayTracedShadow;
	bAffectReflection: boolean;
	bAffectGlobalIllumination: boolean;
	DeepShadowLayerDistribution: number;
	IndirectLightingIntensity: number;
	VolumetricScatteringIntensity: number;
	SamplesPerPixel: number;
	StaticEditorTexture: Texture2D;
	StaticEditorTextureScale: number;
	DynamicEditorTexture: Texture2D;
	DynamicEditorTextureScale: number;
	static Load(ResourceName: string): LightComponentBase;
	static Find(Outer: UObject, ResourceName: string): LightComponentBase;
	static GetDefaultObject(): LightComponentBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponentBase;
	SetSamplesPerPixel(NewValue: number): void;
	SetCastVolumetricShadow(bNewValue: boolean): void;
	SetCastShadows(bNewValue: boolean): void;
	SetCastRaytracedShadows(bNewValue: ECastRayTracedShadow): void;
	SetCastRaytracedShadow(bNewValue: boolean): void;
	SetCastDeepShadow(bNewValue: boolean): void;
	SetAffectReflection(bNewValue: boolean): void;
	SetAffectGlobalIllumination(bNewValue: boolean): void;
	GetLightColor(): LinearColor;
	static C(Other: UObject | any): LightComponentBase;
}

declare class TextureLightProfile extends Texture2D { 
	Brightness: number;
	TextureMultiplier: number;
	static Load(ResourceName: string): TextureLightProfile;
	static Find(Outer: UObject, ResourceName: string): TextureLightProfile;
	static GetDefaultObject(): TextureLightProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureLightProfile;
	static C(Other: UObject | any): TextureLightProfile;
}

declare class LightComponent extends LightComponentBase { 
	Temperature: number;
	MaxDrawDistance: number;
	MaxDistanceFadeRange: number;
	bUseTemperature: boolean;
	ShadowMapChannel: number;
	MinRoughness: number;
	SpecularScale: number;
	ShadowResolutionScale: number;
	ShadowBias: number;
	ShadowSlopeBias: number;
	ShadowSharpen: number;
	ContactShadowLength: number;
	ContactShadowLengthInWS: boolean;
	InverseSquaredFalloff: boolean;
	CastTranslucentShadows: boolean;
	bCastShadowsFromCinematicObjectsOnly: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bForceCachedShadowsForMovablePrimitives: boolean;
	LightingChannels: LightingChannels;
	LightFunctionMaterial: MaterialInterface;
	LightFunctionScale: Vector;
	IESTexture: TextureLightProfile;
	bUseIESBrightness: boolean;
	IESBrightnessScale: number;
	LightFunctionFadeDistance: number;
	DisabledBrightness: number;
	bEnableLightShaftBloom: boolean;
	BloomScale: number;
	BloomThreshold: number;
	BloomMaxBrightness: number;
	BloomTint: Color;
	bUseRayTracedDistanceFieldShadows: boolean;
	RayStartOffsetDepthScale: number;
	static Load(ResourceName: string): LightComponent;
	static Find(Outer: UObject, ResourceName: string): LightComponent;
	static GetDefaultObject(): LightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponent;
	SetVolumetricScatteringIntensity(NewIntensity: number): void;
	SetUseTemperature(bNewValue: boolean): void;
	SetUseIESBrightness(bNewValue: boolean): void;
	SetTransmission(bNewValue: boolean): void;
	SetTemperature(NewTemperature: number): void;
	SetSpecularScale(NewValue: number): void;
	SetShadowSlopeBias(NewValue: number): void;
	SetShadowBias(NewValue: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightFunctionScale(NewLightFunctionScale: Vector): void;
	SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
	SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
	SetLightFunctionDisabledBrightness(NewValue: number): void;
	SetLightFColor(NewLightColor: Color): void;
	SetLightColor(NewLightColor: LinearColor,bSRGB: boolean): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetIESTexture(NewValue: TextureLightProfile): void;
	SetIESBrightnessScale(NewValue: number): void;
	SetForceCachedShadowsForMovablePrimitives(bNewValue: boolean): void;
	SetEnableLightShaftBloom(bNewValue: boolean): void;
	SetBloomTint(NewValue: Color): void;
	SetBloomThreshold(NewValue: number): void;
	SetBloomScale(NewValue: number): void;
	SetBloomMaxBrightness(NewValue: number): void;
	SetAffectTranslucentLighting(bNewValue: boolean): void;
	SetAffectDynamicIndirectLighting(bNewValue: boolean): void;
	static C(Other: UObject | any): LightComponent;
}

declare type ELightUnits = 'Unitless' | 'Candelas' | 'Lumens' | 'ELightUnits_MAX';
declare var ELightUnits : { Unitless:'Unitless',Candelas:'Candelas',Lumens:'Lumens',ELightUnits_MAX:'ELightUnits_MAX', };
declare class LightmassLightSettings { 
	IndirectLightingSaturation: number;
	ShadowExponent: number;
	bUseAreaShadowsForStationaryLight: boolean;
	clone() : LightmassLightSettings;
	static C(Other: UObject | any): LightmassLightSettings;
}

declare class LightmassPointLightSettings extends LightmassLightSettings { 
	clone() : LightmassPointLightSettings;
	static C(Other: UObject | any): LightmassPointLightSettings;
}

declare class LocalLightComponent extends LightComponent { 
	IntensityUnits: ELightUnits;
	InverseExposureBlend: number;
	Radius: number;
	AttenuationRadius: number;
	LightmassSettings: LightmassPointLightSettings;
	static Load(ResourceName: string): LocalLightComponent;
	static Find(Outer: UObject, ResourceName: string): LocalLightComponent;
	static GetDefaultObject(): LocalLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalLightComponent;
	SetIntensityUnits(NewIntensityUnits: ELightUnits): void;
	SetAttenuationRadius(NewRadius: number): void;
	static GetUnitsConversionFactor(SrcUnits: ELightUnits,TargetUnits: ELightUnits,CosHalfConeAngle: number): number;
	static C(Other: UObject | any): LocalLightComponent;
}

declare class PointLightComponent extends LocalLightComponent { 
	bUseInverseSquaredFalloff: boolean;
	LightFalloffExponent: number;
	SourceRadius: number;
	SoftSourceRadius: number;
	SourceLength: number;
	static Load(ResourceName: string): PointLightComponent;
	static Find(Outer: UObject, ResourceName: string): PointLightComponent;
	static GetDefaultObject(): PointLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLightComponent;
	SetUseInverseSquaredFalloff(bNewValue: boolean): void;
	SetSourceRadius(bNewValue: number): void;
	SetSourceLength(NewValue: number): void;
	SetSoftSourceRadius(bNewValue: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
	SetInverseExposureBlend(NewInverseExposureBlend: number): void;
	static C(Other: UObject | any): PointLightComponent;
}

declare type EControllerType = 'Laser' | 'AssistingLaser' | 'UI' | 'Navigation' | 'Unknown' | 'EControllerType_MAX';
declare var EControllerType : { Laser:'Laser',AssistingLaser:'AssistingLaser',UI:'UI',Navigation:'Navigation',Unknown:'Unknown',EControllerType_MAX:'EControllerType_MAX', };
declare class VREditorTeleporter extends Actor { 
	VRMode: VREditorMode;
	TeleportDirectionMeshComponent: StaticMeshComponent;
	HMDMeshComponent: StaticMeshComponent;
	LeftMotionControllerMeshComponent: StaticMeshComponent;
	RightMotionControllerMeshComponent: StaticMeshComponent;
	TeleportMID: MaterialInstanceDynamic;
	InteractorTryingTeleport: ViewportInteractor;
	static GetDefaultObject(): VREditorTeleporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorTeleporter;
	TeleportDone(): void;
	StopAiming(): void;
	StartTeleport(): void;
	StartAiming(Interactor: ViewportInteractor): void;
	Shutdown(): void;
	SetVisibility(bVisible: boolean): void;
	SetColor(Color: LinearColor): void;
	IsTeleporting(): boolean;
	IsAiming(): boolean;
	Init(InMode: VREditorMode): void;
	GetVRMode(): VREditorMode;
	GetSlideDelta(Interactor: VREditorInteractor,Axis: boolean): number;
	GetInteractorTryingTeleport(): ViewportInteractor;
	DoTeleport(): void;
	static C(Other: UObject | any): VREditorTeleporter;
}

declare class VREditorInteractor extends ViewportInteractor { 
	bIsUndoRedoSwipeEnabled: boolean;
	MotionControllerComponent: MotionControllerComponent;
	LaserMotionControllerComponent: MotionControllerComponent;
	HandMeshComponent: StaticMeshComponent;
	LaserSplineComponent: SplineComponent;
	LaserSplineMeshComponents: SplineMeshComponent[];
	LaserPointerMID: MaterialInstanceDynamic;
	TranslucentLaserPointerMID: MaterialInstanceDynamic;
	HoverMeshComponent: StaticMeshComponent;
	HoverPointLightComponent: PointLightComponent;
	HandMeshMID: MaterialInstanceDynamic;
	OwningAvatar: Actor;
	ControllerType: EControllerType;
	OverrideControllerType: EControllerType;
	ControllerMotionSource: string;
	VRMode: VREditorMode;
	static Load(ResourceName: string): VREditorInteractor;
	static Find(Outer: UObject, ResourceName: string): VREditorInteractor;
	static GetDefaultObject(): VREditorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorInteractor;
	UpdateHandMeshRelativeTransform(): void;
	TryOverrideControllerType(InControllerType: EControllerType): boolean;
	SetupComponent(OwningActor: Actor): void;
	SetForceShowLaser(bInForceShow: boolean): void;
	SetForceLaserColor(InColor: LinearColor): void;
	SetControllerType(InControllerType: EControllerType): void;
	SetControllerHandSide(InControllerHandSide: string): void;
	ReplaceHandMeshComponent(NewMesh: StaticMesh,MeshScale: Vector): void;
	IsTouchingTrackpad(): boolean;
	IsHoveringOverUI(): boolean;
	IsClickingOnUI(): boolean;
	Init(InVRMode: VREditorMode): void;
	GetTrackpadPosition(): Vector2D;
	GetTeleportActor(): VREditorTeleporter;
	GetSlideDelta(): number;
	GetSelectAndMoveTriggerValue(): number;
	GetMotionControllerComponent(): MotionControllerComponent;
	GetLastTrackpadPosition(): Vector2D;
	GetLaserStart(): Vector;
	GetLaserEnd(): Vector;
	GetHMDDeviceType(): string;
	GetControllerType(): EControllerType;
	GetControllerSide(): EControllerHand;
	GetControllerHandSide(): string;
	static C(Other: UObject | any): VREditorInteractor;
}

declare class VRButton { 
	ButtonWidget: VREditorWidgetComponent;
	clone() : VRButton;
	static C(Other: UObject | any): VRButton;
}

declare class VRRadialMenuHandler extends UObject { 
	static Load(ResourceName: string): VRRadialMenuHandler;
	static Find(Outer: UObject, ResourceName: string): VRRadialMenuHandler;
	static GetDefaultObject(): VRRadialMenuHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRRadialMenuHandler;
	static C(Other: UObject | any): VRRadialMenuHandler;
}

declare class VREditorUISystem extends UObject { 
	VRMode: VREditorMode;
	FloatingUIs: Map<string, VREditorFloatingUI>;
	PreviewWindowInfo: Map<string, Actor>;
	InfoDisplayPanel: VREditorFloatingUI;
	QuickRadialMenu: VREditorRadialFloatingUI;
	DraggingUI: VREditorDockableWindow;
	ColorPickerUI: VREditorDockableWindow;
	LaserInteractor: VREditorInteractor;
	UIInteractor: VREditorInteractor;
	VRButtons: VRButton[];
	RadialMenuHandler: VRRadialMenuHandler;
	static Load(ResourceName: string): VREditorUISystem;
	static Find(Outer: UObject, ResourceName: string): VREditorUISystem;
	static GetDefaultObject(): VREditorUISystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorUISystem;
	static C(Other: UObject | any): VREditorUISystem;
}

declare class VREditorPlacement extends UObject { 
	VRMode: VREditorMode;
	ViewportWorldInteraction: ViewportWorldInteraction;
	FloatingUIAssetDraggedFrom: WidgetComponent;
	PlacingMaterialOrTextureAsset: UObject;
	static Load(ResourceName: string): VREditorPlacement;
	static Find(Outer: UObject, ResourceName: string): VREditorPlacement;
	static GetDefaultObject(): VREditorPlacement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorPlacement;
	static C(Other: UObject | any): VREditorPlacement;
}

declare class VREditorMode extends EditorWorldExtension { 
	AvatarActor: VREditorAvatarActor;
	UISystem: VREditorUISystem;
	TeleportActor: VREditorTeleporter;
	AutoScalerSystem: VREditorAutoScaler;
	WorldInteraction: ViewportWorldInteraction;
	PlacementSystem: VREditorPlacement;
	Interactors: VREditorInteractor[];
	InteractorClass: Class;
	TeleporterClass: Class;
	AssetContainer: VREditorAssetContainer;
	static Load(ResourceName: string): VREditorMode;
	static Find(Outer: UObject, ResourceName: string): VREditorMode;
	static GetDefaultObject(): VREditorMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorMode;
	SetGameView(bGameView: boolean): void;
	IsInGameView(): boolean;
	GetWorldScaleFactor(): number;
	static C(Other: UObject | any): VREditorMode;
}

declare class VREditorAutoScaler extends UObject { 
	VRMode: VREditorMode;
	static Load(ResourceName: string): VREditorAutoScaler;
	static Find(Outer: UObject, ResourceName: string): VREditorAutoScaler;
	static GetDefaultObject(): VREditorAutoScaler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAutoScaler;
	static C(Other: UObject | any): VREditorAutoScaler;
}

declare class VREditorBaseUserWidget extends UserWidget { 
	Owner: VREditorFloatingUI;
	static Load(ResourceName: string): VREditorBaseUserWidget;
	static Find(Outer: UObject, ResourceName: string): VREditorBaseUserWidget;
	static GetDefaultObject(): VREditorBaseUserWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseUserWidget;
	static C(Other: UObject | any): VREditorBaseUserWidget;
}

declare class VREditorCameraWidgetComponent extends VREditorWidgetComponent { 
	static Load(ResourceName: string): VREditorCameraWidgetComponent;
	static Find(Outer: UObject, ResourceName: string): VREditorCameraWidgetComponent;
	static GetDefaultObject(): VREditorCameraWidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorCameraWidgetComponent;
	static C(Other: UObject | any): VREditorCameraWidgetComponent;
}

declare class VREditorDockableCameraWindow extends VREditorDockableWindow { 
	static GetDefaultObject(): VREditorDockableCameraWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorDockableCameraWindow;
	static C(Other: UObject | any): VREditorDockableCameraWindow;
}

declare class DockableWindowDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): DockableWindowDragOperation;
	static Find(Outer: UObject, ResourceName: string): DockableWindowDragOperation;
	static GetDefaultObject(): DockableWindowDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DockableWindowDragOperation;
	static C(Other: UObject | any): DockableWindowDragOperation;
}

declare class VREditorFloatingCameraUI extends VREditorFloatingUI { 
	OffsetFromCamera: Vector;
	LinkedActor: Actor;
	static GetDefaultObject(): VREditorFloatingCameraUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorFloatingCameraUI;
	static C(Other: UObject | any): VREditorFloatingCameraUI;
}

declare class FloatingText extends Actor { 
	SceneComponent: SceneComponent;
	FirstLineComponent: StaticMeshComponent;
	JointSphereComponent: StaticMeshComponent;
	SecondLineComponent: StaticMeshComponent;
	TextComponent: TextRenderComponent;
	MaskedTextMaterial: MaterialInterface;
	TranslucentTextMaterial: MaterialInterface;
	LineMaterial: MaterialInterface;
	LineMaterialMID: MaterialInstanceDynamic;
	static GetDefaultObject(): FloatingText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatingText;
	static C(Other: UObject | any): FloatingText;
}

declare class VISettings extends UObject { 
	bScaleWorldFromFloor: boolean;
	bScaleWorldWithDynamicPivot: boolean;
	bAllowSimultaneousWorldScalingAndRotation: boolean;
	static Load(ResourceName: string): VISettings;
	static Find(Outer: UObject, ResourceName: string): VISettings;
	static GetDefaultObject(): VISettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VISettings;
	static C(Other: UObject | any): VISettings;
}

declare type EInteractorHand = 'Right' | 'Left' | 'EInteractorHand_MAX';
declare var EInteractorHand : { Right:'Right',Left:'Left',EInteractorHand_MAX:'EInteractorHand_MAX', };
declare class VRModeSettings extends VISettings { 
	bEnableAutoVREditMode: boolean;
	bAutokeySequences: boolean;
	InteractorHand: EInteractorHand;
	bShowWorldMovementGrid: boolean;
	bShowWorldMovementPostProcess: boolean;
	bShowWorldScaleProgressBar: boolean;
	UIBrightness: number;
	GizmoScale: number;
	DoubleClickTime: number;
	TriggerPressedThreshold_Vive: number;
	TriggerPressedThreshold_Rift: number;
	InteractorClass: Class;
	TeleporterClass: Class;
	ModeClass: Class;
	static Load(ResourceName: string): VRModeSettings;
	static Find(Outer: UObject, ResourceName: string): VRModeSettings;
	static GetDefaultObject(): VRModeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRModeSettings;
	static C(Other: UObject | any): VRModeSettings;
}

declare type EGizmoHandleTypes = 'All' | 'Translate' | 'Rotate' | 'Scale' | 'EGizmoHandleTypes_MAX';
declare var EGizmoHandleTypes : { All:'All',Translate:'Translate',Rotate:'Rotate',Scale:'Scale',EGizmoHandleTypes_MAX:'EGizmoHandleTypes_MAX', };
declare class VRScoutingInteractor extends VREditorInteractor { 
	FlyingIndicatorComponent: StaticMeshComponent;
	EditorOnlyInputComponent: InputComponent;
	bReceivesEditorInput: boolean;
	static Load(ResourceName: string): VRScoutingInteractor;
	static Find(Outer: UObject, ResourceName: string): VRScoutingInteractor;
	static GetDefaultObject(): VRScoutingInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRScoutingInteractor;
	SetReceivesEditorInput(bInValue: boolean): void;
	SetGizmoMode(InGizmoMode: EGizmoHandleTypes): void;
	static GetSelectedActors(): Actor[];
	GetReceivesEditorInput(): boolean;
	GetInputComponent(): InputComponent;
	GetGizmoMode(): EGizmoHandleTypes;
	static C(Other: UObject | any): VRScoutingInteractor;
}

declare type ELocalizationTargetConflictStatus = 'Unknown' | 'ConflictsPresent' | 'Clear' | 'ELocalizationTargetConflictStatus_MAX';
declare var ELocalizationTargetConflictStatus : { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear',ELocalizationTargetConflictStatus_MAX:'ELocalizationTargetConflictStatus_MAX', };
declare type ELocalizationGatherPathRoot = 'Auto' | 'Engine' | 'Project' | 'ELocalizationGatherPathRoot_MAX';
declare var ELocalizationGatherPathRoot : { Auto:'Auto',Engine:'Engine',Project:'Project',ELocalizationGatherPathRoot_MAX:'ELocalizationGatherPathRoot_MAX', };
declare class GatherTextSearchDirectory { 
	PathRoot: ELocalizationGatherPathRoot;
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject | any): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject | any): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject | any): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	IsEnabled: boolean;
	SearchDirectories: GatherTextSearchDirectory[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject | any): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject | any): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	Collections: string[];
	ExcludeClasses: SoftClassPath[];
	ShouldExcludeDerivedClasses: boolean;
	ShouldGatherFromEditorOnlyData: boolean;
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject | any): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject | any): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject | any): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	MetaDataKey: MetaDataKeyName;
	TextNamespace: string;
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject | any): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	KeySpecifications: MetaDataKeyGatherSpecification[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject | any): GatherTextFromMetaDataConfiguration;
}

declare type ELocalizedTextCollapseMode = 'IdenticalTextIdAndSource' | 'IdenticalPackageIdTextIdAndSource' | 'IdenticalNamespaceAndSource' | 'ELocalizedTextCollapseMode_MAX';
declare var ELocalizedTextCollapseMode : { IdenticalTextIdAndSource:'IdenticalTextIdAndSource',IdenticalPackageIdTextIdAndSource:'IdenticalPackageIdTextIdAndSource',IdenticalNamespaceAndSource:'IdenticalNamespaceAndSource',ELocalizedTextCollapseMode_MAX:'ELocalizedTextCollapseMode_MAX', };
declare type EPortableObjectFormat = 'Unreal' | 'Crowdin' | 'EPortableObjectFormat_MAX';
declare var EPortableObjectFormat : { Unreal:'Unreal',Crowdin:'Crowdin',EPortableObjectFormat_MAX:'EPortableObjectFormat_MAX', };
declare class LocalizationExportingSettings { 
	CollapseMode: ELocalizedTextCollapseMode;
	POFormat: EPortableObjectFormat;
	ShouldPersistCommentsOnExport: boolean;
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject | any): LocalizationExportingSettings;
}

declare class LocalizationCompilationSettings { 
	SkipSourceCheck: boolean;
	ValidateFormatPatterns: boolean;
	ValidateSafeWhitespace: boolean;
	clone() : LocalizationCompilationSettings;
	static C(Other: UObject | any): LocalizationCompilationSettings;
}

declare class LocalizationImportDialogueSettings { 
	RawAudioPath: DirectoryPath;
	ImportedDialogueFolder: string;
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject | any): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	CultureName: string;
	WordCount: number;
	clone() : CultureStatistics;
	static C(Other: UObject | any): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	Name: string;
	Guid: Guid;
	ConflictStatus: ELocalizationTargetConflictStatus;
	TargetDependencies: Guid[];
	AdditionalManifestDependencies: FilePath[];
	RequiredModuleNames: string[];
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	ExportSettings: LocalizationExportingSettings;
	CompileSettings: LocalizationCompilationSettings;
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	NativeCultureIndex: number;
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject | any): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	Settings: LocalizationTargetSettings;
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static GetDefaultObject(): LocalizationTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject | any): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	TargetObjects: LocalizationTarget[];
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static GetDefaultObject(): LocalizationTargetSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject | any): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	EngineTargetSet: LocalizationTargetSet;
	EngineTargetsSettings: LocalizationTargetSettings[];
	GameTargetSet: LocalizationTargetSet;
	GameTargetsSettings: LocalizationTargetSettings[];
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static GetDefaultObject(): LocalizationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject | any): LocalizationSettings;
}

declare class AutomatedAssetImportData extends UObject { 
	GroupName: string;
	Filenames: string[];
	DestinationPath: string;
	FactoryName: string;
	bReplaceExisting: boolean;
	bSkipReadOnly: boolean;
	Factory: Factory;
	LevelToLoad: string;
	static Load(ResourceName: string): AutomatedAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AutomatedAssetImportData;
	static GetDefaultObject(): AutomatedAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedAssetImportData;
	static C(Other: UObject | any): AutomatedAssetImportData;
}

declare class AssetImportTask extends UObject { 
	Filename: string;
	DestinationPath: string;
	DestinationName: string;
	bReplaceExisting: boolean;
	bReplaceExistingSettings: boolean;
	bAutomated: boolean;
	bSave: boolean;
	bAsync: boolean;
	Factory: Factory;
	Options: UObject;
	ImportedObjectPaths: string[];
	Result: UObject[];
	static Load(ResourceName: string): AssetImportTask;
	static Find(Outer: UObject, ResourceName: string): AssetImportTask;
	static GetDefaultObject(): AssetImportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportTask;
	IsAsyncImportComplete(): boolean;
	GetObjects(): UObject[];
	static C(Other: UObject | any): AssetImportTask;
}

declare class Factory extends UObject { 
	bCreateNew: boolean;
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	AutomatedImportData: AutomatedAssetImportData;
	AssetImportTask: AssetImportTask;
	OverwriteYesOrNoToAllState: number;
	static Load(ResourceName: string): Factory;
	static Find(Outer: UObject, ResourceName: string): Factory;
	static GetDefaultObject(): Factory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	ScriptFactoryCreateFile(InTask: AssetImportTask): boolean;
	ScriptFactoryCanImport(Filename: string): boolean;
	static C(Other: UObject | any): Factory;
}

declare class RuntimeVirtualTextureFactory extends Factory { 
	static Load(ResourceName: string): RuntimeVirtualTextureFactory;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureFactory;
	static GetDefaultObject(): RuntimeVirtualTextureFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureFactory;
	static C(Other: UObject | any): RuntimeVirtualTextureFactory;
}

declare class ThumbnailRenderer extends UObject { 
	static Load(ResourceName: string): ThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): ThumbnailRenderer;
	static GetDefaultObject(): ThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailRenderer;
	static C(Other: UObject | any): ThumbnailRenderer;
}

declare class DefaultSizedThumbnailRenderer extends ThumbnailRenderer { 
	DefaultSizeX: number;
	DefaultSizeY: number;
	static Load(ResourceName: string): DefaultSizedThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): DefaultSizedThumbnailRenderer;
	static GetDefaultObject(): DefaultSizedThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultSizedThumbnailRenderer;
	static C(Other: UObject | any): DefaultSizedThumbnailRenderer;
}

declare class RuntimeVirtualTextureThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): RuntimeVirtualTextureThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureThumbnailRenderer;
	static GetDefaultObject(): RuntimeVirtualTextureThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureThumbnailRenderer;
	static C(Other: UObject | any): RuntimeVirtualTextureThumbnailRenderer;
}

declare class VirtualTextureBuilderFactory extends Factory { 
	static Load(ResourceName: string): VirtualTextureBuilderFactory;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilderFactory;
	static GetDefaultObject(): VirtualTextureBuilderFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilderFactory;
	static C(Other: UObject | any): VirtualTextureBuilderFactory;
}

declare class TextureThumbnailRenderer extends ThumbnailRenderer { 
	static Load(ResourceName: string): TextureThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): TextureThumbnailRenderer;
	static GetDefaultObject(): TextureThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureThumbnailRenderer;
	static C(Other: UObject | any): TextureThumbnailRenderer;
}

declare class VirtualTextureBuilderThumbnailRenderer extends TextureThumbnailRenderer { 
	static Load(ResourceName: string): VirtualTextureBuilderThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilderThumbnailRenderer;
	static GetDefaultObject(): VirtualTextureBuilderThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilderThumbnailRenderer;
	static C(Other: UObject | any): VirtualTextureBuilderThumbnailRenderer;
}

declare type EMeshTrackerVertexColorMode = 'None' | 'Confidence' | 'Block' | 'EMeshTrackerVertexColorMode_MAX';
declare var EMeshTrackerVertexColorMode : { None:'None',Confidence:'Confidence',Block:'Block',EMeshTrackerVertexColorMode_MAX:'EMeshTrackerVertexColorMode_MAX', };
declare class MockDataMeshTrackerComponent extends SceneComponent { 
	OnMeshTrackerUpdated: UnrealEngineMulticastDelegate<(Index: number, Vertices: Vector[], Triangles: number[], Normals: Vector[], Confidence: number[]) => void>;
	ScanWorld: boolean;
	RequestNormals: boolean;
	RequestVertexConfidence: boolean;
	VertexColorMode: EMeshTrackerVertexColorMode;
	BlockVertexColors: Color[];
	VertexColorFromConfidenceZero: LinearColor;
	VertexColorFromConfidenceOne: LinearColor;
	UpdateInterval: number;
	MRMesh: MRMeshComponent;
	static Load(ResourceName: string): MockDataMeshTrackerComponent;
	static Find(Outer: UObject, ResourceName: string): MockDataMeshTrackerComponent;
	static GetDefaultObject(): MockDataMeshTrackerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MockDataMeshTrackerComponent;
	DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	static C(Other: UObject | any): MockDataMeshTrackerComponent;
}

declare class MeshReconstructorBase extends UObject { 
	static Load(ResourceName: string): MeshReconstructorBase;
	static Find(Outer: UObject, ResourceName: string): MeshReconstructorBase;
	static GetDefaultObject(): MeshReconstructorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshReconstructorBase;
	StopReconstruction(): void;
	StartReconstruction(): void;
	PauseReconstruction(): void;
	IsReconstructionStarted(): boolean;
	IsReconstructionPaused(): boolean;
	DisconnectMRMesh(): void;
	ConnectMRMesh(Mesh: MRMeshComponent): void;
	static C(Other: UObject | any): MeshReconstructorBase;
}

declare class ARComponent extends SceneComponent { 
	NativeID: Guid;
	bUseDefaultReplication: boolean;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	MRMeshComponent: MRMeshComponent;
	MyTrackedGeometry: ARTrackedGeometry;
	static Load(ResourceName: string): ARComponent;
	static Find(Outer: UObject, ResourceName: string): ARComponent;
	static GetDefaultObject(): ARComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARComponent;
	UpdateVisualization(): void;
	SetNativeID(NativeID: Guid): void;
	ReceiveRemove(): void;
	OnRep_Payload(): void;
	GetMRMesh(): MRMeshComponent;
	static C(Other: UObject | any): ARComponent;
}

declare class ARActor extends Actor { 
	static GetDefaultObject(): ARActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARActor;
	AddARComponent(InComponentClass: UnrealEngineClass,NativeID: Guid): ARComponent;
	static C(Other: UObject | any): ARActor;
}

declare type EARCaptureType = 'Camera' | 'QRCode' | 'SpatialMapping' | 'SceneUnderstanding' | 'HandMesh' | 'EARCaptureType_MAX';
declare var EARCaptureType : { Camera:'Camera',QRCode:'QRCode',SpatialMapping:'SpatialMapping',SceneUnderstanding:'SceneUnderstanding',HandMesh:'HandMesh',EARCaptureType_MAX:'EARCaptureType_MAX', };
declare type EARWorldAlignment = 'Gravity' | 'GravityAndHeading' | 'Camera' | 'EARWorldAlignment_MAX';
declare var EARWorldAlignment : { Gravity:'Gravity',GravityAndHeading:'GravityAndHeading',Camera:'Camera',EARWorldAlignment_MAX:'EARWorldAlignment_MAX', };
declare type EARSessionType = 'None' | 'Orientation' | 'World' | 'Face' | 'Image' | 'ObjectScanning' | 'PoseTracking' | 'GeoTracking' | 'EARSessionType_MAX';
declare var EARSessionType : { None:'None',Orientation:'Orientation',World:'World',Face:'Face',Image:'Image',ObjectScanning:'ObjectScanning',PoseTracking:'PoseTracking',GeoTracking:'GeoTracking',EARSessionType_MAX:'EARSessionType_MAX', };
declare type EARPlaneDetectionMode = 'None' | 'HorizontalPlaneDetection' | 'VerticalPlaneDetection' | 'EARPlaneDetectionMode_MAX';
declare var EARPlaneDetectionMode : { None:'None',HorizontalPlaneDetection:'HorizontalPlaneDetection',VerticalPlaneDetection:'VerticalPlaneDetection',EARPlaneDetectionMode_MAX:'EARPlaneDetectionMode_MAX', };
declare type EARLightEstimationMode = 'None' | 'AmbientLightEstimate' | 'DirectionalLightEstimate' | 'EARLightEstimationMode_MAX';
declare var EARLightEstimationMode : { None:'None',AmbientLightEstimate:'AmbientLightEstimate',DirectionalLightEstimate:'DirectionalLightEstimate',EARLightEstimationMode_MAX:'EARLightEstimationMode_MAX', };
declare type EARFrameSyncMode = 'SyncTickWithCameraImage' | 'SyncTickWithoutCameraImage' | 'EARFrameSyncMode_MAX';
declare var EARFrameSyncMode : { SyncTickWithCameraImage:'SyncTickWithCameraImage',SyncTickWithoutCameraImage:'SyncTickWithoutCameraImage',EARFrameSyncMode_MAX:'EARFrameSyncMode_MAX', };
declare type EARCandidateImageOrientation = 'Landscape' | 'Portrait' | 'EARCandidateImageOrientation_MAX';
declare var EARCandidateImageOrientation : { Landscape:'Landscape',Portrait:'Portrait',EARCandidateImageOrientation_MAX:'EARCandidateImageOrientation_MAX', };
declare class ARCandidateImage extends DataAsset { 
	CandidateTexture: Texture2D;
	FriendlyName: string;
	Width: number;
	Height: number;
	Orientation: EARCandidateImageOrientation;
	static Load(ResourceName: string): ARCandidateImage;
	static Find(Outer: UObject, ResourceName: string): ARCandidateImage;
	static GetDefaultObject(): ARCandidateImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateImage;
	GetPhysicalWidth(): number;
	GetPhysicalHeight(): number;
	GetOrientation(): EARCandidateImageOrientation;
	GetFriendlyName(): string;
	GetCandidateTexture(): Texture2D;
	static C(Other: UObject | any): ARCandidateImage;
}

declare type EAREnvironmentCaptureProbeType = 'None' | 'Manual' | 'Automatic' | 'EAREnvironmentCaptureProbeType_MAX';
declare var EAREnvironmentCaptureProbeType : { None:'None',Manual:'Manual',Automatic:'Automatic',EAREnvironmentCaptureProbeType_MAX:'EAREnvironmentCaptureProbeType_MAX', };
declare class ARCandidateObject extends DataAsset { 
	CandidateObjectData: number[];
	FriendlyName: string;
	BoundingBox: Box;
	static Load(ResourceName: string): ARCandidateObject;
	static Find(Outer: UObject, ResourceName: string): ARCandidateObject;
	static GetDefaultObject(): ARCandidateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateObject;
	SetFriendlyName(NewName: string): void;
	SetCandidateObjectData(InCandidateObject: number[]): void;
	SetBoundingBox(InBoundingBox: Box): void;
	GetFriendlyName(): string;
	GetCandidateObjectData(): number[];
	GetBoundingBox(): Box;
	static C(Other: UObject | any): ARCandidateObject;
}

declare class ARVideoFormat { 
	FPS: number;
	Width: number;
	Height: number;
	clone() : ARVideoFormat;
	static C(Other: UObject | any): ARVideoFormat;
}

declare type EARFaceTrackingDirection = 'FaceRelative' | 'FaceMirrored' | 'EARFaceTrackingDirection_MAX';
declare var EARFaceTrackingDirection : { FaceRelative:'FaceRelative',FaceMirrored:'FaceMirrored',EARFaceTrackingDirection_MAX:'EARFaceTrackingDirection_MAX', };
declare type EARFaceTrackingUpdate = 'CurvesAndGeo' | 'CurvesOnly' | 'EARFaceTrackingUpdate_MAX';
declare var EARFaceTrackingUpdate : { CurvesAndGeo:'CurvesAndGeo',CurvesOnly:'CurvesOnly',EARFaceTrackingUpdate_MAX:'EARFaceTrackingUpdate_MAX', };
declare type EARSessionTrackingFeature = 'None' | 'PoseDetection2D' | 'PersonSegmentation' | 'PersonSegmentationWithDepth' | 'SceneDepth' | 'SmoothedSceneDepth' | 'EARSessionTrackingFeature_MAX';
declare var EARSessionTrackingFeature : { None:'None',PoseDetection2D:'PoseDetection2D',PersonSegmentation:'PersonSegmentation',PersonSegmentationWithDepth:'PersonSegmentationWithDepth',SceneDepth:'SceneDepth',SmoothedSceneDepth:'SmoothedSceneDepth',EARSessionTrackingFeature_MAX:'EARSessionTrackingFeature_MAX', };
declare type EARSceneReconstruction = 'None' | 'MeshOnly' | 'MeshWithClassification' | 'EARSceneReconstruction_MAX';
declare var EARSceneReconstruction : { None:'None',MeshOnly:'MeshOnly',MeshWithClassification:'MeshWithClassification',EARSceneReconstruction_MAX:'EARSceneReconstruction_MAX', };
declare class ARSessionPayload { 
	ConfigFlags: number;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	clone() : ARSessionPayload;
	static C(Other: UObject | any): ARSessionPayload;
}

declare class ARPlaneUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Center: Vector;
	Extents: Vector;
	BoundaryVertices: Vector[];
	ObjectClassification: EARObjectClassification;
	clone() : ARPlaneUpdatePayload;
	static C(Other: UObject | any): ARPlaneUpdatePayload;
}

declare type EPlaneComponentDebugMode = 'None' | 'ShowNetworkRole' | 'ShowClassification' | 'EPlaneComponentDebugMode_MAX';
declare var EPlaneComponentDebugMode : { None:'None',ShowNetworkRole:'ShowNetworkRole',ShowClassification:'ShowClassification',EPlaneComponentDebugMode_MAX:'EPlaneComponentDebugMode_MAX', };
declare class ARPlaneComponent extends ARComponent { 
	ReplicatedPayload: ARPlaneUpdatePayload;
	static Load(ResourceName: string): ARPlaneComponent;
	static Find(Outer: UObject, ResourceName: string): ARPlaneComponent;
	static GetDefaultObject(): ARPlaneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneComponent;
	static SetPlaneComponentDebugMode(NewDebugMode: EPlaneComponentDebugMode): void;
	static SetObjectClassificationDebugColors(InColors: Map<EARObjectClassification, LinearColor>): void;
	ServerUpdatePayload(NewPayload: ARPlaneUpdatePayload): void;
	ReceiveUpdate(Payload: ARPlaneUpdatePayload): void;
	ReceiveAdd(Payload: ARPlaneUpdatePayload): void;
	static GetObjectClassificationDebugColors(): Map<EARObjectClassification, LinearColor>;
	static C(Other: UObject | any): ARPlaneComponent;
}

declare class ARPointUpdatePayload { 
	clone() : ARPointUpdatePayload;
	static C(Other: UObject | any): ARPointUpdatePayload;
}

declare class ARPointComponent extends ARComponent { 
	ReplicatedPayload: ARPointUpdatePayload;
	static Load(ResourceName: string): ARPointComponent;
	static Find(Outer: UObject, ResourceName: string): ARPointComponent;
	static GetDefaultObject(): ARPointComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPointComponent;
	ServerUpdatePayload(NewPayload: ARPointUpdatePayload): void;
	ReceiveUpdate(Payload: ARPointUpdatePayload): void;
	ReceiveAdd(Payload: ARPointUpdatePayload): void;
	static C(Other: UObject | any): ARPointComponent;
}

declare type EARFaceTransformMixing = 'ComponentOnly' | 'ComponentLocationTrackedRotation' | 'ComponentWithTracked' | 'TrackingOnly' | 'EARFaceTransformMixing_MAX';
declare var EARFaceTransformMixing : { ComponentOnly:'ComponentOnly',ComponentLocationTrackedRotation:'ComponentLocationTrackedRotation',ComponentWithTracked:'ComponentWithTracked',TrackingOnly:'TrackingOnly',EARFaceTransformMixing_MAX:'EARFaceTransformMixing_MAX', };
declare class ARFaceUpdatePayload { 
	SessionPayload: ARSessionPayload;
	LeftEyePosition: Vector;
	RightEyePosition: Vector;
	LookAtTarget: Vector;
	clone() : ARFaceUpdatePayload;
	static C(Other: UObject | any): ARFaceUpdatePayload;
}

declare type EFaceComponentDebugMode = 'None' | 'ShowEyeVectors' | 'ShowFaceMesh' | 'EFaceComponentDebugMode_MAX';
declare var EFaceComponentDebugMode : { None:'None',ShowEyeVectors:'ShowEyeVectors',ShowFaceMesh:'ShowFaceMesh',EFaceComponentDebugMode_MAX:'EFaceComponentDebugMode_MAX', };
declare class ARFaceComponent extends ARComponent { 
	TransformSetting: EARFaceTransformMixing;
	bUpdateVertexNormal: boolean;
	bFaceOutOfScreen: boolean;
	ReplicatedPayload: ARFaceUpdatePayload;
	static Load(ResourceName: string): ARFaceComponent;
	static Find(Outer: UObject, ResourceName: string): ARFaceComponent;
	static GetDefaultObject(): ARFaceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceComponent;
	static SetFaceComponentDebugMode(NewDebugMode: EFaceComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARFaceUpdatePayload): void;
	ReceiveUpdate(Payload: ARFaceUpdatePayload): void;
	ReceiveAdd(Payload: ARFaceUpdatePayload): void;
	static C(Other: UObject | any): ARFaceComponent;
}

declare class ARImageUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	clone() : ARImageUpdatePayload;
	static C(Other: UObject | any): ARImageUpdatePayload;
}

declare type EImageComponentDebugMode = 'None' | 'ShowDetectedImage' | 'EImageComponentDebugMode_MAX';
declare var EImageComponentDebugMode : { None:'None',ShowDetectedImage:'ShowDetectedImage',EImageComponentDebugMode_MAX:'EImageComponentDebugMode_MAX', };
declare class ARImageComponent extends ARComponent { 
	ReplicatedPayload: ARImageUpdatePayload;
	static Load(ResourceName: string): ARImageComponent;
	static Find(Outer: UObject, ResourceName: string): ARImageComponent;
	static GetDefaultObject(): ARImageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARImageComponent;
	static SetImageComponentDebugMode(NewDebugMode: EImageComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARImageUpdatePayload): void;
	ReceiveUpdate(Payload: ARImageUpdatePayload): void;
	ReceiveAdd(Payload: ARImageUpdatePayload): void;
	static C(Other: UObject | any): ARImageComponent;
}

declare class ARQRCodeUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Extents: Vector;
	QRCode: string;
	clone() : ARQRCodeUpdatePayload;
	static C(Other: UObject | any): ARQRCodeUpdatePayload;
}

declare type EQRCodeComponentDebugMode = 'None' | 'ShowQRCode' | 'EQRCodeComponentDebugMode_MAX';
declare var EQRCodeComponentDebugMode : { None:'None',ShowQRCode:'ShowQRCode',EQRCodeComponentDebugMode_MAX:'EQRCodeComponentDebugMode_MAX', };
declare class ARQRCodeComponent extends ARComponent { 
	ReplicatedPayload: ARQRCodeUpdatePayload;
	static Load(ResourceName: string): ARQRCodeComponent;
	static Find(Outer: UObject, ResourceName: string): ARQRCodeComponent;
	static GetDefaultObject(): ARQRCodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARQRCodeComponent;
	static SetQRCodeComponentDebugMode(NewDebugMode: EQRCodeComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARQRCodeUpdatePayload): void;
	ReceiveUpdate(Payload: ARQRCodeUpdatePayload): void;
	ReceiveAdd(Payload: ARQRCodeUpdatePayload): void;
	static C(Other: UObject | any): ARQRCodeComponent;
}

declare class ARPoseUpdatePayload { 
	WorldTransform: Transform;
	JointTransforms: Transform[];
	clone() : ARPoseUpdatePayload;
	static C(Other: UObject | any): ARPoseUpdatePayload;
}

declare type EPoseComponentDebugMode = 'None' | 'ShowSkeleton' | 'EPoseComponentDebugMode_MAX';
declare var EPoseComponentDebugMode : { None:'None',ShowSkeleton:'ShowSkeleton',EPoseComponentDebugMode_MAX:'EPoseComponentDebugMode_MAX', };
declare class ARPoseComponent extends ARComponent { 
	ReplicatedPayload: ARPoseUpdatePayload;
	static Load(ResourceName: string): ARPoseComponent;
	static Find(Outer: UObject, ResourceName: string): ARPoseComponent;
	static GetDefaultObject(): ARPoseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPoseComponent;
	static SetPoseComponentDebugMode(NewDebugMode: EPoseComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARPoseUpdatePayload): void;
	ReceiveUpdate(Payload: ARPoseUpdatePayload): void;
	ReceiveAdd(Payload: ARPoseUpdatePayload): void;
	static C(Other: UObject | any): ARPoseComponent;
}

declare class AREnvironmentProbeUpdatePayload { 
	WorldTransform: Transform;
	clone() : AREnvironmentProbeUpdatePayload;
	static C(Other: UObject | any): AREnvironmentProbeUpdatePayload;
}

declare class AREnvironmentProbeComponent extends ARComponent { 
	ReplicatedPayload: AREnvironmentProbeUpdatePayload;
	static Load(ResourceName: string): AREnvironmentProbeComponent;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentProbeComponent;
	static GetDefaultObject(): AREnvironmentProbeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentProbeComponent;
	ServerUpdatePayload(NewPayload: AREnvironmentProbeUpdatePayload): void;
	ReceiveUpdate(Payload: AREnvironmentProbeUpdatePayload): void;
	ReceiveAdd(Payload: AREnvironmentProbeUpdatePayload): void;
	static C(Other: UObject | any): AREnvironmentProbeComponent;
}

declare class ARObjectUpdatePayload { 
	WorldTransform: Transform;
	clone() : ARObjectUpdatePayload;
	static C(Other: UObject | any): ARObjectUpdatePayload;
}

declare class ARObjectComponent extends ARComponent { 
	ReplicatedPayload: ARObjectUpdatePayload;
	static Load(ResourceName: string): ARObjectComponent;
	static Find(Outer: UObject, ResourceName: string): ARObjectComponent;
	static GetDefaultObject(): ARObjectComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARObjectComponent;
	ServerUpdatePayload(NewPayload: ARObjectUpdatePayload): void;
	ReceiveUpdate(Payload: ARObjectUpdatePayload): void;
	ReceiveAdd(Payload: ARObjectUpdatePayload): void;
	static C(Other: UObject | any): ARObjectComponent;
}

declare class ARMeshUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	ObjectClassification: EARObjectClassification;
	clone() : ARMeshUpdatePayload;
	static C(Other: UObject | any): ARMeshUpdatePayload;
}

declare class ARMeshComponent extends ARComponent { 
	ReplicatedPayload: ARMeshUpdatePayload;
	static Load(ResourceName: string): ARMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ARMeshComponent;
	static GetDefaultObject(): ARMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshComponent;
	ServerUpdatePayload(NewPayload: ARMeshUpdatePayload): void;
	ReceiveUpdate(Payload: ARMeshUpdatePayload): void;
	ReceiveAdd(Payload: ARMeshUpdatePayload): void;
	static C(Other: UObject | any): ARMeshComponent;
}

declare type EARAltitudeSource = 'Precise' | 'Coarse' | 'UserDefined' | 'Unknown' | 'EARAltitudeSource_MAX';
declare var EARAltitudeSource : { Precise:'Precise',Coarse:'Coarse',UserDefined:'UserDefined',Unknown:'Unknown',EARAltitudeSource_MAX:'EARAltitudeSource_MAX', };
declare class ARGeoAnchorUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Longitude: number;
	Latitude: number;
	AltitudeMeters: number;
	AltitudeSource: EARAltitudeSource;
	AnchorName: string;
	clone() : ARGeoAnchorUpdatePayload;
	static C(Other: UObject | any): ARGeoAnchorUpdatePayload;
}

declare type EGeoAnchorComponentDebugMode = 'None' | 'ShowGeoData' | 'EGeoAnchorComponentDebugMode_MAX';
declare var EGeoAnchorComponentDebugMode : { None:'None',ShowGeoData:'ShowGeoData',EGeoAnchorComponentDebugMode_MAX:'EGeoAnchorComponentDebugMode_MAX', };
declare class ARGeoAnchorComponent extends ARComponent { 
	ReplicatedPayload: ARGeoAnchorUpdatePayload;
	static Load(ResourceName: string): ARGeoAnchorComponent;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchorComponent;
	static GetDefaultObject(): ARGeoAnchorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchorComponent;
	static SetGeoAnchorComponentDebugMode(NewDebugMode: EGeoAnchorComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARGeoAnchorUpdatePayload): void;
	ReceiveUpdate(Payload: ARGeoAnchorUpdatePayload): void;
	ReceiveAdd(Payload: ARGeoAnchorUpdatePayload): void;
	static C(Other: UObject | any): ARGeoAnchorComponent;
}

declare class ARSessionConfig extends DataAsset { 
	bGenerateMeshDataFromTrackedGeometry: boolean;
	bGenerateCollisionForMeshData: boolean;
	bGenerateNavMeshForMeshData: boolean;
	bUseMeshDataForOcclusion: boolean;
	bRenderMeshDataInWireframe: boolean;
	bTrackSceneObjects: boolean;
	bUsePersonSegmentationForOcclusion: boolean;
	bUseSceneDepthForOcclusion: boolean;
	bUseAutomaticImageScaleEstimation: boolean;
	bUseStandardOnboardingUX: boolean;
	WorldAlignment: EARWorldAlignment;
	SessionType: EARSessionType;
	PlaneDetectionMode: EARPlaneDetectionMode;
	bHorizontalPlaneDetection: boolean;
	bVerticalPlaneDetection: boolean;
	bEnableAutoFocus: boolean;
	LightEstimationMode: EARLightEstimationMode;
	FrameSyncMode: EARFrameSyncMode;
	bEnableAutomaticCameraOverlay: boolean;
	bEnableAutomaticCameraTracking: boolean;
	bResetCameraTracking: boolean;
	bResetTrackedObjects: boolean;
	CandidateImages: ARCandidateImage[];
	MaxNumSimultaneousImagesTracked: number;
	EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
	WorldMapData: number[];
	CandidateObjects: ARCandidateObject[];
	DesiredVideoFormat: ARVideoFormat;
	bUseOptimalVideoFormat: boolean;
	FaceTrackingDirection: EARFaceTrackingDirection;
	FaceTrackingUpdate: EARFaceTrackingUpdate;
	MaxNumberOfTrackedFaces: number;
	SerializedARCandidateImageDatabase: number[];
	EnabledSessionTrackingFeature: EARSessionTrackingFeature;
	SceneReconstructionMethod: EARSceneReconstruction;
	PlaneComponentClass: UnrealEngineClass;
	PointComponentClass: UnrealEngineClass;
	FaceComponentClass: UnrealEngineClass;
	ImageComponentClass: UnrealEngineClass;
	QRCodeComponentClass: UnrealEngineClass;
	PoseComponentClass: UnrealEngineClass;
	EnvironmentProbeComponentClass: UnrealEngineClass;
	ObjectComponentClass: UnrealEngineClass;
	MeshComponentClass: UnrealEngineClass;
	GeoAnchorComponentClass: UnrealEngineClass;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	static Load(ResourceName: string): ARSessionConfig;
	static Find(Outer: UObject, ResourceName: string): ARSessionConfig;
	static GetDefaultObject(): ARSessionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSessionConfig;
	ShouldResetTrackedObjects(): boolean;
	ShouldResetCameraTracking(): boolean;
	ShouldRenderCameraOverlay(): boolean;
	ShouldEnableCameraTracking(): boolean;
	ShouldEnableAutoFocus(): boolean;
	SetWorldMapData(WorldMapData: number[]): void;
	SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;
	SetSceneReconstructionMethod(InSceneReconstructionMethod: EARSceneReconstruction): void;
	SetResetTrackedObjects(bNewValue: boolean): void;
	SetResetCameraTracking(bNewValue: boolean): void;
	SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;
	SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;
	SetEnableAutoFocus(bNewValue: boolean): void;
	SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;
	SetCandidateObjectList(InCandidateObjects: ARCandidateObject[]): void;
	GetWorldMapData(): number[];
	GetWorldAlignment(): EARWorldAlignment;
	GetSessionType(): EARSessionType;
	GetSceneReconstructionMethod(): EARSceneReconstruction;
	GetPlaneDetectionMode(): EARPlaneDetectionMode;
	GetMaxNumSimultaneousImagesTracked(): number;
	GetLightEstimationMode(): EARLightEstimationMode;
	GetFrameSyncMode(): EARFrameSyncMode;
	GetFaceTrackingUpdate(): EARFaceTrackingUpdate;
	GetFaceTrackingDirection(): EARFaceTrackingDirection;
	GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;
	GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;
	GetDesiredVideoFormat(): ARVideoFormat;
	GetCandidateObjectList(): ARCandidateObject[];
	GetCandidateImageList(): ARCandidateImage[];
	AddCandidateObject(CandidateObject: ARCandidateObject): void;
	AddCandidateImage(NewCandidateImage: ARCandidateImage): void;
	static C(Other: UObject | any): ARSessionConfig;
	AddRuntimeCandidateImage(CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	StartARSession(): void;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static StartARSession(SessionConfig: ARSessionConfig): void;
}

declare type EARWorldMappingState = 'NotAvailable' | 'StillMappingNotRelocalizable' | 'StillMappingRelocalizable' | 'Mapped' | 'EARWorldMappingState_MAX';
declare var EARWorldMappingState : { NotAvailable:'NotAvailable',StillMappingNotRelocalizable:'StillMappingNotRelocalizable',StillMappingRelocalizable:'StillMappingRelocalizable',Mapped:'Mapped',EARWorldMappingState_MAX:'EARWorldMappingState_MAX', };
declare type EARTrackingQualityReason = 'None' | 'Initializing' | 'Relocalizing' | 'ExcessiveMotion' | 'InsufficientFeatures' | 'InsufficientLight' | 'BadState' | 'EARTrackingQualityReason_MAX';
declare var EARTrackingQualityReason : { None:'None',Initializing:'Initializing',Relocalizing:'Relocalizing',ExcessiveMotion:'ExcessiveMotion',InsufficientFeatures:'InsufficientFeatures',InsufficientLight:'InsufficientLight',BadState:'BadState',EARTrackingQualityReason_MAX:'EARTrackingQualityReason_MAX', };
declare type EARTrackingQuality = 'NotTracking' | 'OrientationOnly' | 'OrientationAndPosition' | 'EARTrackingQuality_MAX';
declare var EARTrackingQuality : { NotTracking:'NotTracking',OrientationOnly:'OrientationOnly',OrientationAndPosition:'OrientationAndPosition',EARTrackingQuality_MAX:'EARTrackingQuality_MAX', };
declare type EARTextureType = 'Unknown' | 'CameraImage' | 'CameraDepth' | 'EnvironmentCapture' | 'PersonSegmentationImage' | 'PersonSegmentationDepth' | 'SceneDepthMap' | 'SceneDepthConfidenceMap' | 'EARTextureType_MAX';
declare var EARTextureType : { Unknown:'Unknown',CameraImage:'CameraImage',CameraDepth:'CameraDepth',EnvironmentCapture:'EnvironmentCapture',PersonSegmentationImage:'PersonSegmentationImage',PersonSegmentationDepth:'PersonSegmentationDepth',SceneDepthMap:'SceneDepthMap',SceneDepthConfidenceMap:'SceneDepthConfidenceMap',EARTextureType_MAX:'EARTextureType_MAX', };
declare class ARTexture extends Texture { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): ARTexture;
	static Find(Outer: UObject, ResourceName: string): ARTexture;
	static GetDefaultObject(): ARTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTexture;
	static C(Other: UObject | any): ARTexture;
}

declare class ARLightEstimate extends UObject { 
	static Load(ResourceName: string): ARLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARLightEstimate;
	static GetDefaultObject(): ARLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLightEstimate;
	static C(Other: UObject | any): ARLightEstimate;
}

declare class ARCameraIntrinsics { 
	ImageResolution: IntPoint;
	FocalLength: Vector2D;
	PrincipalPoint: Vector2D;
	clone() : ARCameraIntrinsics;
	static C(Other: UObject | any): ARCameraIntrinsics;
	GetCameraIntrinsics(): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
}

declare class ARTextureCameraImage extends ARTexture { 
	static Load(ResourceName: string): ARTextureCameraImage;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraImage;
	static GetDefaultObject(): ARTextureCameraImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraImage;
	static C(Other: UObject | any): ARTextureCameraImage;
}

declare type EARDepthQuality = 'Unkown' | 'Low' | 'High' | 'EARDepthQuality_MAX';
declare var EARDepthQuality : { Unkown:'Unkown',Low:'Low',High:'High',EARDepthQuality_MAX:'EARDepthQuality_MAX', };
declare type EARDepthAccuracy = 'Unkown' | 'Approximate' | 'Accurate' | 'EARDepthAccuracy_MAX';
declare var EARDepthAccuracy : { Unkown:'Unkown',Approximate:'Approximate',Accurate:'Accurate',EARDepthAccuracy_MAX:'EARDepthAccuracy_MAX', };
declare class ARTextureCameraDepth extends ARTexture { 
	DepthQuality: EARDepthQuality;
	DepthAccuracy: EARDepthAccuracy;
	bIsTemporallySmoothed: boolean;
	static Load(ResourceName: string): ARTextureCameraDepth;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraDepth;
	static GetDefaultObject(): ARTextureCameraDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraDepth;
	static C(Other: UObject | any): ARTextureCameraDepth;
}

declare type EARSessionStatus = 'NotStarted' | 'Running' | 'NotSupported' | 'FatalError' | 'PermissionNotGranted' | 'UnsupportedConfiguration' | 'Other' | 'EARSessionStatus_MAX';
declare var EARSessionStatus : { NotStarted:'NotStarted',Running:'Running',NotSupported:'NotSupported',FatalError:'FatalError',PermissionNotGranted:'PermissionNotGranted',UnsupportedConfiguration:'UnsupportedConfiguration',Other:'Other',EARSessionStatus_MAX:'EARSessionStatus_MAX', };
declare class ARSessionStatus { 
	AdditionalInfo: string;
	Status: EARSessionStatus;
	clone() : ARSessionStatus;
	static C(Other: UObject | any): ARSessionStatus;
	static GetARSessionStatus(): ARSessionStatus;
}

declare class ARSkeletonDefinition { 
	NumJoints: number;
	JointNames: string[];
	ParentIndices: number[];
	clone() : ARSkeletonDefinition;
	static C(Other: UObject | any): ARSkeletonDefinition;
}

declare type EARJointTransformSpace = 'Model' | 'ParentJoint' | 'EARJointTransformSpace_MAX';
declare var EARJointTransformSpace : { Model:'Model',ParentJoint:'ParentJoint',EARJointTransformSpace_MAX:'EARJointTransformSpace_MAX', };
declare class ARPose3D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointTransforms: Transform[];
	IsJointTracked: boolean[];
	JointTransformSpace: EARJointTransformSpace;
	clone() : ARPose3D;
	static C(Other: UObject | any): ARPose3D;
}

declare class ARTrackedPose extends ARTrackedGeometry { 
	TrackedPose: ARPose3D;
	static Load(ResourceName: string): ARTrackedPose;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPose;
	static GetDefaultObject(): ARTrackedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPose;
	GetTrackedPoseData(): ARPose3D;
	static C(Other: UObject | any): ARTrackedPose;
}

declare class ARTrackedPoint extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARTrackedPoint;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPoint;
	static GetDefaultObject(): ARTrackedPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPoint;
	static C(Other: UObject | any): ARTrackedPoint;
}

declare type EARPlaneOrientation = 'Horizontal' | 'Vertical' | 'Diagonal' | 'EARPlaneOrientation_MAX';
declare var EARPlaneOrientation : { Horizontal:'Horizontal',Vertical:'Vertical',Diagonal:'Diagonal',EARPlaneOrientation_MAX:'EARPlaneOrientation_MAX', };
declare class ARPlaneGeometry extends ARTrackedGeometry { 
	Orientation: EARPlaneOrientation;
	Center: Vector;
	Extent: Vector;
	BoundaryPolygon: Vector[];
	SubsumedBy: ARPlaneGeometry;
	static Load(ResourceName: string): ARPlaneGeometry;
	static Find(Outer: UObject, ResourceName: string): ARPlaneGeometry;
	static GetDefaultObject(): ARPlaneGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneGeometry;
	GetSubsumedBy(): ARPlaneGeometry;
	GetOrientation(): EARPlaneOrientation;
	GetExtent(): Vector;
	GetCenter(): Vector;
	GetBoundaryPolygonInLocalSpace(): Vector[];
	static C(Other: UObject | any): ARPlaneGeometry;
}

declare class ARTrackedImage extends ARTrackedGeometry { 
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	static Load(ResourceName: string): ARTrackedImage;
	static Find(Outer: UObject, ResourceName: string): ARTrackedImage;
	static GetDefaultObject(): ARTrackedImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedImage;
	GetEstimateSize(): Vector2D;
	GetDetectedImage(): ARCandidateImage;
	static C(Other: UObject | any): ARTrackedImage;
}

declare class AREnvironmentCaptureProbeTexture extends TextureCube { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): AREnvironmentCaptureProbeTexture;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbeTexture;
	static GetDefaultObject(): AREnvironmentCaptureProbeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbeTexture;
}

declare class AREnvironmentCaptureProbe extends ARTrackedGeometry { 
	Extent: Vector;
	EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;
	static Load(ResourceName: string): AREnvironmentCaptureProbe;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbe;
	static GetDefaultObject(): AREnvironmentCaptureProbe;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbe;
	GetExtent(): Vector;
	GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbe;
}

declare class ARPose2D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointLocations: Vector2D[];
	IsJointTracked: boolean[];
	clone() : ARPose2D;
	static C(Other: UObject | any): ARPose2D;
}

declare class ARBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ARBlueprintLibrary;
	static GetDefaultObject(): ARBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBlueprintLibrary;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
	static ToggleARCapture(bOnOff: boolean,CaptureType: EARCaptureType): boolean;
	static StopARSession(): void;
	static StartARSession(SessionConfig: ARSessionConfig): void;
	static SetEnabledXRCamera(bOnOff: boolean): void;
	static SetARWorldScale(InWorldScale: number): void;
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static SaveARPinToLocalStore(InSaveName: string,InPin: ARPin): boolean;
	static ResizeXRCamera(InSize: IntPoint): IntPoint;
	static RemovePin(PinToRemove: ARPin): void;
	static RemoveARPinFromLocalStore(InSaveName: string): void;
	static RemoveAllARPinsFromLocalStore(): void;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PauseARSession(): void;
	static LoadARPinsFromLocalStore(): Map<string, ARPin>;
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static IsSessionTypeSupported(SessionType: EARSessionType): boolean;
	static IsSessionTrackingFeatureSupported(SessionType: EARSessionType,SessionTrackingFeature: EARSessionTrackingFeature): boolean;
	static IsSceneReconstructionSupported(SessionType: EARSessionType,SceneReconstructionMethod: EARSceneReconstruction): boolean;
	static IsARSupported(): boolean;
	static IsARPinLocalStoreSupported(): boolean;
	static IsARPinLocalStoreReady(): boolean;
	static GetWorldMappingStatus(): EARWorldMappingState;
	static GetTrackingQualityReason(): EARTrackingQualityReason;
	static GetTrackingQuality(): EARTrackingQuality;
	static GetSupportedVideoFormats(SessionType: EARSessionType): ARVideoFormat[];
	static GetSessionConfig(): ARSessionConfig;
	static GetPointCloud(): Vector[];
	static GetPersonSegmentationImage(): ARTexture;
	static GetPersonSegmentationDepthImage(): ARTexture;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static GetNumberOfTrackedFacesSupported(): number;
	static GetCurrentLightEstimate(): ARLightEstimate;
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraImage(): ARTextureCameraImage;
	static GetCameraDepth(): ARTextureCameraDepth;
	static GetARWorldScale(): number;
	static GetARTexture(TextureType: EARTextureType): ARTexture;
	static GetARSessionStatus(): ARSessionStatus;
	static GetAllTrackedPoses(): ARTrackedPose[];
	static GetAllTrackedPoints(): ARTrackedPoint[];
	static GetAllTrackedPlanes(): ARPlaneGeometry[];
	static GetAllTrackedImages(): ARTrackedImage[];
	static GetAllTrackedEnvironmentCaptureProbes(): AREnvironmentCaptureProbe[];
	static GetAllTracked2DPoses(): ARPose2D[];
	static GetAllPins(): ARPin[];
	static GetAllGeometriesByClass(GeometryClass: UnrealEngineClass): ARTrackedGeometry[];
	static GetAllGeometries(): ARTrackedGeometry[];
	static GetAlignmentTransform(): Transform;
	static FindTrackedPointsByName(PointName: string): ARTrackedPoint[];
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static CalculateClosestIntersection(StartPoints: Vector[],EndPoints: Vector[],ClosestIntersection?: Vector): {ClosestIntersection: Vector};
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static C(Other: UObject | any): ARBlueprintLibrary;
}

declare class ARTraceResultLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARTraceResultLibrary;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultLibrary;
	static GetDefaultObject(): ARTraceResultLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultLibrary;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static C(Other: UObject | any): ARTraceResultLibrary;
}

declare class BlueprintAsyncActionBase extends UObject { 
	static Load(ResourceName: string): BlueprintAsyncActionBase;
	static Find(Outer: UObject, ResourceName: string): BlueprintAsyncActionBase;
	static GetDefaultObject(): BlueprintAsyncActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintAsyncActionBase;
	Activate(): void;
	static C(Other: UObject | any): BlueprintAsyncActionBase;
}

declare class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARBaseAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBaseAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARBaseAsyncTaskBlueprintProxy;
}

declare class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	static Load(ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARSaveWorldAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSaveWorldAsyncTaskBlueprintProxy;
	static ARSaveWorld(WorldContextObject: UObject): ARSaveWorldAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARSaveWorldAsyncTaskBlueprintProxy;
}

declare class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	static Load(ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static ARGetCandidateObject(WorldContextObject: UObject,Location: Vector,Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARGetCandidateObjectAsyncTaskBlueprintProxy;
}

declare type EARServicePermissionRequestResult = 'Granted' | 'Denied' | 'EARServicePermissionRequestResult_MAX';
declare var EARServicePermissionRequestResult : { Granted:'Granted',Denied:'Denied',EARServicePermissionRequestResult_MAX:'EARServicePermissionRequestResult_MAX', };
declare type EARServiceInstallRequestResult = 'Installed' | 'DeviceNotCompatible' | 'UserDeclinedInstallation' | 'FatalError' | 'EARServiceInstallRequestResult_MAX';
declare var EARServiceInstallRequestResult : { Installed:'Installed',DeviceNotCompatible:'DeviceNotCompatible',UserDeclinedInstallation:'UserDeclinedInstallation',FatalError:'FatalError',EARServiceInstallRequestResult_MAX:'EARServiceInstallRequestResult_MAX', };
declare type EARServiceAvailability = 'UnknownError' | 'UnknownChecking' | 'UnknownTimedOut' | 'UnsupportedDeviceNotCapable' | 'SupportedNotInstalled' | 'SupportedVersionTooOld' | 'SupportedInstalled' | 'EARServiceAvailability_MAX';
declare var EARServiceAvailability : { UnknownError:'UnknownError',UnknownChecking:'UnknownChecking',UnknownTimedOut:'UnknownTimedOut',UnsupportedDeviceNotCapable:'UnsupportedDeviceNotCapable',SupportedNotInstalled:'SupportedNotInstalled',SupportedVersionTooOld:'SupportedVersionTooOld',SupportedInstalled:'SupportedInstalled',EARServiceAvailability_MAX:'EARServiceAvailability_MAX', };
declare class ARDependencyHandler extends UObject { 
	static Load(ResourceName: string): ARDependencyHandler;
	static Find(Outer: UObject, ResourceName: string): ARDependencyHandler;
	static GetDefaultObject(): ARDependencyHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARDependencyHandler;
	StartARSessionLatent(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo): void;
	RequestARSessionPermission(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo,OutPermissionResult?: EARServicePermissionRequestResult): {OutPermissionResult: EARServicePermissionRequestResult};
	InstallARService(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutInstallResult?: EARServiceInstallRequestResult): {OutInstallResult: EARServiceInstallRequestResult};
	static GetARDependencyHandler(): ARDependencyHandler;
	CheckARServiceAvailability(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutAvailability?: EARServiceAvailability): {OutAvailability: EARServiceAvailability};
	static C(Other: UObject | any): ARDependencyHandler;
}

declare type EARGeoTrackingStateReason = 'None' | 'NotAvailableAtLocation' | 'NeedLocationPermissions' | 'DevicePointedTooLow' | 'WorldTrackingUnstable' | 'WaitingForLocation' | 'GeoDataNotLoaded' | 'VisualLocalizationFailed' | 'WaitingForAvailabilityCheck' | 'EARGeoTrackingStateReason_MAX';
declare var EARGeoTrackingStateReason : { None:'None',NotAvailableAtLocation:'NotAvailableAtLocation',NeedLocationPermissions:'NeedLocationPermissions',DevicePointedTooLow:'DevicePointedTooLow',WorldTrackingUnstable:'WorldTrackingUnstable',WaitingForLocation:'WaitingForLocation',GeoDataNotLoaded:'GeoDataNotLoaded',VisualLocalizationFailed:'VisualLocalizationFailed',WaitingForAvailabilityCheck:'WaitingForAvailabilityCheck',EARGeoTrackingStateReason_MAX:'EARGeoTrackingStateReason_MAX', };
declare type EARGeoTrackingState = 'Initializing' | 'Localized' | 'Localizing' | 'NotAvailable' | 'EARGeoTrackingState_MAX';
declare var EARGeoTrackingState : { Initializing:'Initializing',Localized:'Localized',Localizing:'Localizing',NotAvailable:'NotAvailable',EARGeoTrackingState_MAX:'EARGeoTrackingState_MAX', };
declare type EARGeoTrackingAccuracy = 'Undetermined' | 'Low' | 'Medium' | 'High' | 'EARGeoTrackingAccuracy_MAX';
declare var EARGeoTrackingAccuracy : { Undetermined:'Undetermined',Low:'Low',Medium:'Medium',High:'High',EARGeoTrackingAccuracy_MAX:'EARGeoTrackingAccuracy_MAX', };
declare class ARGeoTrackingSupport extends UObject { 
	static Load(ResourceName: string): ARGeoTrackingSupport;
	static Find(Outer: UObject, ResourceName: string): ARGeoTrackingSupport;
	static GetDefaultObject(): ARGeoTrackingSupport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoTrackingSupport;
	static GetGeoTrackingSupport(): ARGeoTrackingSupport;
	GetGeoTrackingStateReason(): EARGeoTrackingStateReason;
	GetGeoTrackingState(): EARGeoTrackingState;
	GetGeoTrackingAccuracy(): EARGeoTrackingAccuracy;
	AddGeoAnchorAtLocationWithAltitude(Longitude: number,Latitude: number,AltitudeMeters: number,OptionalAnchorName: string): boolean;
	AddGeoAnchorAtLocation(Longitude: number,Latitude: number,OptionalAnchorName: string): boolean;
	static C(Other: UObject | any): ARGeoTrackingSupport;
}

declare class CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	static Load(ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static GetDefaultObject(): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailabilityAtLocation(WorldContextObject: UObject,Longitude: number,Latitude: number): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailability(WorldContextObject: UObject): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
}

declare class GetGeoLocationAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	static Load(ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetDefaultObject(): GetGeoLocationAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetGeoLocationAtWorldPosition(WorldContextObject: UObject,WorldPosition: Vector): GetGeoLocationAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): GetGeoLocationAsyncTaskBlueprintProxy;
}

declare class ARLifeCycleComponent extends SceneComponent { 
	OnARActorSpawnedDelegate: UnrealEngineMulticastDelegate<(ComponentClass: UnrealEngineClass, NativeID: Guid, SpawnedActor: ARActor) => void>;
	OnARActorToBeDestroyedDelegate: UnrealEngineMulticastDelegate<(Actor: ARActor) => void>;
	static Load(ResourceName: string): ARLifeCycleComponent;
	static Find(Outer: UObject, ResourceName: string): ARLifeCycleComponent;
	static GetDefaultObject(): ARLifeCycleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLifeCycleComponent;
	ServerSpawnARActor(ComponentClass: UnrealEngineClass,NativeID: Guid): void;
	ServerDestroyARActor(Actor: ARActor): void;
	static C(Other: UObject | any): ARLifeCycleComponent;
}

declare class ARBasicLightEstimate extends ARLightEstimate { 
	AmbientIntensityLumens: number;
	AmbientColorTemperatureKelvin: number;
	AmbientColor: LinearColor;
	static Load(ResourceName: string): ARBasicLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARBasicLightEstimate;
	static GetDefaultObject(): ARBasicLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBasicLightEstimate;
	GetAmbientIntensityLumens(): number;
	GetAmbientColorTemperatureKelvin(): number;
	GetAmbientColor(): LinearColor;
	static C(Other: UObject | any): ARBasicLightEstimate;
}

declare class AROriginActor extends Actor { 
	static GetDefaultObject(): AROriginActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AROriginActor;
	static C(Other: UObject | any): AROriginActor;
}

declare class GameMode extends GameModeBase { 
	MatchState: string;
	bDelayedStart: boolean;
	NumSpectators: number;
	NumPlayers: number;
	NumBots: number;
	MinRespawnDelay: number;
	NumTravellingPlayers: number;
	EngineMessageClass: UnrealEngineClass;
	InactivePlayerArray: PlayerState[];
	InactivePlayerStateLifeSpan: number;
	MaxInactivePlayers: number;
	bHandleDedicatedServerReplays: boolean;
	static GetDefaultObject(): GameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMode;
	StartMatch(): void;
	Say(Msg: string): void;
	RestartGame(): void;
	ReadyToStartMatch(): boolean;
	ReadyToEndMatch(): boolean;
	K2_OnSetMatchState(NewState: string): void;
	IsMatchInProgress(): boolean;
	GetMatchState(): string;
	EndMatch(): void;
	AbortMatch(): void;
	static C(Other: UObject | any): GameMode;
}

declare class GameState extends GameStateBase { 
	MatchState: string;
	PreviousMatchState: string;
	ElapsedTime: number;
	static GetDefaultObject(): GameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameState;
	OnRep_MatchState(): void;
	OnRep_ElapsedTime(): void;
	static C(Other: UObject | any): GameState;
}

declare class ARSharedWorldGameState extends GameState { 
	PreviewImageData: number[];
	ARWorldData: number[];
	PreviewImageBytesTotal: number;
	ARWorldBytesTotal: number;
	PreviewImageBytesDelivered: number;
	ARWorldBytesDelivered: number;
	static GetDefaultObject(): ARSharedWorldGameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameState;
	K2_OnARWorldMapIsReady(): void;
	static C(Other: UObject | any): ARSharedWorldGameState;
}

declare class ARSharedWorldGameMode extends GameMode { 
	BufferSizePerChunk: number;
	static GetDefaultObject(): ARSharedWorldGameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameMode;
	SetPreviewImageData(ImageData: number[]): void;
	SetARWorldSharingIsReady(): void;
	SetARSharedWorldData(ARWorldData: number[]): void;
	GetARSharedWorldGameState(): ARSharedWorldGameState;
	static C(Other: UObject | any): ARSharedWorldGameMode;
}

declare class ARSharedWorldPlayerController extends PlayerController { 
	static GetDefaultObject(): ARSharedWorldPlayerController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldPlayerController;
	ServerMarkReadyForReceiving(): void;
	ClientUpdatePreviewImageData(Offset: number,Buffer: number[]): void;
	ClientUpdateARWorldData(Offset: number,Buffer: number[]): void;
	ClientInitSharedWorld(PreviewImageSize: number,ARWorldDataSize: number): void;
	static C(Other: UObject | any): ARSharedWorldPlayerController;
}

declare type ESkyLightSourceType = 'SLS_CapturedScene' | 'SLS_SpecifiedCubemap' | 'SLS_MAX';
declare var ESkyLightSourceType : { SLS_CapturedScene:'SLS_CapturedScene',SLS_SpecifiedCubemap:'SLS_SpecifiedCubemap',SLS_MAX:'SLS_MAX', };
declare type EOcclusionCombineMode = 'OCM_Minimum' | 'OCM_Multiply' | 'OCM_MAX';
declare var EOcclusionCombineMode : { OCM_Minimum:'OCM_Minimum',OCM_Multiply:'OCM_Multiply',OCM_MAX:'OCM_MAX', };
declare class SkyLightComponent extends LightComponentBase { 
	bRealTimeCapture: boolean;
	SourceType: ESkyLightSourceType;
	Cubemap: TextureCube;
	SourceCubemapAngle: number;
	CubemapResolution: number;
	SkyDistanceThreshold: number;
	bCaptureEmissiveOnly: boolean;
	bLowerHemisphereIsBlack: boolean;
	LowerHemisphereColor: LinearColor;
	OcclusionMaxDistance: number;
	Contrast: number;
	OcclusionExponent: number;
	MinOcclusion: number;
	OcclusionTint: Color;
	bCloudAmbientOcclusion: boolean;
	CloudAmbientOcclusionStrength: number;
	CloudAmbientOcclusionExtent: number;
	CloudAmbientOcclusionMapResolutionScale: number;
	CloudAmbientOcclusionApertureScale: number;
	OcclusionCombineMode: EOcclusionCombineMode;
	BlendDestinationCubemap: TextureCube;
	static Load(ResourceName: string): SkyLightComponent;
	static Find(Outer: UObject, ResourceName: string): SkyLightComponent;
	static GetDefaultObject(): SkyLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLightComponent;
	SetVolumetricScatteringIntensity(NewIntensity: number): void;
	SetSourceCubemapAngle(NewValue: number): void;
	SetOcclusionTint(InTint: Color): void;
	SetOcclusionExponent(InOcclusionExponent: number): void;
	SetOcclusionContrast(InOcclusionContrast: number): void;
	SetMinOcclusion(InMinOcclusion: number): void;
	SetLowerHemisphereColor(InLowerHemisphereColor: LinearColor): void;
	SetLightColor(NewLightColor: LinearColor): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetCubemapBlend(SourceCubemap: TextureCube,DestinationCubemap: TextureCube,InBlendFraction: number): void;
	SetCubemap(NewCubemap: TextureCube): void;
	RecaptureSky(): void;
	static C(Other: UObject | any): SkyLightComponent;
}

declare class SkyLight extends Info { 
	LightComponent: SkyLightComponent;
	bEnabled: boolean;
	static GetDefaultObject(): SkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLight;
	OnRep_bEnabled(): void;
	static C(Other: UObject | any): SkyLight;
}

declare class ARSkyLight extends SkyLight { 
	CaptureProbe: AREnvironmentCaptureProbe;
	static GetDefaultObject(): ARSkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSkyLight;
	SetEnvironmentCaptureProbe(InCaptureProbe: AREnvironmentCaptureProbe): void;
	static C(Other: UObject | any): ARSkyLight;
}

declare class ARTraceResultDummy extends UObject { 
	static Load(ResourceName: string): ARTraceResultDummy;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultDummy;
	static GetDefaultObject(): ARTraceResultDummy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultDummy;
	static C(Other: UObject | any): ARTraceResultDummy;
}

declare class ARTrackedQRCode extends ARTrackedImage { 
	QRCode: string;
	Version: number;
	static Load(ResourceName: string): ARTrackedQRCode;
	static Find(Outer: UObject, ResourceName: string): ARTrackedQRCode;
	static GetDefaultObject(): ARTrackedQRCode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedQRCode;
	static C(Other: UObject | any): ARTrackedQRCode;
}

declare type EARFaceBlendShape = 'EyeBlinkLeft' | 'EyeLookDownLeft' | 'EyeLookInLeft' | 'EyeLookOutLeft' | 'EyeLookUpLeft' | 'EyeSquintLeft' | 'EyeWideLeft' | 'EyeBlinkRight' | 'EyeLookDownRight' | 'EyeLookInRight' | 'EyeLookOutRight' | 'EyeLookUpRight' | 'EyeSquintRight' | 'EyeWideRight' | 'JawForward' | 'JawLeft' | 'JawRight' | 'JawOpen' | 'MouthClose' | 'MouthFunnel' | 'MouthPucker' | 'MouthLeft' | 'MouthRight' | 'MouthSmileLeft' | 'MouthSmileRight' | 'MouthFrownLeft' | 'MouthFrownRight' | 'MouthDimpleLeft' | 'MouthDimpleRight' | 'MouthStretchLeft' | 'MouthStretchRight' | 'MouthRollLower' | 'MouthRollUpper' | 'MouthShrugLower' | 'MouthShrugUpper' | 'MouthPressLeft' | 'MouthPressRight' | 'MouthLowerDownLeft' | 'MouthLowerDownRight' | 'MouthUpperUpLeft' | 'MouthUpperUpRight' | 'BrowDownLeft' | 'BrowDownRight' | 'BrowInnerUp' | 'BrowOuterUpLeft' | 'BrowOuterUpRight' | 'CheekPuff' | 'CheekSquintLeft' | 'CheekSquintRight' | 'NoseSneerLeft' | 'NoseSneerRight' | 'TongueOut' | 'HeadYaw' | 'HeadPitch' | 'HeadRoll' | 'LeftEyeYaw' | 'LeftEyePitch' | 'LeftEyeRoll' | 'RightEyeYaw' | 'RightEyePitch' | 'RightEyeRoll' | 'MAX';
declare var EARFaceBlendShape : { EyeBlinkLeft:'EyeBlinkLeft',EyeLookDownLeft:'EyeLookDownLeft',EyeLookInLeft:'EyeLookInLeft',EyeLookOutLeft:'EyeLookOutLeft',EyeLookUpLeft:'EyeLookUpLeft',EyeSquintLeft:'EyeSquintLeft',EyeWideLeft:'EyeWideLeft',EyeBlinkRight:'EyeBlinkRight',EyeLookDownRight:'EyeLookDownRight',EyeLookInRight:'EyeLookInRight',EyeLookOutRight:'EyeLookOutRight',EyeLookUpRight:'EyeLookUpRight',EyeSquintRight:'EyeSquintRight',EyeWideRight:'EyeWideRight',JawForward:'JawForward',JawLeft:'JawLeft',JawRight:'JawRight',JawOpen:'JawOpen',MouthClose:'MouthClose',MouthFunnel:'MouthFunnel',MouthPucker:'MouthPucker',MouthLeft:'MouthLeft',MouthRight:'MouthRight',MouthSmileLeft:'MouthSmileLeft',MouthSmileRight:'MouthSmileRight',MouthFrownLeft:'MouthFrownLeft',MouthFrownRight:'MouthFrownRight',MouthDimpleLeft:'MouthDimpleLeft',MouthDimpleRight:'MouthDimpleRight',MouthStretchLeft:'MouthStretchLeft',MouthStretchRight:'MouthStretchRight',MouthRollLower:'MouthRollLower',MouthRollUpper:'MouthRollUpper',MouthShrugLower:'MouthShrugLower',MouthShrugUpper:'MouthShrugUpper',MouthPressLeft:'MouthPressLeft',MouthPressRight:'MouthPressRight',MouthLowerDownLeft:'MouthLowerDownLeft',MouthLowerDownRight:'MouthLowerDownRight',MouthUpperUpLeft:'MouthUpperUpLeft',MouthUpperUpRight:'MouthUpperUpRight',BrowDownLeft:'BrowDownLeft',BrowDownRight:'BrowDownRight',BrowInnerUp:'BrowInnerUp',BrowOuterUpLeft:'BrowOuterUpLeft',BrowOuterUpRight:'BrowOuterUpRight',CheekPuff:'CheekPuff',CheekSquintLeft:'CheekSquintLeft',CheekSquintRight:'CheekSquintRight',NoseSneerLeft:'NoseSneerLeft',NoseSneerRight:'NoseSneerRight',TongueOut:'TongueOut',HeadYaw:'HeadYaw',HeadPitch:'HeadPitch',HeadRoll:'HeadRoll',LeftEyeYaw:'LeftEyeYaw',LeftEyePitch:'LeftEyePitch',LeftEyeRoll:'LeftEyeRoll',RightEyeYaw:'RightEyeYaw',RightEyePitch:'RightEyePitch',RightEyeRoll:'RightEyeRoll',MAX:'MAX', };
declare type EAREye = 'LeftEye' | 'RightEye' | 'EAREye_MAX';
declare var EAREye : { LeftEye:'LeftEye',RightEye:'RightEye',EAREye_MAX:'EAREye_MAX', };
declare class ARFaceGeometry extends ARTrackedGeometry { 
	LookAtTarget: Vector;
	bIsTracked: boolean;
	BlendShapes: Map<EARFaceBlendShape, number>;
	LeftEyeTransform: Transform;
	RightEyeTransform: Transform;
	static Load(ResourceName: string): ARFaceGeometry;
	static Find(Outer: UObject, ResourceName: string): ARFaceGeometry;
	static GetDefaultObject(): ARFaceGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceGeometry;
	GetWorldSpaceEyeTransform(Eye: EAREye): Transform;
	GetLocalSpaceEyeTransform(Eye: EAREye): Transform;
	GetBlendShapeValue(BlendShape: EARFaceBlendShape): number;
	GetBlendShapes(): Map<EARFaceBlendShape, number>;
	static C(Other: UObject | any): ARFaceGeometry;
}

declare class ARTrackedObject extends ARTrackedGeometry { 
	DetectedObject: ARCandidateObject;
	static Load(ResourceName: string): ARTrackedObject;
	static Find(Outer: UObject, ResourceName: string): ARTrackedObject;
	static GetDefaultObject(): ARTrackedObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedObject;
	GetDetectedObject(): ARCandidateObject;
	static C(Other: UObject | any): ARTrackedObject;
}

declare class ARMeshGeometry extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARMeshGeometry;
	static Find(Outer: UObject, ResourceName: string): ARMeshGeometry;
	static GetDefaultObject(): ARMeshGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshGeometry;
	GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static C(Other: UObject | any): ARMeshGeometry;
}

declare class ARGeoAnchor extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARGeoAnchor;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchor;
	static GetDefaultObject(): ARGeoAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchor;
	GetLongitude(): number;
	GetLatitude(): number;
	GetAltitudeSource(): EARAltitudeSource;
	GetAltitudeMeters(): number;
	static C(Other: UObject | any): ARGeoAnchor;
}

declare class ARTrackableNotifyComponent extends ActorComponent { 
	OnAddTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnUpdateTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnRemoveTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnAddTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnUpdateTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnRemoveTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnAddTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnUpdateTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnRemoveTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnAddTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnUpdateTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnRemoveTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnAddTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnUpdateTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnRemoveTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnAddTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnUpdateTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnRemoveTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnAddTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnUpdateTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnRemoveTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	static Load(ResourceName: string): ARTrackableNotifyComponent;
	static Find(Outer: UObject, ResourceName: string): ARTrackableNotifyComponent;
	static GetDefaultObject(): ARTrackableNotifyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackableNotifyComponent;
	static C(Other: UObject | any): ARTrackableNotifyComponent;
}

declare class ARTypesDummyClass extends UObject { 
	static Load(ResourceName: string): ARTypesDummyClass;
	static Find(Outer: UObject, ResourceName: string): ARTypesDummyClass;
	static GetDefaultObject(): ARTypesDummyClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTypesDummyClass;
	static C(Other: UObject | any): ARTypesDummyClass;
}

declare type EHandKeypoint = 'Palm' | 'Wrist' | 'ThumbMetacarpal' | 'ThumbProximal' | 'ThumbDistal' | 'ThumbTip' | 'IndexMetacarpal' | 'IndexProximal' | 'IndexIntermediate' | 'IndexDistal' | 'IndexTip' | 'MiddleMetacarpal' | 'MiddleProximal' | 'MiddleIntermediate' | 'MiddleDistal' | 'MiddleTip' | 'RingMetacarpal' | 'RingProximal' | 'RingIntermediate' | 'RingDistal' | 'RingTip' | 'LittleMetacarpal' | 'LittleProximal' | 'LittleIntermediate' | 'LittleDistal' | 'LittleTip' | 'EHandKeypoint_MAX';
declare var EHandKeypoint : { Palm:'Palm',Wrist:'Wrist',ThumbMetacarpal:'ThumbMetacarpal',ThumbProximal:'ThumbProximal',ThumbDistal:'ThumbDistal',ThumbTip:'ThumbTip',IndexMetacarpal:'IndexMetacarpal',IndexProximal:'IndexProximal',IndexIntermediate:'IndexIntermediate',IndexDistal:'IndexDistal',IndexTip:'IndexTip',MiddleMetacarpal:'MiddleMetacarpal',MiddleProximal:'MiddleProximal',MiddleIntermediate:'MiddleIntermediate',MiddleDistal:'MiddleDistal',MiddleTip:'MiddleTip',RingMetacarpal:'RingMetacarpal',RingProximal:'RingProximal',RingIntermediate:'RingIntermediate',RingDistal:'RingDistal',RingTip:'RingTip',LittleMetacarpal:'LittleMetacarpal',LittleProximal:'LittleProximal',LittleIntermediate:'LittleIntermediate',LittleDistal:'LittleDistal',LittleTip:'LittleTip',EHandKeypoint_MAX:'EHandKeypoint_MAX', };
declare class HandKeypointConversion extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HandKeypointConversion;
	static Find(Outer: UObject, ResourceName: string): HandKeypointConversion;
	static GetDefaultObject(): HandKeypointConversion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandKeypointConversion;
	static Conv_HandKeypointToInt32(Input: EHandKeypoint): number;
	static C(Other: UObject | any): HandKeypointConversion;
}

declare type ESpectatorScreenMode = 'Disabled' | 'SingleEyeLetterboxed' | 'Undistorted' | 'Distorted' | 'SingleEye' | 'SingleEyeCroppedToFill' | 'Texture' | 'TexturePlusEye' | 'ESpectatorScreenMode_MAX';
declare var ESpectatorScreenMode : { Disabled:'Disabled',SingleEyeLetterboxed:'SingleEyeLetterboxed',Undistorted:'Undistorted',Distorted:'Distorted',SingleEye:'SingleEye',SingleEyeCroppedToFill:'SingleEyeCroppedToFill',Texture:'Texture',TexturePlusEye:'TexturePlusEye',ESpectatorScreenMode_MAX:'ESpectatorScreenMode_MAX', };
declare type EOrientPositionSelector = 'Orientation' | 'Position' | 'OrientationAndPosition' | 'EOrientPositionSelector_MAX';
declare var EOrientPositionSelector : { Orientation:'Orientation',Position:'Position',OrientationAndPosition:'OrientationAndPosition',EOrientPositionSelector_MAX:'EOrientPositionSelector_MAX', };
declare type EHMDWornState = 'Unknown' | 'Worn' | 'NotWorn' | 'EHMDWornState_MAX';
declare var EHMDWornState : { Unknown:'Unknown',Worn:'Worn',NotWorn:'NotWorn',EHMDWornState_MAX:'EHMDWornState_MAX', };
declare type EXRTrackedDeviceType = 'HeadMountedDisplay' | 'Controller' | 'TrackingReference' | 'Other' | 'Invalid' | 'Any' | 'EXRTrackedDeviceType_MAX';
declare var EXRTrackedDeviceType : { HeadMountedDisplay:'HeadMountedDisplay',Controller:'Controller',TrackingReference:'TrackingReference',Other:'Other',Invalid:'Invalid',Any:'Any',EXRTrackedDeviceType_MAX:'EXRTrackedDeviceType_MAX', };
declare type EXRDeviceConnectionResult = 'NoTrackingSystem' | 'FeatureNotSupported' | 'NoValidViewport' | 'MiscFailure' | 'Success' | 'EXRDeviceConnectionResult_MAX';
declare var EXRDeviceConnectionResult : { NoTrackingSystem:'NoTrackingSystem',FeatureNotSupported:'FeatureNotSupported',NoValidViewport:'NoValidViewport',MiscFailure:'MiscFailure',Success:'Success',EXRDeviceConnectionResult_MAX:'EXRDeviceConnectionResult_MAX', };
declare type ESpatialInputGestureAxis = 'None' | 'Manipulation' | 'Navigation' | 'NavigationRails' | 'ESpatialInputGestureAxis_MAX';
declare var ESpatialInputGestureAxis : { None:'None',Manipulation:'Manipulation',Navigation:'Navigation',NavigationRails:'NavigationRails',ESpatialInputGestureAxis_MAX:'ESpatialInputGestureAxis_MAX', };
declare class XRGestureConfig { 
	bTap: boolean;
	bHold: boolean;
	AxisGesture: ESpatialInputGestureAxis;
	bNavigationAxisX: boolean;
	bNavigationAxisY: boolean;
	bNavigationAxisZ: boolean;
	clone() : XRGestureConfig;
	static C(Other: UObject | any): XRGestureConfig;
	ConfigureGestures(): boolean;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
}

declare class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static GetDefaultObject(): HeadMountedDisplayFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HeadMountedDisplayFunctionLibrary;
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
	static SetTrackingOrigin(Origin: EHMDTrackingOrigin): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static SetSpectatorScreenMode(Mode: ESpectatorScreenMode): void;
	static SetClippingPlanes(Near: number,Far: number): void;
	static ResetOrientationAndPosition(Yaw: number,Options: EOrientPositionSelector): void;
	static IsSpectatorScreenModeControllable(): boolean;
	static IsInLowPersistenceMode(): boolean;
	static IsHeadMountedDisplayEnabled(): boolean;
	static IsHeadMountedDisplayConnected(): boolean;
	static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
	static HasValidTrackingPosition(): boolean;
	static GetXRSystemFlags(): number;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static GetVRFocusState(bUseFocus?: boolean,bHasFocus?: boolean): {bUseFocus: boolean, bHasFocus: boolean};
	static GetVersionString(): string;
	static GetTrackingToWorldTransform(WorldContext: UObject): Transform;
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static GetTrackingOriginTransform(Origin: EHMDTrackingOrigin,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	static GetTrackingOrigin(): EHMDTrackingOrigin;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetPlayAreaRect(OutTransform?: Transform,OutRect?: Vector2D): {OutTransform: Transform, OutRect: Vector2D, $: boolean};
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
	static GetPixelDensity(): number;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static GetNumOfTrackingSensors(): number;
	static GetMotionControllerData(WorldContext: UObject,Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	static GetHMDWornState(): EHMDWornState;
	static GetHMDDeviceName(): string;
	static GetHMDData(WorldContext: UObject,HMDData?: XRHMDData): {HMDData: XRHMDData};
	static GetDeviceWorldPose(WorldContext: UObject,XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetDevicePose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,Position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, Position: Vector};
	static GetCurrentInteractionProfile(Hand: EControllerHand,InteractionProfile?: string): {InteractionProfile: string, $: boolean};
	static GetControllerTransformForTime(WorldContext: UObject,ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,Position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, Position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	static EnumerateTrackedDevices(SystemId: string,DeviceType: EXRTrackedDeviceType): XRDeviceId[];
	static EnableLowPersistenceMode(bEnable: boolean): void;
	static EnableHMD(bEnable: boolean): boolean;
	static DisconnectRemoteXRDevice(): void;
	static ConnectRemoteXRDevice(IpAddress: string,BitRate: number): EXRDeviceConnectionResult;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
	static ClearXRTimedInputActionDelegate(ActionPath: string): void;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static BreakKey(InKey: Key,InteractionProfile?: string,Hand?: EControllerHand,MotionSource?: string,Indentifier?: string,Component?: string): {InteractionProfile: string, Hand: EControllerHand, MotionSource: string, Indentifier: string, Component: string};
	static C(Other: UObject | any): HeadMountedDisplayFunctionLibrary;
}

declare class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static GetDefaultObject(): MotionTrackedDeviceFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrackedDeviceFunctionLibrary;
	static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;
	static IsMotionTrackingEnabledForSource(PlayerIndex: number,SourceName: string): boolean;
	static IsMotionTrackingEnabledForDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackedDeviceCountManagementNecessary(): boolean;
	static IsMotionSourceTracking(PlayerIndex: number,SourceName: string): boolean;
	static GetMotionTrackingEnabledControllerCount(): number;
	static GetMaximumMotionTrackedControllerCount(): number;
	static GetActiveTrackingSystemName(): string;
	static EnumerateMotionSources(): string[];
	static EnableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): boolean;
	static EnableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static DisableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): void;
	static DisableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): void;
	static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;
	static DisableMotionTrackingOfAllControllers(): void;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static C(Other: UObject | any): MotionTrackedDeviceFunctionLibrary;
}

declare class VRNotificationsComponent extends ActorComponent { 
	HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDTrackingInitializedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDLostDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDReconnectedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDConnectCanceledDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDPutOnHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRemovedFromHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	VRControllerRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	XRTrackingOriginChangedDelegate: UnrealEngineMulticastDelegate<() => void>;
	XRPlayAreaChangedDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): VRNotificationsComponent;
	static Find(Outer: UObject, ResourceName: string): VRNotificationsComponent;
	static GetDefaultObject(): VRNotificationsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRNotificationsComponent;
	static C(Other: UObject | any): VRNotificationsComponent;
}

declare class XRAssetFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRAssetFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRAssetFunctionLibrary;
	static GetDefaultObject(): XRAssetFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRAssetFunctionLibrary;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static C(Other: UObject | any): XRAssetFunctionLibrary;
}

declare class AsyncTask_LoadXRDeviceVisComponent extends BlueprintAsyncActionBase { 
	OnModelLoaded: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	OnLoadFailure: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	SpawnedComponent: PrimitiveComponent;
	static Load(ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static Find(Outer: UObject, ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static GetDefaultObject(): AsyncTask_LoadXRDeviceVisComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTask_LoadXRDeviceVisComponent;
	static AddNamedDeviceVisualizationComponentAsync(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId,NewComponent?: PrimitiveComponent): {XRDeviceId: XRDeviceId, NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static AddDeviceVisualizationComponentAsync(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform,NewComponent?: PrimitiveComponent): {NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static C(Other: UObject | any): AsyncTask_LoadXRDeviceVisComponent;
}

declare class XRLoadingScreenFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRLoadingScreenFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRLoadingScreenFunctionLibrary;
	static GetDefaultObject(): XRLoadingScreenFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRLoadingScreenFunctionLibrary;
	static ShowLoadingScreen(): void;
	static SetLoadingScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static HideLoadingScreen(): void;
	static ClearLoadingScreenSplashes(): void;
	static AddLoadingScreenSplash(Texture: Texture,Translation: Vector,Rotation: Rotator,Size: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	static C(Other: UObject | any): XRLoadingScreenFunctionLibrary;
}

declare class ActorTransformer extends ViewportTransformer { 
	static Load(ResourceName: string): ActorTransformer;
	static Find(Outer: UObject, ResourceName: string): ActorTransformer;
	static GetDefaultObject(): ActorTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTransformer;
	static C(Other: UObject | any): ActorTransformer;
}

declare class ViewportInteractableInterface extends Interface { 
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static GetDefaultObject(): ViewportInteractableInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject | any): ViewportInteractableInterface;
}

declare class TranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): TranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): TranslationDragOperation;
	static GetDefaultObject(): TranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationDragOperation;
	static C(Other: UObject | any): TranslationDragOperation;
}

declare class PlaneTranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): PlaneTranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): PlaneTranslationDragOperation;
	static GetDefaultObject(): PlaneTranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneTranslationDragOperation;
	static C(Other: UObject | any): PlaneTranslationDragOperation;
}

declare class RotateOnAngleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): RotateOnAngleDragOperation;
	static Find(Outer: UObject, ResourceName: string): RotateOnAngleDragOperation;
	static GetDefaultObject(): RotateOnAngleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotateOnAngleDragOperation;
	static C(Other: UObject | any): RotateOnAngleDragOperation;
}

declare class ScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): ScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): ScaleDragOperation;
	static GetDefaultObject(): ScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleDragOperation;
	static C(Other: UObject | any): ScaleDragOperation;
}

declare class UniformScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): UniformScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): UniformScaleDragOperation;
	static GetDefaultObject(): UniformScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleDragOperation;
	static C(Other: UObject | any): UniformScaleDragOperation;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject | any): AxisGizmoHandleGroup;
}

declare class GizmoHandleMeshComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): GizmoHandleMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleMeshComponent;
	static GetDefaultObject(): GizmoHandleMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleMeshComponent;
	static C(Other: UObject | any): GizmoHandleMeshComponent;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject | any): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject | any): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	RootFullRotationHandleComponent: SceneComponent;
	FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
	StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootStartRotationIdicatorComponent: SceneComponent;
	DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootDeltaRotationIndicatorComponent: SceneComponent;
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject | any): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject | any): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	LastDraggingHandle: ActorComponent;
	static GetDefaultObject(): PivotTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject | any): PivotTransformGizmo;
}

declare class StretchGizmoHandleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): StretchGizmoHandleDragOperation;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleDragOperation;
	static GetDefaultObject(): StretchGizmoHandleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleDragOperation;
	static C(Other: UObject | any): StretchGizmoHandleDragOperation;
}

declare class InterchangeAssetImportData extends AssetImportData { 
	NodeContainer: InterchangeBaseNodeContainer;
	NodeUniqueID: string;
	Pipelines: UObject[];
	static Load(ResourceName: string): InterchangeAssetImportData;
	static Find(Outer: UObject, ResourceName: string): InterchangeAssetImportData;
	static GetDefaultObject(): InterchangeAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAssetImportData;
	ScriptGetFirstFilename(): string;
	ScriptExtractFilenames(): string[];
	ScriptExtractDisplayLabels(): string[];
	static C(Other: UObject | any): InterchangeAssetImportData;
}

declare class InterchangeBlueprintPipelineBase extends Blueprint { 
	static Load(ResourceName: string): InterchangeBlueprintPipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeBlueprintPipelineBase;
	static GetDefaultObject(): InterchangeBlueprintPipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBlueprintPipelineBase;
	static C(Other: UObject | any): InterchangeBlueprintPipelineBase;
}

declare type EInterchangeTranslatorType = 'Invalid' | 'Assets' | 'Actors' | 'Scenes' | 'EInterchangeTranslatorType_MAX';
declare var EInterchangeTranslatorType : { Invalid:'Invalid',Assets:'Assets',Actors:'Actors',Scenes:'Scenes',EInterchangeTranslatorType_MAX:'EInterchangeTranslatorType_MAX', };
declare class InterchangeFilePickerParameters { 
	bAllowMultipleFiles: boolean;
	Title: string;
	DefaultPath: string;
	clone() : InterchangeFilePickerParameters;
	static C(Other: UObject | any): InterchangeFilePickerParameters;
}

declare type EInterchangeTranslatorAssetType = 'None' | 'Textures' | 'Materials' | 'Meshes' | 'Animations' | 'EInterchangeTranslatorAssetType_MAX';
declare var EInterchangeTranslatorAssetType : { None:'None',Textures:'Textures',Materials:'Materials',Meshes:'Meshes',Animations:'Animations',EInterchangeTranslatorAssetType_MAX:'EInterchangeTranslatorAssetType_MAX', };
declare class InterchangeFilePickerBase extends UObject { 
	static Load(ResourceName: string): InterchangeFilePickerBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFilePickerBase;
	static GetDefaultObject(): InterchangeFilePickerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFilePickerBase;
	ScriptedFilePickerForTranslatorType(TranslatorType: EInterchangeTranslatorType,Parameters?: InterchangeFilePickerParameters,OutFilenames?: string[]): {Parameters: InterchangeFilePickerParameters, OutFilenames: string[], $: boolean};
	ScriptedFilePickerForTranslatorAssetType(TranslatorAssetType: EInterchangeTranslatorAssetType,Parameters?: InterchangeFilePickerParameters,OutFilenames?: string[]): {Parameters: InterchangeFilePickerParameters, OutFilenames: string[], $: boolean};
	static C(Other: UObject | any): InterchangeFilePickerBase;
}

declare type EInterchangePipelineConfigurationDialogResult = 'Cancel' | 'Import' | 'ImportAll' | 'EInterchangePipelineConfigurationDialogResult_MAX';
declare var EInterchangePipelineConfigurationDialogResult : { Cancel:'Cancel',Import:'Import',ImportAll:'ImportAll',EInterchangePipelineConfigurationDialogResult_MAX:'EInterchangePipelineConfigurationDialogResult_MAX', };
declare class InterchangePipelineConfigurationBase extends UObject { 
	static Load(ResourceName: string): InterchangePipelineConfigurationBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineConfigurationBase;
	static GetDefaultObject(): InterchangePipelineConfigurationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineConfigurationBase;
	ScriptedShowScenePipelineConfigurationDialog(SourceData: InterchangeSourceData): EInterchangePipelineConfigurationDialogResult;
	ScriptedShowReimportPipelineConfigurationDialog(PipelineStack?: InterchangePipelineBase[],SourceData?: InterchangeSourceData): {PipelineStack: InterchangePipelineBase[], $: EInterchangePipelineConfigurationDialogResult};
	ScriptedShowPipelineConfigurationDialog(SourceData: InterchangeSourceData): EInterchangePipelineConfigurationDialogResult;
	static C(Other: UObject | any): InterchangePipelineConfigurationBase;
}

declare class InterchangePipelineStack { 
	Pipelines: SoftObjectPath[];
	clone() : InterchangePipelineStack;
	static C(Other: UObject | any): InterchangePipelineStack;
}

declare class InterchangeImportSettings { 
	PipelineStacks: Map<string, InterchangePipelineStack>;
	DefaultPipelineStack: string;
	PipelineConfigurationDialogClass: Class;
	bShowPipelineStacksConfigurationDialog: boolean;
	clone() : InterchangeImportSettings;
	static C(Other: UObject | any): InterchangeImportSettings;
}

declare class InterchangeContentImportSettings extends InterchangeImportSettings { 
	DefaultPipelineStackOverride: Map<EInterchangeTranslatorAssetType, string>;
	ShowPipelineStacksConfigurationDialogOverride: Map<EInterchangeTranslatorAssetType, boolean>;
	clone() : InterchangeContentImportSettings;
	static C(Other: UObject | any): InterchangeContentImportSettings;
}

declare class InterchangeProjectSettings extends DeveloperSettings { 
	ContentImportSettings: InterchangeContentImportSettings;
	SceneImportSettings: InterchangeImportSettings;
	FilePickerClass: Class;
	bStaticMeshUseSmoothEdgesIfSmoothingInformationIsMissing: boolean;
	GenericPipelineClass: Class;
	static Load(ResourceName: string): InterchangeProjectSettings;
	static Find(Outer: UObject, ResourceName: string): InterchangeProjectSettings;
	static GetDefaultObject(): InterchangeProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeProjectSettings;
	static C(Other: UObject | any): InterchangeProjectSettings;
}

declare class InterchangePythonPipelineBase extends InterchangePipelineBase { 
	static Load(ResourceName: string): InterchangePythonPipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePythonPipelineBase;
	static GetDefaultObject(): InterchangePythonPipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePythonPipelineBase;
	static C(Other: UObject | any): InterchangePythonPipelineBase;
}

declare class InterchangePythonPipelineAsset extends UObject { 
	PythonClass: Class;
	GeneratedPipeline: InterchangePythonPipelineBase;
	JsonDefaultProperties: string;
	static Load(ResourceName: string): InterchangePythonPipelineAsset;
	static Find(Outer: UObject, ResourceName: string): InterchangePythonPipelineAsset;
	static GetDefaultObject(): InterchangePythonPipelineAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePythonPipelineAsset;
	static C(Other: UObject | any): InterchangePythonPipelineAsset;
}

declare class ImportAssetParameters { 
	ReimportAsset: UObject;
	ReimportSourceIndex: number;
	bIsAutomated: boolean;
	OverridePipelines: InterchangePipelineBase[];
	OnAssetDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnAssetsImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	OnSceneObjectDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnSceneImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	clone() : ImportAssetParameters;
	static C(Other: UObject | any): ImportAssetParameters;
}

declare class InterchangeManager extends UObject { 
	RegisteredTranslatorsClass: Set<UnrealEngineClass>;
	RegisteredFactoryClasses: Map<UnrealEngineClass, UnrealEngineClass>;
	RegisteredWriters: Map<UnrealEngineClass, InterchangeWriterBase>;
	static Load(ResourceName: string): InterchangeManager;
	static Find(Outer: UObject, ResourceName: string): InterchangeManager;
	static GetDefaultObject(): InterchangeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeManager;
	ImportScene(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	ImportAsset(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	GetRegisteredFactoryClass(ClassToMake: UnrealEngineClass): UnrealEngineClass;
	static GetInterchangeManagerScripted(): InterchangeManager;
	ExportScene(World: UObject,bIsAutomated: boolean): boolean;
	ExportAsset(Asset: UObject,bIsAutomated: boolean): boolean;
	static CreateSourceData(InFilename: string): InterchangeSourceData;
	static C(Other: UObject | any): InterchangeManager;
}

declare class InterchangeMeshUtilities extends UObject { 
	static Load(ResourceName: string): InterchangeMeshUtilities;
	static Find(Outer: UObject, ResourceName: string): InterchangeMeshUtilities;
	static GetDefaultObject(): InterchangeMeshUtilities;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeMeshUtilities;
	static C(Other: UObject | any): InterchangeMeshUtilities;
}

declare class AdvancedCopyMap { 
	ClassToCopy: SoftClassPath;
	AdvancedCopyCustomization: SoftClassPath;
	clone() : AdvancedCopyMap;
	static C(Other: UObject | any): AdvancedCopyMap;
}

declare class AssetToolsSettings extends DeveloperSettings { 
	AdvancedCopyCustomizations: AdvancedCopyMap[];
	static Load(ResourceName: string): AssetToolsSettings;
	static Find(Outer: UObject, ResourceName: string): AssetToolsSettings;
	static GetDefaultObject(): AssetToolsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsSettings;
	static C(Other: UObject | any): AssetToolsSettings;
}

declare class AssetRenameData { 
	Asset: UObject;
	NewPackagePath: string;
	NewName: string;
	OldObjectPath: SoftObjectPath;
	NewObjectPath: SoftObjectPath;
	bOnlyFixSoftReferences: boolean;
	clone() : AssetRenameData;
	static C(Other: UObject | any): AssetRenameData;
}

declare type EAssetRenameResult = 'Failure' | 'Success' | 'Pending' | 'EAssetRenameResult_MAX';
declare var EAssetRenameResult : { Failure:'Failure',Success:'Success',Pending:'Pending',EAssetRenameResult_MAX:'EAssetRenameResult_MAX', };
declare type EAssetMigrationConflict = 'Skip' | 'Overwrite' | 'Cancel' | 'EAssetMigrationConflict_MAX';
declare var EAssetMigrationConflict : { Skip:'Skip',Overwrite:'Overwrite',Cancel:'Cancel',EAssetMigrationConflict_MAX:'EAssetMigrationConflict_MAX', };
declare class MigrationOptions { 
	AssetConflict: EAssetMigrationConflict;
	OrphanFolder: string;
	clone() : MigrationOptions;
	static C(Other: UObject | any): MigrationOptions;
}

declare class RevisionInfo { 
	Revision: string;
	Changelist: number;
	Date: DateTime;
	clone() : RevisionInfo;
	static C(Other: UObject | any): RevisionInfo;
}

declare class AssetTools extends Interface { 
	static Load(ResourceName: string): AssetTools;
	static Find(Outer: UObject, ResourceName: string): AssetTools;
	static GetDefaultObject(): AssetTools;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetTools;
	RenameReferencingSoftObjectPaths(PackagesToCheck: Package[],AssetRedirectorMap: Map<SoftObjectPath, SoftObjectPath>): void;
	RenameAssetsWithDialog(AssetsAndNames: AssetRenameData[],bAutoCheckout: boolean): EAssetRenameResult;
	RenameAssets(AssetsAndNames: AssetRenameData[]): boolean;
	OpenEditorForAssets(Assets: UObject[]): void;
	MigratePackages(PackageNamesToMigrate: string[],DestinationPath: string,Options: MigrationOptions): void;
	ImportAssetTasks(ImportTasks: AssetImportTask[]): void;
	ImportAssetsWithDialog(DestinationPath: string): UObject[];
	ImportAssetsAutomated(ImportData: AutomatedAssetImportData): UObject[];
	FindSoftReferencesToObject(TargetObject: SoftObjectPath,ReferencingObjects?: UObject[]): {ReferencingObjects: UObject[]};
	ExportAssetsWithDialog(AssetsToExport: string[],bPromptForIndividualFilenames: boolean): void;
	ExportAssets(AssetsToExport: string[],ExportPath: string): void;
	DuplicateAssetWithDialogAndTitle(AssetName: string,PackagePath: string,OriginalObject: UObject,DialogTitle: string): UObject;
	DuplicateAssetWithDialog(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DuplicateAsset(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DiffAssets(OldAsset: UObject,NewAsset: UObject,OldRevision: RevisionInfo,NewRevision: RevisionInfo): void;
	DiffAgainstDepot(InObject: UObject,InPackagePath: string,InPackageName: string): void;
	CreateUniqueAssetName(InBasePackageName: string,InSuffix: string,OutPackageName?: string,OutAssetName?: string): {OutPackageName: string, OutAssetName: string};
	CreateAssetWithDialog(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string,bCallConfigureProperties: boolean): UObject;
	CreateAsset(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string): UObject;
	static C(Other: UObject | any): AssetTools;
}

declare class AssetToolsHelpers extends UObject { 
	static Load(ResourceName: string): AssetToolsHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetToolsHelpers;
	static GetDefaultObject(): AssetToolsHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsHelpers;
	static C(Other: UObject | any): AssetToolsHelpers;
}

declare class AdvancedCopyCustomization extends UObject { 
	static Load(ResourceName: string): AdvancedCopyCustomization;
	static Find(Outer: UObject, ResourceName: string): AdvancedCopyCustomization;
	static GetDefaultObject(): AdvancedCopyCustomization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AdvancedCopyCustomization;
	static C(Other: UObject | any): AdvancedCopyCustomization;
}

declare class AssetToolsImpl extends UObject { 
	static Load(ResourceName: string): AssetToolsImpl;
	static Find(Outer: UObject, ResourceName: string): AssetToolsImpl;
	static GetDefaultObject(): AssetToolsImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsImpl;
	static C(Other: UObject | any): AssetToolsImpl;
}

declare class StatusBarSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): StatusBarSubsystem;
	static Find(Outer: UObject, ResourceName: string): StatusBarSubsystem;
	static GetDefaultObject(): StatusBarSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatusBarSubsystem;
	static C(Other: UObject | any): StatusBarSubsystem;
}

declare class LevelEditorMenuContext extends UObject { 
	static Load(ResourceName: string): LevelEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorMenuContext;
	static GetDefaultObject(): LevelEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorMenuContext;
	static C(Other: UObject | any): LevelEditorMenuContext;
}

declare type ELevelEditorMenuContext = 'Viewport' | 'SceneOutliner' | 'MainMenu' | 'ELevelEditorMenuContext_MAX';
declare var ELevelEditorMenuContext : { Viewport:'Viewport',SceneOutliner:'SceneOutliner',MainMenu:'MainMenu',ELevelEditorMenuContext_MAX:'ELevelEditorMenuContext_MAX', };
declare class LevelEditorContextMenuContext extends UObject { 
	ContextType: ELevelEditorMenuContext;
	CurrentSelection: TypedElementSelectionSet;
	CursorWorldLocation: Vector;
	SelectedComponents: ActorComponent[];
	HitProxyActor: Actor;
	static Load(ResourceName: string): LevelEditorContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorContextMenuContext;
	static GetDefaultObject(): LevelEditorContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorContextMenuContext;
	GetScriptHitProxyElement(): ScriptTypedElementHandle;
	static C(Other: UObject | any): LevelEditorContextMenuContext;
}

declare class LevelViewportToolBarContext extends UObject { 
	static Load(ResourceName: string): LevelViewportToolBarContext;
	static Find(Outer: UObject, ResourceName: string): LevelViewportToolBarContext;
	static GetDefaultObject(): LevelViewportToolBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelViewportToolBarContext;
	static C(Other: UObject | any): LevelViewportToolBarContext;
}

declare class QuickActionMenuContext extends UObject { 
	CurrentSelection: TypedElementSelectionSet;
	static Load(ResourceName: string): QuickActionMenuContext;
	static Find(Outer: UObject, ResourceName: string): QuickActionMenuContext;
	static GetDefaultObject(): QuickActionMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuickActionMenuContext;
	static C(Other: UObject | any): QuickActionMenuContext;
}

declare class LevelEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LevelEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorSubsystem;
	static GetDefaultObject(): LevelEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorSubsystem;
	SetCurrentLevelByName(LevelName: string): boolean;
	SetAllowsCinematicControl(bAllow: boolean,ViewportConfigKey: string): void;
	SaveCurrentLevel(): boolean;
	SaveAllDirtyLevels(): boolean;
	PilotLevelActor(ActorToPilot: Actor,ViewportConfigKey: string): void;
	NewLevelFromTemplate(AssetPath: string,TemplateAssetPath: string): boolean;
	NewLevel(AssetPath: string): boolean;
	LoadLevel(AssetPath: string): boolean;
	IsInPlayInEditor(): boolean;
	GetViewportConfigKeys(): string[];
	GetSelectionSet(): TypedElementSelectionSet;
	GetPilotLevelActor(ViewportConfigKey: string): Actor;
	GetCurrentLevel(): Level;
	GetAllowsCinematicControl(ViewportConfigKey: string): boolean;
	GetActiveViewportConfigKey(): string;
	EjectPilotLevelActor(ViewportConfigKey: string): void;
	EditorSetGameView(bGameView: boolean,ViewportConfigKey: string): void;
	EditorRequestEndPlay(): void;
	EditorPlaySimulate(): void;
	EditorInvalidateViewports(): void;
	EditorGetGameView(ViewportConfigKey: string): boolean;
	BuildLightMaps(Quality: ELightingBuildQuality,bWithReflectionCaptures: boolean): boolean;
	static C(Other: UObject | any): LevelEditorSubsystem;
}

declare class LightEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LightEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LightEditorSubsystem;
	static GetDefaultObject(): LightEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightEditorSubsystem;
	static C(Other: UObject | any): LightEditorSubsystem;
}

declare class AssetEditorUISubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): AssetEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): AssetEditorUISubsystem;
	static GetDefaultObject(): AssetEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorUISubsystem;
	static C(Other: UObject | any): AssetEditorUISubsystem;
}

declare class LevelEditorUISubsystem extends AssetEditorUISubsystem { 
	static Load(ResourceName: string): LevelEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorUISubsystem;
	static GetDefaultObject(): LevelEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorUISubsystem;
	static C(Other: UObject | any): LevelEditorUISubsystem;
}

declare class Manipulator extends Actor { 
	AssociatedComponent: SceneComponent;
	StaticMeshComponent: StaticMeshComponent;
	static GetDefaultObject(): Manipulator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Manipulator;
	static C(Other: UObject | any): Manipulator;
}

declare class PropertyNameAndIndex { 
	Name: string;
	Index: number;
	clone() : PropertyNameAndIndex;
	static C(Other: UObject | any): PropertyNameAndIndex;
}

declare class ComponentPropertyPath { 
	ParentOwningActor: Actor;
	LastResortComponentPtr: ActorComponent;
	PropertyChain: PropertyNameAndIndex[];
	clone() : ComponentPropertyPath;
	static C(Other: UObject | any): ComponentPropertyPath;
}

declare type ESelectedTangentHandle = 'None' | 'Leave' | 'Arrive' | 'ESelectedTangentHandle_MAX';
declare var ESelectedTangentHandle : { None:'None',Leave:'Leave',Arrive:'Arrive',ESelectedTangentHandle_MAX:'ESelectedTangentHandle_MAX', };
declare class SplineComponentVisualizerSelectionState extends UObject { 
	SplinePropertyPath: ComponentPropertyPath;
	SelectedKeys: Set<number>;
	LastKeyIndexSelected: number;
	SelectedSegmentIndex: number;
	SelectedTangentHandle: number;
	SelectedTangentHandleType: ESelectedTangentHandle;
	SelectedSplinePosition: Vector;
	CachedRotation: Quat;
	static Load(ResourceName: string): SplineComponentVisualizerSelectionState;
	static Find(Outer: UObject, ResourceName: string): SplineComponentVisualizerSelectionState;
	static GetDefaultObject(): SplineComponentVisualizerSelectionState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponentVisualizerSelectionState;
	static C(Other: UObject | any): SplineComponentVisualizerSelectionState;
}

declare type EShapeAddMode = 'AppendAfter' | 'AppendBefore' | 'InsertAfter' | 'InsertBefore' | 'EShapeAddMode_MAX';
declare var EShapeAddMode : { AppendAfter:'AppendAfter',AppendBefore:'AppendBefore',InsertAfter:'InsertAfter',InsertBefore:'InsertBefore',EShapeAddMode_MAX:'EShapeAddMode_MAX', };
declare class SplineGeneratorBase extends UObject { 
	ShapeAddMode: EShapeAddMode;
	static Load(ResourceName: string): SplineGeneratorBase;
	static Find(Outer: UObject, ResourceName: string): SplineGeneratorBase;
	static GetDefaultObject(): SplineGeneratorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineGeneratorBase;
	static C(Other: UObject | any): SplineGeneratorBase;
}

declare class CircleSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Radius: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): CircleSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): CircleSplineGenerator;
	static GetDefaultObject(): CircleSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircleSplineGenerator;
	static C(Other: UObject | any): CircleSplineGenerator;
}

declare class ArcSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Radius: number;
	Degrees: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): ArcSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): ArcSplineGenerator;
	static GetDefaultObject(): ArcSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArcSplineGenerator;
	static C(Other: UObject | any): ArcSplineGenerator;
}

declare class SquareSplineGenerator extends SplineGeneratorBase { 
	Length: number;
	bBranchRight: boolean;
	static Load(ResourceName: string): SquareSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): SquareSplineGenerator;
	static GetDefaultObject(): SquareSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SquareSplineGenerator;
	static C(Other: UObject | any): SquareSplineGenerator;
}

declare class EllipseSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Length: number;
	Width: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): EllipseSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): EllipseSplineGenerator;
	static GetDefaultObject(): EllipseSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EllipseSplineGenerator;
	static C(Other: UObject | any): EllipseSplineGenerator;
}

declare class RectangleSplineGenerator extends SplineGeneratorBase { 
	Length: number;
	Width: number;
	bBranchRight: boolean;
	static Load(ResourceName: string): RectangleSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): RectangleSplineGenerator;
	static GetDefaultObject(): RectangleSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectangleSplineGenerator;
	static C(Other: UObject | any): RectangleSplineGenerator;
}

declare class LineSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Length: number;
	bEnableUpToNextPoint: boolean;
	bUpToNextPoint: boolean;
	static Load(ResourceName: string): LineSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): LineSplineGenerator;
	static GetDefaultObject(): LineSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LineSplineGenerator;
	static C(Other: UObject | any): LineSplineGenerator;
}

declare class GameplayTaskOwnerInterface extends Interface { 
	static Load(ResourceName: string): GameplayTaskOwnerInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTaskOwnerInterface;
	static GetDefaultObject(): GameplayTaskOwnerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskOwnerInterface;
	static C(Other: UObject | any): GameplayTaskOwnerInterface;
}

declare class GameplayTask_ClaimResource extends GameplayTask { 
	static Load(ResourceName: string): GameplayTask_ClaimResource;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_ClaimResource;
	static GetDefaultObject(): GameplayTask_ClaimResource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_ClaimResource;
	static C(Other: UObject | any): GameplayTask_ClaimResource;
}

declare class GameplayTask_SpawnActor extends GameplayTask { 
	Success: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	DidNotSpawn: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	ClassToSpawn: UnrealEngineClass;
	static Load(ResourceName: string): GameplayTask_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_SpawnActor;
	static GetDefaultObject(): GameplayTask_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_SpawnActor;
	FinishSpawningActor(WorldContextObject: UObject,SpawnedActor: Actor): void;
	BeginSpawningActor(WorldContextObject: UObject,SpawnedActor?: Actor): {SpawnedActor: Actor, $: boolean};
	static C(Other: UObject | any): GameplayTask_SpawnActor;
}

declare class GameplayTask_TimeLimitedExecution extends GameplayTask { 
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	OnTimeExpired: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_TimeLimitedExecution;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_TimeLimitedExecution;
	static GetDefaultObject(): GameplayTask_TimeLimitedExecution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_TimeLimitedExecution;
	static C(Other: UObject | any): GameplayTask_TimeLimitedExecution;
}

declare class GameplayTask_WaitDelay extends GameplayTask { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_WaitDelay;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_WaitDelay;
	static GetDefaultObject(): GameplayTask_WaitDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_WaitDelay;
	static C(Other: UObject | any): GameplayTask_WaitDelay;
}

declare class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintGameplayTagLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintGameplayTagLibrary;
	static GetDefaultObject(): BlueprintGameplayTagLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGameplayTagLibrary;
	static RemoveGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
	static NotEqual_TagContainerTagContainer(A: GameplayTagContainer,B: string): boolean;
	static NotEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static NotEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static MatchesTag(TagOne: GameplayTag,TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	static MatchesAnyTags(TagOne: GameplayTag,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
	static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
	static MakeGameplayTagContainerFromArray(GameplayTags: GameplayTag[]): GameplayTagContainer;
	static IsTagQueryEmpty(TagQuery: GameplayTagQuery): boolean;
	static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
	static HasTag(TagContainer: GameplayTagContainer,Tag: GameplayTag,bExactMatch: boolean): boolean;
	static HasAnyTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasAllTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static GetTagName(GameplayTag: GameplayTag): string;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static EqualEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static EqualEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer,GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	static AppendGameplayTagContainers(InOutTagContainer?: GameplayTagContainer,InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	static AddGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): BlueprintGameplayTagLibrary;
}

declare class GameplayTagAssetInterface extends Interface { 
	static Load(ResourceName: string): GameplayTagAssetInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTagAssetInterface;
	static GetDefaultObject(): GameplayTagAssetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagAssetInterface;
	HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;
	HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	GetOwnedGameplayTags(TagContainer?: GameplayTagContainer): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): GameplayTagAssetInterface;
}

declare class EditableGameplayTagQueryExpression extends UObject { 
	static Load(ResourceName: string): EditableGameplayTagQueryExpression;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression;
	static GetDefaultObject(): EditableGameplayTagQueryExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression;
}

declare class EditableGameplayTagQuery extends UObject { 
	UserDescription: string;
	RootExpression: EditableGameplayTagQueryExpression;
	TagQueryExportText_Helper: GameplayTagQuery;
	static Load(ResourceName: string): EditableGameplayTagQuery;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQuery;
	static GetDefaultObject(): EditableGameplayTagQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQuery;
	static C(Other: UObject | any): EditableGameplayTagQuery;
}

declare class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllTagsMatch;
}

declare class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyExprMatch;
}

declare class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllExprMatch;
}

declare class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoExprMatch;
}

declare type EGameplayTagSourceType = 'Native' | 'DefaultTagList' | 'TagList' | 'RestrictedTagList' | 'DataTable' | 'Invalid' | 'EGameplayTagSourceType_MAX';
declare var EGameplayTagSourceType : { Native:'Native',DefaultTagList:'DefaultTagList',TagList:'TagList',RestrictedTagList:'RestrictedTagList',DataTable:'DataTable',Invalid:'Invalid',EGameplayTagSourceType_MAX:'EGameplayTagSourceType_MAX', };
declare class GameplayTagTableRow extends TableRowBase { 
	Tag: string;
	DevComment: string;
	clone() : GameplayTagTableRow;
	static C(Other: UObject | any): GameplayTagTableRow;
}

declare class GameplayTagsList extends UObject { 
	ConfigFileName: string;
	GameplayTagList: GameplayTagTableRow[];
	static Load(ResourceName: string): GameplayTagsList;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsList;
	static GetDefaultObject(): GameplayTagsList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsList;
	static C(Other: UObject | any): GameplayTagsList;
}

declare class RestrictedGameplayTagTableRow extends GameplayTagTableRow { 
	bAllowNonRestrictedChildren: boolean;
	clone() : RestrictedGameplayTagTableRow;
	static C(Other: UObject | any): RestrictedGameplayTagTableRow;
}

declare class RestrictedGameplayTagsList extends UObject { 
	ConfigFileName: string;
	RestrictedGameplayTagList: RestrictedGameplayTagTableRow[];
	static Load(ResourceName: string): RestrictedGameplayTagsList;
	static Find(Outer: UObject, ResourceName: string): RestrictedGameplayTagsList;
	static GetDefaultObject(): RestrictedGameplayTagsList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RestrictedGameplayTagsList;
	static C(Other: UObject | any): RestrictedGameplayTagsList;
}

declare class GameplayTagSource { 
	SourceName: string;
	SourceType: EGameplayTagSourceType;
	SourceTagList: GameplayTagsList;
	SourceRestrictedTagList: RestrictedGameplayTagsList;
	clone() : GameplayTagSource;
	static C(Other: UObject | any): GameplayTagSource;
}

declare class GameplayTagsManager extends UObject { 
	TagSources: Map<string, GameplayTagSource>;
	GameplayTagTables: DataTable[];
	static Load(ResourceName: string): GameplayTagsManager;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsManager;
	static GetDefaultObject(): GameplayTagsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsManager;
	static C(Other: UObject | any): GameplayTagsManager;
}

declare class GameplayTagCategoryRemap { 
	BaseCategory: string;
	RemapCategories: string[];
	clone() : GameplayTagCategoryRemap;
	static C(Other: UObject | any): GameplayTagCategoryRemap;
}

declare class GameplayTagRedirect { 
	OldTagName: string;
	NewTagName: string;
	clone() : GameplayTagRedirect;
	static C(Other: UObject | any): GameplayTagRedirect;
}

declare class RestrictedConfigInfo { 
	RestrictedConfigName: string;
	Owners: string[];
	clone() : RestrictedConfigInfo;
	static C(Other: UObject | any): RestrictedConfigInfo;
}

declare class GameplayTagsSettings extends GameplayTagsList { 
	ImportTagsFromConfig: boolean;
	WarnOnInvalidTags: boolean;
	ClearInvalidTags: boolean;
	AllowEditorTagUnloading: boolean;
	AllowGameTagUnloading: boolean;
	FastReplication: boolean;
	InvalidTagCharacters: string;
	CategoryRemapping: GameplayTagCategoryRemap[];
	GameplayTagTableList: SoftObjectPath[];
	GameplayTagRedirects: GameplayTagRedirect[];
	CommonlyReplicatedTags: string[];
	NumBitsForContainerSize: number;
	NetIndexFirstBitSegment: number;
	RestrictedConfigFiles: RestrictedConfigInfo[];
	RestrictedTagList: string;
	static Load(ResourceName: string): GameplayTagsSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsSettings;
	static GetDefaultObject(): GameplayTagsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsSettings;
	static C(Other: UObject | any): GameplayTagsSettings;
}

declare class GameplayTagsDeveloperSettings extends DeveloperSettings { 
	DeveloperConfigName: string;
	FavoriteTagSource: string;
	static Load(ResourceName: string): GameplayTagsDeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsDeveloperSettings;
	static GetDefaultObject(): GameplayTagsDeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsDeveloperSettings;
	static C(Other: UObject | any): GameplayTagsDeveloperSettings;
}

declare class GameplayDebuggerNetPack { 
	clone() : GameplayDebuggerNetPack;
	static C(Other: UObject | any): GameplayDebuggerNetPack;
}

declare class GameplayDebuggerDebugActor { 
	ActorName: string;
	SyncCounter: number;
	clone() : GameplayDebuggerDebugActor;
	static C(Other: UObject | any): GameplayDebuggerDebugActor;
}

declare class GameplayDebuggerVisLogSync { 
	DeviceIDs: string;
	clone() : GameplayDebuggerVisLogSync;
	static C(Other: UObject | any): GameplayDebuggerVisLogSync;
}

declare class DebugDrawComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): DebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): DebugDrawComponent;
	static GetDefaultObject(): DebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugDrawComponent;
	static C(Other: UObject | any): DebugDrawComponent;
}

declare class GameplayDebuggerRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): GameplayDebuggerRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerRenderingComponent;
	static C(Other: UObject | any): GameplayDebuggerRenderingComponent;
}

declare class GameplayDebuggerCategoryReplicator extends Actor { 
	OwnerPC: PlayerController;
	bIsEnabled: boolean;
	ReplicatedData: GameplayDebuggerNetPack;
	DebugActor: GameplayDebuggerDebugActor;
	VisLogSync: GameplayDebuggerVisLogSync;
	RenderingComp: GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerCategoryReplicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerCategoryReplicator;
	ServerSetViewPoint(InViewLocation: Vector,InViewDirection: Vector): void;
	ServerSetEnabled(bEnable: boolean): void;
	ServerSetDebugActor(Actor: Actor,bSelectInEditor: boolean): void;
	ServerSetCategoryEnabled(CategoryId: number,bEnable: boolean): void;
	ServerSendExtensionInputEvent(ExtensionId: number,HandlerId: number): void;
	ServerSendCategoryInputEvent(CategoryId: number,HandlerId: number): void;
	ServerResetViewPoint(): void;
	static C(Other: UObject | any): GameplayDebuggerCategoryReplicator;
}

declare type EGameplayDebuggerOverrideMode = 'Enable' | 'Disable' | 'UseDefault' | 'EGameplayDebuggerOverrideMode_MAX';
declare var EGameplayDebuggerOverrideMode : { Enable:'Enable',Disable:'Disable',UseDefault:'UseDefault',EGameplayDebuggerOverrideMode_MAX:'EGameplayDebuggerOverrideMode_MAX', };
declare class GameplayDebuggerInputConfig { 
	ConfigName: string;
	Key: Key;
	bModShift: boolean;
	bModCtrl: boolean;
	bModAlt: boolean;
	bModCmd: boolean;
	clone() : GameplayDebuggerInputConfig;
	static C(Other: UObject | any): GameplayDebuggerInputConfig;
}

declare class GameplayDebuggerCategoryConfig { 
	CategoryName: string;
	SlotIdx: number;
	ActiveInGame: EGameplayDebuggerOverrideMode;
	ActiveInSimulate: EGameplayDebuggerOverrideMode;
	Hidden: EGameplayDebuggerOverrideMode;
	bOverrideSlotIdx: boolean;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerCategoryConfig;
	static C(Other: UObject | any): GameplayDebuggerCategoryConfig;
}

declare class GameplayDebuggerExtensionConfig { 
	ExtensionName: string;
	UseExtension: EGameplayDebuggerOverrideMode;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerExtensionConfig;
	static C(Other: UObject | any): GameplayDebuggerExtensionConfig;
}

declare class GameplayDebuggerConfig extends UObject { 
	ActivationKey: Key;
	CategoryRowNextKey: Key;
	CategoryRowPrevKey: Key;
	CategorySlot0: Key;
	CategorySlot1: Key;
	CategorySlot2: Key;
	CategorySlot3: Key;
	CategorySlot4: Key;
	CategorySlot5: Key;
	CategorySlot6: Key;
	CategorySlot7: Key;
	CategorySlot8: Key;
	CategorySlot9: Key;
	DebugCanvasPaddingLeft: number;
	DebugCanvasPaddingRight: number;
	DebugCanvasPaddingTop: number;
	DebugCanvasPaddingBottom: number;
	bDebugCanvasEnableTextShadow: boolean;
	Categories: GameplayDebuggerCategoryConfig[];
	Extensions: GameplayDebuggerExtensionConfig[];
	static Load(ResourceName: string): GameplayDebuggerConfig;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerConfig;
	static GetDefaultObject(): GameplayDebuggerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerConfig;
	static C(Other: UObject | any): GameplayDebuggerConfig;
}

declare class GameplayDebuggerUserSettings extends DeveloperSettings { 
	bEnableGameplayDebuggerInEditor: boolean;
	MaxViewDistance: number;
	MaxViewAngle: number;
	FontSize: number;
	static Load(ResourceName: string): GameplayDebuggerUserSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerUserSettings;
	static GetDefaultObject(): GameplayDebuggerUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerUserSettings;
	static C(Other: UObject | any): GameplayDebuggerUserSettings;
}

declare class GameplayDebuggerPlayerData { 
	Controller: GameplayDebuggerLocalController;
	InputComponent: InputComponent;
	Replicator: GameplayDebuggerCategoryReplicator;
	clone() : GameplayDebuggerPlayerData;
	static C(Other: UObject | any): GameplayDebuggerPlayerData;
}

declare class GameplayDebuggerPlayerManager extends Actor { 
	PlayerData: GameplayDebuggerPlayerData[];
	PendingRegistrations: GameplayDebuggerCategoryReplicator[];
	EditorWorldData: GameplayDebuggerPlayerData;
	static GetDefaultObject(): GameplayDebuggerPlayerManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerPlayerManager;
	static C(Other: UObject | any): GameplayDebuggerPlayerManager;
}

declare class GameplayDebuggerLocalController extends UObject { 
	CachedReplicator: GameplayDebuggerCategoryReplicator;
	CachedPlayerManager: GameplayDebuggerPlayerManager;
	DebugActorCandidate: Actor;
	HUDFont: Font;
	static Load(ResourceName: string): GameplayDebuggerLocalController;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerLocalController;
	static GetDefaultObject(): GameplayDebuggerLocalController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerLocalController;
	static C(Other: UObject | any): GameplayDebuggerLocalController;
}

declare class AIResourceInterface extends Interface { 
	static Load(ResourceName: string): AIResourceInterface;
	static Find(Outer: UObject, ResourceName: string): AIResourceInterface;
	static GetDefaultObject(): AIResourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResourceInterface;
	static C(Other: UObject | any): AIResourceInterface;
}

declare type EUserDefinedStructureStatus = 'UDSS_UpToDate' | 'UDSS_Dirty' | 'UDSS_Error' | 'UDSS_Duplicate' | 'UDSS_MAX';
declare var EUserDefinedStructureStatus : { UDSS_UpToDate:'UDSS_UpToDate',UDSS_Dirty:'UDSS_Dirty',UDSS_Error:'UDSS_Error',UDSS_Duplicate:'UDSS_Duplicate',UDSS_MAX:'UDSS_MAX', };
declare class ObjectCookedMetaDataStore { 
	ObjectMetaData: Map<string, string>;
	clone() : ObjectCookedMetaDataStore;
	static C(Other: UObject | any): ObjectCookedMetaDataStore;
}

declare class FieldCookedMetaDataStore { 
	FieldMetaData: Map<string, string>;
	clone() : FieldCookedMetaDataStore;
	static C(Other: UObject | any): FieldCookedMetaDataStore;
}

declare class StructCookedMetaDataStore { 
	ObjectMetaData: ObjectCookedMetaDataStore;
	PropertiesMetaData: Map<string, FieldCookedMetaDataStore>;
	clone() : StructCookedMetaDataStore;
	static C(Other: UObject | any): StructCookedMetaDataStore;
}

declare class StructCookedMetaData extends UObject { 
	StructMetadata: StructCookedMetaDataStore;
	static Load(ResourceName: string): StructCookedMetaData;
	static Find(Outer: UObject, ResourceName: string): StructCookedMetaData;
	static GetDefaultObject(): StructCookedMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructCookedMetaData;
	static C(Other: UObject | any): StructCookedMetaData;
}

declare class UserDefinedStruct extends ScriptStruct { 
	PrimaryStruct: UserDefinedStruct;
	ErrorMessage: string;
	EditorData: UObject;
	Status: EUserDefinedStructureStatus;
	Guid: Guid;
	CachedCookedMetaDataPtr: StructCookedMetaData;
	static Load(ResourceName: string): UserDefinedStruct;
	static Find(Outer: UObject, ResourceName: string): UserDefinedStruct;
	static GetDefaultObject(): UserDefinedStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedStruct;
	static C(Other: UObject | any): UserDefinedStruct;
}

declare class AISenseBlueprintListener extends UserDefinedStruct { 
	static Load(ResourceName: string): AISenseBlueprintListener;
	static Find(Outer: UObject, ResourceName: string): AISenseBlueprintListener;
	static GetDefaultObject(): AISenseBlueprintListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseBlueprintListener;
	static C(Other: UObject | any): AISenseBlueprintListener;
}

declare class AISense_Blueprint extends AISense { 
	ListenerDataType: UnrealEngineClass;
	ListenerContainer: AIPerceptionComponent[];
	UnprocessedEvents: AISenseEvent[];
	static Load(ResourceName: string): AISense_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISense_Blueprint;
	static GetDefaultObject(): AISense_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Blueprint;
	OnUpdate(EventsToProcess: AISenseEvent[]): number;
	OnListenerUpdated(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerUnregistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerRegistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	K2_OnNewPawn(NewPawn: Pawn): void;
	GetAllListenerComponents(ListenerComponents?: AIPerceptionComponent[]): {ListenerComponents: AIPerceptionComponent[]};
	GetAllListenerActors(ListenerActors?: Actor[]): {ListenerActors: Actor[]};
	static C(Other: UObject | any): AISense_Blueprint;
}

declare class AISenseConfig_Blueprint extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Blueprint;
	static GetDefaultObject(): AISenseConfig_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Blueprint;
	static C(Other: UObject | any): AISenseConfig_Blueprint;
}

declare class AINoiseEvent { 
	NoiseLocation: Vector;
	Loudness: number;
	MaxRange: number;
	Instigator: Actor;
	Tag: string;
	clone() : AINoiseEvent;
	static C(Other: UObject | any): AINoiseEvent;
}

declare class AISense_Hearing extends AISense { 
	NoiseEvents: AINoiseEvent[];
	SpeedOfSoundSq: number;
	static Load(ResourceName: string): AISense_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISense_Hearing;
	static GetDefaultObject(): AISense_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Hearing;
	static ReportNoiseEvent(WorldContextObject: UObject,NoiseLocation: Vector,Loudness: number,Instigator: Actor,MaxRange: number,Tag: string): void;
	static C(Other: UObject | any): AISense_Hearing;
}

declare class AISenseAffiliationFilter { 
	bDetectEnemies: boolean;
	bDetectNeutrals: boolean;
	bDetectFriendlies: boolean;
	clone() : AISenseAffiliationFilter;
	static C(Other: UObject | any): AISenseAffiliationFilter;
}

declare class AISenseConfig_Hearing extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	HearingRange: number;
	LoSHearingRange: number;
	bUseLoSHearing: boolean;
	DetectionByAffiliation: AISenseAffiliationFilter;
	static Load(ResourceName: string): AISenseConfig_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Hearing;
	static GetDefaultObject(): AISenseConfig_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Hearing;
	static C(Other: UObject | any): AISenseConfig_Hearing;
}

declare class AISenseConfig_Prediction extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Prediction;
	static GetDefaultObject(): AISenseConfig_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Prediction;
	static C(Other: UObject | any): AISenseConfig_Prediction;
}

declare class AISense_Sight extends AISense { 
	MaxTracesPerTick: number;
	MinQueriesPerTimeSliceCheck: number;
	MaxTimeSlicePerTick: number;
	HighImportanceQueryDistanceThreshold: number;
	MaxQueryImportance: number;
	SightLimitQueryImportance: number;
	static Load(ResourceName: string): AISense_Sight;
	static Find(Outer: UObject, ResourceName: string): AISense_Sight;
	static GetDefaultObject(): AISense_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Sight;
	static C(Other: UObject | any): AISense_Sight;
}

declare class AISenseConfig_Sight extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	SightRadius: number;
	LoseSightRadius: number;
	PeripheralVisionAngleDegrees: number;
	DetectionByAffiliation: AISenseAffiliationFilter;
	AutoSuccessRangeFromLastSeenLocation: number;
	PointOfViewBackwardOffset: number;
	NearClippingRadius: number;
	static Load(ResourceName: string): AISenseConfig_Sight;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Sight;
	static GetDefaultObject(): AISenseConfig_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Sight;
	static C(Other: UObject | any): AISenseConfig_Sight;
}

declare class AISenseConfig_Team extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Team;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Team;
	static GetDefaultObject(): AISenseConfig_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Team;
	static C(Other: UObject | any): AISenseConfig_Team;
}

declare class AISenseConfig_Touch extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Touch;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Touch;
	static GetDefaultObject(): AISenseConfig_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Touch;
	static C(Other: UObject | any): AISenseConfig_Touch;
}

declare class AIDamageEvent { 
	Amount: number;
	Location: Vector;
	HitLocation: Vector;
	DamagedActor: Actor;
	Instigator: Actor;
	Tag: string;
	clone() : AIDamageEvent;
	static C(Other: UObject | any): AIDamageEvent;
}

declare class AISenseEvent_Damage extends AISenseEvent { 
	Event: AIDamageEvent;
	static Load(ResourceName: string): AISenseEvent_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Damage;
	static GetDefaultObject(): AISenseEvent_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Damage;
	static C(Other: UObject | any): AISenseEvent_Damage;
}

declare class AISenseEvent_Hearing extends AISenseEvent { 
	Event: AINoiseEvent;
	static Load(ResourceName: string): AISenseEvent_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Hearing;
	static GetDefaultObject(): AISenseEvent_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Hearing;
	static C(Other: UObject | any): AISenseEvent_Hearing;
}

declare class CrowdAgentInterface extends Interface { 
	static Load(ResourceName: string): CrowdAgentInterface;
	static Find(Outer: UObject, ResourceName: string): CrowdAgentInterface;
	static GetDefaultObject(): CrowdAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdAgentInterface;
	static C(Other: UObject | any): CrowdAgentInterface;
}

declare class EnvQueryTypes extends UObject { 
	static Load(ResourceName: string): EnvQueryTypes;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTypes;
	static GetDefaultObject(): EnvQueryTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTypes;
	static C(Other: UObject | any): EnvQueryTypes;
}

declare class EQSQueryResultSourceInterface extends Interface { 
	static Load(ResourceName: string): EQSQueryResultSourceInterface;
	static Find(Outer: UObject, ResourceName: string): EQSQueryResultSourceInterface;
	static GetDefaultObject(): EQSQueryResultSourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSQueryResultSourceInterface;
	static C(Other: UObject | any): EQSQueryResultSourceInterface;
}

declare class GenericTeamAgentInterface extends Interface { 
	static Load(ResourceName: string): GenericTeamAgentInterface;
	static Find(Outer: UObject, ResourceName: string): GenericTeamAgentInterface;
	static GetDefaultObject(): GenericTeamAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenericTeamAgentInterface;
	static C(Other: UObject | any): GenericTeamAgentInterface;
}

declare class PawnAction_BlueprintBase extends PawnAction { 
	static Load(ResourceName: string): PawnAction_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): PawnAction_BlueprintBase;
	static GetDefaultObject(): PawnAction_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_BlueprintBase;
	ActionTick(ControlledPawn: Pawn,DeltaSeconds: number): void;
	ActionStart(ControlledPawn: Pawn): void;
	ActionResume(ControlledPawn: Pawn): void;
	ActionPause(ControlledPawn: Pawn): void;
	ActionFinished(ControlledPawn: Pawn,WithResult: EPawnActionResult): void;
	static C(Other: UObject | any): PawnAction_BlueprintBase;
}

declare class PawnAction_Move extends PawnAction { 
	GoalActor: Actor;
	GoalLocation: Vector;
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	bAllowStrafe: boolean;
	bFinishOnOverlap: boolean;
	bUsePathfinding: boolean;
	bAllowPartialPath: boolean;
	bProjectGoalToNavigation: boolean;
	bUpdatePathToGoal: boolean;
	bAbortSubActionOnPathChange: boolean;
	static Load(ResourceName: string): PawnAction_Move;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Move;
	static GetDefaultObject(): PawnAction_Move;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Move;
	static C(Other: UObject | any): PawnAction_Move;
}

declare type EPawnActionFailHandling = 'RequireSuccess' | 'IgnoreFailure' | 'EPawnActionFailHandling_MAX';
declare var EPawnActionFailHandling : { RequireSuccess:'RequireSuccess',IgnoreFailure:'IgnoreFailure',EPawnActionFailHandling_MAX:'EPawnActionFailHandling_MAX', };
declare class PawnAction_Repeat extends PawnAction { 
	ActionToRepeat: PawnAction;
	RecentActionCopy: PawnAction;
	ChildFailureHandlingMode: EPawnActionFailHandling;
	static Load(ResourceName: string): PawnAction_Repeat;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Repeat;
	static GetDefaultObject(): PawnAction_Repeat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Repeat;
	static C(Other: UObject | any): PawnAction_Repeat;
}

declare class PawnAction_Sequence extends PawnAction { 
	ActionSequence: PawnAction[];
	ChildFailureHandlingMode: EPawnActionFailHandling;
	RecentActionCopy: PawnAction;
	static Load(ResourceName: string): PawnAction_Sequence;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Sequence;
	static GetDefaultObject(): PawnAction_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Sequence;
	static C(Other: UObject | any): PawnAction_Sequence;
}

declare class PawnAction_Wait extends PawnAction { 
	TimeToWait: number;
	static Load(ResourceName: string): PawnAction_Wait;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Wait;
	static GetDefaultObject(): PawnAction_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Wait;
	static C(Other: UObject | any): PawnAction_Wait;
}

declare class AIResource_Movement extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Movement;
	static Find(Outer: UObject, ResourceName: string): AIResource_Movement;
	static GetDefaultObject(): AIResource_Movement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Movement;
	static C(Other: UObject | any): AIResource_Movement;
}

declare class AIResource_Logic extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Logic;
	static Find(Outer: UObject, ResourceName: string): AIResource_Logic;
	static GetDefaultObject(): AIResource_Logic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Logic;
	static C(Other: UObject | any): AIResource_Logic;
}

declare class BehaviorTreeTypes extends UObject { 
	static Load(ResourceName: string): BehaviorTreeTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeTypes;
	static GetDefaultObject(): BehaviorTreeTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeTypes;
	static C(Other: UObject | any): BehaviorTreeTypes;
}

declare class BlackboardAssetProvider extends Interface { 
	static Load(ResourceName: string): BlackboardAssetProvider;
	static Find(Outer: UObject, ResourceName: string): BlackboardAssetProvider;
	static GetDefaultObject(): BlackboardAssetProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardAssetProvider;
	GetBlackboardAsset(): BlackboardData;
	static C(Other: UObject | any): BlackboardAssetProvider;
}

declare class BlackboardKeyType_Bool extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Bool;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Bool;
	static GetDefaultObject(): BlackboardKeyType_Bool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Bool;
	static C(Other: UObject | any): BlackboardKeyType_Bool;
}

declare class BlackboardKeyType_Class extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Class;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Class;
	static GetDefaultObject(): BlackboardKeyType_Class;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Class;
	static C(Other: UObject | any): BlackboardKeyType_Class;
}

declare class BlackboardKeyType_Enum extends BlackboardKeyType { 
	EnumType: Enum;
	EnumName: string;
	bIsEnumNameValid: boolean;
	static Load(ResourceName: string): BlackboardKeyType_Enum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Enum;
	static GetDefaultObject(): BlackboardKeyType_Enum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Enum;
	static C(Other: UObject | any): BlackboardKeyType_Enum;
}

declare class BlackboardKeyType_Float extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Float;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Float;
	static GetDefaultObject(): BlackboardKeyType_Float;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Float;
	static C(Other: UObject | any): BlackboardKeyType_Float;
}

declare class BlackboardKeyType_Int extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Int;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Int;
	static GetDefaultObject(): BlackboardKeyType_Int;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Int;
	static C(Other: UObject | any): BlackboardKeyType_Int;
}

declare class BlackboardKeyType_Name extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Name;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Name;
	static GetDefaultObject(): BlackboardKeyType_Name;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Name;
	static C(Other: UObject | any): BlackboardKeyType_Name;
}

declare class BlackboardKeyType_NativeEnum extends BlackboardKeyType { 
	EnumName: string;
	EnumType: Enum;
	static Load(ResourceName: string): BlackboardKeyType_NativeEnum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_NativeEnum;
	static GetDefaultObject(): BlackboardKeyType_NativeEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_NativeEnum;
	static C(Other: UObject | any): BlackboardKeyType_NativeEnum;
}

declare class BlackboardKeyType_Object extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Object;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Object;
	static GetDefaultObject(): BlackboardKeyType_Object;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Object;
	static C(Other: UObject | any): BlackboardKeyType_Object;
}

declare class BlackboardKeyType_Rotator extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Rotator;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Rotator;
	static GetDefaultObject(): BlackboardKeyType_Rotator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Rotator;
	static C(Other: UObject | any): BlackboardKeyType_Rotator;
}

declare class BlackboardKeyType_String extends BlackboardKeyType { 
	StringValue: string;
	static Load(ResourceName: string): BlackboardKeyType_String;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_String;
	static GetDefaultObject(): BlackboardKeyType_String;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_String;
	static C(Other: UObject | any): BlackboardKeyType_String;
}

declare class BlackboardKeyType_Vector extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Vector;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Vector;
	static GetDefaultObject(): BlackboardKeyType_Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Vector;
	static C(Other: UObject | any): BlackboardKeyType_Vector;
}

declare class BTFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BTFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BTFunctionLibrary;
	static GetDefaultObject(): BTFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTFunctionLibrary;
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static C(Other: UObject | any): BTFunctionLibrary;
}

declare class BTComposite_Selector extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Selector;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Selector;
	static GetDefaultObject(): BTComposite_Selector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Selector;
	static C(Other: UObject | any): BTComposite_Selector;
}

declare class BTComposite_Sequence extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Sequence;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Sequence;
	static GetDefaultObject(): BTComposite_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Sequence;
	static C(Other: UObject | any): BTComposite_Sequence;
}

declare type EBTParallelMode = 'AbortBackground' | 'WaitForBackground' | 'EBTParallelMode_MAX';
declare var EBTParallelMode : { AbortBackground:'AbortBackground',WaitForBackground:'WaitForBackground',EBTParallelMode_MAX:'EBTParallelMode_MAX', };
declare class BTComposite_SimpleParallel extends BTCompositeNode { 
	FinishMode: EBTParallelMode;
	static Load(ResourceName: string): BTComposite_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BTComposite_SimpleParallel;
	static GetDefaultObject(): BTComposite_SimpleParallel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_SimpleParallel;
	static C(Other: UObject | any): BTComposite_SimpleParallel;
}

declare class BTDecorator_BlackboardBase extends BTDecorator { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlackboardBase;
	static GetDefaultObject(): BTDecorator_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlackboardBase;
	static C(Other: UObject | any): BTDecorator_BlackboardBase;
}

declare type EBTBlackboardRestart = 'ValueChange' | 'ResultChange' | 'EBTBlackboardRestart_MAX';
declare var EBTBlackboardRestart : { ValueChange:'ValueChange',ResultChange:'ResultChange',EBTBlackboardRestart_MAX:'EBTBlackboardRestart_MAX', };
declare type EBasicKeyOperation = 'Set' | 'NotSet' | 'EBasicKeyOperation_MAX';
declare var EBasicKeyOperation : { Set:'Set',NotSet:'NotSet',EBasicKeyOperation_MAX:'EBasicKeyOperation_MAX', };
declare type EArithmeticKeyOperation = 'Equal' | 'NotEqual' | 'Less' | 'LessOrEqual' | 'Greater' | 'GreaterOrEqual' | 'EArithmeticKeyOperation_MAX';
declare var EArithmeticKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Less:'Less',LessOrEqual:'LessOrEqual',Greater:'Greater',GreaterOrEqual:'GreaterOrEqual',EArithmeticKeyOperation_MAX:'EArithmeticKeyOperation_MAX', };
declare type ETextKeyOperation = 'Equal' | 'NotEqual' | 'Contain' | 'NotContain' | 'ETextKeyOperation_MAX';
declare var ETextKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Contain:'Contain',NotContain:'NotContain',ETextKeyOperation_MAX:'ETextKeyOperation_MAX', };
declare class BTDecorator_Blackboard extends BTDecorator_BlackboardBase { 
	IntValue: number;
	FloatValue: number;
	StringValue: string;
	CachedDescription: string;
	OperationType: number;
	NotifyObserver: EBTBlackboardRestart;
	BasicOperation: EBasicKeyOperation;
	ArithmeticOperation: EArithmeticKeyOperation;
	TextOperation: ETextKeyOperation;
	static Load(ResourceName: string): BTDecorator_Blackboard;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Blackboard;
	static GetDefaultObject(): BTDecorator_Blackboard;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Blackboard;
	static C(Other: UObject | any): BTDecorator_Blackboard;
}

declare type EBTNodeResult = 'Succeeded' | 'Failed' | 'Aborted' | 'InProgress' | 'EBTNodeResult_MAX';
declare var EBTNodeResult : { Succeeded:'Succeeded',Failed:'Failed',Aborted:'Aborted',InProgress:'InProgress',EBTNodeResult_MAX:'EBTNodeResult_MAX', };
declare class BTDecorator_BlueprintBase extends BTDecorator { 
	AIOwner: AIController;
	ActorOwner: Actor;
	ObservedKeyNames: string[];
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	bCheckConditionOnlyBlackBoardChanges: boolean;
	bIsObservingBB: boolean;
	static Load(ResourceName: string): BTDecorator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlueprintBase;
	static GetDefaultObject(): BTDecorator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveObserverDeactivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverDeactivated(OwnerActor: Actor): void;
	ReceiveObserverActivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverActivated(OwnerActor: Actor): void;
	ReceiveExecutionStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecutionStart(OwnerActor: Actor): void;
	ReceiveExecutionFinishAI(OwnerController: AIController,ControlledPawn: Pawn,NodeResult: EBTNodeResult): void;
	ReceiveExecutionFinish(OwnerActor: Actor,NodeResult: EBTNodeResult): void;
	PerformConditionCheckAI(OwnerController: AIController,ControlledPawn: Pawn): boolean;
	PerformConditionCheck(OwnerActor: Actor): boolean;
	IsDecoratorObserverActive(): boolean;
	IsDecoratorExecutionActive(): boolean;
	static C(Other: UObject | any): BTDecorator_BlueprintBase;
}

declare type EGameplayContainerMatchType = 'Any' | 'All' | 'EGameplayContainerMatchType_MAX';
declare var EGameplayContainerMatchType : { Any:'Any',All:'All',EGameplayContainerMatchType_MAX:'EGameplayContainerMatchType_MAX', };
declare class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator { 
	ActorToCheck: BlackboardKeySelector;
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	CachedDescription: string;
	static Load(ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static GetDefaultObject(): BTDecorator_CheckGameplayTagsOnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CheckGameplayTagsOnActor;
	static C(Other: UObject | any): BTDecorator_CheckGameplayTagsOnActor;
}

declare type EBlackBoardEntryComparison = 'Equal' | 'NotEqual' | 'EBlackBoardEntryComparison_MAX';
declare var EBlackBoardEntryComparison : { Equal:'Equal',NotEqual:'NotEqual',EBlackBoardEntryComparison_MAX:'EBlackBoardEntryComparison_MAX', };
declare class BTDecorator_CompareBBEntries extends BTDecorator { 
	Operator: EBlackBoardEntryComparison;
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_CompareBBEntries;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CompareBBEntries;
	static GetDefaultObject(): BTDecorator_CompareBBEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CompareBBEntries;
	static C(Other: UObject | any): BTDecorator_CompareBBEntries;
}

declare class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard { 
	static Load(ResourceName: string): BTDecorator_ConditionalLoop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConditionalLoop;
	static GetDefaultObject(): BTDecorator_ConditionalLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConditionalLoop;
	static C(Other: UObject | any): BTDecorator_ConditionalLoop;
}

declare class BTDecorator_ConeCheck extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	ConeDirection: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_ConeCheck;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConeCheck;
	static GetDefaultObject(): BTDecorator_ConeCheck;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConeCheck;
	static C(Other: UObject | any): BTDecorator_ConeCheck;
}

declare class BTDecorator_Cooldown extends BTDecorator { 
	CoolDownTime: number;
	static Load(ResourceName: string): BTDecorator_Cooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Cooldown;
	static GetDefaultObject(): BTDecorator_Cooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Cooldown;
	static C(Other: UObject | any): BTDecorator_Cooldown;
}

declare type EPathExistanceQueryType = 'NavmeshRaycast2D' | 'HierarchicalQuery' | 'RegularPathFinding' | 'EPathExistanceQueryType_MAX';
declare var EPathExistanceQueryType : { NavmeshRaycast2D:'NavmeshRaycast2D',HierarchicalQuery:'HierarchicalQuery',RegularPathFinding:'RegularPathFinding',EPathExistanceQueryType_MAX:'EPathExistanceQueryType_MAX', };
declare class BTDecorator_DoesPathExist extends BTDecorator { 
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	bUseSelf: boolean;
	PathQueryType: EPathExistanceQueryType;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_DoesPathExist;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_DoesPathExist;
	static GetDefaultObject(): BTDecorator_DoesPathExist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_DoesPathExist;
	static C(Other: UObject | any): BTDecorator_DoesPathExist;
}

declare class BTDecorator_ForceSuccess extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ForceSuccess;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ForceSuccess;
	static GetDefaultObject(): BTDecorator_ForceSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ForceSuccess;
	static C(Other: UObject | any): BTDecorator_ForceSuccess;
}

declare type FAIDistanceType = 'Distance3D' | 'Distance2D' | 'DistanceZ' | 'MAX';
declare var FAIDistanceType : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ',MAX:'MAX', };
declare class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase { 
	AcceptableRadius: number;
	ParametrizedAcceptableRadius: AIDataProviderFloatValue;
	GeometricDistanceType: FAIDistanceType;
	bUseParametrizedRadius: boolean;
	bUseNavAgentGoalLocation: boolean;
	bPathFindingBasedTest: boolean;
	static Load(ResourceName: string): BTDecorator_IsAtLocation;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsAtLocation;
	static GetDefaultObject(): BTDecorator_IsAtLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsAtLocation;
	static C(Other: UObject | any): BTDecorator_IsAtLocation;
}

declare class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase { 
	TestClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static GetDefaultObject(): BTDecorator_IsBBEntryOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsBBEntryOfClass;
	static C(Other: UObject | any): BTDecorator_IsBBEntryOfClass;
}

declare class BTDecorator_KeepInCone extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	bUseSelfAsOrigin: boolean;
	bUseSelfAsObserved: boolean;
	static Load(ResourceName: string): BTDecorator_KeepInCone;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_KeepInCone;
	static GetDefaultObject(): BTDecorator_KeepInCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_KeepInCone;
	static C(Other: UObject | any): BTDecorator_KeepInCone;
}

declare class BTDecorator_Loop extends BTDecorator { 
	NumLoops: number;
	bInfiniteLoop: boolean;
	InfiniteLoopTimeoutTime: number;
	static Load(ResourceName: string): BTDecorator_Loop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Loop;
	static GetDefaultObject(): BTDecorator_Loop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Loop;
	static C(Other: UObject | any): BTDecorator_Loop;
}

declare class BTDecorator_ReachedMoveGoal extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ReachedMoveGoal;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ReachedMoveGoal;
	static GetDefaultObject(): BTDecorator_ReachedMoveGoal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ReachedMoveGoal;
	static C(Other: UObject | any): BTDecorator_ReachedMoveGoal;
}

declare class BTDecorator_SetTagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	static Load(ResourceName: string): BTDecorator_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_SetTagCooldown;
	static GetDefaultObject(): BTDecorator_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_SetTagCooldown;
	static C(Other: UObject | any): BTDecorator_SetTagCooldown;
}

declare class BTDecorator_TagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	bActivatesCooldown: boolean;
	static Load(ResourceName: string): BTDecorator_TagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TagCooldown;
	static GetDefaultObject(): BTDecorator_TagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TagCooldown;
	static C(Other: UObject | any): BTDecorator_TagCooldown;
}

declare class BTDecorator_TimeLimit extends BTDecorator { 
	TimeLimit: number;
	static Load(ResourceName: string): BTDecorator_TimeLimit;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TimeLimit;
	static GetDefaultObject(): BTDecorator_TimeLimit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TimeLimit;
	static C(Other: UObject | any): BTDecorator_TimeLimit;
}

declare class BTService_BlackboardBase extends BTService { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTService_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlackboardBase;
	static GetDefaultObject(): BTService_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlackboardBase;
	static C(Other: UObject | any): BTService_BlackboardBase;
}

declare class BTService_BlueprintBase extends BTService { 
	AIOwner: AIController;
	ActorOwner: Actor;
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	bShowEventDetails: boolean;
	static Load(ResourceName: string): BTService_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlueprintBase;
	static GetDefaultObject(): BTService_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveSearchStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveSearchStart(OwnerActor: Actor): void;
	ReceiveDeactivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveDeactivation(OwnerActor: Actor): void;
	ReceiveActivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveActivation(OwnerActor: Actor): void;
	IsServiceActive(): boolean;
	static C(Other: UObject | any): BTService_BlueprintBase;
}

declare class BTService_DefaultFocus extends BTService_BlackboardBase { 
	FocusPriority: number;
	static Load(ResourceName: string): BTService_DefaultFocus;
	static Find(Outer: UObject, ResourceName: string): BTService_DefaultFocus;
	static GetDefaultObject(): BTService_DefaultFocus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_DefaultFocus;
	static C(Other: UObject | any): BTService_DefaultFocus;
}

declare type EAIParamType = 'Float' | 'Int' | 'Bool' | 'MAX';
declare var EAIParamType : { Float:'Float',Int:'Int',Bool:'Bool',MAX:'MAX', };
declare class AIDynamicParam { 
	ParamName: string;
	ParamType: EAIParamType;
	Value: number;
	BBKey: BlackboardKeySelector;
	clone() : AIDynamicParam;
	static C(Other: UObject | any): AIDynamicParam;
}

declare class EQSParametrizedQueryExecutionRequest { 
	QueryTemplate: EnvQuery;
	QueryConfig: AIDynamicParam[];
	EQSQueryBlackboardKey: BlackboardKeySelector;
	RunMode: EEnvQueryRunMode;
	bUseBBKeyForQueryTemplate: boolean;
	clone() : EQSParametrizedQueryExecutionRequest;
	static C(Other: UObject | any): EQSParametrizedQueryExecutionRequest;
}

declare class BTService_RunEQS extends BTService_BlackboardBase { 
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	bUpdateBBOnFail: boolean;
	static Load(ResourceName: string): BTService_RunEQS;
	static Find(Outer: UObject, ResourceName: string): BTService_RunEQS;
	static GetDefaultObject(): BTService_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_RunEQS;
	static C(Other: UObject | any): BTService_RunEQS;
}

declare class BTTask_BlackboardBase extends BTTaskNode { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlackboardBase;
	static GetDefaultObject(): BTTask_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlackboardBase;
	static C(Other: UObject | any): BTTask_BlackboardBase;
}

declare class IntervalCountdown { 
	Interval: number;
	clone() : IntervalCountdown;
	static C(Other: UObject | any): IntervalCountdown;
}

declare class BTTask_BlueprintBase extends BTTaskNode { 
	AIOwner: AIController;
	ActorOwner: Actor;
	TickInterval: IntervalCountdown;
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	static Load(ResourceName: string): BTTask_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlueprintBase;
	static GetDefaultObject(): BTTask_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlueprintBase;
	SetFinishOnMessageWithId(MessageName: string,RequestID: number): void;
	SetFinishOnMessage(MessageName: string): void;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveExecuteAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecute(OwnerActor: Actor): void;
	ReceiveAbortAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveAbort(OwnerActor: Actor): void;
	IsTaskExecuting(): boolean;
	IsTaskAborting(): boolean;
	FinishExecute(bSuccess: boolean): void;
	FinishAbort(): void;
	static C(Other: UObject | any): BTTask_BlueprintBase;
}

declare class BTTask_FinishWithResult extends BTTaskNode { 
	Result: EBTNodeResult;
	static Load(ResourceName: string): BTTask_FinishWithResult;
	static Find(Outer: UObject, ResourceName: string): BTTask_FinishWithResult;
	static GetDefaultObject(): BTTask_FinishWithResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_FinishWithResult;
	static C(Other: UObject | any): BTTask_FinishWithResult;
}

declare class BTTask_GameplayTaskBase extends BTTaskNode { 
	bWaitForGameplayTask: boolean;
	static Load(ResourceName: string): BTTask_GameplayTaskBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_GameplayTaskBase;
	static GetDefaultObject(): BTTask_GameplayTaskBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_GameplayTaskBase;
	static C(Other: UObject | any): BTTask_GameplayTaskBase;
}

declare class BTTask_MakeNoise extends BTTaskNode { 
	Loudnes: number;
	static Load(ResourceName: string): BTTask_MakeNoise;
	static Find(Outer: UObject, ResourceName: string): BTTask_MakeNoise;
	static GetDefaultObject(): BTTask_MakeNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MakeNoise;
	static C(Other: UObject | any): BTTask_MakeNoise;
}

declare class BTTask_MoveTo extends BTTask_BlackboardBase { 
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	ObservedBlackboardValueTolerance: number;
	bObserveBlackboardValue: boolean;
	bAllowStrafe: boolean;
	bAllowPartialPath: boolean;
	bTrackMovingGoal: boolean;
	bProjectGoalLocation: boolean;
	bReachTestIncludesAgentRadius: boolean;
	bReachTestIncludesGoalRadius: boolean;
	bStopOnOverlap: boolean;
	bStopOnOverlapNeedsUpdate: boolean;
	static Load(ResourceName: string): BTTask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveTo;
	static GetDefaultObject(): BTTask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveTo;
	static C(Other: UObject | any): BTTask_MoveTo;
}

declare class BTTask_MoveDirectlyToward extends BTTask_MoveTo { 
	bDisablePathUpdateOnGoalLocationChange: boolean;
	bProjectVectorGoalToNavigation: boolean;
	bUpdatedDeprecatedProperties: boolean;
	static Load(ResourceName: string): BTTask_MoveDirectlyToward;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveDirectlyToward;
	static GetDefaultObject(): BTTask_MoveDirectlyToward;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveDirectlyToward;
	static C(Other: UObject | any): BTTask_MoveDirectlyToward;
}

declare class BTTask_PawnActionBase extends BTTaskNode { 
	static Load(ResourceName: string): BTTask_PawnActionBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_PawnActionBase;
	static GetDefaultObject(): BTTask_PawnActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PawnActionBase;
	static C(Other: UObject | any): BTTask_PawnActionBase;
}

declare class BTTask_PlayAnimation extends BTTaskNode { 
	AnimationToPlay: AnimationAsset;
	bLooping: boolean;
	bNonBlocking: boolean;
	MyOwnerComp: BehaviorTreeComponent;
	CachedSkelMesh: SkeletalMeshComponent;
	static Load(ResourceName: string): BTTask_PlayAnimation;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlayAnimation;
	static GetDefaultObject(): BTTask_PlayAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlayAnimation;
	static C(Other: UObject | any): BTTask_PlayAnimation;
}

declare class BTTask_PlaySound extends BTTaskNode { 
	SoundToPlay: SoundCue;
	static Load(ResourceName: string): BTTask_PlaySound;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlaySound;
	static GetDefaultObject(): BTTask_PlaySound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlaySound;
	static C(Other: UObject | any): BTTask_PlaySound;
}

declare class BTTask_PushPawnAction extends BTTask_PawnActionBase { 
	Action: PawnAction;
	static Load(ResourceName: string): BTTask_PushPawnAction;
	static Find(Outer: UObject, ResourceName: string): BTTask_PushPawnAction;
	static GetDefaultObject(): BTTask_PushPawnAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PushPawnAction;
	static C(Other: UObject | any): BTTask_PushPawnAction;
}

declare class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase { 
	Precision: number;
	static Load(ResourceName: string): BTTask_RotateToFaceBBEntry;
	static Find(Outer: UObject, ResourceName: string): BTTask_RotateToFaceBBEntry;
	static GetDefaultObject(): BTTask_RotateToFaceBBEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RotateToFaceBBEntry;
	static C(Other: UObject | any): BTTask_RotateToFaceBBEntry;
}

declare class BTTask_RunBehavior extends BTTaskNode { 
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehavior;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehavior;
	static GetDefaultObject(): BTTask_RunBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehavior;
	static C(Other: UObject | any): BTTask_RunBehavior;
}

declare class BTTask_RunBehaviorDynamic extends BTTaskNode { 
	InjectionTag: GameplayTag;
	DefaultBehaviorAsset: BehaviorTree;
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehaviorDynamic;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehaviorDynamic;
	static GetDefaultObject(): BTTask_RunBehaviorDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehaviorDynamic;
	static C(Other: UObject | any): BTTask_RunBehaviorDynamic;
}

declare class EnvNamedValue { 
	ParamName: string;
	ParamType: EAIParamType;
	Value: number;
	clone() : EnvNamedValue;
	static C(Other: UObject | any): EnvNamedValue;
}

declare class BTTask_RunEQSQuery extends BTTask_BlackboardBase { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	RunMode: EEnvQueryRunMode;
	EQSQueryBlackboardKey: BlackboardKeySelector;
	bUseBBKey: boolean;
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	bUpdateBBOnFail: boolean;
	static Load(ResourceName: string): BTTask_RunEQSQuery;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunEQSQuery;
	static GetDefaultObject(): BTTask_RunEQSQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunEQSQuery;
	static C(Other: UObject | any): BTTask_RunEQSQuery;
}

declare class BTTask_SetTagCooldown extends BTTaskNode { 
	CooldownTag: GameplayTag;
	bAddToExistingDuration: boolean;
	CooldownDuration: number;
	static Load(ResourceName: string): BTTask_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTTask_SetTagCooldown;
	static GetDefaultObject(): BTTask_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_SetTagCooldown;
	static C(Other: UObject | any): BTTask_SetTagCooldown;
}

declare class BTTask_Wait extends BTTaskNode { 
	WaitTime: number;
	RandomDeviation: number;
	static Load(ResourceName: string): BTTask_Wait;
	static Find(Outer: UObject, ResourceName: string): BTTask_Wait;
	static GetDefaultObject(): BTTask_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_Wait;
	static C(Other: UObject | any): BTTask_Wait;
}

declare class BTTask_WaitBlackboardTime extends BTTask_Wait { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_WaitBlackboardTime;
	static Find(Outer: UObject, ResourceName: string): BTTask_WaitBlackboardTime;
	static GetDefaultObject(): BTTask_WaitBlackboardTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_WaitBlackboardTime;
	static C(Other: UObject | any): BTTask_WaitBlackboardTime;
}

declare class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AIBlueprintHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): AIBlueprintHelperLibrary;
	static GetDefaultObject(): AIBlueprintHelperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIBlueprintHelperLibrary;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static GetNextNavLinkIndex(Controller: Controller): number;
	static GetCurrentPathPoints(Controller: Controller): Vector[];
	static GetCurrentPathIndex(Controller: Controller): number;
	static GetCurrentPath(Controller: Controller): NavigationPath;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static GetAIController(ControlledActor: Actor): AIController;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): AIBlueprintHelperLibrary;
}

declare class AIDataProvider_QueryParams extends AIDataProvider { 
	ParamName: string;
	FloatValue: number;
	IntValue: number;
	BoolValue: boolean;
	static Load(ResourceName: string): AIDataProvider_QueryParams;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_QueryParams;
	static GetDefaultObject(): AIDataProvider_QueryParams;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_QueryParams;
	static C(Other: UObject | any): AIDataProvider_QueryParams;
}

declare class AIDataProvider_Random extends AIDataProvider_QueryParams { 
	Min: number;
	Max: number;
	bInteger: boolean;
	static Load(ResourceName: string): AIDataProvider_Random;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_Random;
	static GetDefaultObject(): AIDataProvider_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_Random;
	static C(Other: UObject | any): AIDataProvider_Random;
}

declare class DetourCrowdAIController extends AIController { 
	static GetDefaultObject(): DetourCrowdAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetourCrowdAIController;
	static C(Other: UObject | any): DetourCrowdAIController;
}

declare class EnvQueryContext_BlueprintBase extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_BlueprintBase;
	static GetDefaultObject(): EnvQueryContext_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_BlueprintBase;
	ProvideSingleLocation(QuerierObject: UObject,QuerierActor: Actor,ResultingLocation?: Vector): {ResultingLocation: Vector};
	ProvideSingleActor(QuerierObject: UObject,QuerierActor: Actor,ResultingActor?: Actor): {ResultingActor: Actor};
	ProvideLocationsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingLocationSet?: Vector[]): {ResultingLocationSet: Vector[]};
	ProvideActorsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingActorsSet?: Actor[]): {ResultingActorsSet: Actor[]};
	static C(Other: UObject | any): EnvQueryContext_BlueprintBase;
}

declare class EnvQueryContext_Item extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Item;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Item;
	static GetDefaultObject(): EnvQueryContext_Item;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Item;
	static C(Other: UObject | any): EnvQueryContext_Item;
}

declare class EnvQueryContext_Querier extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Querier;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Querier;
	static GetDefaultObject(): EnvQueryContext_Querier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Querier;
	static C(Other: UObject | any): EnvQueryContext_Querier;
}

declare class EnvQueryDebugHelpers extends UObject { 
	static Load(ResourceName: string): EnvQueryDebugHelpers;
	static Find(Outer: UObject, ResourceName: string): EnvQueryDebugHelpers;
	static GetDefaultObject(): EnvQueryDebugHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryDebugHelpers;
	static C(Other: UObject | any): EnvQueryDebugHelpers;
}

declare class EQSRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): EQSRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): EQSRenderingComponent;
	static GetDefaultObject(): EQSRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSRenderingComponent;
	static C(Other: UObject | any): EQSRenderingComponent;
}

declare type EEnvQueryHightlightMode = 'All' | 'Best5Pct' | 'Best25Pct' | 'EEnvQueryHightlightMode_MAX';
declare var EEnvQueryHightlightMode : { All:'All',Best5Pct:'Best5Pct',Best25Pct:'Best25Pct',EEnvQueryHightlightMode_MAX:'EEnvQueryHightlightMode_MAX', };
declare class EQSTestingPawn extends Character { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	TimeLimitPerStep: number;
	StepToDebugDraw: number;
	HighlightMode: EEnvQueryHightlightMode;
	bDrawLabels: boolean;
	bDrawFailedItems: boolean;
	bReRunQueryOnlyOnFinishedMove: boolean;
	bShouldBeVisibleInGame: boolean;
	bTickDuringGame: boolean;
	QueryingMode: EEnvQueryRunMode;
	NavAgentProperties: NavAgentProperties;
	EdRenderComp: EQSRenderingComponent;
	static GetDefaultObject(): EQSTestingPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSTestingPawn;
	static C(Other: UObject | any): EQSTestingPawn;
}

declare class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator { 
	SearchedActorClass: UnrealEngineClass;
	GenerateOnlyActorsInRadius: AIDataProviderBoolValue;
	SearchRadius: AIDataProviderFloatValue;
	SearchCenter: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static GetDefaultObject(): EnvQueryGenerator_ActorsOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ActorsOfClass;
	static C(Other: UObject | any): EnvQueryGenerator_ActorsOfClass;
}

declare class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator { 
	GeneratorsActionDescription: string;
	Context: UnrealEngineClass;
	GeneratedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static GetDefaultObject(): EnvQueryGenerator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_BlueprintBase;
	GetQuerier(): UObject;
	DoItemGenerationFromActors(ContextActors: Actor[]): void;
	DoItemGeneration(ContextLocations: Vector[]): void;
	AddGeneratedVector(GeneratedVector: Vector): void;
	AddGeneratedActor(GeneratedActor: Actor): void;
	static C(Other: UObject | any): EnvQueryGenerator_BlueprintBase;
}

declare class EnvQueryGenerator_Composite extends EnvQueryGenerator { 
	Generators: EnvQueryGenerator[];
	bAllowDifferentItemTypes: boolean;
	bHasMatchingItemType: boolean;
	ForcedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_Composite;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Composite;
	static GetDefaultObject(): EnvQueryGenerator_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Composite;
	static C(Other: UObject | any): EnvQueryGenerator_Composite;
}

declare type EEnvTraceShape = 'Line' | 'Box' | 'Sphere' | 'Capsule' | 'EEnvTraceShape_MAX';
declare var EEnvTraceShape : { Line:'Line',Box:'Box',Sphere:'Sphere',Capsule:'Capsule',EEnvTraceShape_MAX:'EEnvTraceShape_MAX', };
declare type EEnvQueryTrace = 'None' | 'Navigation' | 'GeometryByChannel' | 'GeometryByProfile' | 'NavigationOverLedges' | 'EEnvQueryTrace_MAX';
declare var EEnvQueryTrace : { None:'None',Navigation:'Navigation',GeometryByChannel:'GeometryByChannel',GeometryByProfile:'GeometryByProfile',NavigationOverLedges:'NavigationOverLedges',EEnvQueryTrace_MAX:'EEnvQueryTrace_MAX', };
declare class EnvTraceData { 
	VersionNum: number;
	NavigationFilter: UnrealEngineClass;
	ProjectDown: number;
	ProjectUp: number;
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	PostProjectionVerticalOffset: number;
	TraceChannel: ETraceTypeQuery;
	SerializedChannel: ECollisionChannel;
	TraceProfileName: string;
	TraceShape: EEnvTraceShape;
	TraceMode: EEnvQueryTrace;
	bTraceComplex: boolean;
	bOnlyBlockingHits: boolean;
	bCanTraceOnNavMesh: boolean;
	bCanTraceOnGeometry: boolean;
	bCanDisableTrace: boolean;
	bCanProjectDown: boolean;
	clone() : EnvTraceData;
	static C(Other: UObject | any): EnvTraceData;
}

declare class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static GetDefaultObject(): EnvQueryGenerator_ProjectedPoints;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ProjectedPoints;
	static C(Other: UObject | any): EnvQueryGenerator_ProjectedPoints;
}

declare class EnvQueryGenerator_Cone extends EnvQueryGenerator_ProjectedPoints { 
	AlignedPointsDistance: AIDataProviderFloatValue;
	ConeDegrees: AIDataProviderFloatValue;
	AngleStep: AIDataProviderFloatValue;
	Range: AIDataProviderFloatValue;
	CenterActor: UnrealEngineClass;
	bIncludeContextLocation: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Cone;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Cone;
	static GetDefaultObject(): EnvQueryGenerator_Cone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Cone;
	static C(Other: UObject | any): EnvQueryGenerator_Cone;
}

declare class EnvQueryGenerator_CurrentLocation extends EnvQueryGenerator { 
	QueryContext: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static GetDefaultObject(): EnvQueryGenerator_CurrentLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_CurrentLocation;
	static C(Other: UObject | any): EnvQueryGenerator_CurrentLocation;
}

declare class AIDataProviderIntValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
	clone() : AIDataProviderIntValue;
	static C(Other: UObject | any): AIDataProviderIntValue;
}

declare type EEnvDirection = 'TwoPoints' | 'Rotation' | 'EEnvDirection_MAX';
declare var EEnvDirection : { TwoPoints:'TwoPoints',Rotation:'Rotation',EEnvDirection_MAX:'EEnvDirection_MAX', };
declare class EnvDirection { 
	LineFrom: UnrealEngineClass;
	LineTo: UnrealEngineClass;
	Rotation: UnrealEngineClass;
	DirMode: EEnvDirection;
	clone() : EnvDirection;
	static C(Other: UObject | any): EnvDirection;
}

declare class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints { 
	InnerRadius: AIDataProviderFloatValue;
	OuterRadius: AIDataProviderFloatValue;
	NumberOfRings: AIDataProviderIntValue;
	PointsPerRing: AIDataProviderIntValue;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	bUseSpiralPattern: boolean;
	Center: UnrealEngineClass;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Donut;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Donut;
	static GetDefaultObject(): EnvQueryGenerator_Donut;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Donut;
	static C(Other: UObject | any): EnvQueryGenerator_Donut;
}

declare type EPointOnCircleSpacingMethod = 'BySpaceBetween' | 'ByNumberOfPoints' | 'EPointOnCircleSpacingMethod_MAX';
declare var EPointOnCircleSpacingMethod : { BySpaceBetween:'BySpaceBetween',ByNumberOfPoints:'ByNumberOfPoints',EPointOnCircleSpacingMethod_MAX:'EPointOnCircleSpacingMethod_MAX', };
declare class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints { 
	CircleRadius: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	NumberOfPoints: AIDataProviderIntValue;
	PointOnCircleSpacingMethod: EPointOnCircleSpacingMethod;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	AngleRadians: number;
	CircleCenter: UnrealEngineClass;
	bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
	CircleCenterZOffset: AIDataProviderFloatValue;
	TraceData: EnvTraceData;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_OnCircle;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_OnCircle;
	static GetDefaultObject(): EnvQueryGenerator_OnCircle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_OnCircle;
	static C(Other: UObject | any): EnvQueryGenerator_OnCircle;
}

declare class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints { 
	GridSize: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	GenerateAround: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static GetDefaultObject(): EnvQueryGenerator_SimpleGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_SimpleGrid;
	static C(Other: UObject | any): EnvQueryGenerator_SimpleGrid;
}

declare class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid { 
	PathToItem: AIDataProviderBoolValue;
	NavigationFilter: UnrealEngineClass;
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryGenerator_PathingGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_PathingGrid;
	static GetDefaultObject(): EnvQueryGenerator_PathingGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PathingGrid;
	static C(Other: UObject | any): EnvQueryGenerator_PathingGrid;
}

declare class EnvQueryGenerator_PerceivedActors extends EnvQueryGenerator { 
	AllowedActorClass: UnrealEngineClass;
	SearchRadius: AIDataProviderFloatValue;
	ListenerContext: UnrealEngineClass;
	SenseToUse: UnrealEngineClass;
	bIncludeKnownActors: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_PerceivedActors;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_PerceivedActors;
	static GetDefaultObject(): EnvQueryGenerator_PerceivedActors;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PerceivedActors;
	static C(Other: UObject | any): EnvQueryGenerator_PerceivedActors;
}

declare class EnvQueryItemType_VectorBase extends EnvQueryItemType { 
	static Load(ResourceName: string): EnvQueryItemType_VectorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_VectorBase;
	static GetDefaultObject(): EnvQueryItemType_VectorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_VectorBase;
	static C(Other: UObject | any): EnvQueryItemType_VectorBase;
}

declare class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_ActorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_ActorBase;
	static GetDefaultObject(): EnvQueryItemType_ActorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_ActorBase;
	static C(Other: UObject | any): EnvQueryItemType_ActorBase;
}

declare class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Actor;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Actor;
	static GetDefaultObject(): EnvQueryItemType_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Actor;
	static C(Other: UObject | any): EnvQueryItemType_Actor;
}

declare class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Direction;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Direction;
	static GetDefaultObject(): EnvQueryItemType_Direction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Direction;
	static C(Other: UObject | any): EnvQueryItemType_Direction;
}

declare class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Point;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Point;
	static GetDefaultObject(): EnvQueryItemType_Point;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Point;
	static C(Other: UObject | any): EnvQueryItemType_Point;
}

declare type EEnvTestDistance = 'Distance3D' | 'Distance2D' | 'DistanceZ' | 'DistanceAbsoluteZ' | 'EEnvTestDistance_MAX';
declare var EEnvTestDistance : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ',DistanceAbsoluteZ:'DistanceAbsoluteZ',EEnvTestDistance_MAX:'EEnvTestDistance_MAX', };
declare class EnvQueryTest_Distance extends EnvQueryTest { 
	TestMode: EEnvTestDistance;
	DistanceTo: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Distance;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Distance;
	static GetDefaultObject(): EnvQueryTest_Distance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Distance;
	static C(Other: UObject | any): EnvQueryTest_Distance;
}

declare type EEnvTestDot = 'Dot3D' | 'Dot2D' | 'EEnvTestDot_MAX';
declare var EEnvTestDot : { Dot3D:'Dot3D',Dot2D:'Dot2D',EEnvTestDot_MAX:'EEnvTestDot_MAX', };
declare class EnvQueryTest_Dot extends EnvQueryTest { 
	LineA: EnvDirection;
	LineB: EnvDirection;
	TestMode: EEnvTestDot;
	bAbsoluteValue: boolean;
	static Load(ResourceName: string): EnvQueryTest_Dot;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Dot;
	static GetDefaultObject(): EnvQueryTest_Dot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Dot;
	static C(Other: UObject | any): EnvQueryTest_Dot;
}

declare class EnvQueryTest_GameplayTags extends EnvQueryTest { 
	TagQueryToMatch: GameplayTagQuery;
	bRejectIncompatibleItems: boolean;
	bUpdatedToUseQuery: boolean;
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	static Load(ResourceName: string): EnvQueryTest_GameplayTags;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_GameplayTags;
	static GetDefaultObject(): EnvQueryTest_GameplayTags;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_GameplayTags;
	static C(Other: UObject | any): EnvQueryTest_GameplayTags;
}

declare type EEnvOverlapShape = 'Box' | 'Sphere' | 'Capsule' | 'EEnvOverlapShape_MAX';
declare var EEnvOverlapShape : { Box:'Box',Sphere:'Sphere',Capsule:'Capsule',EEnvOverlapShape_MAX:'EEnvOverlapShape_MAX', };
declare class EnvOverlapData { 
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	ShapeOffset: Vector;
	OverlapChannel: ECollisionChannel;
	OverlapShape: EEnvOverlapShape;
	bOnlyBlockingHits: boolean;
	bOverlapComplex: boolean;
	bSkipOverlapQuerier: boolean;
	clone() : EnvOverlapData;
	static C(Other: UObject | any): EnvOverlapData;
}

declare class EnvQueryTest_Overlap extends EnvQueryTest { 
	OverlapData: EnvOverlapData;
	static Load(ResourceName: string): EnvQueryTest_Overlap;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Overlap;
	static GetDefaultObject(): EnvQueryTest_Overlap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Overlap;
	static C(Other: UObject | any): EnvQueryTest_Overlap;
}

declare type EEnvTestPathfinding = 'PathExist' | 'PathCost' | 'PathLength' | 'EEnvTestPathfinding_MAX';
declare var EEnvTestPathfinding : { PathExist:'PathExist',PathCost:'PathCost',PathLength:'PathLength',EEnvTestPathfinding_MAX:'EEnvTestPathfinding_MAX', };
declare class EnvQueryTest_Pathfinding extends EnvQueryTest { 
	TestMode: EEnvTestPathfinding;
	Context: UnrealEngineClass;
	PathFromContext: AIDataProviderBoolValue;
	SkipUnreachable: AIDataProviderBoolValue;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Pathfinding;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Pathfinding;
	static GetDefaultObject(): EnvQueryTest_Pathfinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Pathfinding;
	static C(Other: UObject | any): EnvQueryTest_Pathfinding;
}

declare class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding { 
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryTest_PathfindingBatch;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_PathfindingBatch;
	static GetDefaultObject(): EnvQueryTest_PathfindingBatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_PathfindingBatch;
	static C(Other: UObject | any): EnvQueryTest_PathfindingBatch;
}

declare class EnvQueryTest_Project extends EnvQueryTest { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryTest_Project;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Project;
	static GetDefaultObject(): EnvQueryTest_Project;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Project;
	static C(Other: UObject | any): EnvQueryTest_Project;
}

declare class EnvQueryTest_Random extends EnvQueryTest { 
	static Load(ResourceName: string): EnvQueryTest_Random;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Random;
	static GetDefaultObject(): EnvQueryTest_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Random;
	static C(Other: UObject | any): EnvQueryTest_Random;
}

declare class EnvQueryTest_Trace extends EnvQueryTest { 
	TraceData: EnvTraceData;
	TraceFromContext: AIDataProviderBoolValue;
	ItemHeightOffset: AIDataProviderFloatValue;
	ContextHeightOffset: AIDataProviderFloatValue;
	Context: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Trace;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Trace;
	static GetDefaultObject(): EnvQueryTest_Trace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Trace;
	static C(Other: UObject | any): EnvQueryTest_Trace;
}

declare class EnvQueryTest_Volume extends EnvQueryTest { 
	VolumeContext: UnrealEngineClass;
	VolumeClass: UnrealEngineClass;
	bDoComplexVolumeTest: boolean;
	static Load(ResourceName: string): EnvQueryTest_Volume;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Volume;
	static GetDefaultObject(): EnvQueryTest_Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Volume;
	static C(Other: UObject | any): EnvQueryTest_Volume;
}

declare class GridPathAIController extends AIController { 
	static GetDefaultObject(): GridPathAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathAIController;
	static C(Other: UObject | any): GridPathAIController;
}

declare class CrowdFollowingComponent extends PathFollowingComponent { 
	CrowdAgentMoveDirection: Vector;
	CharacterMovement: CharacterMovementComponent;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	static Load(ResourceName: string): CrowdFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): CrowdFollowingComponent;
	static GetDefaultObject(): CrowdFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdFollowingComponent;
	SuspendCrowdSteering(bSuspend: boolean): void;
	static C(Other: UObject | any): CrowdFollowingComponent;
}

declare class CrowdManagerBase extends UObject { 
	static Load(ResourceName: string): CrowdManagerBase;
	static Find(Outer: UObject, ResourceName: string): CrowdManagerBase;
	static GetDefaultObject(): CrowdManagerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManagerBase;
	static C(Other: UObject | any): CrowdManagerBase;
}

declare class CrowdAvoidanceConfig { 
	VelocityBias: number;
	DesiredVelocityWeight: number;
	CurrentVelocityWeight: number;
	SideBiasWeight: number;
	ImpactTimeWeight: number;
	ImpactTimeRange: number;
	CustomPatternIdx: number;
	AdaptiveDivisions: number;
	AdaptiveRings: number;
	AdaptiveDepth: number;
	clone() : CrowdAvoidanceConfig;
	static C(Other: UObject | any): CrowdAvoidanceConfig;
}

declare class CrowdAvoidanceSamplingPattern { 
	Angles: number[];
	Radii: number[];
	clone() : CrowdAvoidanceSamplingPattern;
	static C(Other: UObject | any): CrowdAvoidanceSamplingPattern;
}

declare class CrowdManager extends CrowdManagerBase { 
	MyNavData: NavigationData;
	AvoidanceConfig: CrowdAvoidanceConfig[];
	SamplingPatterns: CrowdAvoidanceSamplingPattern[];
	MaxAgents: number;
	MaxAgentRadius: number;
	MaxAvoidedAgents: number;
	MaxAvoidedWalls: number;
	NavmeshCheckInterval: number;
	PathOptimizationInterval: number;
	SeparationDirClamp: number;
	PathOffsetRadiusMultiplier: number;
	bResolveCollisions: boolean;
	static Load(ResourceName: string): CrowdManager;
	static Find(Outer: UObject, ResourceName: string): CrowdManager;
	static GetDefaultObject(): CrowdManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManager;
	static C(Other: UObject | any): CrowdManager;
}

declare class GridPathFollowingComponent extends PathFollowingComponent { 
	GridManager: NavLocalGridManager;
	static Load(ResourceName: string): GridPathFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): GridPathFollowingComponent;
	static GetDefaultObject(): GridPathFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathFollowingComponent;
	static C(Other: UObject | any): GridPathFollowingComponent;
}

declare class NavFilter_AIControllerDefault extends NavigationQueryFilter { 
	static Load(ResourceName: string): NavFilter_AIControllerDefault;
	static Find(Outer: UObject, ResourceName: string): NavFilter_AIControllerDefault;
	static GetDefaultObject(): NavFilter_AIControllerDefault;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavFilter_AIControllerDefault;
	static C(Other: UObject | any): NavFilter_AIControllerDefault;
}

declare type ENavLinkDirection = 'BothWays' | 'LeftToRight' | 'RightToLeft' | 'ENavLinkDirection_MAX';
declare var ENavLinkDirection : { BothWays:'BothWays',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ENavLinkDirection_MAX:'ENavLinkDirection_MAX', };
declare class NavigationLinkBase { 
	LeftProjectHeight: number;
	MaxFallDownLength: number;
	SnapRadius: number;
	SnapHeight: number;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	Description: string;
	Direction: ENavLinkDirection;
	bUseSnapHeight: boolean;
	bSnapToCheapestArea: boolean;
	bCustomFlag0: boolean;
	bCustomFlag1: boolean;
	bCustomFlag2: boolean;
	bCustomFlag3: boolean;
	bCustomFlag4: boolean;
	bCustomFlag5: boolean;
	bCustomFlag6: boolean;
	bCustomFlag7: boolean;
	AreaClass: UnrealEngineClass;
	clone() : NavigationLinkBase;
	static C(Other: UObject | any): NavigationLinkBase;
}

declare class NavigationLink extends NavigationLinkBase { 
	Left: Vector;
	Right: Vector;
	clone() : NavigationLink;
	static C(Other: UObject | any): NavigationLink;
}

declare class NavigationSegmentLink extends NavigationLinkBase { 
	LeftStart: Vector;
	LeftEnd: Vector;
	RightStart: Vector;
	RightEnd: Vector;
	clone() : NavigationSegmentLink;
	static C(Other: UObject | any): NavigationSegmentLink;
}

declare class NavRelevantComponent extends ActorComponent { 
	bAttachToOwnersRoot: boolean;
	CachedNavParent: UObject;
	static Load(ResourceName: string): NavRelevantComponent;
	static Find(Outer: UObject, ResourceName: string): NavRelevantComponent;
	static GetDefaultObject(): NavRelevantComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantComponent;
	SetNavigationRelevancy(bRelevant: boolean): void;
	static C(Other: UObject | any): NavRelevantComponent;
}

declare class NavLinkCustomComponent extends NavRelevantComponent { 
	NavLinkUserId: number;
	EnabledAreaClass: UnrealEngineClass;
	DisabledAreaClass: UnrealEngineClass;
	SupportedAgents: NavAgentSelector;
	LinkRelativeStart: Vector;
	LinkRelativeEnd: Vector;
	LinkDirection: ENavLinkDirection;
	bLinkEnabled: boolean;
	bNotifyWhenEnabled: boolean;
	bNotifyWhenDisabled: boolean;
	bCreateBoxObstacle: boolean;
	ObstacleOffset: Vector;
	ObstacleExtent: Vector;
	ObstacleAreaClass: UnrealEngineClass;
	BroadcastRadius: number;
	BroadcastInterval: number;
	BroadcastChannel: ECollisionChannel;
	static Load(ResourceName: string): NavLinkCustomComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkCustomComponent;
	static GetDefaultObject(): NavLinkCustomComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkCustomComponent;
	static C(Other: UObject | any): NavLinkCustomComponent;
}

declare class NavLinkRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): NavLinkRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkRenderingComponent;
	static GetDefaultObject(): NavLinkRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkRenderingComponent;
	static C(Other: UObject | any): NavLinkRenderingComponent;
}

declare class NavLinkProxy extends Actor { 
	PointLinks: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	SmartLinkComp: NavLinkCustomComponent;
	bSmartLinkIsRelevant: boolean;
	EdRenderComp: NavLinkRenderingComponent;
	SpriteComponent: BillboardComponent;
	OnSmartLinkReached: UnrealEngineMulticastDelegate<(MovingActor: Actor, DestinationPoint: Vector) => void>;
	static GetDefaultObject(): NavLinkProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkProxy;
	SetSmartLinkEnabled(bEnabled: boolean): void;
	ResumePathFollowing(Agent: Actor): void;
	ReceiveSmartLinkReached(Agent: Actor,Destination: Vector): void;
	IsSmartLinkEnabled(): boolean;
	HasMovingAgents(): boolean;
	CopyEndPointsFromSimpleLinkToSmartLink(): void;
	static C(Other: UObject | any): NavLinkProxy;
}

declare class PathFollowingManager extends UObject { 
	static Load(ResourceName: string): PathFollowingManager;
	static Find(Outer: UObject, ResourceName: string): PathFollowingManager;
	static GetDefaultObject(): PathFollowingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingManager;
	static C(Other: UObject | any): PathFollowingManager;
}

declare class AIPerceptionListenerInterface extends Interface { 
	static Load(ResourceName: string): AIPerceptionListenerInterface;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionListenerInterface;
	static GetDefaultObject(): AIPerceptionListenerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionListenerInterface;
	static C(Other: UObject | any): AIPerceptionListenerInterface;
}

declare class AIPerceptionStimuliSourceComponent extends ActorComponent { 
	bAutoRegisterAsSource: boolean;
	RegisterAsSourceForSenses: UnrealEngineClass[];
	static Load(ResourceName: string): AIPerceptionStimuliSourceComponent;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionStimuliSourceComponent;
	static GetDefaultObject(): AIPerceptionStimuliSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionStimuliSourceComponent;
	UnregisterFromSense(SenseClass: UnrealEngineClass): void;
	UnregisterFromPerceptionSystem(): void;
	RegisterWithPerceptionSystem(): void;
	RegisterForSense(SenseClass: UnrealEngineClass): void;
	static C(Other: UObject | any): AIPerceptionStimuliSourceComponent;
}

declare class AISense_Damage extends AISense { 
	RegisteredEvents: AIDamageEvent[];
	static Load(ResourceName: string): AISense_Damage;
	static Find(Outer: UObject, ResourceName: string): AISense_Damage;
	static GetDefaultObject(): AISense_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Damage;
	static ReportDamageEvent(WorldContextObject: UObject,DamagedActor: Actor,Instigator: Actor,DamageAmount: number,EventLocation: Vector,HitLocation: Vector,Tag: string): void;
	static C(Other: UObject | any): AISense_Damage;
}

declare class AISenseConfig_Damage extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Damage;
	static GetDefaultObject(): AISenseConfig_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Damage;
	static C(Other: UObject | any): AISenseConfig_Damage;
}

declare class AIPredictionEvent { 
	Requestor: Actor;
	PredictedActor: Actor;
	clone() : AIPredictionEvent;
	static C(Other: UObject | any): AIPredictionEvent;
}

declare class AISense_Prediction extends AISense { 
	RegisteredEvents: AIPredictionEvent[];
	static Load(ResourceName: string): AISense_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISense_Prediction;
	static GetDefaultObject(): AISense_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Prediction;
	static RequestPawnPredictionEvent(Requestor: Pawn,PredictedActor: Actor,PredictionTime: number): void;
	static RequestControllerPredictionEvent(Requestor: AIController,PredictedActor: Actor,PredictionTime: number): void;
	static C(Other: UObject | any): AISense_Prediction;
}

declare class AITeamStimulusEvent { 
	Broadcaster: Actor;
	Enemy: Actor;
	clone() : AITeamStimulusEvent;
	static C(Other: UObject | any): AITeamStimulusEvent;
}

declare class AISense_Team extends AISense { 
	RegisteredEvents: AITeamStimulusEvent[];
	static Load(ResourceName: string): AISense_Team;
	static Find(Outer: UObject, ResourceName: string): AISense_Team;
	static GetDefaultObject(): AISense_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Team;
	static C(Other: UObject | any): AISense_Team;
}

declare class AITouchEvent { 
	TouchReceiver: Actor;
	OtherActor: Actor;
	clone() : AITouchEvent;
	static C(Other: UObject | any): AITouchEvent;
}

declare class AISense_Touch extends AISense { 
	RegisteredEvents: AITouchEvent[];
	static Load(ResourceName: string): AISense_Touch;
	static Find(Outer: UObject, ResourceName: string): AISense_Touch;
	static GetDefaultObject(): AISense_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Touch;
	static ReportTouchEvent(WorldContextObject: UObject,TouchReceiver: Actor,OtherActor: Actor,Location: Vector): void;
	static C(Other: UObject | any): AISense_Touch;
}

declare class AISightTargetInterface extends Interface { 
	static Load(ResourceName: string): AISightTargetInterface;
	static Find(Outer: UObject, ResourceName: string): AISightTargetInterface;
	static GetDefaultObject(): AISightTargetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISightTargetInterface;
	static C(Other: UObject | any): AISightTargetInterface;
}

declare class PawnSensingComponent extends ActorComponent { 
	HearingThreshold: number;
	LOSHearingThreshold: number;
	SightRadius: number;
	SensingInterval: number;
	HearingMaxSoundAge: number;
	bEnableSensingUpdates: boolean;
	bOnlySensePlayers: boolean;
	bSeePawns: boolean;
	bHearNoises: boolean;
	OnSeePawn: UnrealEngineMulticastDelegate<(Pawn: Pawn) => void>;
	OnHearNoise: UnrealEngineMulticastDelegate<(Instigator: Pawn, Location: Vector, Volume: number) => void>;
	PeripheralVisionAngle: number;
	PeripheralVisionCosine: number;
	static Load(ResourceName: string): PawnSensingComponent;
	static Find(Outer: UObject, ResourceName: string): PawnSensingComponent;
	static GetDefaultObject(): PawnSensingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnSensingComponent;
	SetSensingUpdatesEnabled(bEnabled: boolean): void;
	SetSensingInterval(NewSensingInterval: number): void;
	SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;
	GetPeripheralVisionCosine(): number;
	GetPeripheralVisionAngle(): number;
	static C(Other: UObject | any): PawnSensingComponent;
}

declare class AITask extends GameplayTask { 
	OwnerController: AIController;
	static Load(ResourceName: string): AITask;
	static Find(Outer: UObject, ResourceName: string): AITask;
	static GetDefaultObject(): AITask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask;
	static C(Other: UObject | any): AITask;
}

declare class AITask_LockLogic extends AITask { 
	static Load(ResourceName: string): AITask_LockLogic;
	static Find(Outer: UObject, ResourceName: string): AITask_LockLogic;
	static GetDefaultObject(): AITask_LockLogic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_LockLogic;
	static C(Other: UObject | any): AITask_LockLogic;
}

declare class AIMoveRequest { 
	GoalActor: Actor;
	clone() : AIMoveRequest;
	static C(Other: UObject | any): AIMoveRequest;
}

declare type EAIOptionFlag = 'Default' | 'Enable' | 'Disable' | 'MAX';
declare var EAIOptionFlag : { Default:'Default',Enable:'Enable',Disable:'Disable',MAX:'MAX', };
declare class AITask_MoveTo extends AITask { 
	OnRequestFailed: UnrealEngineMulticastDelegate<() => void>;
	OnMoveFinished: UnrealEngineMulticastDelegate<(Result: EPathFollowingResult, AIController: AIController) => void>;
	MoveRequest: AIMoveRequest;
	static Load(ResourceName: string): AITask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): AITask_MoveTo;
	static GetDefaultObject(): AITask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_MoveTo;
	static AIMoveTo(Controller: AIController,GoalLocation: Vector,GoalActor: Actor,AcceptanceRadius: number,StopOnOverlap: EAIOptionFlag,AcceptPartialPath: EAIOptionFlag,bUsePathfinding: boolean,bLockAILogic: boolean,bUseContinuousGoalTracking: boolean,ProjectGoalOnNavigation: EAIOptionFlag): AITask_MoveTo;
	static C(Other: UObject | any): AITask_MoveTo;
}

declare class AITask_RunEQS extends AITask { 
	static Load(ResourceName: string): AITask_RunEQS;
	static Find(Outer: UObject, ResourceName: string): AITask_RunEQS;
	static GetDefaultObject(): AITask_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_RunEQS;
	static RunEQS(Controller: AIController,QueryTemplate: EnvQuery): AITask_RunEQS;
	static C(Other: UObject | any): AITask_RunEQS;
}

declare class VisualLoggerExtension extends UObject { 
	static Load(ResourceName: string): VisualLoggerExtension;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerExtension;
	static GetDefaultObject(): VisualLoggerExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerExtension;
	static C(Other: UObject | any): VisualLoggerExtension;
}

declare class NavigationGraphNode extends Actor { 
	static GetDefaultObject(): NavigationGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraphNode;
	static C(Other: UObject | any): NavigationGraphNode;
}

declare class NavGraphNode { 
	Owner: UObject;
	clone() : NavGraphNode;
	static C(Other: UObject | any): NavGraphNode;
}

declare class NavigationGraphNodeComponent extends SceneComponent { 
	UNode: NavGraphNode;
	NextNodeComponent: NavigationGraphNodeComponent;
	PrevNodeComponent: NavigationGraphNodeComponent;
	static Load(ResourceName: string): NavigationGraphNodeComponent;
	static Find(Outer: UObject, ResourceName: string): NavigationGraphNodeComponent;
	static GetDefaultObject(): NavigationGraphNodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraphNodeComponent;
	static C(Other: UObject | any): NavigationGraphNodeComponent;
}

declare class NavigationPathGenerator extends Interface { 
	static Load(ResourceName: string): NavigationPathGenerator;
	static Find(Outer: UObject, ResourceName: string): NavigationPathGenerator;
	static GetDefaultObject(): NavigationPathGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationPathGenerator;
	static C(Other: UObject | any): NavigationPathGenerator;
}

declare class NavLinkCustomInterface extends Interface { 
	static Load(ResourceName: string): NavLinkCustomInterface;
	static Find(Outer: UObject, ResourceName: string): NavLinkCustomInterface;
	static GetDefaultObject(): NavLinkCustomInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkCustomInterface;
	static C(Other: UObject | any): NavLinkCustomInterface;
}

declare class NavLinkHostInterface extends Interface { 
	static Load(ResourceName: string): NavLinkHostInterface;
	static Find(Outer: UObject, ResourceName: string): NavLinkHostInterface;
	static GetDefaultObject(): NavLinkHostInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkHostInterface;
	static C(Other: UObject | any): NavLinkHostInterface;
}

declare class NavLinkDefinition extends UObject { 
	Links: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	static Load(ResourceName: string): NavLinkDefinition;
	static Find(Outer: UObject, ResourceName: string): NavLinkDefinition;
	static GetDefaultObject(): NavLinkDefinition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkDefinition;
	static C(Other: UObject | any): NavLinkDefinition;
}

declare class NavLinkTrivial extends NavLinkDefinition { 
	static Load(ResourceName: string): NavLinkTrivial;
	static Find(Outer: UObject, ResourceName: string): NavLinkTrivial;
	static GetDefaultObject(): NavLinkTrivial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkTrivial;
	static C(Other: UObject | any): NavLinkTrivial;
}

declare class NavNodeInterface extends Interface { 
	static Load(ResourceName: string): NavNodeInterface;
	static Find(Outer: UObject, ResourceName: string): NavNodeInterface;
	static GetDefaultObject(): NavNodeInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavNodeInterface;
	static C(Other: UObject | any): NavNodeInterface;
}

declare class AbstractNavData extends NavigationData { 
	static GetDefaultObject(): AbstractNavData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbstractNavData;
	static C(Other: UObject | any): AbstractNavData;
}

declare class NavAreaMeta extends NavArea { 
	static Load(ResourceName: string): NavAreaMeta;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta;
	static GetDefaultObject(): NavAreaMeta;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta;
	static C(Other: UObject | any): NavAreaMeta;
}

declare class NavAreaMeta_SwitchByAgent extends NavAreaMeta { 
	Agent0Area: UnrealEngineClass;
	Agent1Area: UnrealEngineClass;
	Agent2Area: UnrealEngineClass;
	Agent3Area: UnrealEngineClass;
	Agent4Area: UnrealEngineClass;
	Agent5Area: UnrealEngineClass;
	Agent6Area: UnrealEngineClass;
	Agent7Area: UnrealEngineClass;
	Agent8Area: UnrealEngineClass;
	Agent9Area: UnrealEngineClass;
	Agent10Area: UnrealEngineClass;
	Agent11Area: UnrealEngineClass;
	Agent12Area: UnrealEngineClass;
	Agent13Area: UnrealEngineClass;
	Agent14Area: UnrealEngineClass;
	Agent15Area: UnrealEngineClass;
	static Load(ResourceName: string): NavAreaMeta_SwitchByAgent;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta_SwitchByAgent;
	static GetDefaultObject(): NavAreaMeta_SwitchByAgent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta_SwitchByAgent;
	static C(Other: UObject | any): NavAreaMeta_SwitchByAgent;
}

declare class NavArea_Default extends NavArea { 
	static Load(ResourceName: string): NavArea_Default;
	static Find(Outer: UObject, ResourceName: string): NavArea_Default;
	static GetDefaultObject(): NavArea_Default;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Default;
	static C(Other: UObject | any): NavArea_Default;
}

declare class NavArea_LowHeight extends NavArea { 
	static Load(ResourceName: string): NavArea_LowHeight;
	static Find(Outer: UObject, ResourceName: string): NavArea_LowHeight;
	static GetDefaultObject(): NavArea_LowHeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_LowHeight;
	static C(Other: UObject | any): NavArea_LowHeight;
}

declare class NavArea_Null extends NavArea { 
	static Load(ResourceName: string): NavArea_Null;
	static Find(Outer: UObject, ResourceName: string): NavArea_Null;
	static GetDefaultObject(): NavArea_Null;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Null;
	static C(Other: UObject | any): NavArea_Null;
}

declare class NavArea_Obstacle extends NavArea { 
	static Load(ResourceName: string): NavArea_Obstacle;
	static Find(Outer: UObject, ResourceName: string): NavArea_Obstacle;
	static GetDefaultObject(): NavArea_Obstacle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Obstacle;
	static C(Other: UObject | any): NavArea_Obstacle;
}

declare class NavCollisionCylinder { 
	Offset: Vector;
	Radius: number;
	Height: number;
	clone() : NavCollisionCylinder;
	static C(Other: UObject | any): NavCollisionCylinder;
}

declare class NavCollisionBox { 
	Offset: Vector;
	Extent: Vector;
	clone() : NavCollisionBox;
	static C(Other: UObject | any): NavCollisionBox;
}

declare class NavCollision extends NavCollisionBase { 
	CylinderCollision: NavCollisionCylinder[];
	BoxCollision: NavCollisionBox[];
	AreaClass: UnrealEngineClass;
	bGatherConvexGeometry: boolean;
	bCreateOnClient: boolean;
	static Load(ResourceName: string): NavCollision;
	static Find(Outer: UObject, ResourceName: string): NavCollision;
	static GetDefaultObject(): NavCollision;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollision;
	static C(Other: UObject | any): NavCollision;
}

declare class RecastFilter_UseDefaultArea extends NavigationQueryFilter { 
	static Load(ResourceName: string): RecastFilter_UseDefaultArea;
	static Find(Outer: UObject, ResourceName: string): RecastFilter_UseDefaultArea;
	static GetDefaultObject(): RecastFilter_UseDefaultArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastFilter_UseDefaultArea;
	static C(Other: UObject | any): RecastFilter_UseDefaultArea;
}

declare class NavigationGraph extends NavigationData { 
	static GetDefaultObject(): NavigationGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraph;
	static C(Other: UObject | any): NavigationGraph;
}

declare class NavigationInvokerComponent extends ActorComponent { 
	TileGenerationRadius: number;
	TileRemovalRadius: number;
	static Load(ResourceName: string): NavigationInvokerComponent;
	static Find(Outer: UObject, ResourceName: string): NavigationInvokerComponent;
	static GetDefaultObject(): NavigationInvokerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationInvokerComponent;
	static C(Other: UObject | any): NavigationInvokerComponent;
}

declare type ENavDataGatheringModeConfig = 'Invalid' | 'Instant' | 'Lazy' | 'ENavDataGatheringModeConfig_MAX';
declare var ENavDataGatheringModeConfig : { Invalid:'Invalid',Instant:'Instant',Lazy:'Lazy',ENavDataGatheringModeConfig_MAX:'ENavDataGatheringModeConfig_MAX', };
declare type FNavigationSystemRunMode = 'InvalidMode' | 'GameMode' | 'EditorMode' | 'SimulationMode' | 'PIEMode' | 'InferFromWorldMode' | 'EditorWorldPartitionBuildMode' | 'FNavigationSystemRunMode_MAX';
declare var FNavigationSystemRunMode : { InvalidMode:'InvalidMode',GameMode:'GameMode',EditorMode:'EditorMode',SimulationMode:'SimulationMode',PIEMode:'PIEMode',InferFromWorldMode:'InferFromWorldMode',EditorWorldPartitionBuildMode:'EditorWorldPartitionBuildMode',FNavigationSystemRunMode_MAX:'FNavigationSystemRunMode_MAX', };
declare class NavMeshBoundsVolume extends Volume { 
	SupportedAgents: NavAgentSelector;
	static GetDefaultObject(): NavMeshBoundsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshBoundsVolume;
	static C(Other: UObject | any): NavMeshBoundsVolume;
}

declare type ENavigationQueryResult = 'Invalid' | 'Error' | 'Fail' | 'Success' | 'ENavigationQueryResult_MAX';
declare var ENavigationQueryResult : { Invalid:'Invalid',Error:'Error',Fail:'Fail',Success:'Success',ENavigationQueryResult_MAX:'ENavigationQueryResult_MAX', };
declare class NavigationSystemV1 extends NavigationSystemBase { 
	MainNavData: NavigationData;
	AbstractNavData: NavigationData;
	DefaultAgentName: string;
	CrowdManagerClass: Class;
	bAutoCreateNavigationData: boolean;
	bSpawnNavDataInNavBoundsLevel: boolean;
	bAllowClientSideNavigation: boolean;
	bShouldDiscardSubLevelNavData: boolean;
	bTickWhilePaused: boolean;
	bSupportRebuilding: boolean;
	bInitialBuildingLocked: boolean;
	bSkipAgentHeightCheckWhenPickingNavData: boolean;
	GeometryExportVertexCountWarningThreshold: number;
	bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
	ActiveTilesUpdateInterval: number;
	DataGatheringMode: ENavDataGatheringModeConfig;
	DirtyAreaWarningSizeThreshold: number;
	GatheringNavModifiersWarningLimitTime: number;
	SupportedAgents: NavDataConfig[];
	SupportedAgentsMask: NavAgentSelector;
	BuildBounds: Box;
	NavDataSet: NavigationData[];
	NavDataRegistrationQueue: NavigationData[];
	OnNavDataRegisteredEvent: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OnNavigationGenerationFinishedDelegate: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OperationMode: FNavigationSystemRunMode;
	static Load(ResourceName: string): NavigationSystemV1;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemV1;
	static GetDefaultObject(): NavigationSystemV1;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemV1;
	UnregisterNavigationInvoker(Invoker: Actor): void;
	SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;
	SetGeometryGatheringMode(NewMode: ENavDataGatheringModeConfig): void;
	ResetMaxSimultaneousTileGenerationJobsCount(): void;
	RegisterNavigationInvoker(Invoker: Actor,TileGenerationRadius: number,TileRemovalRadius: number): void;
	OnNavigationBoundsUpdated(NavVolume: NavMeshBoundsVolume): void;
	static NavigationRaycast(WorldContextObject: UObject,RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	K2_ReplaceAreaInOctreeData(UObject: UObject,OldArea: UnrealEngineClass,NewArea: UnrealEngineClass): boolean;
	static K2_ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,ProjectedLocation?: Vector,NavData?: NavigationData,FilterClass?: UnrealEngineClass,QueryExtent?: Vector): {ProjectedLocation: Vector, $: boolean};
	static K2_GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomLocationInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static IsNavigationBeingBuiltOrLocked(WorldContextObject: UObject): boolean;
	static IsNavigationBeingBuilt(WorldContextObject: UObject): boolean;
	static GetPathLength(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	static GetPathCost(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	static GetNavigationSystem(WorldContextObject: UObject): NavigationSystemV1;
	static FindPathToLocationSynchronously(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static FindPathToActorSynchronously(WorldContextObject: UObject,PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static C(Other: UObject | any): NavigationSystemV1;
}

declare class NavigationSystemModuleConfig extends NavigationSystemConfig { 
	bStrictlyStatic: boolean;
	bCreateOnClient: boolean;
	bAutoSpawnMissingNavData: boolean;
	bSpawnNavDataInNavBoundsLevel: boolean;
	static Load(ResourceName: string): NavigationSystemModuleConfig;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemModuleConfig;
	static GetDefaultObject(): NavigationSystemModuleConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemModuleConfig;
	static C(Other: UObject | any): NavigationSystemModuleConfig;
}

declare class NavTestRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): NavTestRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavTestRenderingComponent;
	static GetDefaultObject(): NavTestRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavTestRenderingComponent;
	static C(Other: UObject | any): NavTestRenderingComponent;
}

declare type ENavCostDisplay = 'TotalCost' | 'HeuristicOnly' | 'RealCostOnly' | 'ENavCostDisplay_MAX';
declare var ENavCostDisplay : { TotalCost:'TotalCost',HeuristicOnly:'HeuristicOnly',RealCostOnly:'RealCostOnly',ENavCostDisplay_MAX:'ENavCostDisplay_MAX', };
declare class NavigationTestingActor extends Actor { 
	CapsuleComponent: CapsuleComponent;
	EdRenderComp: NavTestRenderingComponent;
	InvokerComponent: NavigationInvokerComponent;
	bActAsNavigationInvoker: boolean;
	NavAgentProps: NavAgentProperties;
	QueryingExtent: Vector;
	MyNavData: NavigationData;
	ProjectedLocation: Vector;
	bProjectedLocationValid: boolean;
	bSearchStart: boolean;
	CostLimitFactor: number;
	MinimumCostLimit: number;
	bBacktracking: boolean;
	bUseHierarchicalPathfinding: boolean;
	bGatherDetailedInfo: boolean;
	bDrawDistanceToWall: boolean;
	bShowNodePool: boolean;
	bShowBestPath: boolean;
	bShowDiffWithPreviousStep: boolean;
	bShouldBeVisibleInGame: boolean;
	CostDisplayMode: ENavCostDisplay;
	TextCanvasOffset: Vector2D;
	bPathExist: boolean;
	bPathIsPartial: boolean;
	bPathSearchOutOfNodes: boolean;
	PathfindingTime: number;
	PathCost: number;
	PathfindingSteps: number;
	OtherActor: NavigationTestingActor;
	FilterClass: UnrealEngineClass;
	ShowStepIndex: number;
	OffsetFromCornersDistance: number;
	static GetDefaultObject(): NavigationTestingActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationTestingActor;
	static C(Other: UObject | any): NavigationTestingActor;
}

declare class NavLinkComponent extends PrimitiveComponent { 
	Links: NavigationLink[];
	static Load(ResourceName: string): NavLinkComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkComponent;
	static GetDefaultObject(): NavLinkComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkComponent;
	static C(Other: UObject | any): NavLinkComponent;
}

declare class NavMeshRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): NavMeshRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavMeshRenderingComponent;
	static GetDefaultObject(): NavMeshRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshRenderingComponent;
	static C(Other: UObject | any): NavMeshRenderingComponent;
}

declare class RecastNavMeshDataChunk extends NavigationDataChunk { 
	static Load(ResourceName: string): RecastNavMeshDataChunk;
	static Find(Outer: UObject, ResourceName: string): RecastNavMeshDataChunk;
	static GetDefaultObject(): RecastNavMeshDataChunk;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMeshDataChunk;
	static C(Other: UObject | any): RecastNavMeshDataChunk;
}

declare class NavModifierComponent extends NavRelevantComponent { 
	AreaClass: UnrealEngineClass;
	FailsafeExtent: Vector;
	bIncludeAgentHeight: boolean;
	static Load(ResourceName: string): NavModifierComponent;
	static Find(Outer: UObject, ResourceName: string): NavModifierComponent;
	static GetDefaultObject(): NavModifierComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavModifierComponent;
	SetAreaClass(NewAreaClass: UnrealEngineClass): void;
	static C(Other: UObject | any): NavModifierComponent;
}

declare class NavModifierVolume extends Volume { 
	AreaClass: UnrealEngineClass;
	bMaskFillCollisionUnderneathForNavmesh: boolean;
	static GetDefaultObject(): NavModifierVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavModifierVolume;
	SetAreaClass(NewAreaClass: UnrealEngineClass): void;
	static C(Other: UObject | any): NavModifierVolume;
}

declare type ENavSystemOverridePolicy = 'Override' | 'Append' | 'Skip' | 'ENavSystemOverridePolicy_MAX';
declare var ENavSystemOverridePolicy : { Override:'Override',Append:'Append',Skip:'Skip',ENavSystemOverridePolicy_MAX:'ENavSystemOverridePolicy_MAX', };
declare class NavSystemConfigOverride extends Actor { 
	SpriteComponent: BillboardComponent;
	NavigationSystemConfig: NavigationSystemConfig;
	OverridePolicy: ENavSystemOverridePolicy;
	bLoadOnClient: boolean;
	static GetDefaultObject(): NavSystemConfigOverride;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavSystemConfigOverride;
	ApplyChanges(): void;
	static C(Other: UObject | any): NavSystemConfigOverride;
}

declare type ETimezoneSetting = 'InternationalDateLineWest' | 'CoordinatedUniversalTimeNeg11' | 'Samoa' | 'Hawaii' | 'Alaska' | 'PacificTime_USCAN' | 'BajaCalifornia' | 'MountainTime_USCAN' | 'Chihuahua_LaPaz_Mazatlan' | 'Arizona' | 'Saskatchewan' | 'CentralAmerica' | 'CentralTime_USCAN' | 'Guadalajara_MexicoCity_Monterrey' | 'EasternTime_USCAN' | 'Bogota_Lima_Quito' | 'Indiana_US' | 'Caracas' | 'AtlanticTime_Canada' | 'Cuiaba' | 'Santiago' | 'Georgetown_LaPaz_Manaus_SanJuan' | 'Asuncion' | 'Newfoundland' | 'Brasilia' | 'Greenland' | 'Montevideo' | 'Cayenne_Fortaleza' | 'BuenosAires' | 'MidAtlantic' | 'CoordinatedUniversalTimeNeg02' | 'Azores' | 'CaboVerdeIs' | 'Dublin_Edinburgh_Lisbon_London' | 'Monrovia_Reykjavik' | 'Casablanca' | 'UTC' | 'Belgrade_Bratislava_Budapest_Ljubljana_Prague' | 'Sarajevo_Skopje_Warsaw_Zagreb' | 'Brussels_Copenhagen_Madrid_Paris' | 'WestCentralAfrica' | 'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna' | 'Windhoek' | 'Minsk' | 'Cairo' | 'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius' | 'Athens_Bucharest' | 'Jerusalem' | 'Amman' | 'Beirut' | 'Harare_Pretoria' | 'Damascus' | 'Istanbul' | 'Kuwait_Riyadh' | 'Baghdad' | 'Nairobi' | 'Kaliningrad' | 'Tehran' | 'Moscow_StPetersburg_Volgograd' | 'AbuDhabi_Muscat' | 'Baku' | 'Yerevan' | 'Tbilisi' | 'PortLouis' | 'Kabul' | 'Tashkent' | 'Islamabad_Karachi' | 'Chennai_Kolkata_Mumbai_NewDelhi' | 'SriJayawardenepura' | 'Kathmandu' | 'Ekaterinburg' | 'Astana' | 'Dhaka' | 'Yangon_Rangoon' | 'Novosibirsk' | 'Bangkok_Hanoi_Jakarta' | 'Krasnoyarsk' | 'Beijing_Chongqing_HongKong_Urumqi' | 'KualaLumpur_Singapore' | 'Taipei' | 'Perth' | 'Ulaanbaatar' | 'Irkutsk' | 'Seoul' | 'Osaka_Sapporo_Tokyo' | 'Darwin' | 'Adelaide' | 'Yakutsk' | 'Canberra_Melbourne_Sydney' | 'Brisbane' | 'Hobart' | 'Guam_PortMoresby' | 'Vladivostok' | 'SolomonIs_NewCaledonia' | 'Magadan' | 'Fiji' | 'Auckland_Wellington' | 'CoordinatedUniversalTime12' | 'Nukualofa' | 'LocalTime' | 'ETimezoneSetting_MAX';
declare var ETimezoneSetting : { InternationalDateLineWest:'InternationalDateLineWest',CoordinatedUniversalTimeNeg11:'CoordinatedUniversalTimeNeg11',Samoa:'Samoa',Hawaii:'Hawaii',Alaska:'Alaska',PacificTime_USCAN:'PacificTime_USCAN',BajaCalifornia:'BajaCalifornia',MountainTime_USCAN:'MountainTime_USCAN',Chihuahua_LaPaz_Mazatlan:'Chihuahua_LaPaz_Mazatlan',Arizona:'Arizona',Saskatchewan:'Saskatchewan',CentralAmerica:'CentralAmerica',CentralTime_USCAN:'CentralTime_USCAN',Guadalajara_MexicoCity_Monterrey:'Guadalajara_MexicoCity_Monterrey',EasternTime_USCAN:'EasternTime_USCAN',Bogota_Lima_Quito:'Bogota_Lima_Quito',Indiana_US:'Indiana_US',Caracas:'Caracas',AtlanticTime_Canada:'AtlanticTime_Canada',Cuiaba:'Cuiaba',Santiago:'Santiago',Georgetown_LaPaz_Manaus_SanJuan:'Georgetown_LaPaz_Manaus_SanJuan',Asuncion:'Asuncion',Newfoundland:'Newfoundland',Brasilia:'Brasilia',Greenland:'Greenland',Montevideo:'Montevideo',Cayenne_Fortaleza:'Cayenne_Fortaleza',BuenosAires:'BuenosAires',MidAtlantic:'MidAtlantic',CoordinatedUniversalTimeNeg02:'CoordinatedUniversalTimeNeg02',Azores:'Azores',CaboVerdeIs:'CaboVerdeIs',Dublin_Edinburgh_Lisbon_London:'Dublin_Edinburgh_Lisbon_London',Monrovia_Reykjavik:'Monrovia_Reykjavik',Casablanca:'Casablanca',UTC:'UTC',Belgrade_Bratislava_Budapest_Ljubljana_Prague:'Belgrade_Bratislava_Budapest_Ljubljana_Prague',Sarajevo_Skopje_Warsaw_Zagreb:'Sarajevo_Skopje_Warsaw_Zagreb',Brussels_Copenhagen_Madrid_Paris:'Brussels_Copenhagen_Madrid_Paris',WestCentralAfrica:'WestCentralAfrica',Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna:'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna',Windhoek:'Windhoek',Minsk:'Minsk',Cairo:'Cairo',Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius:'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius',Athens_Bucharest:'Athens_Bucharest',Jerusalem:'Jerusalem',Amman:'Amman',Beirut:'Beirut',Harare_Pretoria:'Harare_Pretoria',Damascus:'Damascus',Istanbul:'Istanbul',Kuwait_Riyadh:'Kuwait_Riyadh',Baghdad:'Baghdad',Nairobi:'Nairobi',Kaliningrad:'Kaliningrad',Tehran:'Tehran',Moscow_StPetersburg_Volgograd:'Moscow_StPetersburg_Volgograd',AbuDhabi_Muscat:'AbuDhabi_Muscat',Baku:'Baku',Yerevan:'Yerevan',Tbilisi:'Tbilisi',PortLouis:'PortLouis',Kabul:'Kabul',Tashkent:'Tashkent',Islamabad_Karachi:'Islamabad_Karachi',Chennai_Kolkata_Mumbai_NewDelhi:'Chennai_Kolkata_Mumbai_NewDelhi',SriJayawardenepura:'SriJayawardenepura',Kathmandu:'Kathmandu',Ekaterinburg:'Ekaterinburg',Astana:'Astana',Dhaka:'Dhaka',Yangon_Rangoon:'Yangon_Rangoon',Novosibirsk:'Novosibirsk',Bangkok_Hanoi_Jakarta:'Bangkok_Hanoi_Jakarta',Krasnoyarsk:'Krasnoyarsk',Beijing_Chongqing_HongKong_Urumqi:'Beijing_Chongqing_HongKong_Urumqi',KualaLumpur_Singapore:'KualaLumpur_Singapore',Taipei:'Taipei',Perth:'Perth',Ulaanbaatar:'Ulaanbaatar',Irkutsk:'Irkutsk',Seoul:'Seoul',Osaka_Sapporo_Tokyo:'Osaka_Sapporo_Tokyo',Darwin:'Darwin',Adelaide:'Adelaide',Yakutsk:'Yakutsk',Canberra_Melbourne_Sydney:'Canberra_Melbourne_Sydney',Brisbane:'Brisbane',Hobart:'Hobart',Guam_PortMoresby:'Guam_PortMoresby',Vladivostok:'Vladivostok',SolomonIs_NewCaledonia:'SolomonIs_NewCaledonia',Magadan:'Magadan',Fiji:'Fiji',Auckland_Wellington:'Auckland_Wellington',CoordinatedUniversalTime12:'CoordinatedUniversalTime12',Nukualofa:'Nukualofa',LocalTime:'LocalTime',ETimezoneSetting_MAX:'ETimezoneSetting_MAX', };
declare class InternationalizationSettingsModel extends UObject { 
	DisplayTimezone: ETimezoneSetting;
	static Load(ResourceName: string): InternationalizationSettingsModel;
	static Find(Outer: UObject, ResourceName: string): InternationalizationSettingsModel;
	static GetDefaultObject(): InternationalizationSettingsModel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationSettingsModel;
	static C(Other: UObject | any): InternationalizationSettingsModel;
}

declare class SplineMetadataDetailsFactoryBase extends UObject { 
	static Load(ResourceName: string): SplineMetadataDetailsFactoryBase;
	static Find(Outer: UObject, ResourceName: string): SplineMetadataDetailsFactoryBase;
	static GetDefaultObject(): SplineMetadataDetailsFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadataDetailsFactoryBase;
	static C(Other: UObject | any): SplineMetadataDetailsFactoryBase;
}

declare class ActorFactory extends UObject { 
	DisplayName: string;
	MenuPriority: number;
	NewActorClassName: string;
	NewActorClass: UnrealEngineClass;
	bShowInEditorQuickMenu: boolean;
	bUseSurfaceOrientation: boolean;
	bUsePlacementExtent: boolean;
	SpawnPositionOffset: Vector;
	static Load(ResourceName: string): ActorFactory;
	static Find(Outer: UObject, ResourceName: string): ActorFactory;
	static GetDefaultObject(): ActorFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactory;
	static C(Other: UObject | any): ActorFactory;
}

declare class ActorFactoryVolume extends ActorFactory { 
	static Load(ResourceName: string): ActorFactoryVolume;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryVolume;
	static GetDefaultObject(): ActorFactoryVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryVolume;
	static C(Other: UObject | any): ActorFactoryVolume;
}

declare class ActorFactoryBoxVolume extends ActorFactoryVolume { 
	static Load(ResourceName: string): ActorFactoryBoxVolume;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryBoxVolume;
	static GetDefaultObject(): ActorFactoryBoxVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBoxVolume;
	static C(Other: UObject | any): ActorFactoryBoxVolume;
}

declare class ActorFactoryProceduralFoliage extends ActorFactoryBoxVolume { 
	static Load(ResourceName: string): ActorFactoryProceduralFoliage;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryProceduralFoliage;
	static GetDefaultObject(): ActorFactoryProceduralFoliage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryProceduralFoliage;
	static C(Other: UObject | any): ActorFactoryProceduralFoliage;
}

declare class FoliageType_InstancedStaticMeshFactory extends Factory { 
	static Load(ResourceName: string): FoliageType_InstancedStaticMeshFactory;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMeshFactory;
	static GetDefaultObject(): FoliageType_InstancedStaticMeshFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMeshFactory;
	static C(Other: UObject | any): FoliageType_InstancedStaticMeshFactory;
}

declare class FoliageType_ActorFactory extends Factory { 
	static Load(ResourceName: string): FoliageType_ActorFactory;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ActorFactory;
	static GetDefaultObject(): FoliageType_ActorFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ActorFactory;
	static C(Other: UObject | any): FoliageType_ActorFactory;
}

declare class BlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): BlueprintThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): BlueprintThumbnailRenderer;
	static GetDefaultObject(): BlueprintThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintThumbnailRenderer;
	static C(Other: UObject | any): BlueprintThumbnailRenderer;
}

declare class FoliageType_ActorThumbnailRenderer extends BlueprintThumbnailRenderer { 
	static Load(ResourceName: string): FoliageType_ActorThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ActorThumbnailRenderer;
	static GetDefaultObject(): FoliageType_ActorThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ActorThumbnailRenderer;
	static C(Other: UObject | any): FoliageType_ActorThumbnailRenderer;
}

declare class FoliageType_ISMThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): FoliageType_ISMThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ISMThumbnailRenderer;
	static GetDefaultObject(): FoliageType_ISMThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ISMThumbnailRenderer;
	static C(Other: UObject | any): FoliageType_ISMThumbnailRenderer;
}

declare class LandscapeGrassTypeFactory extends Factory { 
	static Load(ResourceName: string): LandscapeGrassTypeFactory;
	static Find(Outer: UObject, ResourceName: string): LandscapeGrassTypeFactory;
	static GetDefaultObject(): LandscapeGrassTypeFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGrassTypeFactory;
	static C(Other: UObject | any): LandscapeGrassTypeFactory;
}

declare type EFoliageScaling = 'Uniform' | 'Free' | 'LockXY' | 'LockXZ' | 'LockYZ' | 'EFoliageScaling_MAX';
declare var EFoliageScaling : { Uniform:'Uniform',Free:'Free',LockXY:'LockXY',LockXZ:'LockXZ',LockYZ:'LockYZ',EFoliageScaling_MAX:'EFoliageScaling_MAX', };
declare class FloatInterval { 
	Min: number;
	Max: number;
	clone() : FloatInterval;
	static C(Other: UObject | any): FloatInterval;
}

declare class FoliageVertexColorChannelMask { 
	UseMask: boolean;
	MaskThreshold: number;
	InvertMask: boolean;
	clone() : FoliageVertexColorChannelMask;
	static C(Other: UObject | any): FoliageVertexColorChannelMask;
}

declare type FoliageVertexColorMask = 'FOLIAGEVERTEXCOLORMASK_Disabled' | 'FOLIAGEVERTEXCOLORMASK_Red' | 'FOLIAGEVERTEXCOLORMASK_Green' | 'FOLIAGEVERTEXCOLORMASK_Blue' | 'FOLIAGEVERTEXCOLORMASK_Alpha' | 'FOLIAGEVERTEXCOLORMASK_MAX';
declare var FoliageVertexColorMask : { FOLIAGEVERTEXCOLORMASK_Disabled:'FOLIAGEVERTEXCOLORMASK_Disabled',FOLIAGEVERTEXCOLORMASK_Red:'FOLIAGEVERTEXCOLORMASK_Red',FOLIAGEVERTEXCOLORMASK_Green:'FOLIAGEVERTEXCOLORMASK_Green',FOLIAGEVERTEXCOLORMASK_Blue:'FOLIAGEVERTEXCOLORMASK_Blue',FOLIAGEVERTEXCOLORMASK_Alpha:'FOLIAGEVERTEXCOLORMASK_Alpha',FOLIAGEVERTEXCOLORMASK_MAX:'FOLIAGEVERTEXCOLORMASK_MAX', };
declare class Int32Interval { 
	Min: number;
	Max: number;
	clone() : Int32Interval;
	static C(Other: UObject | any): Int32Interval;
}

declare class FoliageDensityFalloff { 
	bUseFalloffCurve: boolean;
	FalloffCurve: RuntimeFloatCurve;
	clone() : FoliageDensityFalloff;
	static C(Other: UObject | any): FoliageDensityFalloff;
}

declare class FoliageType extends UObject { 
	UpdateGuid: Guid;
	Density: number;
	DensityAdjustmentFactor: number;
	Radius: number;
	bSingleInstanceModeOverrideRadius: boolean;
	SingleInstanceModeRadius: number;
	Scaling: EFoliageScaling;
	ScaleX: FloatInterval;
	ScaleY: FloatInterval;
	ScaleZ: FloatInterval;
	VertexColorMaskByChannel: FoliageVertexColorChannelMask;
	VertexColorMask: FoliageVertexColorMask;
	VertexColorMaskThreshold: number;
	VertexColorMaskInvert: boolean;
	ZOffset: FloatInterval;
	AlignToNormal: boolean;
	AverageNormal: boolean;
	AverageNormalSingleComponent: boolean;
	AlignMaxAngle: number;
	RandomYaw: boolean;
	RandomPitchAngle: number;
	GroundSlopeAngle: FloatInterval;
	Height: FloatInterval;
	LandscapeLayers: string[];
	MinimumLayerWeight: number;
	ExclusionLandscapeLayers: string[];
	MinimumExclusionLayerWeight: number;
	LandscapeLayer: string;
	CollisionWithWorld: boolean;
	CollisionScale: Vector;
	AverageNormalSampleCount: number;
	MeshBounds: BoxSphereBounds;
	LowBoundOriginRadius: Vector;
	Mobility: EComponentMobility;
	CullDistance: Int32Interval;
	bEnableStaticLighting: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	LightmapType: ELightmapType;
	bUseAsOccluder: boolean;
	bVisibleInRayTracing: boolean;
	bEvaluateWorldPositionOffset: boolean;
	WorldPositionOffsetDisableDistance: number;
	BodyInstance: BodyInstance;
	CustomNavigableGeometry: EHasCustomNavigableGeometry;
	LightingChannels: LightingChannels;
	bRenderCustomDepth: boolean;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	HiddenEditorViews: number;
	IsSelected: boolean;
	CollisionRadius: number;
	ShadeRadius: number;
	NumSteps: number;
	InitialSeedDensity: number;
	AverageSpreadDistance: number;
	SpreadVariance: number;
	SeedsPerStep: number;
	DistributionSeed: number;
	MaxInitialSeedOffset: number;
	bCanGrowInShade: boolean;
	bSpawnsInShade: boolean;
	MaxInitialAge: number;
	MaxAge: number;
	OverlapPriority: number;
	ProceduralScale: FloatInterval;
	ScaleCurve: RuntimeFloatCurve;
	DensityFalloff: FoliageDensityFalloff;
	ChangeCount: number;
	ReapplyDensity: boolean;
	ReapplyRadius: boolean;
	ReapplyAlignToNormal: boolean;
	ReapplyRandomYaw: boolean;
	ReapplyScaling: boolean;
	ReapplyScaleX: boolean;
	ReapplyScaleY: boolean;
	ReapplyScaleZ: boolean;
	ReapplyRandomPitchAngle: boolean;
	ReapplyGroundSlope: boolean;
	ReapplyHeight: boolean;
	ReapplyLandscapeLayers: boolean;
	ReapplyZOffset: boolean;
	ReapplyCollisionWithWorld: boolean;
	ReapplyVertexColorMask: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureCullMips: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	bIncludeInHLOD: boolean;
	ScaleMinX: number;
	ScaleMinY: number;
	ScaleMinZ: number;
	ScaleMaxX: number;
	ScaleMaxY: number;
	ScaleMaxZ: number;
	HeightMin: number;
	HeightMax: number;
	ZOffsetMin: number;
	ZOffsetMax: number;
	StartCullDistance: number;
	EndCullDistance: number;
	UniformScale: boolean;
	LockScaleX: boolean;
	LockScaleY: boolean;
	LockScaleZ: boolean;
	GroundSlope: number;
	MinGroundSlope: number;
	MinScale: number;
	MaxScale: number;
	static Load(ResourceName: string): FoliageType;
	static Find(Outer: UObject, ResourceName: string): FoliageType;
	static GetDefaultObject(): FoliageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType;
	static C(Other: UObject | any): FoliageType;
}

declare class InstancedStaticMeshInstanceData { 
	Transform: Matrix;
	clone() : InstancedStaticMeshInstanceData;
	static C(Other: UObject | any): InstancedStaticMeshInstanceData;
}

declare class InstancedStaticMeshRandomSeed { 
	StartInstanceIndex: number;
	RandomSeed: number;
	clone() : InstancedStaticMeshRandomSeed;
	static C(Other: UObject | any): InstancedStaticMeshRandomSeed;
}

declare class InstancedStaticMeshMappingInfo { 
	clone() : InstancedStaticMeshMappingInfo;
	static C(Other: UObject | any): InstancedStaticMeshMappingInfo;
}

declare class InstancedStaticMeshComponent extends StaticMeshComponent { 
	PerInstanceSMData: InstancedStaticMeshInstanceData[];
	PerInstancePrevTransform: Matrix[];
	NumCustomDataFloats: number;
	PerInstanceSMCustomData: number[];
	InstancingRandomSeed: number;
	AdditionalRandomSeeds: InstancedStaticMeshRandomSeed[];
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	InstanceReorderTable: number[];
	NumPendingLightmaps: number;
	CachedMappings: InstancedStaticMeshMappingInfo[];
	static Load(ResourceName: string): InstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): InstancedStaticMeshComponent;
	static GetDefaultObject(): InstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedStaticMeshComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	SetCustomDataValue(InstanceIndex: number,CustomDataIndex: number,CustomDataValue: number,bMarkRenderStateDirty: boolean): boolean;
	SetCullDistances(StartCullDistance: number,EndCullDistance: number): void;
	RemoveInstances(InstancesToRemove: number[]): boolean;
	RemoveInstance(InstanceIndex: number): boolean;
	IsValidInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstancesOverlappingSphere(Center: Vector,Radius: number,bSphereInWorldSpace: boolean): number[];
	GetInstancesOverlappingBox(Box: Box,bBoxInWorldSpace: boolean): number[];
	GetInstanceCount(): number;
	ClearInstances(): void;
	BatchUpdateInstancesTransforms(StartInstanceIndex: number,NewInstancesTransforms: Transform[],bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	BatchUpdateInstancesTransform(StartInstanceIndex: number,NumInstances: number,NewInstancesTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	AddInstanceWorldSpace(WorldTransform: Transform): number;
	AddInstances(InstanceTransforms: Transform[],bShouldReturnIndices: boolean,bWorldSpace: boolean): number[];
	AddInstance(InstanceTransform: Transform,bWorldSpace: boolean): number;
	static C(Other: UObject | any): InstancedStaticMeshComponent;
	K2_AcquireEditorSMInstanceElementHandle(InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorSMInstanceElementHandle(ISMComponent: InstancedStaticMeshComponent,InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent { 
	bUseTranslatedInstanceSpace: boolean;
	TranslatedInstanceSpaceOrigin: Vector;
	SortedInstances: number[];
	NumBuiltInstances: number;
	BuiltInstanceBounds: Box;
	UnbuiltInstanceBounds: Box;
	UnbuiltInstanceBoundsList: Box[];
	bEnableDensityScaling: boolean;
	OcclusionLayerNumNodes: number;
	CacheMeshExtendedBounds: BoxSphereBounds;
	bDisableCollision: boolean;
	InstanceCountToRender: number;
	static Load(ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static GetDefaultObject(): HierarchicalInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalInstancedStaticMeshComponent;
	static C(Other: UObject | any): HierarchicalInstancedStaticMeshComponent;
}

declare class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	OnInstanceTakePointDamage: UnrealEngineMulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnInstanceTakeRadialDamage: UnrealEngineMulticastDelegate<(Instances: number[], Damages: number[], InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
	bEnableDiscardOnLoad: boolean;
	FoliageHiddenEditorViews: number;
	GenerationGuid: Guid;
	static Load(ResourceName: string): FoliageInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): FoliageInstancedStaticMeshComponent;
	static GetDefaultObject(): FoliageInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageInstancedStaticMeshComponent;
	static C(Other: UObject | any): FoliageInstancedStaticMeshComponent;
}

declare class FoliageType_InstancedStaticMesh extends FoliageType { 
	Mesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	NaniteOverrideMaterials: MaterialInterface[];
	ComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_InstancedStaticMesh;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMesh;
	static GetDefaultObject(): FoliageType_InstancedStaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMesh;
	static C(Other: UObject | any): FoliageType_InstancedStaticMesh;
}

declare class FoliageTypeObject { 
	FoliageTypeObject: UObject;
	TypeInstance: FoliageType;
	bIsAsset: boolean;
	Type: UnrealEngineClass;
	clone() : FoliageTypeObject;
	static C(Other: UObject | any): FoliageTypeObject;
}

declare class ProceduralFoliageSpawner extends UObject { 
	RandomSeed: number;
	TileSize: number;
	NumUniqueTiles: number;
	MinimumQuadTreeSize: number;
	FoliageTypes: FoliageTypeObject[];
	static Load(ResourceName: string): ProceduralFoliageSpawner;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawner;
	static GetDefaultObject(): ProceduralFoliageSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawner;
	Simulate(NumSteps: number): void;
	static C(Other: UObject | any): ProceduralFoliageSpawner;
}

declare class ProceduralFoliageComponent extends ActorComponent { 
	FoliageSpawner: ProceduralFoliageSpawner;
	TileOverlap: number;
	bAllowLandscape: boolean;
	bAllowBSP: boolean;
	bAllowStaticMesh: boolean;
	bAllowTranslucent: boolean;
	bAllowFoliage: boolean;
	bShowDebugTiles: boolean;
	SpawningVolume: Volume;
	ProceduralGuid: Guid;
	static Load(ResourceName: string): ProceduralFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageComponent;
	static C(Other: UObject | any): ProceduralFoliageComponent;
}

declare class ProceduralFoliageVolume extends Volume { 
	ProceduralComponent: ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageVolume;
	static C(Other: UObject | any): ProceduralFoliageVolume;
}

declare class ProceduralFoliageEditorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ProceduralFoliageEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageEditorLibrary;
	static GetDefaultObject(): ProceduralFoliageEditorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageEditorLibrary;
	static ResimulateProceduralFoliageVolumes(ProceduralFoliageVolumes: ProceduralFoliageVolume[]): void;
	static ResimulateProceduralFoliageComponents(ProceduralFoliageComponents: ProceduralFoliageComponent[]): void;
	static ClearProceduralFoliageVolumes(ProceduralFoliageVolumes: ProceduralFoliageVolume[]): void;
	static ClearProceduralFoliageComponents(ProceduralFoliageComponents: ProceduralFoliageComponent[]): void;
	static C(Other: UObject | any): ProceduralFoliageEditorLibrary;
}

declare class ProceduralFoliageSpawnerFactory extends Factory { 
	static Load(ResourceName: string): ProceduralFoliageSpawnerFactory;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawnerFactory;
	static GetDefaultObject(): ProceduralFoliageSpawnerFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawnerFactory;
	static C(Other: UObject | any): ProceduralFoliageSpawnerFactory;
}

declare class CookerStats extends UObject { 
	Assets: UObject[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	static Load(ResourceName: string): CookerStats;
	static Find(Outer: UObject, ResourceName: string): CookerStats;
	static GetDefaultObject(): CookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject | any): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: UObject;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	static Load(ResourceName: string): LightingBuildInfo;
	static Find(Outer: UObject, ResourceName: string): LightingBuildInfo;
	static GetDefaultObject(): LightingBuildInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject | any): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: UObject;
	Actors: Actor[];
	Type: string;
	Count: number;
	Sections: number;
	HWInstances: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	static Load(ResourceName: string): PrimitiveStats;
	static Find(Outer: UObject, ResourceName: string): PrimitiveStats;
	static GetDefaultObject(): PrimitiveStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject | any): PrimitiveStats;
}

declare class ShaderCookerStats extends UObject { 
	Name: string;
	Platform: string;
	Category: string;
	Compiled: number;
	Cooked: number;
	Permutations: number;
	CompileTime: number;
	Path: string;
	static Load(ResourceName: string): ShaderCookerStats;
	static Find(Outer: UObject, ResourceName: string): ShaderCookerStats;
	static GetDefaultObject(): ShaderCookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderCookerStats;
	static C(Other: UObject | any): ShaderCookerStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: Actor;
	StaticMesh: StaticMesh;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	LightmapTextureNames: string[];
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static Find(Outer: UObject, ResourceName: string): StaticMeshLightingInfo;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject | any): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: Texture;
	Actors: Actor[];
	Type: string;
	Virtual: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	static Load(ResourceName: string): TextureStats;
	static Find(Outer: UObject, ResourceName: string): TextureStats;
	static GetDefaultObject(): TextureStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject | any): TextureStats;
}

declare class TextureImportSettings extends DeveloperSettings { 
	AutoVTSize: number;
	static Load(ResourceName: string): TextureImportSettings;
	static Find(Outer: UObject, ResourceName: string): TextureImportSettings;
	static GetDefaultObject(): TextureImportSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureImportSettings;
	static C(Other: UObject | any): TextureImportSettings;
}

declare class ClothConfigCommon extends ClothConfigBase { 
	static Load(ResourceName: string): ClothConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothConfigCommon;
	static GetDefaultObject(): ClothConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigCommon;
	static C(Other: UObject | any): ClothConfigCommon;
}

declare class ClothSharedConfigCommon extends ClothConfigCommon { 
	static Load(ResourceName: string): ClothSharedConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothSharedConfigCommon;
	static GetDefaultObject(): ClothSharedConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedConfigCommon;
	static C(Other: UObject | any): ClothSharedConfigCommon;
}

declare class ClothingAssetCustomData extends UObject { 
	static Load(ResourceName: string): ClothingAssetCustomData;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCustomData;
	static GetDefaultObject(): ClothingAssetCustomData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCustomData;
	static C(Other: UObject | any): ClothingAssetCustomData;
}

declare class PointWeightMap { 
	Values: number[];
	Name: string;
	CurrentTarget: number;
	bEnabled: boolean;
	clone() : PointWeightMap;
	static C(Other: UObject | any): PointWeightMap;
}

declare class ClothTetherData { 
	clone() : ClothTetherData;
	static C(Other: UObject | any): ClothTetherData;
}

declare class ClothPhysicalMeshData { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: number[];
	WeightMaps: Map<number, PointWeightMap>;
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	SelfCollisionIndices: number[];
	EuclideanTethers: ClothTetherData;
	GeodesicTethers: ClothTetherData;
	MaxBoneWeights: number;
	NumFixedVerts: number;
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	AnimDriveMultipliers: number[];
	clone() : ClothPhysicalMeshData;
	static C(Other: UObject | any): ClothPhysicalMeshData;
}

declare class ClothCollisionPrim_Sphere { 
	BoneIndex: number;
	Radius: number;
	LocalPosition: Vector;
	clone() : ClothCollisionPrim_Sphere;
	static C(Other: UObject | any): ClothCollisionPrim_Sphere;
}

declare class ClothCollisionPrim_SphereConnection { 
	SphereIndices: number;
	clone() : ClothCollisionPrim_SphereConnection;
	static C(Other: UObject | any): ClothCollisionPrim_SphereConnection;
}

declare class ClothCollisionPrim_ConvexFace { 
	Plane: Plane;
	Indices: number[];
	clone() : ClothCollisionPrim_ConvexFace;
	static C(Other: UObject | any): ClothCollisionPrim_ConvexFace;
}

declare class ClothCollisionPrim_Convex { 
	planes: Plane[];
	Faces: ClothCollisionPrim_ConvexFace[];
	SurfacePoints: Vector[];
	BoneIndex: number;
	clone() : ClothCollisionPrim_Convex;
	static C(Other: UObject | any): ClothCollisionPrim_Convex;
}

declare class ClothCollisionPrim_Box { 
	LocalPosition: Vector;
	LocalRotation: Quat;
	HalfExtents: Vector;
	BoneIndex: number;
	clone() : ClothCollisionPrim_Box;
	static C(Other: UObject | any): ClothCollisionPrim_Box;
}

declare class ClothCollisionData { 
	Spheres: ClothCollisionPrim_Sphere[];
	SphereConnections: ClothCollisionPrim_SphereConnection[];
	Convexes: ClothCollisionPrim_Convex[];
	Boxes: ClothCollisionPrim_Box[];
	clone() : ClothCollisionData;
	static C(Other: UObject | any): ClothCollisionData;
}

declare class ClothLODDataCommon_Legacy extends UObject { 
	PhysicalMeshData: ClothPhysicalMeshDataBase_Legacy;
	ClothPhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	ParameterMasks: PointWeightMap[];
	static Load(ResourceName: string): ClothLODDataCommon_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothLODDataCommon_Legacy;
	static GetDefaultObject(): ClothLODDataCommon_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothLODDataCommon_Legacy;
	static C(Other: UObject | any): ClothLODDataCommon_Legacy;
}

declare type EWeightMapTargetCommon = 'None' | 'MaxDistance' | 'BackstopDistance' | 'BackstopRadius' | 'AnimDriveStiffness' | 'AnimDriveDamping_DEPRECATED' | 'EWeightMapTargetCommon_MAX';
declare var EWeightMapTargetCommon : { None:'None',MaxDistance:'MaxDistance',BackstopDistance:'BackstopDistance',BackstopRadius:'BackstopRadius',AnimDriveStiffness:'AnimDriveStiffness',AnimDriveDamping_DEPRECATED:'AnimDriveDamping_DEPRECATED',EWeightMapTargetCommon_MAX:'EWeightMapTargetCommon_MAX', };
declare class ClothParameterMask_Legacy { 
	MaskName: string;
	CurrentTarget: EWeightMapTargetCommon;
	MaxValue: number;
	MinValue: number;
	Values: number[];
	bEnabled: boolean;
	clone() : ClothParameterMask_Legacy;
	static C(Other: UObject | any): ClothParameterMask_Legacy;
}

declare class ClothLODDataCommon { 
	PhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	bUseMultipleInfluences: boolean;
	SkinningKernelRadius: number;
	bSmoothTransition: boolean;
	ParameterMasks: ClothParameterMask_Legacy[];
	PointWeightMaps: PointWeightMap[];
	clone() : ClothLODDataCommon;
	static C(Other: UObject | any): ClothLODDataCommon;
}

declare type EClothingWindMethod_Legacy = 'Legacy' | 'Accurate' | 'EClothingWindMethod_MAX';
declare var EClothingWindMethod_Legacy : { Legacy:'Legacy',Accurate:'Accurate',EClothingWindMethod_MAX:'EClothingWindMethod_MAX', };
declare class ClothConstraintSetup_Legacy { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetup_Legacy;
	static C(Other: UObject | any): ClothConstraintSetup_Legacy;
}

declare class ClothConfig_Legacy { 
	WindMethod: EClothingWindMethod_Legacy;
	VerticalConstraintConfig: ClothConstraintSetup_Legacy;
	HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
	BendConstraintConfig: ClothConstraintSetup_Legacy;
	ShearConstraintConfig: ClothConstraintSetup_Legacy;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	GravityOverride: Vector;
	bUseGravityOverride: boolean;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	AnimDriveSpringStiffness: number;
	AnimDriveDamperStiffness: number;
	clone() : ClothConfig_Legacy;
	static C(Other: UObject | any): ClothConfig_Legacy;
}

declare class ClothingAssetCommon extends ClothingAssetBase { 
	PhysicsAsset: PhysicsAsset;
	ClothConfigs: Map<string, ClothConfigBase>;
	ClothSharedSimConfig: ClothConfigBase;
	ClothSimConfig: ClothConfigBase;
	ChaosClothSimConfig: ClothConfigBase;
	ClothLODData: ClothLODDataCommon_Legacy[];
	LODData: ClothLODDataCommon[];
	LodMap: number[];
	UsedBoneNames: string[];
	UsedBoneIndices: number[];
	ReferenceBoneIndex: number;
	CustomData: ClothingAssetCustomData;
	ClothConfig: ClothConfig_Legacy;
	static Load(ResourceName: string): ClothingAssetCommon;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCommon;
	static GetDefaultObject(): ClothingAssetCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCommon;
	static C(Other: UObject | any): ClothingAssetCommon;
}

declare class PreviewSceneProfile { 
	ProfileName: string;
	bSharedProfile: boolean;
	bUseSkyLighting: boolean;
	DirectionalLightIntensity: number;
	DirectionalLightColor: LinearColor;
	SkyLightIntensity: number;
	bRotateLightingRig: boolean;
	bShowEnvironment: boolean;
	bShowFloor: boolean;
	EnvironmentColor: LinearColor;
	EnvironmentIntensity: number;
	EnvironmentCubeMap: TextureCube;
	EnvironmentCubeMapPath: string;
	bPostProcessingEnabled: boolean;
	PostProcessingSettings: PostProcessSettings;
	LightingRigRotation: number;
	RotationSpeed: number;
	DirectionalLightRotation: Rotator;
	clone() : PreviewSceneProfile;
	static C(Other: UObject | any): PreviewSceneProfile;
}

declare class LocalProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): LocalProfiles;
	static Find(Outer: UObject, ResourceName: string): LocalProfiles;
	static GetDefaultObject(): LocalProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalProfiles;
	static C(Other: UObject | any): LocalProfiles;
}

declare class SharedProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): SharedProfiles;
	static Find(Outer: UObject, ResourceName: string): SharedProfiles;
	static GetDefaultObject(): SharedProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedProfiles;
	static C(Other: UObject | any): SharedProfiles;
}

declare class AssetViewerSettings extends UObject { 
	Profiles: PreviewSceneProfile[];
	bFakeConfigValue_HACK: boolean;
	static Load(ResourceName: string): AssetViewerSettings;
	static Find(Outer: UObject, ResourceName: string): AssetViewerSettings;
	static GetDefaultObject(): AssetViewerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetViewerSettings;
	static C(Other: UObject | any): AssetViewerSettings;
}

declare class PropertyEntry { 
	Property: EMaterialProperty;
	bUseCustomSize: boolean;
	CustomSize: IntPoint;
	bUseConstantValue: boolean;
	ConstantValue: number;
	clone() : PropertyEntry;
	static C(Other: UObject | any): PropertyEntry;
}

declare class MaterialOptions extends UObject { 
	Properties: PropertyEntry[];
	TextureSize: IntPoint;
	LODIndices: number[];
	bUseMeshData: boolean;
	bUseSpecificUVIndex: boolean;
	TextureCoordinateIndex: number;
	static Load(ResourceName: string): MaterialOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialOptions;
	static GetDefaultObject(): MaterialOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialOptions;
	static C(Other: UObject | any): MaterialOptions;
}

declare class AssetBakeOptions extends UObject { 
	static Load(ResourceName: string): AssetBakeOptions;
	static Find(Outer: UObject, ResourceName: string): AssetBakeOptions;
	static GetDefaultObject(): AssetBakeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBakeOptions;
	static C(Other: UObject | any): AssetBakeOptions;
}

declare type EMaterialBakeMethod = 'IndividualMaterial' | 'AtlasMaterial' | 'BinnedMaterial' | 'EMaterialBakeMethod_MAX';
declare var EMaterialBakeMethod : { IndividualMaterial:'IndividualMaterial',AtlasMaterial:'AtlasMaterial',BinnedMaterial:'BinnedMaterial',EMaterialBakeMethod_MAX:'EMaterialBakeMethod_MAX', };
declare class MaterialMergeOptions extends UObject { 
	Method: EMaterialBakeMethod;
	BlendMode: EBlendMode;
	static Load(ResourceName: string): MaterialMergeOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialMergeOptions;
	static GetDefaultObject(): MaterialMergeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialMergeOptions;
	static C(Other: UObject | any): MaterialMergeOptions;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	PhysMaterialMask: PhysicalMaterialMask;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	SetNaniteOverrideMaterial(bInEnableOverride: boolean,InOverrideMaterial: MaterialInterface): void;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	static C(Other: UObject | any): MaterialInstanceConstant;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	GetMaterialInstanceScalarParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): number;
	GetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	GetMaterialInstanceTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	UpdateMaterialInstance(): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialEditingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MaterialEditingLibrary;
	static Find(Outer: UObject, ResourceName: string): MaterialEditingLibrary;
	static GetDefaultObject(): MaterialEditingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditingLibrary;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface,PreviewMaterial: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static RecompileMaterial(Material: Material): void;
	static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
	static LayoutMaterialExpressions(Material: Material): void;
	static HasMaterialUsage(Material: Material,Usage: EMaterialUsage): boolean;
	static GetVectorParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetVectorParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetUsedTextures(Material: Material): Texture[];
	static GetTextureParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetTextureParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetStatistics(Material: MaterialInterface): MaterialStatistics;
	static GetStaticSwitchParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStaticSwitchParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetScalarParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetScalarParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetMaterialSelectedNodes(Material: Material): Set<UObject>;
	static GetMaterialPropertyInputNodeOutputName(Material: Material,Property: EMaterialProperty): string;
	static GetMaterialPropertyInputNode(Material: Material,Property: EMaterialProperty): MaterialExpression;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialExpressionNodePosition(MaterialExpression: MaterialExpression,NodePosX?: number,NodePosY?: number): {NodePosX: number, NodePosY: number};
	static GetMaterialDefaultVectorParameterValue(Material: Material,ParameterName: string): LinearColor;
	static GetMaterialDefaultTextureParameterValue(Material: Material,ParameterName: string): Texture;
	static GetMaterialDefaultStaticSwitchParameterValue(Material: Material,ParameterName: string): boolean;
	static GetMaterialDefaultScalarParameterValue(Material: Material,ParameterName: string): number;
	static GetInputsForMaterialExpression(Material: Material,MaterialExpression: MaterialExpression): MaterialExpression[];
	static GetInputNodeOutputNameForMaterialExpression(MaterialExpression: MaterialExpression,InputNode: MaterialExpression,OutputName?: string): {OutputName: string, $: boolean};
	static GetChildInstances(Parent: MaterialInterface,ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	static DuplicateMaterialExpression(Material: Material,MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static C(Other: UObject | any): MaterialEditingLibrary;
}

declare class MaterialEditorMenuContext extends UObject { 
	static Load(ResourceName: string): MaterialEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorMenuContext;
	static GetDefaultObject(): MaterialEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorMenuContext;
	static C(Other: UObject | any): MaterialEditorMenuContext;
}

declare type EBackgroundType = 'SolidColor' | 'Checkered' | 'EBackgroundType_MAX';
declare var EBackgroundType : { SolidColor:'SolidColor',Checkered:'Checkered',EBackgroundType_MAX:'EBackgroundType_MAX', };
declare class CheckerboardSettings { 
	ColorOne: Color;
	ColorTwo: Color;
	Size: number;
	clone() : CheckerboardSettings;
	static C(Other: UObject | any): CheckerboardSettings;
}

declare class PreviewBackgroundSettings { 
	bShowBorder: boolean;
	BorderColor: Color;
	BackgroundType: EBackgroundType;
	BackgroundColor: Color;
	Checkerboard: CheckerboardSettings;
	clone() : PreviewBackgroundSettings;
	static C(Other: UObject | any): PreviewBackgroundSettings;
}

declare class MaterialEditorSettings extends UObject { 
	MaliOfflineCompilerPath: FilePath;
	DefaultPreviewWidth: number;
	DefaultPreviewHeight: number;
	PreviewBackground: PreviewBackgroundSettings;
	static Load(ResourceName: string): MaterialEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorSettings;
	static GetDefaultObject(): MaterialEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorSettings;
	static C(Other: UObject | any): MaterialEditorSettings;
}

declare class CurveEditorFilterBase extends UObject { 
	static Load(ResourceName: string): CurveEditorFilterBase;
	static Find(Outer: UObject, ResourceName: string): CurveEditorFilterBase;
	static GetDefaultObject(): CurveEditorFilterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorFilterBase;
	static C(Other: UObject | any): CurveEditorFilterBase;
}

declare class CurveEditorBakeFilter extends CurveEditorFilterBase { 
	bUseFrameBake: boolean;
	BakeIntervalInFrames: FrameNumber;
	BakeIntervalInSeconds: number;
	static Load(ResourceName: string): CurveEditorBakeFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorBakeFilter;
	static GetDefaultObject(): CurveEditorBakeFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorBakeFilter;
	static C(Other: UObject | any): CurveEditorBakeFilter;
}

declare class KeyPosition { 
	InputValue: number;
	OutputValue: number;
	clone() : KeyPosition;
	static C(Other: UObject | any): KeyPosition;
}

declare class KeyAttributes { 
	bHasArriveTangent: boolean;
	bHasLeaveTangent: boolean;
	bHasInterpMode: boolean;
	bHasTangentMode: boolean;
	bHasTangentWeightMode: boolean;
	bHasArriveTangentWeight: boolean;
	bHasLeaveTangentWeight: boolean;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	ArriveTangentWeight: number;
	LeaveTangentWeight: number;
	clone() : KeyAttributes;
	static C(Other: UObject | any): KeyAttributes;
}

declare class CurveEditorCopyableCurveKeys extends UObject { 
	KeyPositions: KeyPosition[];
	KeyAttributes: KeyAttributes[];
	ShortDisplayName: string;
	LongDisplayName: string;
	IntentionName: string;
	LongIntentionName: string;
	static Load(ResourceName: string): CurveEditorCopyableCurveKeys;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyableCurveKeys;
	static GetDefaultObject(): CurveEditorCopyableCurveKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyableCurveKeys;
	static C(Other: UObject | any): CurveEditorCopyableCurveKeys;
}

declare class CurveEditorCopyBuffer extends UObject { 
	Curves: CurveEditorCopyableCurveKeys[];
	TimeOffset: number;
	bAbsolutePosition: boolean;
	static Load(ResourceName: string): CurveEditorCopyBuffer;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyBuffer;
	static GetDefaultObject(): CurveEditorCopyBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyBuffer;
	static C(Other: UObject | any): CurveEditorCopyBuffer;
}

declare class CurveEditorEulerFilter extends CurveEditorFilterBase { 
	static Load(ResourceName: string): CurveEditorEulerFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorEulerFilter;
	static GetDefaultObject(): CurveEditorEulerFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorEulerFilter;
	static C(Other: UObject | any): CurveEditorEulerFilter;
}

declare class CurveEditorKeyProxy extends Interface { 
	static Load(ResourceName: string): CurveEditorKeyProxy;
	static Find(Outer: UObject, ResourceName: string): CurveEditorKeyProxy;
	static GetDefaultObject(): CurveEditorKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorKeyProxy;
	static C(Other: UObject | any): CurveEditorKeyProxy;
}

declare class CurveEditorReduceFilter extends CurveEditorFilterBase { 
	Tolerance: number;
	bTryRemoveUserSetTangentKeys: boolean;
	SampleRate: FrameRate;
	static Load(ResourceName: string): CurveEditorReduceFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorReduceFilter;
	static GetDefaultObject(): CurveEditorReduceFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorReduceFilter;
	static C(Other: UObject | any): CurveEditorReduceFilter;
}

declare type ECurveEditorTangentVisibility = 'AllTangents' | 'SelectedKeys' | 'NoTangents' | 'ECurveEditorTangentVisibility_MAX';
declare var ECurveEditorTangentVisibility : { AllTangents:'AllTangents',SelectedKeys:'SelectedKeys',NoTangents:'NoTangents',ECurveEditorTangentVisibility_MAX:'ECurveEditorTangentVisibility_MAX', };
declare type ECurveEditorZoomPosition = 'CurrentTime' | 'MousePosition' | 'ECurveEditorZoomPosition_MAX';
declare var ECurveEditorZoomPosition : { CurrentTime:'CurrentTime',MousePosition:'MousePosition',ECurveEditorZoomPosition_MAX:'ECurveEditorZoomPosition_MAX', };
declare class CustomColorForChannel { 
	UObject: Class;
	PropertyName: string;
	Color: LinearColor;
	clone() : CustomColorForChannel;
	static C(Other: UObject | any): CustomColorForChannel;
}

declare class CustomColorForSpaceSwitch { 
	ControlName: string;
	Color: LinearColor;
	clone() : CustomColorForSpaceSwitch;
	static C(Other: UObject | any): CustomColorForSpaceSwitch;
}

declare class CurveEditorSettings extends UObject { 
	bAutoFrameCurveEditor: boolean;
	FrameInputPadding: number;
	FrameOutputPadding: number;
	bShowBufferedCurves: boolean;
	bShowCurveEditorCurveToolTips: boolean;
	TangentVisibility: ECurveEditorTangentVisibility;
	ZoomPosition: ECurveEditorZoomPosition;
	bSnapTimeToSelection: boolean;
	SelectionColor: LinearColor;
	CustomColors: CustomColorForChannel[];
	ParentSpaceCustomColor: LinearColor;
	WorldSpaceCustomColor: LinearColor;
	ControlSpaceCustomColors: CustomColorForSpaceSwitch[];
	static Load(ResourceName: string): CurveEditorSettings;
	static Find(Outer: UObject, ResourceName: string): CurveEditorSettings;
	static GetDefaultObject(): CurveEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorSettings;
	static C(Other: UObject | any): CurveEditorSettings;
}

declare class RichCurveKeyProxy extends UObject { 
	Value: RichCurveKey;
	static Load(ResourceName: string): RichCurveKeyProxy;
	static Find(Outer: UObject, ResourceName: string): RichCurveKeyProxy;
	static GetDefaultObject(): RichCurveKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichCurveKeyProxy;
	static C(Other: UObject | any): RichCurveKeyProxy;
}

declare class NamedLensPreset { 
	Name: string;
	LensSettings: CameraLensSettings;
	clone() : NamedLensPreset;
	static C(Other: UObject | any): NamedLensPreset;
}

declare class NamedFilmbackPreset { 
	Name: string;
	FilmbackSettings: CameraFilmbackSettings;
	clone() : NamedFilmbackPreset;
	static C(Other: UObject | any): NamedFilmbackPreset;
}

declare class PlateCropSettings { 
	AspectRatio: number;
	clone() : PlateCropSettings;
	static C(Other: UObject | any): PlateCropSettings;
}

declare class NamedPlateCropPreset { 
	Name: string;
	CropSettings: PlateCropSettings;
	clone() : NamedPlateCropPreset;
	static C(Other: UObject | any): NamedPlateCropPreset;
}

declare class CineCameraSettings extends DeveloperSettings { 
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPreset: string;
	FilmbackPresets: NamedFilmbackPreset[];
	DefaultCropPresetName: string;
	CropPresets: NamedPlateCropPreset[];
	static Load(ResourceName: string): CineCameraSettings;
	static Find(Outer: UObject, ResourceName: string): CineCameraSettings;
	static GetDefaultObject(): CineCameraSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraSettings;
	SetLensPresets(InLensPresets: NamedLensPreset[]): void;
	SetFilmbackPresets(InFilmbackPresets: NamedFilmbackPreset[]): void;
	SetDefaultLensPresetName(InDefaultLensPresetName: string): void;
	SetDefaultLensFStop(InDefaultLensFStop: number): void;
	SetDefaultLensFocalLength(InDefaultLensFocalLength: number): void;
	SetDefaultFilmbackPreset(InDefaultFilmbackPreset: string): void;
	SetDefaultCropPresetName(InDefaultCropPresetName: string): void;
	SetCropPresets(InCropPresets: NamedPlateCropPreset[]): void;
	GetLensPresetNames(): string[];
	GetLensPresetByName(PresetName: string,LensSettings?: CameraLensSettings): {LensSettings: CameraLensSettings, $: boolean};
	GetFilmbackPresetNames(): string[];
	GetFilmbackPresetByName(PresetName: string,FilmbackSettings?: CameraFilmbackSettings): {FilmbackSettings: CameraFilmbackSettings, $: boolean};
	GetCropPresetNames(): string[];
	GetCropPresetByName(PresetName: string,CropSettings?: PlateCropSettings): {CropSettings: PlateCropSettings, $: boolean};
	static GetCineCameraSettings(): CineCameraSettings;
	static C(Other: UObject | any): CineCameraSettings;
}

declare class CameraRig_Crane extends Actor { 
	CranePitch: number;
	CraneYaw: number;
	CraneArmLength: number;
	bLockMountPitch: boolean;
	bLockMountYaw: boolean;
	TransformComponent: SceneComponent;
	CraneYawControl: SceneComponent;
	CranePitchControl: SceneComponent;
	CraneCameraMount: SceneComponent;
	PreviewMesh_CraneArm: StaticMeshComponent;
	PreviewMesh_CraneBase: StaticMeshComponent;
	PreviewMesh_CraneMount: StaticMeshComponent;
	PreviewMesh_CraneCounterWeight: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Crane;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Crane;
	static C(Other: UObject | any): CameraRig_Crane;
}

declare class CameraRig_Rail extends Actor { 
	CurrentPositionOnRail: number;
	bLockOrientationToRail: boolean;
	bShowRailVisualization: boolean;
	PreviewMeshScale: number;
	TransformComponent: SceneComponent;
	RailSplineComponent: SplineComponent;
	RailCameraMount: SceneComponent;
	PreviewMesh_Rail: SplineMeshComponent;
	PreviewRailMeshSegments: SplineMeshComponent[];
	PreviewRailStaticMesh: StaticMesh;
	PreviewMesh_Mount: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Rail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Rail;
	GetRailSplineComponent(): SplineComponent;
	static C(Other: UObject | any): CameraRig_Rail;
}

declare class CameraLookatTrackingSettings { 
	bEnableLookAtTracking: boolean;
	bDrawDebugLookAtTrackingPosition: boolean;
	LookAtTrackingInterpSpeed: number;
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bAllowRoll: boolean;
	clone() : CameraLookatTrackingSettings;
	static C(Other: UObject | any): CameraLookatTrackingSettings;
}

declare class CineCameraComponent extends CameraComponent { 
	FilmbackSettings: CameraFilmbackSettings;
	Filmback: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CropSettings: PlateCropSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	bOverride_CustomNearClippingPlane: boolean;
	CustomNearClippingPlane: number;
	CurrentHorizontalFOV: number;
	FocusPlaneVisualizationMesh: StaticMesh;
	FocusPlaneVisualizationMaterial: Material;
	DebugFocusPlaneComponent: StaticMeshComponent;
	DebugFocusPlaneMID: MaterialInstanceDynamic;
	FilmbackPresets: NamedFilmbackPreset[];
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPresetName: string;
	DefaultFilmbackPreset: string;
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	static Load(ResourceName: string): CineCameraComponent;
	static Find(Outer: UObject, ResourceName: string): CineCameraComponent;
	static GetDefaultObject(): CineCameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraComponent;
	SetLensSettings(NewLensSettings: CameraLensSettings): void;
	SetLensPresetByName(InPresetName: string): void;
	SetFocusSettings(NewFocusSettings: CameraFocusSettings): void;
	SetFilmbackPresetByName(InPresetName: string): void;
	SetFilmback(NewFilmback: CameraFilmbackSettings): void;
	SetCurrentFocalLength(InFocalLength: number): void;
	SetCurrentAperture(NewCurrentAperture: number): void;
	SetCropSettings(NewCropSettings: PlateCropSettings): void;
	SetCropPresetByName(InPresetName: string): void;
	GetVerticalFieldOfView(): number;
	static GetLensPresetsCopy(): NamedLensPreset[];
	GetLensPresetName(): string;
	GetHorizontalFieldOfView(): number;
	static GetFilmbackPresetsCopy(): NamedFilmbackPreset[];
	GetFilmbackPresetName(): string;
	GetDefaultFilmbackPresetName(): string;
	GetCropPresetName(): string;
	static C(Other: UObject | any): CineCameraComponent;
}

declare class CineCameraActor extends CameraActor { 
	LookatTrackingSettings: CameraLookatTrackingSettings;
	static GetDefaultObject(): CineCameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraActor;
	GetCineCameraComponent(): CineCameraComponent;
	static C(Other: UObject | any): CineCameraActor;
}

declare class ConstraintsActor extends Actor { 
	ConstraintsManager: ConstraintsManager;
	static GetDefaultObject(): ConstraintsActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintsActor;
	static C(Other: UObject | any): ConstraintsActor;
}

declare class ConstraintsScriptingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ConstraintsScriptingLibrary;
	static Find(Outer: UObject, ResourceName: string): ConstraintsScriptingLibrary;
	static GetDefaultObject(): ConstraintsScriptingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstraintsScriptingLibrary;
	static RemoveConstraint(InWorld: World,InIndex: number): boolean;
	static GetManager(InWorld: World): ConstraintsManager;
	static CreateTransformableComponentHandle(InWorld: World,InSceneComponent: SceneComponent,InSocketName: string): TransformableComponentHandle;
	static CreateFromType(InWorld: World,InType: ETransformConstraintType): TickableTransformConstraint;
	static AddConstraint(InWorld: World,InParentHandle: TransformableHandle,InChildHandle: TransformableHandle,InConstraint: TickableTransformConstraint,bMaintainOffset: boolean): boolean;
	static C(Other: UObject | any): ConstraintsScriptingLibrary;
}

declare class TickableTranslationConstraint extends TickableTransformConstraint { 
	OffsetTranslation: Vector;
	static Load(ResourceName: string): TickableTranslationConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableTranslationConstraint;
	static GetDefaultObject(): TickableTranslationConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableTranslationConstraint;
	static C(Other: UObject | any): TickableTranslationConstraint;
}

declare class TickableRotationConstraint extends TickableTransformConstraint { 
	OffsetRotation: Quat;
	static Load(ResourceName: string): TickableRotationConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableRotationConstraint;
	static GetDefaultObject(): TickableRotationConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableRotationConstraint;
	static C(Other: UObject | any): TickableRotationConstraint;
}

declare class TickableScaleConstraint extends TickableTransformConstraint { 
	OffsetScale: Vector;
	static Load(ResourceName: string): TickableScaleConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableScaleConstraint;
	static GetDefaultObject(): TickableScaleConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableScaleConstraint;
	static C(Other: UObject | any): TickableScaleConstraint;
}

declare class TickableParentConstraint extends TickableTransformConstraint { 
	OffsetTransform: Transform;
	bScaling: boolean;
	static Load(ResourceName: string): TickableParentConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableParentConstraint;
	static GetDefaultObject(): TickableParentConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableParentConstraint;
	static C(Other: UObject | any): TickableParentConstraint;
}

declare class TickableLookAtConstraint extends TickableTransformConstraint { 
	Axis: Vector;
	static Load(ResourceName: string): TickableLookAtConstraint;
	static Find(Outer: UObject, ResourceName: string): TickableLookAtConstraint;
	static GetDefaultObject(): TickableLookAtConstraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableLookAtConstraint;
	static C(Other: UObject | any): TickableLookAtConstraint;
}

declare class DataLayerCreationParameters { 
	DataLayerAsset: DataLayerAsset;
	WorldDataLayers: WorldDataLayers;
	clone() : DataLayerCreationParameters;
	static C(Other: UObject | any): DataLayerCreationParameters;
}

declare class DataLayerEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): DataLayerEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataLayerEditorSubsystem;
	static GetDefaultObject(): DataLayerEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerEditorSubsystem;
	UpdateAllViewVisibility(DataLayerThatChanged: DataLayer): void;
	UpdateAllActorsVisibility(bNotifySelectionChange: boolean,bRedrawViewports: boolean): boolean;
	UpdateActorVisibility(Actor: Actor,bOutSelectionChanged?: boolean,bOutActorModified?: boolean,bNotifySelectionChange?: boolean,bRedrawViewports?: boolean): {bOutSelectionChanged: boolean, bOutActorModified: boolean, $: boolean};
	UpdateActorAllViewsVisibility(Actor: Actor): void;
	ToggleDataLayerVisibility(DataLayer: DataLayerInstance): void;
	ToggleDataLayersVisibility(DataLayers: DataLayerInstance[]): void;
	ToggleDataLayersIsLoadedInEditor(DataLayers: DataLayerInstance[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsLoadedInEditor(DataLayer: DataLayerInstance,bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	SetParentDataLayer(DataLayer: DataLayerInstance,ParentDataLayer: DataLayerInstance): boolean;
	SetDataLayerVisibility(DataLayer: DataLayerInstance,bIsVisible: boolean): void;
	SetDataLayersVisibility(DataLayers: DataLayerInstance[],bIsVisible: boolean): void;
	SetDataLayersIsLoadedInEditor(DataLayers: DataLayerInstance[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsLoadedInEditor(DataLayer: DataLayerInstance,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SelectActorsInDataLayers(DataLayers: DataLayerInstance[],bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	SelectActorsInDataLayer(DataLayer: DataLayerInstance,bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	RenameDataLayer(DataLayer: DataLayerInstance,NewDataLayerLabel: string): boolean;
	RemoveSelectedActorsFromDataLayers(DataLayers: DataLayerInstance[]): boolean;
	RemoveSelectedActorsFromDataLayer(DataLayer: DataLayerInstance): boolean;
	RemoveActorsFromDataLayers(Actors: Actor[],DataLayers: DataLayerInstance[]): boolean;
	RemoveActorsFromDataLayer(Actors: Actor[],DataLayer: DataLayerInstance): boolean;
	RemoveActorsFromAllDataLayers(Actors: Actor[]): boolean;
	RemoveActorFromDataLayers(Actor: Actor,DataLayers: DataLayerInstance[]): boolean;
	RemoveActorFromDataLayer(Actor: Actor,DataLayerToRemove: DataLayerInstance): boolean;
	RemoveActorFromAllDataLayers(Actor: Actor): boolean;
	MakeAllDataLayersVisible(): void;
	IsActorValidForDataLayer(Actor: Actor): boolean;
	GetDataLayerInstances(DataLayerAssets: DataLayerAsset[]): DataLayerInstance[];
	GetDataLayerInstance(DataLayerAsset: DataLayerAsset): DataLayerInstance;
	GetDataLayerFromLabel(DataLayerLabel: string): DataLayerInstance;
	GetDataLayer(ActorDataLayer: ActorDataLayer): DataLayerInstance;
	GetAllDataLayers(): DataLayerInstance[];
	GetActorsFromDataLayers(DataLayers: DataLayerInstance[]): Actor[];
	GetActorsFromDataLayer(DataLayer: DataLayerInstance): Actor[];
	DeleteDataLayers(DataLayersToDelete: DataLayerInstance[]): void;
	DeleteDataLayer(DataLayerToDelete: DataLayerInstance): void;
	CreateDataLayerInstance(Parameters: DataLayerCreationParameters): DataLayerInstance;
	CreateDataLayer(ParentDataLayer: DataLayerInstance): DataLayerInstance;
	AppendActorsFromDataLayers(DataLayers: DataLayerInstance[],InOutActors?: Actor[]): {InOutActors: Actor[]};
	AppendActorsFromDataLayer(DataLayer: DataLayerInstance,InOutActors?: Actor[]): {InOutActors: Actor[]};
	AddSelectedActorsToDataLayers(DataLayers: DataLayerInstance[]): boolean;
	AddSelectedActorsToDataLayer(DataLayer: DataLayerInstance): boolean;
	AddActorToDataLayers(Actor: Actor,DataLayers: DataLayerInstance[]): boolean;
	AddActorToDataLayer(Actor: Actor,DataLayer: DataLayerInstance): boolean;
	AddActorsToDataLayers(Actors: Actor[],DataLayers: DataLayerInstance[]): boolean;
	AddActorsToDataLayer(Actors: Actor[],DataLayer: DataLayerInstance): boolean;
	static C(Other: UObject | any): DataLayerEditorSubsystem;
}

declare class DataLayerFactory extends Factory { 
	static Load(ResourceName: string): DataLayerFactory;
	static Find(Outer: UObject, ResourceName: string): DataLayerFactory;
	static GetDefaultObject(): DataLayerFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerFactory;
	static C(Other: UObject | any): DataLayerFactory;
}

declare type EHardwareClass = 'Unspecified' | 'Desktop' | 'Mobile' | 'EHardwareClass_MAX';
declare var EHardwareClass : { Unspecified:'Unspecified',Desktop:'Desktop',Mobile:'Mobile',EHardwareClass_MAX:'EHardwareClass_MAX', };
declare type EGraphicsPreset = 'Unspecified' | 'Maximum' | 'Scalable' | 'EGraphicsPreset_MAX';
declare var EGraphicsPreset : { Unspecified:'Unspecified',Maximum:'Maximum',Scalable:'Scalable',EGraphicsPreset_MAX:'EGraphicsPreset_MAX', };
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	static Load(ResourceName: string): HardwareTargetingSettings;
	static Find(Outer: UObject, ResourceName: string): HardwareTargetingSettings;
	static GetDefaultObject(): HardwareTargetingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject | any): HardwareTargetingSettings;
}

declare class ClassTemplate extends UObject { 
	GeneratedBaseClass: UnrealEngineClass;
	static Load(ResourceName: string): ClassTemplate;
	static Find(Outer: UObject, ResourceName: string): ClassTemplate;
	static GetDefaultObject(): ClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplate;
	static C(Other: UObject | any): ClassTemplate;
}

declare class PluginClassTemplate extends ClassTemplate { 
	PluginName: string;
	static Load(ResourceName: string): PluginClassTemplate;
	static Find(Outer: UObject, ResourceName: string): PluginClassTemplate;
	static GetDefaultObject(): PluginClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginClassTemplate;
	static C(Other: UObject | any): PluginClassTemplate;
}

declare class ClassTemplateEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): ClassTemplateEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): ClassTemplateEditorSubsystem;
	static GetDefaultObject(): ClassTemplateEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplateEditorSubsystem;
	static C(Other: UObject | any): ClassTemplateEditorSubsystem;
}

declare class LocalizedTemplateString { 
	Language: string;
	Text: string;
	clone() : LocalizedTemplateString;
	static C(Other: UObject | any): LocalizedTemplateString;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
	clone() : TemplateFolderRename;
	static C(Other: UObject | any): TemplateFolderRename;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
	clone() : TemplateReplacement;
	static C(Other: UObject | any): TemplateReplacement;
}

declare type ETemplateSetting = 'Languages' | 'HardwareTarget' | 'GraphicsPreset' | 'StarterContent' | 'XR' | 'Raytracing' | 'All' | 'ETemplateSetting_MAX';
declare var ETemplateSetting : { Languages:'Languages',HardwareTarget:'HardwareTarget',GraphicsPreset:'GraphicsPreset',StarterContent:'StarterContent',XR:'XR',Raytracing:'Raytracing',All:'All',ETemplateSetting_MAX:'ETemplateSetting_MAX', };
declare type EFeaturePackDetailLevel = 'Standard' | 'High' | 'EFeaturePackDetailLevel_MAX';
declare var EFeaturePackDetailLevel : { Standard:'Standard',High:'High',EFeaturePackDetailLevel_MAX:'EFeaturePackDetailLevel_MAX', };
declare class FeaturePackLevelSet { 
	DetailLevels: EFeaturePackDetailLevel[];
	MountName: string;
	clone() : FeaturePackLevelSet;
	static C(Other: UObject | any): FeaturePackLevelSet;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Categories: string[];
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	bIsEnterprise: boolean;
	bIsBlank: boolean;
	bThumbnailAsIcon: boolean;
	HiddenSettings: ETemplateSetting[];
	PacksToInclude: string[];
	EditDetailLevelPreference: EFeaturePackDetailLevel;
	SharedContentPacks: FeaturePackLevelSet[];
	StarterContent: string;
	static Load(ResourceName: string): TemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): TemplateProjectDefs;
	static GetDefaultObject(): TemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject | any): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): DefaultTemplateProjectDefs;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject | any): DefaultTemplateProjectDefs;
}

declare class TemplateCategoryDef { 
	Key: string;
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	Icon: string;
	IsMajorCategory: boolean;
	clone() : TemplateCategoryDef;
	static C(Other: UObject | any): TemplateCategoryDef;
}

declare class TemplateCategories extends UObject { 
	Categories: TemplateCategoryDef[];
	static Load(ResourceName: string): TemplateCategories;
	static Find(Outer: UObject, ResourceName: string): TemplateCategories;
	static GetDefaultObject(): TemplateCategories;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateCategories;
	static C(Other: UObject | any): TemplateCategories;
}

declare class SubobjectDataHandle { 
	clone() : SubobjectDataHandle;
	static C(Other: UObject | any): SubobjectDataHandle;
	GetData(OutData?: SubobjectData): {OutData: SubobjectData};
	IsHandleValid(): boolean;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
}

declare class SubobjectData { 
	WeakObjectPtr: UObject;
	Handle: SubobjectDataHandle;
	ParentObjectHandle: SubobjectDataHandle;
	ChildrenHandles: SubobjectDataHandle[];
	clone() : SubobjectData;
	static C(Other: UObject | any): SubobjectData;
	CanCopy(): boolean;
	CanDelete(): boolean;
	CanDuplicate(): boolean;
	CanEdit(): boolean;
	CanRename(): boolean;
	CanReparent(): boolean;
	GetHandle(OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetObject(bEvenIfPendingKill: boolean): UObject;
	GetObjectForBlueprint(Blueprint: Blueprint): UObject;
	GetVariableName(): string;
	IsActor(): boolean;
	IsAttachedTo(InHandle: SubobjectDataHandle): boolean;
	IsChildActor(): boolean;
	IsComponent(): boolean;
	IsDefaultSceneRoot(): boolean;
	IsInheritedComponent(): boolean;
	IsInstancedActor(): boolean;
	IsInstancedComponent(): boolean;
	IsNativeComponent(): boolean;
	IsRootActor(): boolean;
	IsRootComponent(): boolean;
	IsSceneComponent(): boolean;
	IsValid(): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanReparent(Data: SubobjectData): boolean;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetObjectForBlueprint(Data: SubobjectData,Blueprint: Blueprint): UObject;
	static GetVariableName(Data: SubobjectData): string;
	static IsActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsValid(Data: SubobjectData): boolean;
}

declare class SubobjectDataBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static GetDefaultObject(): SubobjectDataBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataBlueprintFunctionLibrary;
	static IsValid(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsActor(Data: SubobjectData): boolean;
	static GetVariableName(Data: SubobjectData): string;
	static GetObjectForBlueprint(Data: SubobjectData,Blueprint: Blueprint): UObject;
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetDisplayName(Data: SubobjectData): string;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	GetBlueprint(Data: SubobjectData): Blueprint;
	static CanReparent(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static C(Other: UObject | any): SubobjectDataBlueprintFunctionLibrary;
}

declare class ReparentSubobjectParams { 
	NewParentHandle: SubobjectDataHandle;
	BlueprintContext: Blueprint;
	ActorPreviewContext: Actor;
	clone() : ReparentSubobjectParams;
	static C(Other: UObject | any): ReparentSubobjectParams;
}

declare class AddNewSubobjectParams { 
	ParentHandle: SubobjectDataHandle;
	NewClass: UnrealEngineClass;
	BlueprintContext: Blueprint;
	bSkipMarkBlueprintModified: boolean;
	bConformTransformToParent: boolean;
	clone() : AddNewSubobjectParams;
	static C(Other: UObject | any): AddNewSubobjectParams;
}

declare class SubobjectDataSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): SubobjectDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataSubsystem;
	static GetDefaultObject(): SubobjectDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataSubsystem;
	ReparentSubobjects(Params: ReparentSubobjectParams,HandlesToMove: SubobjectDataHandle[]): boolean;
	ReparentSubobject(Params: ReparentSubobjectParams,ToReparentHandle: SubobjectDataHandle): boolean;
	static RenameSubobjectMemberVariable(BPContext: Blueprint,InHandle: SubobjectDataHandle,NewName: string): void;
	RenameSubobject(Handle: SubobjectDataHandle,InNewName: string): boolean;
	MakeNewSceneRoot(Context: SubobjectDataHandle,NewSceneRoot: SubobjectDataHandle,BPContext: Blueprint): boolean;
	K2_GatherSubobjectDataForInstance(Context: Actor,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_GatherSubobjectDataForBlueprint(Context: Blueprint,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_FindSubobjectDataFromHandle(Handle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData, $: boolean};
	K2_DeleteSubobjectsFromInstance(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[]): number;
	K2_DeleteSubobjectFromInstance(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle): number;
	IsValidRename(Handle: SubobjectDataHandle,InNewText: string,OutErrorMessage?: string): {OutErrorMessage: string, $: boolean};
	FindHandleForObject(Context: SubobjectDataHandle,ObjectToFind: UObject,BPContext: Blueprint): SubobjectDataHandle;
	DetachSubobject(OwnerHandle: SubobjectDataHandle,ChildToRemove: SubobjectDataHandle): boolean;
	DeleteSubobjects(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[],BPContext: Blueprint): number;
	DeleteSubobject(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle,BPContext: Blueprint): number;
	static CreateNewCPPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	static CreateNewBPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	CopySubobjects(Handles: SubobjectDataHandle[],BPContext: Blueprint): void;
	ChangeSubobjectClass(Handle: SubobjectDataHandle,NewClass: UnrealEngineClass): boolean;
	CanPasteSubobjects(RootHandle: SubobjectDataHandle,BPContext: Blueprint): boolean;
	CanCopySubobjects(Handles: SubobjectDataHandle[]): boolean;
	AttachSubobject(OwnerHandle: SubobjectDataHandle,ChildToAddHandle: SubobjectDataHandle): boolean;
	AddNewSubobject(Params: AddNewSubobjectParams,FailReason?: string): {FailReason: string, $: SubobjectDataHandle};
	static C(Other: UObject | any): SubobjectDataSubsystem;
}

declare class SubobjectEditorMenuContext extends UObject { 
	static Load(ResourceName: string): SubobjectEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): SubobjectEditorMenuContext;
	static GetDefaultObject(): SubobjectEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectEditorMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): SubobjectEditorMenuContext;
}

declare class NotifyFieldValueChanged extends Interface { 
	static Load(ResourceName: string): NotifyFieldValueChanged;
	static Find(Outer: UObject, ResourceName: string): NotifyFieldValueChanged;
	static GetDefaultObject(): NotifyFieldValueChanged;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NotifyFieldValueChanged;
	static C(Other: UObject | any): NotifyFieldValueChanged;
}

declare class UserWidgetPool { 
	ActiveWidgets: UserWidget[];
	InactiveWidgets: UserWidget[];
	clone() : UserWidgetPool;
	static C(Other: UObject | any): UserWidgetPool;
}

declare class ListViewBase extends Widget { 
	BP_OnEntryGenerated: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	EntryWidgetClass: UnrealEngineClass;
	WheelScrollMultiplier: number;
	bEnableScrollAnimation: boolean;
	AllowOverscroll: boolean;
	bEnableRightClickScrolling: boolean;
	bEnableFixedLineOffset: boolean;
	FixedLineScrollOffset: number;
	bAllowDragging: boolean;
	BP_OnEntryReleased: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	NumDesignerPreviewEntries: number;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): ListViewBase;
	static Find(Outer: UObject, ResourceName: string): ListViewBase;
	static GetDefaultObject(): ListViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewBase;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollOffset(InScrollOffset: number): void;
	SetScrollbarVisibility(InVisibility: ESlateVisibility): void;
	ScrollToTop(): void;
	ScrollToBottom(): void;
	RequestRefresh(): void;
	RegenerateAllEntries(): void;
	GetScrollOffset(): number;
	GetDisplayedEntryWidgets(): UserWidget[];
	static C(Other: UObject | any): ListViewBase;
}

declare class TableViewStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	clone() : TableViewStyle;
	static C(Other: UObject | any): TableViewStyle;
}

declare type EOrientation = 'Orient_Horizontal' | 'Orient_Vertical' | 'Orient_MAX';
declare var EOrientation : { Orient_Horizontal:'Orient_Horizontal',Orient_Vertical:'Orient_Vertical',Orient_MAX:'Orient_MAX', };
declare type ESelectionMode = 'None' | 'Single' | 'SingleToggle' | 'Multi' | 'ESelectionMode_MAX';
declare var ESelectionMode : { None:'None',Single:'Single',SingleToggle:'SingleToggle',Multi:'Multi',ESelectionMode_MAX:'ESelectionMode_MAX', };
declare type EConsumeMouseWheel = 'WhenScrollingPossible' | 'Always' | 'Never' | 'EConsumeMouseWheel_MAX';
declare var EConsumeMouseWheel : { WhenScrollingPossible:'WhenScrollingPossible',Always:'Always',Never:'Never',EConsumeMouseWheel_MAX:'EConsumeMouseWheel_MAX', };
declare class ListView extends ListViewBase { 
	WidgetStyle: TableViewStyle;
	ScrollBarStyle: ScrollBarStyle;
	Orientation: EOrientation;
	SelectionMode: ESelectionMode;
	ConsumeMouseWheel: EConsumeMouseWheel;
	bClearSelectionOnClick: boolean;
	bIsFocusable: boolean;
	EntrySpacing: number;
	bReturnFocusToSelection: boolean;
	ListItems: UObject[];
	BP_OnEntryInitialized: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	BP_OnItemClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemDoubleClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemIsHoveredChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsHovered: boolean) => void>;
	BP_OnItemSelectionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsSelected: boolean) => void>;
	BP_OnItemScrolledIntoView: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	static Load(ResourceName: string): ListView;
	static Find(Outer: UObject, ResourceName: string): ListView;
	static GetDefaultObject(): ListView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListView;
	SetSelectionMode(SelectionMode: ESelectionMode): void;
	SetSelectedIndex(Index: number): void;
	ScrollIndexIntoView(Index: number): void;
	RemoveItem(Item: UObject): void;
	OnListItemOuterEndPlayed(ItemOuter: Actor,EndPlayReason: EEndPlayReason): void;
	OnListItemEndPlayed(Item: Actor,EndPlayReason: EEndPlayReason): void;
	NavigateToIndex(Index: number): void;
	IsRefreshPending(): boolean;
	GetNumItems(): number;
	GetListItems(): UObject[];
	GetItemAt(Index: number): UObject;
	GetIndexForItem(Item: UObject): number;
	ClearListItems(): void;
	BP_SetSelectedItem(Item: UObject): void;
	BP_SetListItems(InListItems: UObject[]): void;
	BP_SetItemSelection(Item: UObject,bSelected: boolean): void;
	BP_ScrollItemIntoView(Item: UObject): void;
	BP_NavigateToItem(Item: UObject): void;
	BP_IsItemVisible(Item: UObject): boolean;
	BP_GetSelectedItems(Items?: UObject[]): {Items: UObject[], $: boolean};
	BP_GetSelectedItem(): UObject;
	BP_GetNumItemsSelected(): number;
	BP_ClearSelection(): void;
	BP_CancelScrollIntoView(): void;
	AddItem(Item: UObject): void;
	static C(Other: UObject | any): ListView;
}

declare class ListViewDesignerPreviewItem extends UObject { 
	static Load(ResourceName: string): ListViewDesignerPreviewItem;
	static Find(Outer: UObject, ResourceName: string): ListViewDesignerPreviewItem;
	static GetDefaultObject(): ListViewDesignerPreviewItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewDesignerPreviewItem;
	static C(Other: UObject | any): ListViewDesignerPreviewItem;
}

declare class UserWidgetBlueprint extends Blueprint { 
	static Load(ResourceName: string): UserWidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): UserWidgetBlueprint;
	static GetDefaultObject(): UserWidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidgetBlueprint;
	static C(Other: UObject | any): UserWidgetBlueprint;
}

declare class WidgetBlueprintGeneratedClassExtension extends UObject { 
	static Load(ResourceName: string): WidgetBlueprintGeneratedClassExtension;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintGeneratedClassExtension;
	static GetDefaultObject(): WidgetBlueprintGeneratedClassExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintGeneratedClassExtension;
	static C(Other: UObject | any): WidgetBlueprintGeneratedClassExtension;
}

declare class WidgetFieldNotificationExtension extends UserWidgetExtension { 
	static Load(ResourceName: string): WidgetFieldNotificationExtension;
	static Find(Outer: UObject, ResourceName: string): WidgetFieldNotificationExtension;
	static GetDefaultObject(): WidgetFieldNotificationExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetFieldNotificationExtension;
	static C(Other: UObject | any): WidgetFieldNotificationExtension;
}

declare class MovieSceneEntitySystem extends UObject { 
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): MovieSceneEntitySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntitySystem;
	static GetDefaultObject(): MovieSceneEntitySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntitySystem;
	static C(Other: UObject | any): MovieSceneEntitySystem;
}

declare class MovieSceneEntityInstantiatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static GetDefaultObject(): MovieSceneEntityInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneEntityInstantiatorSystem;
}

declare class MovieScenePropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static GetDefaultObject(): MovieScenePropertyInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyInstantiatorSystem;
	static C(Other: UObject | any): MovieScenePropertyInstantiatorSystem;
}

declare class MovieScenePropertySystem extends MovieSceneEntitySystem { 
	InstantiatorSystem: MovieScenePropertyInstantiatorSystem;
	static Load(ResourceName: string): MovieScenePropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertySystem;
	static GetDefaultObject(): MovieScenePropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertySystem;
	static C(Other: UObject | any): MovieScenePropertySystem;
}

declare class MovieScene2DTransformPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieScene2DTransformPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformPropertySystem;
	static GetDefaultObject(): MovieScene2DTransformPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformPropertySystem;
	static C(Other: UObject | any): MovieScene2DTransformPropertySystem;
}

declare class MovieScene2DTransformMask { 
	mask: number;
	clone() : MovieScene2DTransformMask;
	static C(Other: UObject | any): MovieScene2DTransformMask;
}

declare class MovieScene2DTransformSection extends MovieSceneSection { 
	TransformMask: MovieScene2DTransformMask;
	Translation: MovieSceneFloatChannel;
	Rotation: MovieSceneFloatChannel;
	Scale: MovieSceneFloatChannel;
	Shear: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieScene2DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformSection;
	static GetDefaultObject(): MovieScene2DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformSection;
	static C(Other: UObject | any): MovieScene2DTransformSection;
}

declare class MovieScenePropertyBinding { 
	PropertyName: string;
	PropertyPath: string;
	bCanUseClassLookup: boolean;
	clone() : MovieScenePropertyBinding;
	static C(Other: UObject | any): MovieScenePropertyBinding;
}

declare class MovieScenePropertyTrack extends MovieSceneNameableTrack { 
	UniqueTrackName: string;
	PropertyName: string;
	PropertyPath: string;
	SectionToKey: MovieSceneSection;
	PropertyBinding: MovieScenePropertyBinding;
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieScenePropertyTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyTrack;
	static GetDefaultObject(): MovieScenePropertyTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyTrack;
	static C(Other: UObject | any): MovieScenePropertyTrack;
	GetPropertyName(): string;
	GetPropertyPath(): string;
	GetUniqueTrackName(): string;
	SetPropertyNameAndPath(InPropertyName: string,InPropertyPath: string): void;
	static GetPropertyName(Track: MovieScenePropertyTrack): string;
	static GetPropertyPath(Track: MovieScenePropertyTrack): string;
	static GetUniqueTrackName(Track: MovieScenePropertyTrack): string;
	static SetPropertyNameAndPath(Track: MovieScenePropertyTrack,InPropertyName: string,InPropertyPath: string): void;
}

declare class MovieScene2DTransformTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieScene2DTransformTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformTrack;
	static GetDefaultObject(): MovieScene2DTransformTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformTrack;
	static C(Other: UObject | any): MovieScene2DTransformTrack;
}

declare class MovieSceneMarginPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieSceneMarginPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginPropertySystem;
	static GetDefaultObject(): MovieSceneMarginPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginPropertySystem;
	static C(Other: UObject | any): MovieSceneMarginPropertySystem;
}

declare class MovieSceneMarginSection extends MovieSceneSection { 
	TopCurve: MovieSceneFloatChannel;
	LeftCurve: MovieSceneFloatChannel;
	RightCurve: MovieSceneFloatChannel;
	BottomCurve: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieSceneMarginSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginSection;
	static GetDefaultObject(): MovieSceneMarginSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginSection;
	static C(Other: UObject | any): MovieSceneMarginSection;
}

declare class MovieSceneMarginTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieSceneMarginTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginTrack;
	static GetDefaultObject(): MovieSceneMarginTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginTrack;
	static C(Other: UObject | any): MovieSceneMarginTrack;
}

declare class MovieSceneWidgetMaterialSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneWidgetMaterialSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialSystem;
	static GetDefaultObject(): MovieSceneWidgetMaterialSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialSystem;
	static C(Other: UObject | any): MovieSceneWidgetMaterialSystem;
}

declare class MovieSceneMaterialTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMaterialTrack;
	static GetDefaultObject(): MovieSceneMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialTrack;
	static C(Other: UObject | any): MovieSceneMaterialTrack;
}

declare class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack { 
	BrushPropertyNamePath: string[];
	TrackName: string;
	static Load(ResourceName: string): MovieSceneWidgetMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialTrack;
	static GetDefaultObject(): MovieSceneWidgetMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialTrack;
	static C(Other: UObject | any): MovieSceneWidgetMaterialTrack;
}

declare class BlueprintWidgetAnimationDelegateBinding { 
	Action: EWidgetAnimationEvent;
	AnimationToBind: string;
	FunctionNameToBind: string;
	UserTag: string;
	clone() : BlueprintWidgetAnimationDelegateBinding;
	static C(Other: UObject | any): BlueprintWidgetAnimationDelegateBinding;
}

declare class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding { 
	WidgetAnimationDelegateBindings: BlueprintWidgetAnimationDelegateBinding[];
	static Load(ResourceName: string): WidgetAnimationDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationDelegateBinding;
	static GetDefaultObject(): WidgetAnimationDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationDelegateBinding;
	static C(Other: UObject | any): WidgetAnimationDelegateBinding;
}

declare class WidgetAnimationPlayCallbackProxy extends UObject { 
	Finished: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static GetDefaultObject(): WidgetAnimationPlayCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationPlayCallbackProxy;
	static CreatePlayAnimationTimeRangeProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,EndAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static CreatePlayAnimationProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static C(Other: UObject | any): WidgetAnimationPlayCallbackProxy;
}

declare class BoolBinding extends PropertyBinding { 
	static Load(ResourceName: string): BoolBinding;
	static Find(Outer: UObject, ResourceName: string): BoolBinding;
	static GetDefaultObject(): BoolBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolBinding;
	GetValue(): boolean;
	static C(Other: UObject | any): BoolBinding;
}

declare class BrushBinding extends PropertyBinding { 
	static Load(ResourceName: string): BrushBinding;
	static Find(Outer: UObject, ResourceName: string): BrushBinding;
	static GetDefaultObject(): BrushBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBinding;
	GetValue(): SlateBrush;
	static C(Other: UObject | any): BrushBinding;
}

declare class CheckedStateBinding extends PropertyBinding { 
	static Load(ResourceName: string): CheckedStateBinding;
	static Find(Outer: UObject, ResourceName: string): CheckedStateBinding;
	static GetDefaultObject(): CheckedStateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckedStateBinding;
	GetValue(): ECheckBoxState;
	static C(Other: UObject | any): CheckedStateBinding;
}

declare class ColorBinding extends PropertyBinding { 
	static Load(ResourceName: string): ColorBinding;
	static Find(Outer: UObject, ResourceName: string): ColorBinding;
	static GetDefaultObject(): ColorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ColorBinding;
	GetSlateValue(): SlateColor;
	GetLinearValue(): LinearColor;
	static C(Other: UObject | any): ColorBinding;
}

declare class FloatBinding extends PropertyBinding { 
	static Load(ResourceName: string): FloatBinding;
	static Find(Outer: UObject, ResourceName: string): FloatBinding;
	static GetDefaultObject(): FloatBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatBinding;
	GetValue(): number;
	static C(Other: UObject | any): FloatBinding;
}

declare class Int32Binding extends PropertyBinding { 
	static Load(ResourceName: string): Int32Binding;
	static Find(Outer: UObject, ResourceName: string): Int32Binding;
	static GetDefaultObject(): Int32Binding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int32Binding;
	GetValue(): number;
	static C(Other: UObject | any): Int32Binding;
}

declare class MouseCursorBinding extends PropertyBinding { 
	static Load(ResourceName: string): MouseCursorBinding;
	static Find(Outer: UObject, ResourceName: string): MouseCursorBinding;
	static GetDefaultObject(): MouseCursorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorBinding;
	GetValue(): EMouseCursor;
	static C(Other: UObject | any): MouseCursorBinding;
}

declare class TextBinding extends PropertyBinding { 
	static Load(ResourceName: string): TextBinding;
	static Find(Outer: UObject, ResourceName: string): TextBinding;
	static GetDefaultObject(): TextBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBinding;
	GetTextValue(): string;
	GetStringValue(): string;
	static C(Other: UObject | any): TextBinding;
}

declare class VisibilityBinding extends PropertyBinding { 
	static Load(ResourceName: string): VisibilityBinding;
	static Find(Outer: UObject, ResourceName: string): VisibilityBinding;
	static GetDefaultObject(): VisibilityBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisibilityBinding;
	GetValue(): ESlateVisibility;
	static C(Other: UObject | any): VisibilityBinding;
}

declare class WidgetBinding extends PropertyBinding { 
	static Load(ResourceName: string): WidgetBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetBinding;
	static GetDefaultObject(): WidgetBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBinding;
	GetValue(): Widget;
	static C(Other: UObject | any): WidgetBinding;
}

declare class Texture2DDynamic extends Texture { 
	Format: EPixelFormat;
	static Load(ResourceName: string): Texture2DDynamic;
	static Find(Outer: UObject, ResourceName: string): Texture2DDynamic;
	static GetDefaultObject(): Texture2DDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DDynamic;
	static C(Other: UObject | any): Texture2DDynamic;
}

declare class AsyncTaskDownloadImage extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	OnFail: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	static Load(ResourceName: string): AsyncTaskDownloadImage;
	static Find(Outer: UObject, ResourceName: string): AsyncTaskDownloadImage;
	static GetDefaultObject(): AsyncTaskDownloadImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTaskDownloadImage;
	static DownloadImage(URL: string): AsyncTaskDownloadImage;
	static C(Other: UObject | any): AsyncTaskDownloadImage;
}

declare class GameViewportWidgetSlot { 
	Anchors: Anchors;
	Offsets: Margin;
	Alignment: Vector2D;
	ZOrder: number;
	clone() : GameViewportWidgetSlot;
	static C(Other: UObject | any): GameViewportWidgetSlot;
}

declare class GameViewportSubsystem extends GameInstanceSubsystem { 
	static Load(ResourceName: string): GameViewportSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameViewportSubsystem;
	static GetDefaultObject(): GameViewportSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameViewportSubsystem;
	static SetWidgetSlotPosition(Slot: GameViewportWidgetSlot,Widget: Widget,Position: Vector2D,bRemoveDPIScale: boolean): GameViewportWidgetSlot;
	static SetWidgetSlotDesiredSize(Slot: GameViewportWidgetSlot,Size: Vector2D): GameViewportWidgetSlot;
	SetWidgetSlot(Widget: Widget,Slot: GameViewportWidgetSlot): void;
	RemoveWidget(Widget: Widget): void;
	IsWidgetAdded(Widget: Widget): boolean;
	GetWidgetSlot(Widget: Widget): GameViewportWidgetSlot;
	AddWidgetForPlayer(Widget: Widget,Player: LocalPlayer,Slot: GameViewportWidgetSlot): void;
	AddWidget(Widget: Widget,Slot: GameViewportWidgetSlot): void;
	static C(Other: UObject | any): GameViewportSubsystem;
}

declare class UserListEntry extends Interface { 
	static Load(ResourceName: string): UserListEntry;
	static Find(Outer: UObject, ResourceName: string): UserListEntry;
	static GetDefaultObject(): UserListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntry;
	BP_OnItemSelectionChanged(bIsSelected: boolean): void;
	BP_OnItemExpansionChanged(bIsExpanded: boolean): void;
	BP_OnEntryReleased(): void;
	static C(Other: UObject | any): UserListEntry;
}

declare class UserListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserListEntryLibrary;
	static GetDefaultObject(): UserListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntryLibrary;
	static C(Other: UObject | any): UserListEntryLibrary;
}

declare class UserObjectListEntry extends UserListEntry { 
	static Load(ResourceName: string): UserObjectListEntry;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntry;
	static GetDefaultObject(): UserObjectListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntry;
	OnListItemObjectSet(ListItemObject: UObject): void;
	static C(Other: UObject | any): UserObjectListEntry;
}

declare class UserObjectListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserObjectListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntryLibrary;
	static GetDefaultObject(): UserObjectListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntryLibrary;
	static C(Other: UObject | any): UserObjectListEntryLibrary;
}

declare class ContentWidget extends PanelWidget { 
	static Load(ResourceName: string): ContentWidget;
	static Find(Outer: UObject, ResourceName: string): ContentWidget;
	static GetDefaultObject(): ContentWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentWidget;
	SetContent(Content: Widget): PanelSlot;
	GetContentSlot(): PanelSlot;
	GetContent(): Widget;
	static C(Other: UObject | any): ContentWidget;
}

declare class BackgroundBlur extends ContentWidget { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bApplyAlphaToBlur: boolean;
	BlurStrength: number;
	bOverrideAutoRadiusCalculation: boolean;
	BlurRadius: number;
	CornerRadius: Vector4;
	LowQualityFallbackBrush: SlateBrush;
	static Load(ResourceName: string): BackgroundBlur;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlur;
	static GetDefaultObject(): BackgroundBlur;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlur;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetLowQualityFallbackBrush(InBrush: SlateBrush): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetCornerRadius(InCornerRadius: Vector4): void;
	SetBlurStrength(InStrength: number): void;
	SetBlurRadius(InBlurRadius: number): void;
	SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;
	static C(Other: UObject | any): BackgroundBlur;
}

declare class BackgroundBlurSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BackgroundBlurSlot;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlurSlot;
	static GetDefaultObject(): BackgroundBlurSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlurSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BackgroundBlurSlot;
}

declare class Border extends ContentWidget { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bShowEffectWhenDisabled: boolean;
	ContentColorAndOpacity: LinearColor;
	ContentColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Padding: Margin;
	Background: SlateBrush;
	BackgroundDelegate: UnrealEngineDelegate<() => SlateBrush>;
	BrushColor: LinearColor;
	BrushColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	DesiredSizeScale: Vector2D;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseButtonUpEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseMoveEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseDoubleClickEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): Border;
	static Find(Outer: UObject, ResourceName: string): Border;
	static GetDefaultObject(): Border;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Border;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetShowEffectWhenDisabled(bInShowEffectWhenDisabled: boolean): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetDesiredSizeScale(InScale: Vector2D): void;
	SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrushColor(InBrushColor: LinearColor): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): Border;
}

declare type EButtonClickMethod = 'DownAndUp' | 'MouseDown' | 'MouseUp' | 'PreciseClick' | 'EButtonClickMethod_MAX';
declare var EButtonClickMethod : { DownAndUp:'DownAndUp',MouseDown:'MouseDown',MouseUp:'MouseUp',PreciseClick:'PreciseClick',EButtonClickMethod_MAX:'EButtonClickMethod_MAX', };
declare type EButtonTouchMethod = 'DownAndUp' | 'Down' | 'PreciseTap' | 'EButtonTouchMethod_MAX';
declare var EButtonTouchMethod : { DownAndUp:'DownAndUp',Down:'Down',PreciseTap:'PreciseTap',EButtonTouchMethod_MAX:'EButtonTouchMethod_MAX', };
declare type EButtonPressMethod = 'DownAndUp' | 'ButtonPress' | 'ButtonRelease' | 'EButtonPressMethod_MAX';
declare var EButtonPressMethod : { DownAndUp:'DownAndUp',ButtonPress:'ButtonPress',ButtonRelease:'ButtonRelease',EButtonPressMethod_MAX:'EButtonPressMethod_MAX', };
declare class Button extends ContentWidget { 
	WidgetStyle: ButtonStyle;
	ColorAndOpacity: LinearColor;
	BackgroundColor: LinearColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnPressed: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	OnHovered: UnrealEngineMulticastDelegate<() => void>;
	OnUnhovered: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): Button;
	static Find(Outer: UObject, ResourceName: string): Button;
	static GetDefaultObject(): Button;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Button;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetStyle(InStyle: ButtonStyle): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetBackgroundColor(InBackgroundColor: LinearColor): void;
	IsPressed(): boolean;
	static C(Other: UObject | any): Button;
}

declare class ButtonSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ButtonSlot;
	static Find(Outer: UObject, ResourceName: string): ButtonSlot;
	static GetDefaultObject(): ButtonSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ButtonSlot;
}

declare class CanvasPanel extends PanelWidget { 
	static Load(ResourceName: string): CanvasPanel;
	static Find(Outer: UObject, ResourceName: string): CanvasPanel;
	static GetDefaultObject(): CanvasPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanel;
	AddChildToCanvas(Content: Widget): CanvasPanelSlot;
	static C(Other: UObject | any): CanvasPanel;
}

declare class CheckBox extends ContentWidget { 
	CheckedState: ECheckBoxState;
	CheckedStateDelegate: UnrealEngineDelegate<() => ECheckBoxState>;
	WidgetStyle: CheckBoxStyle;
	HorizontalAlignment: EHorizontalAlignment;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnCheckStateChanged: UnrealEngineMulticastDelegate<(bIsChecked: boolean) => void>;
	static Load(ResourceName: string): CheckBox;
	static Find(Outer: UObject, ResourceName: string): CheckBox;
	static GetDefaultObject(): CheckBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBox;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetIsChecked(InIsChecked: boolean): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetCheckedState(InCheckedState: ECheckBoxState): void;
	IsPressed(): boolean;
	IsChecked(): boolean;
	GetCheckedState(): ECheckBoxState;
	static C(Other: UObject | any): CheckBox;
}

declare class CircularThrobber extends Widget { 
	NumberOfPieces: number;
	Period: number;
	Radius: number;
	UImage: SlateBrush;
	bEnableRadius: boolean;
	static Load(ResourceName: string): CircularThrobber;
	static Find(Outer: UObject, ResourceName: string): CircularThrobber;
	static GetDefaultObject(): CircularThrobber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircularThrobber;
	SetRadius(InRadius: number): void;
	SetPeriod(InPeriod: number): void;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	static C(Other: UObject | any): CircularThrobber;
}

declare class ComboBox extends Widget { 
	Items: UObject[];
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	bIsFocusable: boolean;
	static Load(ResourceName: string): ComboBox;
	static Find(Outer: UObject, ResourceName: string): ComboBox;
	static GetDefaultObject(): ComboBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBox;
	static C(Other: UObject | any): ComboBox;
}

declare class TableRowStyle extends SlateWidgetStyle { 
	SelectorFocusedBrush: SlateBrush;
	ActiveHoveredBrush: SlateBrush;
	ActiveBrush: SlateBrush;
	InactiveHoveredBrush: SlateBrush;
	InactiveBrush: SlateBrush;
	bUseParentRowBrush: boolean;
	ParentRowBackgroundBrush: SlateBrush;
	ParentRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundBrush: SlateBrush;
	OddRowBackgroundHoveredBrush: SlateBrush;
	OddRowBackgroundBrush: SlateBrush;
	TextColor: SlateColor;
	SelectedTextColor: SlateColor;
	DropIndicator_Above: SlateBrush;
	DropIndicator_Onto: SlateBrush;
	DropIndicator_Below: SlateBrush;
	ActiveHighlightedBrush: SlateBrush;
	InactiveHighlightedBrush: SlateBrush;
	clone() : TableRowStyle;
	static C(Other: UObject | any): TableRowStyle;
}

declare type ESelectInfo = 'OnKeyPress' | 'OnNavigation' | 'OnMouseClick' | 'Direct' | 'ESelectInfo_MAX';
declare var ESelectInfo : { OnKeyPress:'OnKeyPress',OnNavigation:'OnNavigation',OnMouseClick:'OnMouseClick',Direct:'Direct',ESelectInfo_MAX:'ESelectInfo_MAX', };
declare class ComboBoxKey extends Widget { 
	Options: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ForegroundColor: SlateColor;
	ContentPadding: Margin;
	MaxListHeight: number;
	bHasDownArrow: boolean;
	bEnableGamepadNavigationMode: boolean;
	bIsFocusable: boolean;
	OnGenerateContentWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnGenerateItemWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxKey;
	static Find(Outer: UObject, ResourceName: string): ComboBoxKey;
	static GetDefaultObject(): ComboBoxKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxKey;
	SetSelectedOption(Option: string): void;
	RemoveOption(Option: string): boolean;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxKey;
}

declare class ComboBoxString extends Widget { 
	DefaultOptions: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ContentPadding: Margin;
	MaxListHeight: number;
	HasDownArrow: boolean;
	EnableGamepadNavigationMode: boolean;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	bIsFocusable: boolean;
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxString;
	static Find(Outer: UObject, ResourceName: string): ComboBoxString;
	static GetDefaultObject(): ComboBoxString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxString;
	SetSelectedOption(Option: string): void;
	SetSelectedIndex(Index: number): void;
	RemoveOption(Option: string): boolean;
	RefreshOptions(): void;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	GetSelectedIndex(): number;
	GetOptionCount(): number;
	GetOptionAtIndex(Index: number): string;
	FindOptionIndex(Option: string): number;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxString;
}

declare type EDynamicBoxType = 'Horizontal' | 'Vertical' | 'Wrap' | 'VerticalWrap' | 'Radial' | 'Overlay' | 'EDynamicBoxType_MAX';
declare var EDynamicBoxType : { Horizontal:'Horizontal',Vertical:'Vertical',Wrap:'Wrap',VerticalWrap:'VerticalWrap',Radial:'Radial',Overlay:'Overlay',EDynamicBoxType_MAX:'EDynamicBoxType_MAX', };
declare class RadialBoxSettings { 
	StartingAngle: number;
	bDistributeItemsEvenly: boolean;
	AngleBetweenItems: number;
	SectorCentralAngle: number;
	clone() : RadialBoxSettings;
	static C(Other: UObject | any): RadialBoxSettings;
}

declare class DynamicEntryBoxBase extends Widget { 
	EntryBoxType: EDynamicBoxType;
	EntrySpacing: Vector2D;
	SpacingPattern: Vector2D[];
	EntrySizeRule: SlateChildSize;
	EntryHorizontalAlignment: EHorizontalAlignment;
	EntryVerticalAlignment: EVerticalAlignment;
	MaxElementSize: number;
	RadialBoxSettings: RadialBoxSettings;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): DynamicEntryBoxBase;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBoxBase;
	static GetDefaultObject(): DynamicEntryBoxBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBoxBase;
	SetRadialSettings(InSettings: RadialBoxSettings): void;
	SetEntrySpacing(InEntrySpacing: Vector2D): void;
	GetNumEntries(): number;
	GetAllEntries(): UserWidget[];
	static C(Other: UObject | any): DynamicEntryBoxBase;
}

declare class DynamicEntryBox extends DynamicEntryBoxBase { 
	NumDesignerPreviewEntries: number;
	EntryWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): DynamicEntryBox;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBox;
	static GetDefaultObject(): DynamicEntryBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBox;
	Reset(bDeleteWidgets: boolean): void;
	RemoveEntry(EntryWidget: UserWidget): void;
	BP_CreateEntryOfClass(EntryClass: UnrealEngineClass): UserWidget;
	BP_CreateEntry(): UserWidget;
	static C(Other: UObject | any): DynamicEntryBox;
}

declare type EVirtualKeyboardType = 'Default' | 'Number' | 'Web' | 'Email' | 'Password' | 'AlphaNumeric' | 'EVirtualKeyboardType_MAX';
declare var EVirtualKeyboardType : { Default:'Default',Number:'Number',Web:'Web',Email:'Email',Password:'Password',AlphaNumeric:'AlphaNumeric',EVirtualKeyboardType_MAX:'EVirtualKeyboardType_MAX', };
declare class VirtualKeyboardOptions { 
	bEnableAutocorrect: boolean;
	clone() : VirtualKeyboardOptions;
	static C(Other: UObject | any): VirtualKeyboardOptions;
}

declare type EVirtualKeyboardTrigger = 'OnFocusByPointer' | 'OnAllFocusEvents' | 'EVirtualKeyboardTrigger_MAX';
declare var EVirtualKeyboardTrigger : { OnFocusByPointer:'OnFocusByPointer',OnAllFocusEvents:'OnAllFocusEvents',EVirtualKeyboardTrigger_MAX:'EVirtualKeyboardTrigger_MAX', };
declare type EVirtualKeyboardDismissAction = 'TextChangeOnDismiss' | 'TextCommitOnAccept' | 'TextCommitOnDismiss' | 'EVirtualKeyboardDismissAction_MAX';
declare var EVirtualKeyboardDismissAction : { TextChangeOnDismiss:'TextChangeOnDismiss',TextCommitOnAccept:'TextCommitOnAccept',TextCommitOnDismiss:'TextCommitOnDismiss',EVirtualKeyboardDismissAction_MAX:'EVirtualKeyboardDismissAction_MAX', };
declare type ETextJustify = 'Left' | 'Center' | 'Right' | 'ETextJustify_MAX';
declare var ETextJustify : { Left:'Left',Center:'Center',Right:'Right',ETextJustify_MAX:'ETextJustify_MAX', };
declare type ETextShapingMethod = 'Auto' | 'KerningOnly' | 'FullShaping' | 'ETextShapingMethod_MAX';
declare var ETextShapingMethod : { Auto:'Auto',KerningOnly:'KerningOnly',FullShaping:'FullShaping',ETextShapingMethod_MAX:'ETextShapingMethod_MAX', };
declare type ETextFlowDirection = 'Auto' | 'LeftToRight' | 'RightToLeft' | 'ETextFlowDirection_MAX';
declare var ETextFlowDirection : { Auto:'Auto',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ETextFlowDirection_MAX:'ETextFlowDirection_MAX', };
declare class ShapedTextOptions { 
	bOverride_TextShapingMethod: boolean;
	bOverride_TextFlowDirection: boolean;
	TextShapingMethod: ETextShapingMethod;
	TextFlowDirection: ETextFlowDirection;
	clone() : ShapedTextOptions;
	static C(Other: UObject | any): ShapedTextOptions;
}

declare type ETextCommit = 'Default' | 'OnEnter' | 'OnUserMovedFocus' | 'OnCleared' | 'ETextCommit_MAX';
declare var ETextCommit : { Default:'Default',OnEnter:'OnEnter',OnUserMovedFocus:'OnUserMovedFocus',OnCleared:'OnCleared',ETextCommit_MAX:'ETextCommit_MAX', };
declare class EditableText extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextStyle;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableText;
	static Find(Outer: UObject, ResourceName: string): EditableText;
	static GetDefaultObject(): EditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableText;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetMinimumDesiredWidth(InMinDesiredWidth: number): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(InbIsReadyOnly: boolean): void;
	SetIsPassword(InbIsPassword: boolean): void;
	SetHintText(InHintText: string): void;
	SetFontOutlineMaterial(InMaterial: MaterialInterface): void;
	SetFontMaterial(InMaterial: MaterialInterface): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	GetText(): string;
	GetJustification(): ETextJustify;
	GetHintText(): string;
	GetFont(): SlateFontInfo;
	static C(Other: UObject | any): EditableText;
}

declare class EditableTextBox extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	bIsFontDeprecationDone: boolean;
	static Load(ResourceName: string): EditableTextBox;
	static Find(Outer: UObject, ResourceName: string): EditableTextBox;
	static GetDefaultObject(): EditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBox;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetIsPassword(bIsPassword: boolean): void;
	SetHintText(InText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	HasError(): boolean;
	GetText(): string;
	ClearError(): void;
	static C(Other: UObject | any): EditableTextBox;
}

declare class ExpandableAreaStyle extends SlateWidgetStyle { 
	CollapsedImage: SlateBrush;
	ExpandedImage: SlateBrush;
	RolloutAnimationSeconds: number;
	clone() : ExpandableAreaStyle;
	static C(Other: UObject | any): ExpandableAreaStyle;
}

declare class ExpandableArea extends Widget { 
	Style: ExpandableAreaStyle;
	BorderBrush: SlateBrush;
	BorderColor: SlateColor;
	bIsExpanded: boolean;
	MaxHeight: number;
	HeaderPadding: Margin;
	AreaPadding: Margin;
	OnExpansionChanged: UnrealEngineMulticastDelegate<(Area: ExpandableArea, bIsExpanded: boolean) => void>;
	HeaderContent: Widget;
	BodyContent: Widget;
	static Load(ResourceName: string): ExpandableArea;
	static Find(Outer: UObject, ResourceName: string): ExpandableArea;
	static GetDefaultObject(): ExpandableArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExpandableArea;
	SetIsExpanded_Animated(IsExpanded: boolean): void;
	SetIsExpanded(IsExpanded: boolean): void;
	GetIsExpanded(): boolean;
	static C(Other: UObject | any): ExpandableArea;
}

declare class GridPanel extends PanelWidget { 
	ColumnFill: number[];
	RowFill: number[];
	static Load(ResourceName: string): GridPanel;
	static Find(Outer: UObject, ResourceName: string): GridPanel;
	static GetDefaultObject(): GridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPanel;
	SetRowFill(RowIndex: number,Coefficient: number): void;
	SetColumnFill(ColumnIndex: number,Coefficient: number): void;
	AddChildToGrid(Content: Widget,InRow: number,InColumn: number): GridSlot;
	static C(Other: UObject | any): GridPanel;
}

declare class HorizontalBox extends PanelWidget { 
	static Load(ResourceName: string): HorizontalBox;
	static Find(Outer: UObject, ResourceName: string): HorizontalBox;
	static GetDefaultObject(): HorizontalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBox;
	AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
	static C(Other: UObject | any): HorizontalBox;
}

declare class UImage extends Widget { 
	Brush: SlateBrush;
	BrushDelegate: UnrealEngineDelegate<() => SlateBrush>;
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): UImage;
	static Find(Outer: UObject, ResourceName: string): UImage;
	static GetDefaultObject(): UImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UImage;
	SetOpacity(InOpacity: number): void;
	SetDesiredSizeOverride(DesiredSize: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBrushTintColor(TintColor: SlateColor): void;
	SetBrushResourceObject(ResourceObject: UObject): void;
	SetBrushFromTextureDynamic(Texture: Texture2DDynamic,bMatchSize: boolean): void;
	SetBrushFromTexture(Texture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftTexture(SoftTexture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftMaterial(SoftMaterial: MaterialInterface): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): UImage;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	clone() : InputChord;
	static C(Other: UObject | any): InputChord;
	EqualEqual_InputChordInputChord(B: InputChord): boolean;
	InputChord_GetDisplayName(): string;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
	static InputChord_GetDisplayName(Key: InputChord): string;
}

declare class InputKeySelector extends Widget { 
	WidgetStyle: ButtonStyle;
	TextStyle: TextBlockStyle;
	SelectedKey: InputChord;
	Margin: Margin;
	KeySelectionText: string;
	NoKeySpecifiedText: string;
	bAllowModifierKeys: boolean;
	bAllowGamepadKeys: boolean;
	EscapeKeys: Key[];
	OnKeySelected: UnrealEngineMulticastDelegate<(SelectedKey: InputChord) => void>;
	OnIsSelectingKeyChanged: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): InputKeySelector;
	static Find(Outer: UObject, ResourceName: string): InputKeySelector;
	static GetDefaultObject(): InputKeySelector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeySelector;
	SetTextBlockVisibility(InVisibility: ESlateVisibility): void;
	SetSelectedKey(InSelectedKey: InputChord): void;
	SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;
	SetKeySelectionText(InKeySelectionText: string): void;
	SetEscapeKeys(InKeys: Key[]): void;
	SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;
	SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;
	GetIsSelectingKey(): boolean;
	static C(Other: UObject | any): InputKeySelector;
}

declare class InvalidationBox extends ContentWidget { 
	bCanCache: boolean;
	CacheRelativeTransforms: boolean;
	static Load(ResourceName: string): InvalidationBox;
	static Find(Outer: UObject, ResourceName: string): InvalidationBox;
	static GetDefaultObject(): InvalidationBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InvalidationBox;
	SetCanCache(CanCache: boolean): void;
	InvalidateCache(): void;
	GetCanCache(): boolean;
	static C(Other: UObject | any): InvalidationBox;
}

declare type EMenuPlacement = 'MenuPlacement_BelowAnchor' | 'MenuPlacement_CenteredBelowAnchor' | 'MenuPlacement_BelowRightAnchor' | 'MenuPlacement_ComboBox' | 'MenuPlacement_ComboBoxRight' | 'MenuPlacement_MenuRight' | 'MenuPlacement_AboveAnchor' | 'MenuPlacement_CenteredAboveAnchor' | 'MenuPlacement_AboveRightAnchor' | 'MenuPlacement_MenuLeft' | 'MenuPlacement_Center' | 'MenuPlacement_RightLeftCenter' | 'MenuPlacement_MatchBottomLeft' | 'MenuPlacement_MAX';
declare var EMenuPlacement : { MenuPlacement_BelowAnchor:'MenuPlacement_BelowAnchor',MenuPlacement_CenteredBelowAnchor:'MenuPlacement_CenteredBelowAnchor',MenuPlacement_BelowRightAnchor:'MenuPlacement_BelowRightAnchor',MenuPlacement_ComboBox:'MenuPlacement_ComboBox',MenuPlacement_ComboBoxRight:'MenuPlacement_ComboBoxRight',MenuPlacement_MenuRight:'MenuPlacement_MenuRight',MenuPlacement_AboveAnchor:'MenuPlacement_AboveAnchor',MenuPlacement_CenteredAboveAnchor:'MenuPlacement_CenteredAboveAnchor',MenuPlacement_AboveRightAnchor:'MenuPlacement_AboveRightAnchor',MenuPlacement_MenuLeft:'MenuPlacement_MenuLeft',MenuPlacement_Center:'MenuPlacement_Center',MenuPlacement_RightLeftCenter:'MenuPlacement_RightLeftCenter',MenuPlacement_MatchBottomLeft:'MenuPlacement_MatchBottomLeft',MenuPlacement_MAX:'MenuPlacement_MAX', };
declare class MenuAnchor extends ContentWidget { 
	MenuClass: UnrealEngineClass;
	OnGetMenuContentEvent: UnrealEngineDelegate<() => Widget>;
	OnGetUserMenuContentEvent: UnrealEngineDelegate<() => UserWidget>;
	PLACEMENT: EMenuPlacement;
	bFitInWindow: boolean;
	ShouldDeferPaintingAfterWindowContent: boolean;
	UseApplicationMenuStack: boolean;
	OnMenuOpenChanged: UnrealEngineMulticastDelegate<(bIsOpen: boolean) => void>;
	static Load(ResourceName: string): MenuAnchor;
	static Find(Outer: UObject, ResourceName: string): MenuAnchor;
	static GetDefaultObject(): MenuAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MenuAnchor;
	ToggleOpen(bFocusOnOpen: boolean): void;
	ShouldOpenDueToClick(): boolean;
	SetPlacement(InPlacement: EMenuPlacement): void;
	Open(bFocusMenu: boolean): void;
	IsOpen(): boolean;
	HasOpenSubMenus(): boolean;
	GetMenuPosition(): Vector2D;
	FitInWindow(bFit: boolean): void;
	Close(): void;
	static C(Other: UObject | any): MenuAnchor;
}

declare type ETextWrappingPolicy = 'DefaultWrapping' | 'AllowPerCharacterWrapping' | 'ETextWrappingPolicy_MAX';
declare var ETextWrappingPolicy : { DefaultWrapping:'DefaultWrapping',AllowPerCharacterWrapping:'AllowPerCharacterWrapping',ETextWrappingPolicy_MAX:'ETextWrappingPolicy_MAX', };
declare class TextLayoutWidget extends Widget { 
	ShapedTextOptions: ShapedTextOptions;
	Justification: ETextJustify;
	WrappingPolicy: ETextWrappingPolicy;
	AutoWrapText: boolean;
	WrapTextAt: number;
	Margin: Margin;
	LineHeightPercentage: number;
	static Load(ResourceName: string): TextLayoutWidget;
	static Find(Outer: UObject, ResourceName: string): TextLayoutWidget;
	static GetDefaultObject(): TextLayoutWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextLayoutWidget;
	SetJustification(InJustification: ETextJustify): void;
	static C(Other: UObject | any): TextLayoutWidget;
}

declare class MultiLineEditableText extends TextLayoutWidget { 
	Text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	SelectAllTextWhenFocused: boolean;
	ClearTextSelectionOnFocusLoss: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableText;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableText;
	static GetDefaultObject(): MultiLineEditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableText;
	SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetFontOutlineMaterial(InMaterial: MaterialInterface): void;
	SetFontMaterial(InMaterial: MaterialInterface): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	GetText(): string;
	GetHintText(): string;
	GetFont(): SlateFontInfo;
	static C(Other: UObject | any): MultiLineEditableText;
}

declare class MultiLineEditableTextBox extends TextLayoutWidget { 
	Text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	TextStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	bIsFontDeprecationDone: boolean;
	static Load(ResourceName: string): MultiLineEditableTextBox;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableTextBox;
	static GetDefaultObject(): MultiLineEditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableTextBox;
	SetTextStyle(InTextStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableTextBox;
}

declare class NamedSlot extends ContentWidget { 
	bExposeOnInstanceOnly: boolean;
	static Load(ResourceName: string): NamedSlot;
	static Find(Outer: UObject, ResourceName: string): NamedSlot;
	static GetDefaultObject(): NamedSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlot;
	static C(Other: UObject | any): NamedSlot;
}

declare class NamedSlotInterface extends Interface { 
	static Load(ResourceName: string): NamedSlotInterface;
	static Find(Outer: UObject, ResourceName: string): NamedSlotInterface;
	static GetDefaultObject(): NamedSlotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlotInterface;
	static C(Other: UObject | any): NamedSlotInterface;
}

declare class NativeWidgetHost extends Widget { 
	static Load(ResourceName: string): NativeWidgetHost;
	static Find(Outer: UObject, ResourceName: string): NativeWidgetHost;
	static GetDefaultObject(): NativeWidgetHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NativeWidgetHost;
	static C(Other: UObject | any): NativeWidgetHost;
	SetContent(SlateWidget: JavascriptSlateWidget): Widget;
	static SetContent(TargetWidget: NativeWidgetHost,SlateWidget: JavascriptSlateWidget): Widget;
}

declare class Overlay extends PanelWidget { 
	static Load(ResourceName: string): Overlay;
	static Find(Outer: UObject, ResourceName: string): Overlay;
	static GetDefaultObject(): Overlay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlay;
	AddChildToOverlay(Content: Widget): OverlaySlot;
	static C(Other: UObject | any): Overlay;
}

declare type EProgressBarFillType = 'LeftToRight' | 'RightToLeft' | 'FillFromCenter' | 'FillFromCenterHorizontal' | 'FillFromCenterVertical' | 'TopToBottom' | 'BottomToTop' | 'EProgressBarFillType_MAX';
declare var EProgressBarFillType : { LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',FillFromCenter:'FillFromCenter',FillFromCenterHorizontal:'FillFromCenterHorizontal',FillFromCenterVertical:'FillFromCenterVertical',TopToBottom:'TopToBottom',BottomToTop:'BottomToTop',EProgressBarFillType_MAX:'EProgressBarFillType_MAX', };
declare type EProgressBarFillStyle = 'Mask' | 'Scale' | 'EProgressBarFillStyle_MAX';
declare var EProgressBarFillStyle : { Mask:'Mask',Scale:'Scale',EProgressBarFillStyle_MAX:'EProgressBarFillStyle_MAX', };
declare class ProgressBar extends Widget { 
	WidgetStyle: ProgressBarStyle;
	Percent: number;
	BarFillType: EProgressBarFillType;
	BarFillStyle: EProgressBarFillStyle;
	bIsMarquee: boolean;
	BorderPadding: Vector2D;
	PercentDelegate: UnrealEngineDelegate<() => number>;
	FillColorAndOpacity: LinearColor;
	FillColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	static Load(ResourceName: string): ProgressBar;
	static Find(Outer: UObject, ResourceName: string): ProgressBar;
	static GetDefaultObject(): ProgressBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressBar;
	SetPercent(InPercent: number): void;
	SetIsMarquee(InbIsMarquee: boolean): void;
	SetFillColorAndOpacity(InColor: LinearColor): void;
	static C(Other: UObject | any): ProgressBar;
}

declare class RetainerBox extends ContentWidget { 
	bRetainRender: boolean;
	RenderOnInvalidation: boolean;
	RenderOnPhase: boolean;
	Phase: number;
	PhaseCount: number;
	EffectMaterial: MaterialInterface;
	TextureParameter: string;
	static Load(ResourceName: string): RetainerBox;
	static Find(Outer: UObject, ResourceName: string): RetainerBox;
	static GetDefaultObject(): RetainerBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RetainerBox;
	SetTextureParameter(TextureParameter: string): void;
	SetRetainRendering(bInRetainRendering: boolean): void;
	SetRenderingPhase(RenderPhase: number,TotalPhases: number): void;
	SetEffectMaterial(EffectMaterial: MaterialInterface): void;
	RequestRender(): void;
	GetEffectMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): RetainerBox;
}

declare class RichTextBlockDecorator extends UObject { 
	static Load(ResourceName: string): RichTextBlockDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockDecorator;
	static GetDefaultObject(): RichTextBlockDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockDecorator;
	static C(Other: UObject | any): RichTextBlockDecorator;
}

declare class RichTextBlock extends TextLayoutWidget { 
	Text: string;
	TextStyleSet: DataTable;
	DecoratorClasses: UnrealEngineClass[];
	bOverrideDefaultStyle: boolean;
	DefaultTextStyleOverride: TextBlockStyle;
	MinDesiredWidth: number;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	DefaultTextStyle: TextBlockStyle;
	InstanceDecorators: RichTextBlockDecorator[];
	static Load(ResourceName: string): RichTextBlock;
	static Find(Outer: UObject, ResourceName: string): RichTextBlock;
	static GetDefaultObject(): RichTextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextStyleSet(NewTextStyleSet: DataTable): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetDefaultTextStyle(InDefaultTextStyle: TextBlockStyle): void;
	SetDefaultStrikeBrush(InStrikeBrush?: SlateBrush): {InStrikeBrush: SlateBrush};
	SetDefaultShadowOffset(InShadowOffset: Vector2D): void;
	SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetDefaultMaterial(InMaterial: MaterialInterface): void;
	SetDefaultFont(InFontInfo: SlateFontInfo): void;
	SetDefaultColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetDecorators(InDecoratorClasses: UnrealEngineClass[]): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	RefreshTextLayout(): void;
	GetTextStyleSet(): DataTable;
	GetText(): string;
	GetDefaultDynamicMaterial(): MaterialInstanceDynamic;
	GetDecoratorByClass(DecoratorClass: UnrealEngineClass): RichTextBlockDecorator;
	ClearAllDefaultStyleOverrides(): void;
	static C(Other: UObject | any): RichTextBlock;
}

declare class RichTextBlockImageDecorator extends RichTextBlockDecorator { 
	ImageSet: DataTable;
	static Load(ResourceName: string): RichTextBlockImageDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockImageDecorator;
	static GetDefaultObject(): RichTextBlockImageDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockImageDecorator;
	static C(Other: UObject | any): RichTextBlockImageDecorator;
}

declare class SafeZone extends ContentWidget { 
	PadLeft: boolean;
	PadRight: boolean;
	PadTop: boolean;
	PadBottom: boolean;
	static Load(ResourceName: string): SafeZone;
	static Find(Outer: UObject, ResourceName: string): SafeZone;
	static GetDefaultObject(): SafeZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZone;
	SetSidesToPad(InPadLeft: boolean,InPadRight: boolean,InPadTop: boolean,InPadBottom: boolean): void;
	static C(Other: UObject | any): SafeZone;
}

declare type EStretch = 'None' | 'Fill' | 'ScaleToFit' | 'ScaleToFitX' | 'ScaleToFitY' | 'ScaleToFill' | 'ScaleBySafeZone' | 'UserSpecified' | 'UserSpecifiedWithClipping' | 'EStretch_MAX';
declare var EStretch : { None:'None',Fill:'Fill',ScaleToFit:'ScaleToFit',ScaleToFitX:'ScaleToFitX',ScaleToFitY:'ScaleToFitY',ScaleToFill:'ScaleToFill',ScaleBySafeZone:'ScaleBySafeZone',UserSpecified:'UserSpecified',UserSpecifiedWithClipping:'UserSpecifiedWithClipping',EStretch_MAX:'EStretch_MAX', };
declare type EStretchDirection = 'Both' | 'DownOnly' | 'UpOnly' | 'EStretchDirection_MAX';
declare var EStretchDirection : { Both:'Both',DownOnly:'DownOnly',UpOnly:'UpOnly',EStretchDirection_MAX:'EStretchDirection_MAX', };
declare class ScaleBox extends ContentWidget { 
	Stretch: EStretch;
	StretchDirection: EStretchDirection;
	UserSpecifiedScale: number;
	IgnoreInheritedScale: boolean;
	static Load(ResourceName: string): ScaleBox;
	static Find(Outer: UObject, ResourceName: string): ScaleBox;
	static GetDefaultObject(): ScaleBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBox;
	SetUserSpecifiedScale(InUserSpecifiedScale: number): void;
	SetStretchDirection(InStretchDirection: EStretchDirection): void;
	SetStretch(InStretch: EStretch): void;
	SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean): void;
	static C(Other: UObject | any): ScaleBox;
}

declare class ScrollBar extends Widget { 
	WidgetStyle: ScrollBarStyle;
	bAlwaysShowScrollbar: boolean;
	bAlwaysShowScrollbarTrack: boolean;
	Orientation: EOrientation;
	Thickness: Vector2D;
	Padding: Margin;
	static Load(ResourceName: string): ScrollBar;
	static Find(Outer: UObject, ResourceName: string): ScrollBar;
	static GetDefaultObject(): ScrollBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBar;
	SetState(InOffsetFraction: number,InThumbSizeFraction: number): void;
	static C(Other: UObject | any): ScrollBar;
}

declare type EDescendantScrollDestination = 'IntoView' | 'TopOrLeft' | 'Center' | 'BottomOrRight' | 'EDescendantScrollDestination_MAX';
declare var EDescendantScrollDestination : { IntoView:'IntoView',TopOrLeft:'TopOrLeft',Center:'Center',BottomOrRight:'BottomOrRight',EDescendantScrollDestination_MAX:'EDescendantScrollDestination_MAX', };
declare type EScrollWhenFocusChanges = 'NoScroll' | 'InstantScroll' | 'AnimatedScroll' | 'EScrollWhenFocusChanges_MAX';
declare var EScrollWhenFocusChanges : { NoScroll:'NoScroll',InstantScroll:'InstantScroll',AnimatedScroll:'AnimatedScroll',EScrollWhenFocusChanges_MAX:'EScrollWhenFocusChanges_MAX', };
declare class ScrollBox extends PanelWidget { 
	WidgetStyle: ScrollBoxStyle;
	WidgetBarStyle: ScrollBarStyle;
	Orientation: EOrientation;
	ScrollBarVisibility: ESlateVisibility;
	ConsumeMouseWheel: EConsumeMouseWheel;
	ScrollbarThickness: Vector2D;
	ScrollbarPadding: Margin;
	AlwaysShowScrollbar: boolean;
	AlwaysShowScrollbarTrack: boolean;
	AllowOverscroll: boolean;
	BackPadScrolling: boolean;
	FrontPadScrolling: boolean;
	bAnimateWheelScrolling: boolean;
	NavigationDestination: EDescendantScrollDestination;
	NavigationScrollPadding: number;
	ScrollWhenFocusChanges: EScrollWhenFocusChanges;
	bAllowRightClickDragScrolling: boolean;
	WheelScrollMultiplier: number;
	OnUserScrolled: UnrealEngineMulticastDelegate<(CurrentOffset: number) => void>;
	static Load(ResourceName: string): ScrollBox;
	static Find(Outer: UObject, ResourceName: string): ScrollBox;
	static GetDefaultObject(): ScrollBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBox;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollWhenFocusChanges(NewScrollWhenFocusChanges: EScrollWhenFocusChanges): void;
	SetScrollOffset(NewScrollOffset: number): void;
	SetScrollBarVisibility(NewScrollBarVisibility: ESlateVisibility): void;
	SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;
	SetScrollbarPadding(NewScrollbarPadding: Margin): void;
	SetOrientation(NewOrientation: EOrientation): void;
	SetNavigationDestination(NewNavigationDestination: EDescendantScrollDestination): void;
	SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;
	SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;
	SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;
	SetAllowOverscroll(NewAllowOverscroll: boolean): void;
	ScrollWidgetIntoView(WidgetToFind: Widget,AnimateScroll: boolean,ScrollDestination: EDescendantScrollDestination,Padding: number): void;
	ScrollToStart(): void;
	ScrollToEnd(): void;
	GetViewOffsetFraction(): number;
	GetViewFraction(): number;
	GetScrollOffsetOfEnd(): number;
	GetScrollOffset(): number;
	EndInertialScrolling(): void;
	static C(Other: UObject | any): ScrollBox;
}

declare class SizeBox extends ContentWidget { 
	WidthOverride: number;
	HeightOverride: number;
	MinDesiredWidth: number;
	MinDesiredHeight: number;
	MaxDesiredWidth: number;
	MaxDesiredHeight: number;
	MinAspectRatio: number;
	MaxAspectRatio: number;
	bOverride_WidthOverride: boolean;
	bOverride_HeightOverride: boolean;
	bOverride_MinDesiredWidth: boolean;
	bOverride_MinDesiredHeight: boolean;
	bOverride_MaxDesiredWidth: boolean;
	bOverride_MaxDesiredHeight: boolean;
	bOverride_MinAspectRatio: boolean;
	bOverride_MaxAspectRatio: boolean;
	static Load(ResourceName: string): SizeBox;
	static Find(Outer: UObject, ResourceName: string): SizeBox;
	static GetDefaultObject(): SizeBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBox;
	SetWidthOverride(InWidthOverride: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetMinDesiredHeight(InMinDesiredHeight: number): void;
	SetMinAspectRatio(InMinAspectRatio: number): void;
	SetMaxDesiredWidth(InMaxDesiredWidth: number): void;
	SetMaxDesiredHeight(InMaxDesiredHeight: number): void;
	SetMaxAspectRatio(InMaxAspectRatio: number): void;
	SetHeightOverride(InHeightOverride: number): void;
	ClearWidthOverride(): void;
	ClearMinDesiredWidth(): void;
	ClearMinDesiredHeight(): void;
	ClearMinAspectRatio(): void;
	ClearMaxDesiredWidth(): void;
	ClearMaxDesiredHeight(): void;
	ClearMaxAspectRatio(): void;
	ClearHeightOverride(): void;
	static C(Other: UObject | any): SizeBox;
}

declare class SliderStyle extends SlateWidgetStyle { 
	NormalBarImage: SlateBrush;
	HoveredBarImage: SlateBrush;
	DisabledBarImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DisabledThumbImage: SlateBrush;
	BarThickness: number;
	clone() : SliderStyle;
	static C(Other: UObject | any): SliderStyle;
}

declare class Slider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	MinValue: number;
	MaxValue: number;
	WidgetStyle: SliderStyle;
	Orientation: EOrientation;
	SliderBarColor: LinearColor;
	SliderHandleColor: LinearColor;
	IndentHandle: boolean;
	Locked: boolean;
	MouseUsesStep: boolean;
	RequiresControllerLock: boolean;
	StepSize: number;
	IsFocusable: boolean;
	OnMouseCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnMouseCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): Slider;
	static Find(Outer: UObject, ResourceName: string): Slider;
	static GetDefaultObject(): Slider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Slider;
	SetValue(InValue: number): void;
	SetStepSize(InValue: number): void;
	SetSliderHandleColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetMinValue(InValue: number): void;
	SetMaxValue(InValue: number): void;
	SetLocked(InValue: boolean): void;
	SetIndentHandle(InValue: boolean): void;
	GetValue(): number;
	GetNormalizedValue(): number;
	static C(Other: UObject | any): Slider;
}

declare class Spacer extends Widget { 
	Size: Vector2D;
	static Load(ResourceName: string): Spacer;
	static Find(Outer: UObject, ResourceName: string): Spacer;
	static GetDefaultObject(): Spacer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Spacer;
	SetSize(InSize: Vector2D): void;
	static C(Other: UObject | any): Spacer;
}

declare class SpinBox extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetStyle: SpinBoxStyle;
	MinFractionalDigits: number;
	MaxFractionalDigits: number;
	bAlwaysUsesDeltaSnap: boolean;
	bEnableSlider: boolean;
	Delta: number;
	SliderExponent: number;
	Font: SlateFontInfo;
	Justification: ETextJustify;
	MinDesiredWidth: number;
	KeyboardType: EVirtualKeyboardType;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	ForegroundColor: SlateColor;
	OnValueChanged: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	OnValueCommitted: UnrealEngineMulticastDelegate<(InValue: number, CommitMethod: ETextCommit) => void>;
	OnBeginSliderMovement: UnrealEngineMulticastDelegate<() => void>;
	OnEndSliderMovement: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	bOverride_MinValue: boolean;
	bOverride_MaxValue: boolean;
	bOverride_MinSliderValue: boolean;
	bOverride_MaxSliderValue: boolean;
	MinValue: number;
	MaxValue: number;
	MinSliderValue: number;
	MaxSliderValue: number;
	static Load(ResourceName: string): SpinBox;
	static Find(Outer: UObject, ResourceName: string): SpinBox;
	static GetDefaultObject(): SpinBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBox;
	SetValue(NewValue: number): void;
	SetMinValue(NewValue: number): void;
	SetMinSliderValue(NewValue: number): void;
	SetMinFractionalDigits(NewValue: number): void;
	SetMaxValue(NewValue: number): void;
	SetMaxSliderValue(NewValue: number): void;
	SetMaxFractionalDigits(NewValue: number): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDelta(NewValue: number): void;
	SetAlwaysUsesDeltaSnap(bNewValue: boolean): void;
	GetValue(): number;
	GetMinValue(): number;
	GetMinSliderValue(): number;
	GetMinFractionalDigits(): number;
	GetMaxValue(): number;
	GetMaxSliderValue(): number;
	GetMaxFractionalDigits(): number;
	GetDelta(): number;
	GetAlwaysUsesDeltaSnap(): boolean;
	ClearMinValue(): void;
	ClearMinSliderValue(): void;
	ClearMaxValue(): void;
	ClearMaxSliderValue(): void;
	static C(Other: UObject | any): SpinBox;
}

declare class StackBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): StackBoxSlot;
	static Find(Outer: UObject, ResourceName: string): StackBoxSlot;
	static GetDefaultObject(): StackBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StackBoxSlot;
	static C(Other: UObject | any): StackBoxSlot;
}

declare class StackBox extends PanelWidget { 
	Orientation: EOrientation;
	static Load(ResourceName: string): StackBox;
	static Find(Outer: UObject, ResourceName: string): StackBox;
	static GetDefaultObject(): StackBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StackBox;
	AddChildToStackBox(Content: Widget): StackBoxSlot;
	static C(Other: UObject | any): StackBox;
}

declare class TextBlock extends TextLayoutWidget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	ColorAndOpacity: SlateColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => SlateColor>;
	Font: SlateFontInfo;
	StrikeBrush: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	ShadowColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	MinDesiredWidth: number;
	bWrapWithInvalidationPanel: boolean;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	bSimpleTextMode: boolean;
	static Load(ResourceName: string): TextBlock;
	static Find(Outer: UObject, ResourceName: string): TextBlock;
	static GetDefaultObject(): TextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetStrikeBrush(InStrikeBrush: SlateBrush): void;
	SetShadowOffset(InShadowOffset: Vector2D): void;
	SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetOpacity(InOpacity: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetFontOutlineMaterial(InMaterial: MaterialInterface): void;
	SetFontMaterial(InMaterial: MaterialInterface): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	SetColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	GetText(): string;
	GetDynamicOutlineMaterial(): MaterialInstanceDynamic;
	GetDynamicFontMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): TextBlock;
}

declare class Throbber extends Widget { 
	NumberOfPieces: number;
	bAnimateHorizontally: boolean;
	bAnimateVertically: boolean;
	bAnimateOpacity: boolean;
	UImage: SlateBrush;
	static Load(ResourceName: string): Throbber;
	static Find(Outer: UObject, ResourceName: string): Throbber;
	static GetDefaultObject(): Throbber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Throbber;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	SetAnimateVertically(bInAnimateVertically: boolean): void;
	SetAnimateOpacity(bInAnimateOpacity: boolean): void;
	SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;
	static C(Other: UObject | any): Throbber;
}

declare type EListItemAlignment = 'EvenlyDistributed' | 'EvenlySize' | 'EvenlyWide' | 'LeftAligned' | 'RightAligned' | 'CenterAligned' | 'Fill' | 'EListItemAlignment_MAX';
declare var EListItemAlignment : { EvenlyDistributed:'EvenlyDistributed',EvenlySize:'EvenlySize',EvenlyWide:'EvenlyWide',LeftAligned:'LeftAligned',RightAligned:'RightAligned',CenterAligned:'CenterAligned',Fill:'Fill',EListItemAlignment_MAX:'EListItemAlignment_MAX', };
declare class TileView extends ListView { 
	EntryHeight: number;
	EntryWidth: number;
	TileAlignment: EListItemAlignment;
	bWrapHorizontalNavigation: boolean;
	static Load(ResourceName: string): TileView;
	static Find(Outer: UObject, ResourceName: string): TileView;
	static GetDefaultObject(): TileView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileView;
	SetEntryWidth(NewWidth: number): void;
	SetEntryHeight(NewHeight: number): void;
	GetEntryWidth(): number;
	GetEntryHeight(): number;
	static C(Other: UObject | any): TileView;
}

declare class TreeView extends ListView { 
	BP_OnGetItemChildren: UnrealEngineDelegate<(Item: UObject, Children: UObject[]) => void>;
	BP_OnItemExpansionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsExpanded: boolean) => void>;
	static Load(ResourceName: string): TreeView;
	static Find(Outer: UObject, ResourceName: string): TreeView;
	static GetDefaultObject(): TreeView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TreeView;
	SetItemExpansion(Item: UObject,bExpandItem: boolean): void;
	ExpandAll(): void;
	CollapseAll(): void;
	static C(Other: UObject | any): TreeView;
}

declare class UniformGridPanel extends PanelWidget { 
	SlotPadding: Margin;
	MinDesiredSlotWidth: number;
	MinDesiredSlotHeight: number;
	static Load(ResourceName: string): UniformGridPanel;
	static Find(Outer: UObject, ResourceName: string): UniformGridPanel;
	static GetDefaultObject(): UniformGridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridPanel;
	SetSlotPadding(InSlotPadding: Margin): void;
	SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;
	SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;
	AddChildToUniformGrid(Content: Widget,InRow: number,InColumn: number): UniformGridSlot;
	static C(Other: UObject | any): UniformGridPanel;
}

declare class VerticalBox extends PanelWidget { 
	static Load(ResourceName: string): VerticalBox;
	static Find(Outer: UObject, ResourceName: string): VerticalBox;
	static GetDefaultObject(): VerticalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBox;
	AddChildToVerticalBox(Content: Widget): VerticalBoxSlot;
	static C(Other: UObject | any): VerticalBox;
}

declare class Viewport extends ContentWidget { 
	BackgroundColor: LinearColor;
	static Load(ResourceName: string): Viewport;
	static Find(Outer: UObject, ResourceName: string): Viewport;
	static GetDefaultObject(): Viewport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Viewport;
	Spawn(ActorClass: UnrealEngineClass): Actor;
	SetViewRotation(Rotation: Rotator): void;
	SetViewLocation(Location: Vector): void;
	GetViewRotation(): Rotator;
	GetViewportWorld(): World;
	GetViewLocation(): Vector;
	static C(Other: UObject | any): Viewport;
}

declare type EWidgetInteractionSource = 'World' | 'Mouse' | 'CenterScreen' | 'Custom' | 'EWidgetInteractionSource_MAX';
declare var EWidgetInteractionSource : { World:'World',Mouse:'Mouse',CenterScreen:'CenterScreen',Custom:'Custom',EWidgetInteractionSource_MAX:'EWidgetInteractionSource_MAX', };
declare class WidgetInteractionComponent extends SceneComponent { 
	OnHoveredWidgetChanged: UnrealEngineMulticastDelegate<(WidgetComponent: WidgetComponent, PreviousWidgetComponent: WidgetComponent) => void>;
	VirtualUserIndex: number;
	PointerIndex: number;
	TraceChannel: ECollisionChannel;
	InteractionDistance: number;
	InteractionSource: EWidgetInteractionSource;
	bEnableHitTesting: boolean;
	bShowDebug: boolean;
	DebugSphereLineThickness: number;
	DebugLineThickness: number;
	DebugColor: LinearColor;
	CustomHitResult: HitResult;
	LocalHitLocation: Vector2D;
	LastLocalHitLocation: Vector2D;
	HoveredWidgetComponent: WidgetComponent;
	LastHitResult: HitResult;
	bIsHoveredWidgetInteractable: boolean;
	bIsHoveredWidgetFocusable: boolean;
	bIsHoveredWidgetHitTestVisible: boolean;
	ArrowComponent: ArrowComponent;
	static Load(ResourceName: string): WidgetInteractionComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetInteractionComponent;
	static GetDefaultObject(): WidgetInteractionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetInteractionComponent;
	SetFocus(FocusWidget: Widget): void;
	SetCustomHitResult(HitResult: HitResult): void;
	SendKeyChar(Characters: string,bRepeat: boolean): boolean;
	ScrollWheel(ScrollDelta: number): void;
	ReleasePointerKey(Key: Key): void;
	ReleaseKey(Key: Key): boolean;
	PressPointerKey(Key: Key): void;
	PressKey(Key: Key,bRepeat: boolean): boolean;
	PressAndReleaseKey(Key: Key): boolean;
	IsOverInteractableWidget(): boolean;
	IsOverHitTestVisibleWidget(): boolean;
	IsOverFocusableWidget(): boolean;
	GetLastHitResult(): HitResult;
	GetHoveredWidgetComponent(): WidgetComponent;
	Get2DHitLocation(): Vector2D;
	static C(Other: UObject | any): WidgetInteractionComponent;
}

declare class WidgetSwitcher extends PanelWidget { 
	ActiveWidgetIndex: number;
	static Load(ResourceName: string): WidgetSwitcher;
	static Find(Outer: UObject, ResourceName: string): WidgetSwitcher;
	static GetDefaultObject(): WidgetSwitcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcher;
	SetActiveWidgetIndex(Index: number): void;
	SetActiveWidget(Widget: Widget): void;
	GetWidgetAtIndex(Index: number): Widget;
	GetNumWidgets(): number;
	GetActiveWidgetIndex(): number;
	GetActiveWidget(): Widget;
	static C(Other: UObject | any): WidgetSwitcher;
}

declare class WindowTitleBarArea extends ContentWidget { 
	bWindowButtonsEnabled: boolean;
	bDoubleClickTogglesFullscreen: boolean;
	static Load(ResourceName: string): WindowTitleBarArea;
	static Find(Outer: UObject, ResourceName: string): WindowTitleBarArea;
	static GetDefaultObject(): WindowTitleBarArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowTitleBarArea;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WindowTitleBarArea;
}

